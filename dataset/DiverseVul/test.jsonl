{"func": "static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)\n{\n\tstruct xdr_buf *rcvbuf = &req->rq_rcv_buf;\n\tstruct kvec *iov = rcvbuf->head;\n\tsize_t hdrlen;\n\tu32 len, recvd;\n\t__be32 *p;\n\tchar *kaddr;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READLINK);\n\tif (status)\n\t\treturn status;\n\n\t/* Convert length of symlink */\n\tREAD_BUF(4);\n\tREAD32(len);\n\tif (len >= rcvbuf->page_len || len <= 0) {\n\t\tdprintk(\"nfs: server returned giant symlink!\\n\");\n\t\treturn -ENAMETOOLONG;\n\t}\n\thdrlen = (char *) xdr->p - (char *) iov->iov_base;\n\trecvd = req->rq_rcv_buf.len - hdrlen;\n\tif (recvd < len) {\n\t\tdprintk(\"NFS: server cheating in readlink reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", len, recvd);\n\t\treturn -EIO;\n\t}\n\txdr_read_pages(xdr, len);\n\t/*\n\t * The XDR encode routine has set things up so that\n\t * the link text will be copied directly into the\n\t * buffer.  We just have to do overflow-checking,\n\t * and and null-terminate the text (the VFS expects\n\t * null-termination).\n\t */\n\tkaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);\n\tkaddr[len+rcvbuf->page_base] = '\\0';\n\tkunmap_atomic(kaddr, KM_USER0);\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-703"], "project": "linux", "commit_id": "dc0b027dfadfcb8a5504f7d8052754bf8d501ab9", "hash": 36275114304225962204540707924996458613, "size": 41, "message": "NFSv4: Convert the open and close ops to use fmode\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>", "idx": 0}
{"func": "void NumberFormatTest::verifyFieldPositionIterator(\n        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {\n    int32_t idx = 0;\n    FieldPosition fp;\n    while (iter.next(fp)) {\n        if (expected[idx].spos == -1) {\n            errln(\"Iterator should have ended. got %d\", fp.getField());\n            return;\n        }\n        assertEquals(\"id\", expected[idx].id, fp.getField());\n        assertEquals(\"start\", expected[idx].spos, fp.getBeginIndex());\n        assertEquals(\"end\", expected[idx].epos, fp.getEndIndex());\n        ++idx;\n    }\n    if (expected[idx].spos != -1) {\n        errln(\"Premature end of iterator. expected %d\", expected[idx].id);\n    }\n}", "target": 0, "cwe": ["CWE-190"], "project": "icu", "commit_id": "53d8c8f3d181d87a6aa925b449b51c4a2c922a51", "hash": 280525554965308896467811278400926180040, "size": 18, "message": "ICU-20246 Fixing another integer overflow in number parsing.", "idx": 1}
{"func": "GF_Box *dac3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}", "target": 0, "cwe": ["CWE-787"], "project": "gpac", "commit_id": "77510778516803b7f7402d7423c6d6bef50254c3", "hash": 174764771353118987648885442760301600912, "size": 5, "message": "fixed #2255", "idx": 2}
{"func": "void setCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {\n        return;\n    }\n\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);\n}", "target": 0, "cwe": ["CWE-190"], "project": "redis", "commit_id": "92e3b1802f72ca0c5b0bde97f01d9b57a758d85c", "hash": 64802084236388221862659417799647346961, "size": 12, "message": "Fix integer overflow in STRALGO LCS (CVE-2021-29477)\n\nAn integer overflow bug in Redis version 6.0 or newer could be exploited using\nthe STRALGO LCS command to corrupt the heap and potentially result with remote\ncode execution.\n\n(cherry picked from commit f0c5f920d0f88bd8aa376a2c05af4902789d1ef9)", "idx": 3}
{"func": "static PHP_FUNCTION(readgzfile)\n{\n\tchar *filename;\n\tint filename_len;\n\tint flags = REPORT_ERRORS;\n\tphp_stream *stream;\n\tint size;\n\tlong use_include_path = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &filename, &filename_len, &use_include_path) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (use_include_path) {\n\t\tflags |= USE_PATH;\n\t}\n\n\tstream = php_stream_gzopen(NULL, filename, \"rb\", flags, NULL, NULL STREAMS_CC TSRMLS_CC);\n\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\tsize = php_stream_passthru(stream);\n\tphp_stream_close(stream);\n\tRETURN_LONG(size);\n}", "target": 1, "cwe": ["CWE-20"], "project": "php-src", "commit_id": "52b93f0cfd3cba7ff98cc5198df6ca4f23865f80", "hash": 182660390095693706033270011713289151505, "size": 26, "message": "Fixed bug #69353 (Missing null byte checks for paths in various PHP extensions)", "idx": 4}
{"func": "onigenc_get_case_fold_codes_by_str_with_map(int map_size,\n    const OnigPairCaseFoldCodes map[],\n    int ess_tsett_flag, OnigCaseFoldType flag ARG_UNUSED,\n    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])\n{\n  if (0x41 <= *p && *p <= 0x5a) {\n    items[0].byte_len = 1;\n    items[0].code_len = 1;\n    items[0].code[0] = (OnigCodePoint )(*p + 0x20);\n    if (*p == 0x53 && ess_tsett_flag != 0 && end > p + 1\n\t&& (*(p+1) == 0x53 || *(p+1) == 0x73)) {\n      /* SS */\n      items[1].byte_len = 2;\n      items[1].code_len = 1;\n      items[1].code[0] = (OnigCodePoint )0xdf;\n      return 2;\n    }\n    else\n      return 1;\n  }\n  else if (0x61 <= *p && *p <= 0x7a) {\n    items[0].byte_len = 1;\n    items[0].code_len = 1;\n    items[0].code[0] = (OnigCodePoint )(*p - 0x20);\n    if (*p == 0x73 && ess_tsett_flag != 0 && end > p + 1\n\t&& (*(p+1) == 0x73 || *(p+1) == 0x53)) {\n      /* ss */\n      items[1].byte_len = 2;\n      items[1].code_len = 1;\n      items[1].code[0] = (OnigCodePoint )0xdf;\n      return 2;\n    }\n    else\n      return 1;\n  }\n  else if (*p == 0xdf && ess_tsett_flag != 0) {\n    items[0].byte_len = 1;\n    items[0].code_len = 2;\n    items[0].code[0] = (OnigCodePoint )'s';\n    items[0].code[1] = (OnigCodePoint )'s';\n\n    items[1].byte_len = 1;\n    items[1].code_len = 2;\n    items[1].code[0] = (OnigCodePoint )'S';\n    items[1].code[1] = (OnigCodePoint )'S';\n\n    items[2].byte_len = 1;\n    items[2].code_len = 2;\n    items[2].code[0] = (OnigCodePoint )'s';\n    items[2].code[1] = (OnigCodePoint )'S';\n\n    items[3].byte_len = 1;\n    items[3].code_len = 2;\n    items[3].code[0] = (OnigCodePoint )'S';\n    items[3].code[1] = (OnigCodePoint )'s';\n\n    return 4;\n  }\n  else {\n    int i;\n\n    for (i = 0; i < map_size; i++) {\n      if (*p == map[i].from) {\n\titems[0].byte_len = 1;\n\titems[0].code_len = 1;\n\titems[0].code[0] = map[i].to;\n\treturn 1;\n      }\n      else if (*p == map[i].to) {\n\titems[0].byte_len = 1;\n\titems[0].code_len = 1;\n\titems[0].code[0] = map[i].from;\n\treturn 1;\n      }\n    }\n  }\n\n  return 0;\n}", "target": 0, "cwe": ["CWE-125"], "project": "Onigmo", "commit_id": "d4cf99d30bd5f6a8a4ababd0b9d7b06f3a479a24", "hash": 340050239740136315805476648916830365745, "size": 79, "message": "Fix out-of-bounds read in parse_char_class() (Close #139)\n\n/[\\x{111111}]/ causes out-of-bounds read when encoding is a single byte\nencoding. \\x{111111} is an invalid codepoint for a single byte encoding.\nCheck if it is a valid codepoint.", "idx": 5}
{"func": "static void ccid3_hc_tx_packet_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_hist_entry *acked;\n\tktime_t now;\n\tunsigned long t_nfb;\n\tu32 r_sample;\n\n\t/* we are only interested in ACKs */\n\tif (!(DCCP_SKB_CB(skb)->dccpd_type == DCCP_PKT_ACK ||\n\t      DCCP_SKB_CB(skb)->dccpd_type == DCCP_PKT_DATAACK))\n\t\treturn;\n\t/*\n\t * Locate the acknowledged packet in the TX history.\n\t *\n\t * Returning \"entry not found\" here can for instance happen when\n\t *  - the host has not sent out anything (e.g. a passive server),\n\t *  - the Ack is outdated (packet with higher Ack number was received),\n\t *  - it is a bogus Ack (for a packet not sent on this connection).\n\t */\n\tacked = tfrc_tx_hist_find_entry(hc->tx_hist, dccp_hdr_ack_seq(skb));\n\tif (acked == NULL)\n\t\treturn;\n\t/* For the sake of RTT sampling, ignore/remove all older entries */\n\ttfrc_tx_hist_purge(&acked->next);\n\n\t/* Update the moving average for the RTT estimate (RFC 3448, 4.3) */\n\tnow\t  = ktime_get_real();\n\tr_sample  = dccp_sample_rtt(sk, ktime_us_delta(now, acked->stamp));\n\thc->tx_rtt = tfrc_ewma(hc->tx_rtt, r_sample, 9);\n\n\t/*\n\t * Update allowed sending rate X as per draft rfc3448bis-00, 4.2/3\n\t */\n\tif (hc->tx_state == TFRC_SSTATE_NO_FBACK) {\n\t\tccid3_hc_tx_set_state(sk, TFRC_SSTATE_FBACK);\n\n\t\tif (hc->tx_t_rto == 0) {\n\t\t\t/*\n\t\t\t * Initial feedback packet: Larger Initial Windows (4.2)\n\t\t\t */\n\t\t\thc->tx_x    = rfc3390_initial_rate(sk);\n\t\t\thc->tx_t_ld = now;\n\n\t\t\tccid3_update_send_interval(hc);\n\n\t\t\tgoto done_computing_x;\n\t\t} else if (hc->tx_p == 0) {\n\t\t\t/*\n\t\t\t * First feedback after nofeedback timer expiry (4.3)\n\t\t\t */\n\t\t\tgoto done_computing_x;\n\t\t}\n\t}\n\n\t/* Update sending rate (step 4 of [RFC 3448, 4.3]) */\n\tif (hc->tx_p > 0)\n\t\thc->tx_x_calc = tfrc_calc_x(hc->tx_s, hc->tx_rtt, hc->tx_p);\n\tccid3_hc_tx_update_x(sk, &now);\n\ndone_computing_x:\n\tccid3_pr_debug(\"%s(%p), RTT=%uus (sample=%uus), s=%u, \"\n\t\t\t       \"p=%u, X_calc=%u, X_recv=%u, X=%u\\n\",\n\t\t\t       dccp_role(sk), sk, hc->tx_rtt, r_sample,\n\t\t\t       hc->tx_s, hc->tx_p, hc->tx_x_calc,\n\t\t\t       (unsigned int)(hc->tx_x_recv >> 6),\n\t\t\t       (unsigned int)(hc->tx_x >> 6));\n\n\t/* unschedule no feedback timer */\n\tsk_stop_timer(sk, &hc->tx_no_feedback_timer);\n\n\t/*\n\t * As we have calculated new ipi, delta, t_nom it is possible\n\t * that we now can send a packet, so wake up dccp_wait_for_ccid\n\t */\n\tsk->sk_write_space(sk);\n\n\t/*\n\t * Update timeout interval for the nofeedback timer. In order to control\n\t * rate halving on networks with very low RTTs (<= 1 ms), use per-route\n\t * tunable RTAX_RTO_MIN value as the lower bound.\n\t */\n\thc->tx_t_rto = max_t(u32, 4 * hc->tx_rtt,\n\t\t\t\t  USEC_PER_SEC/HZ * tcp_rto_min(sk));\n\t/*\n\t * Schedule no feedback timer to expire in\n\t * max(t_RTO, 2 * s/X)  =  max(t_RTO, 2 * t_ipi)\n\t */\n\tt_nfb = max(hc->tx_t_rto, 2 * hc->tx_t_ipi);\n\n\tccid3_pr_debug(\"%s(%p), Scheduled no feedback timer to \"\n\t\t       \"expire in %lu jiffies (%luus)\\n\",\n\t\t       dccp_role(sk), sk, usecs_to_jiffies(t_nfb), t_nfb);\n\n\tsk_reset_timer(sk, &hc->tx_no_feedback_timer,\n\t\t\t   jiffies + usecs_to_jiffies(t_nfb));\n}", "target": 0, "cwe": ["CWE-200"], "project": "linux", "commit_id": "7b07f8eb75aa3097cdfd4f6eac3da49db787381d", "hash": 18654794387380207500606806654838729178, "size": 97, "message": "dccp: fix info leak via getsockopt(DCCP_SOCKOPT_CCID_TX_INFO)\n\nThe CCID3 code fails to initialize the trailing padding bytes of struct\ntfrc_tx_info added for alignment on 64 bit architectures. It that for\npotentially leaks four bytes kernel stack via the getsockopt() syscall.\nAdd an explicit memset(0) before filling the structure to avoid the\ninfo leak.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nCc: Gerrit Renker <gerrit@erg.abdn.ac.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 6}
{"func": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n{\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux", "commit_id": "cf872776fc84128bb779ce2b83a37c884c3203ae", "hash": 86641282337461885468464777828072685145, "size": 6, "message": "tty: Fix hang at ldsem_down_read()\n\nWhen a controlling tty is being hung up and the hang up is\nwaiting for a just-signalled tty reader or writer to exit, and a new tty\nreader/writer tries to acquire an ldisc reference concurrently with the\nldisc reference release from the signalled reader/writer, the hangup\ncan hang. The new reader/writer is sleeping in ldsem_down_read() and the\nhangup is sleeping in ldsem_down_write() [1].\n\nThe new reader/writer fails to wakeup the waiting hangup because the\nwrong lock count value is checked (the old lock count rather than the new\nlock count) to see if the lock is unowned.\n\nChange helper function to return the new lock count if the cmpxchg was\nsuccessful; document this behavior.\n\n[1] edited dmesg log from reporter\n\nSysRq : Show Blocked State\n  task                        PC stack   pid father\nsystemd         D ffff88040c4f0000     0     1      0 0x00000000\n ffff88040c49fbe0 0000000000000046 ffff88040c4a0000 ffff88040c49ffd8\n 00000000001d3980 00000000001d3980 ffff88040c4a0000 ffff88040593d840\n ffff88040c49fb40 ffffffff810a4cc0 0000000000000006 0000000000000023\nCall Trace:\n [<ffffffff810a4cc0>] ? sched_clock_cpu+0x9f/0xe4\n [<ffffffff810a4cc0>] ? sched_clock_cpu+0x9f/0xe4\n [<ffffffff810a4cc0>] ? sched_clock_cpu+0x9f/0xe4\n [<ffffffff810a4cc0>] ? sched_clock_cpu+0x9f/0xe4\n [<ffffffff817a6649>] schedule+0x24/0x5e\n [<ffffffff817a588b>] schedule_timeout+0x15b/0x1ec\n [<ffffffff810a4cc0>] ? sched_clock_cpu+0x9f/0xe4\n [<ffffffff817aa691>] ? _raw_spin_unlock_irq+0x24/0x26\n [<ffffffff817aa10c>] down_read_failed+0xe3/0x1b9\n [<ffffffff817aa26d>] ldsem_down_read+0x8b/0xa5\n [<ffffffff8142b5ca>] ? tty_ldisc_ref_wait+0x1b/0x44\n [<ffffffff8142b5ca>] tty_ldisc_ref_wait+0x1b/0x44\n [<ffffffff81423f5b>] tty_write+0x7d/0x28a\n [<ffffffff814241f5>] redirected_tty_write+0x8d/0x98\n [<ffffffff81424168>] ? tty_write+0x28a/0x28a\n [<ffffffff8115d03f>] do_loop_readv_writev+0x56/0x79\n [<ffffffff8115e604>] do_readv_writev+0x1b0/0x1ff\n [<ffffffff8116ea0b>] ? do_vfs_ioctl+0x32a/0x489\n [<ffffffff81167d9d>] ? final_putname+0x1d/0x3a\n [<ffffffff8115e6c7>] vfs_writev+0x2e/0x49\n [<ffffffff8115e7d3>] SyS_writev+0x47/0xaa\n [<ffffffff817ab822>] system_call_fastpath+0x16/0x1b\nbash            D ffffffff81c104c0     0  5469   5302 0x00000082\n ffff8800cf817ac0 0000000000000046 ffff8804086b22a0 ffff8800cf817fd8\n 00000000001d3980 00000000001d3980 ffff8804086b22a0 ffff8800cf817a48\n 000000000000b9a0 ffff8800cf817a78 ffffffff81004675 ffff8800cf817a44\nCall Trace:\n [<ffffffff81004675>] ? dump_trace+0x165/0x29c\n [<ffffffff810a4cc0>] ? sched_clock_cpu+0x9f/0xe4\n [<ffffffff8100edda>] ? save_stack_trace+0x26/0x41\n [<ffffffff817a6649>] schedule+0x24/0x5e\n [<ffffffff817a588b>] schedule_timeout+0x15b/0x1ec\n [<ffffffff810a4cc0>] ? sched_clock_cpu+0x9f/0xe4\n [<ffffffff817a9f03>] ? down_write_failed+0xa3/0x1c9\n [<ffffffff817aa691>] ? _raw_spin_unlock_irq+0x24/0x26\n [<ffffffff817a9f0b>] down_write_failed+0xab/0x1c9\n [<ffffffff817aa300>] ldsem_down_write+0x79/0xb1\n [<ffffffff817aada3>] ? tty_ldisc_lock_pair_timeout+0xa5/0xd9\n [<ffffffff817aada3>] tty_ldisc_lock_pair_timeout+0xa5/0xd9\n [<ffffffff8142bf33>] tty_ldisc_hangup+0xc4/0x218\n [<ffffffff81423ab3>] __tty_hangup+0x2e2/0x3ed\n [<ffffffff81424a76>] disassociate_ctty+0x63/0x226\n [<ffffffff81078aa7>] do_exit+0x79f/0xa11\n [<ffffffff81086bdb>] ? get_signal_to_deliver+0x206/0x62f\n [<ffffffff810b4bfb>] ? lock_release_holdtime.part.8+0xf/0x16e\n [<ffffffff81079b05>] do_group_exit+0x47/0xb5\n [<ffffffff81086c16>] get_signal_to_deliver+0x241/0x62f\n [<ffffffff810020a7>] do_signal+0x43/0x59d\n [<ffffffff810f2af7>] ? __audit_syscall_exit+0x21a/0x2a8\n [<ffffffff810b4bfb>] ? lock_release_holdtime.part.8+0xf/0x16e\n [<ffffffff81002655>] do_notify_resume+0x54/0x6c\n [<ffffffff817abaf8>] int_signal+0x12/0x17\n\nReported-by: Sami Farin <sami.farin@gmail.com>\nCc: <stable@vger.kernel.org> # 3.12.x\nSigned-off-by: Peter Hurley <peter@hurleysoftware.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 7}
{"func": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1, "cwe": ["CWE-703", "CWE-189"], "project": "linux", "commit_id": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3", "hash": 208655412096664790560002029648582237677, "size": 10, "message": "ipc,sem: fine grained locking for semtimedop\n\nIntroduce finer grained locking for semtimedop, to handle the common case\nof a program wanting to manipulate one semaphore from an array with\nmultiple semaphores.\n\nIf the call is a semop manipulating just one semaphore in an array with\nmultiple semaphores, only take the lock for that semaphore itself.\n\nIf the call needs to manipulate multiple semaphores, or another caller is\nin a transaction that manipulates multiple semaphores, the sem_array lock\nis taken, as well as all the locks for the individual semaphores.\n\nOn a 24 CPU system, performance numbers with the semop-multi\ntest with N threads and N semaphores, look like this:\n\n\tvanilla\t\tDavidlohr's\tDavidlohr's +\tDavidlohr's +\nthreads\t\t\tpatches\t\trwlock patches\tv3 patches\n10\t610652\t\t726325\t\t1783589\t\t2142206\n20\t341570\t\t365699\t\t1520453\t\t1977878\n30\t288102\t\t307037\t\t1498167\t\t2037995\n40\t290714\t\t305955\t\t1612665\t\t2256484\n50\t288620\t\t312890\t\t1733453\t\t2650292\n60\t289987\t\t306043\t\t1649360\t\t2388008\n70\t291298\t\t306347\t\t1723167\t\t2717486\n80\t290948\t\t305662\t\t1729545\t\t2763582\n90\t290996\t\t306680\t\t1736021\t\t2757524\n100\t292243\t\t306700\t\t1773700\t\t3059159\n\n[davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]\n[davidlohr.bueso@hp.com: make refcounter atomic]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Jason Low <jason.low2@hp.com>\nReviewed-by: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Emmanuel Benisty <benisty.e@gmail.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 8}
{"func": "void smb2cli_session_stop_replay(struct smbXcli_session *session)\n{\n\tsession->smb2->replay_active = false;\n}", "target": 0, "cwe": ["CWE-20"], "project": "samba", "commit_id": "a819d2b440aafa3138d95ff6e8b824da885a70e9", "hash": 170230412879814954843853791906823001425, "size": 4, "message": "CVE-2015-5296: libcli/smb: make sure we require signing when we demand encryption on a session\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=11536\n\nSigned-off-by: Stefan Metzmacher <metze@samba.org>\nReviewed-by: Jeremy Allison <jra@samba.org>", "idx": 9}
{"func": "psutil_proc_connections(PyObject *self, PyObject *args) {\n    long pid;\n    int pidinfo_result;\n    int iterations;\n    int i;\n    unsigned long nb;\n\n    struct proc_fdinfo *fds_pointer = NULL;\n    struct proc_fdinfo *fdp_pointer;\n    struct socket_fdinfo si;\n\n    PyObject *py_retlist = PyList_New(0);\n    PyObject *py_tuple = NULL;\n    PyObject *py_laddr = NULL;\n    PyObject *py_raddr = NULL;\n    PyObject *py_af_filter = NULL;\n    PyObject *py_type_filter = NULL;\n\n    if (py_retlist == NULL)\n        return NULL;\n\n    if (! PyArg_ParseTuple(args, \"lOO\", &pid, &py_af_filter, &py_type_filter))\n        goto error;\n\n    if (!PySequence_Check(py_af_filter) || !PySequence_Check(py_type_filter)) {\n        PyErr_SetString(PyExc_TypeError, \"arg 2 or 3 is not a sequence\");\n        goto error;\n    }\n\n    if (pid == 0)\n        return py_retlist;\n    pidinfo_result = psutil_proc_pidinfo(pid, PROC_PIDLISTFDS, 0, NULL, 0);\n    if (pidinfo_result <= 0)\n        goto error;\n\n    fds_pointer = malloc(pidinfo_result);\n    if (fds_pointer == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n\n    pidinfo_result = psutil_proc_pidinfo(\n        pid, PROC_PIDLISTFDS, 0, fds_pointer, pidinfo_result);\n    if (pidinfo_result <= 0)\n        goto error;\n\n    iterations = (pidinfo_result / PROC_PIDLISTFD_SIZE);\n    for (i = 0; i < iterations; i++) {\n        py_tuple = NULL;\n        py_laddr = NULL;\n        py_raddr = NULL;\n        fdp_pointer = &fds_pointer[i];\n\n        if (fdp_pointer->proc_fdtype == PROX_FDTYPE_SOCKET) {\n            errno = 0;\n            nb = proc_pidfdinfo((pid_t)pid, fdp_pointer->proc_fd,\n                                PROC_PIDFDSOCKETINFO, &si, sizeof(si));\n\n            // --- errors checking\n            if ((nb <= 0) || (nb < sizeof(si))) {\n                if (errno == EBADF) {\n                    // let's assume socket has been closed\n                    continue;\n                }\n                else {\n                    psutil_raise_for_pid(\n                        pid, \"proc_pidinfo(PROC_PIDFDSOCKETINFO)\");\n                    goto error;\n                }\n            }\n            // --- /errors checking\n\n            //\n            int fd, family, type, lport, rport, state;\n            char lip[200], rip[200];\n            int inseq;\n            PyObject *py_family;\n            PyObject *py_type;\n\n            fd = (int)fdp_pointer->proc_fd;\n            family = si.psi.soi_family;\n            type = si.psi.soi_type;\n\n            // apply filters\n            py_family = PyLong_FromLong((long)family);\n            inseq = PySequence_Contains(py_af_filter, py_family);\n            Py_DECREF(py_family);\n            if (inseq == 0)\n                continue;\n            py_type = PyLong_FromLong((long)type);\n            inseq = PySequence_Contains(py_type_filter, py_type);\n            Py_DECREF(py_type);\n            if (inseq == 0)\n                continue;\n\n            if (errno != 0) {\n                PyErr_SetFromErrno(PyExc_OSError);\n                goto error;\n            }\n\n            if ((family == AF_INET) || (family == AF_INET6)) {\n                if (family == AF_INET) {\n                    inet_ntop(AF_INET,\n                              &si.psi.soi_proto.pri_tcp.tcpsi_ini. \\\n                                  insi_laddr.ina_46.i46a_addr4,\n                              lip,\n                              sizeof(lip));\n                    inet_ntop(AF_INET,\n                              &si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_faddr. \\\n                                  ina_46.i46a_addr4,\n                              rip,\n                              sizeof(rip));\n                }\n                else {\n                    inet_ntop(AF_INET6,\n                              &si.psi.soi_proto.pri_tcp.tcpsi_ini. \\\n                                  insi_laddr.ina_6,\n                              lip, sizeof(lip));\n                    inet_ntop(AF_INET6,\n                              &si.psi.soi_proto.pri_tcp.tcpsi_ini. \\\n                                  insi_faddr.ina_6,\n                              rip, sizeof(rip));\n                }\n\n                // check for inet_ntop failures\n                if (errno != 0) {\n                    PyErr_SetFromOSErrnoWithSyscall(\"inet_ntop()\");\n                    goto error;\n                }\n\n                lport = ntohs(si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_lport);\n                rport = ntohs(si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_fport);\n                if (type == SOCK_STREAM)\n                    state = (int)si.psi.soi_proto.pri_tcp.tcpsi_state;\n                else\n                    state = PSUTIL_CONN_NONE;\n\n                py_laddr = Py_BuildValue(\"(si)\", lip, lport);\n                if (!py_laddr)\n                    goto error;\n                if (rport != 0)\n                    py_raddr = Py_BuildValue(\"(si)\", rip, rport);\n                else\n                    py_raddr = Py_BuildValue(\"()\");\n                if (!py_raddr)\n                    goto error;\n\n                // construct the python list\n                py_tuple = Py_BuildValue(\n                    \"(iiiNNi)\", fd, family, type, py_laddr, py_raddr, state);\n                if (!py_tuple)\n                    goto error;\n                if (PyList_Append(py_retlist, py_tuple))\n                    goto error;\n                Py_DECREF(py_tuple);\n            }\n            else if (family == AF_UNIX) {\n                py_laddr = PyUnicode_DecodeFSDefault(\n                    si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path);\n                if (!py_laddr)\n                    goto error;\n                py_raddr = PyUnicode_DecodeFSDefault(\n                    si.psi.soi_proto.pri_un.unsi_caddr.ua_sun.sun_path);\n                if (!py_raddr)\n                    goto error;\n                // construct the python list\n                py_tuple = Py_BuildValue(\n                    \"(iiiOOi)\",\n                    fd, family, type,\n                    py_laddr,\n                    py_raddr,\n                    PSUTIL_CONN_NONE);\n                if (!py_tuple)\n                    goto error;\n                if (PyList_Append(py_retlist, py_tuple))\n                    goto error;\n                Py_DECREF(py_tuple);\n                Py_DECREF(py_laddr);\n                Py_DECREF(py_raddr);\n            }\n        }\n    }\n\n    free(fds_pointer);\n    return py_retlist;\n\nerror:\n    Py_XDECREF(py_tuple);\n    Py_XDECREF(py_laddr);\n    Py_XDECREF(py_raddr);\n    Py_DECREF(py_retlist);\n    if (fds_pointer != NULL)\n        free(fds_pointer);\n    return NULL;\n}", "target": 1, "cwe": ["CWE-415"], "project": "psutil", "commit_id": "7d512c8e4442a896d56505be3e78f1156f443465", "hash": 177344690296141700705961386798247779146, "size": 195, "message": "Use Py_CLEAR instead of Py_DECREF to also set the variable to NULL (#1616)\n\nThese files contain loops that convert system data into python objects\r\nand during the process they create objects and dereference their\r\nrefcounts after they have been added to the resulting list.\r\n\r\nHowever, in case of errors during the creation of those python objects,\r\nthe refcount to previously allocated objects is dropped again with\r\nPy_XDECREF, which should be a no-op in case the paramater is NULL. Even\r\nso, in most of these loops the variables pointing to the objects are\r\nnever set to NULL, even after Py_DECREF is called at the end of the loop\r\niteration. This means, after the first iteration, if an error occurs\r\nthose python objects will get their refcount dropped two times,\r\nresulting in a possible double-free.", "idx": 10}
{"func": "void DRW_TableEntry::parseCode(int code, dxfReader *reader){\n    switch (code) {\n    case 5:\n        handle = reader->getHandleString();\n        break;\n    case 330:\n        parentHandle = reader->getHandleString();\n        break;\n    case 2:\n        name = reader->getUtf8String();\n        break;\n    case 70:\n        flags = reader->getInt32();\n        break;\n    case 1000:\n    case 1001:\n    case 1002:\n    case 1003:\n    case 1004:\n    case 1005:\n        extData.push_back(new DRW_Variant(code, reader->getString()));\n        break;\n    case 1010:\n    case 1011:\n    case 1012:\n    case 1013:\n        curr = new DRW_Variant(code, DRW_Coord(reader->getDouble(), 0.0, 0.0));\n        extData.push_back(curr);\n        break;\n    case 1020:\n    case 1021:\n    case 1022:\n    case 1023:\n        if (curr)\n            curr->setCoordY(reader->getDouble());\n        break;\n    case 1030:\n    case 1031:\n    case 1032:\n    case 1033:\n        if (curr)\n            curr->setCoordZ(reader->getDouble());\n        curr=NULL;\n        break;\n    case 1040:\n    case 1041:\n    case 1042:\n        extData.push_back(new DRW_Variant(code, reader->getDouble()));\n        break;\n    case 1070:\n    case 1071:\n        extData.push_back(new DRW_Variant(code, reader->getInt32() ));\n        break;\n    default:\n        break;\n    }\n}", "target": 1, "cwe": ["CWE-191"], "project": "libdxfrw", "commit_id": "fcd977cc7f8f6cc7f012e5b72d33cf7d77b3fa69", "hash": 96937073433208321504177626408078259850, "size": 57, "message": "fixed heap use after free vulnerability CVE-2021-21900\n\nas reported in TALOS-2021-1351 / CVE-2021-21900,\nDRW_TableEntry::parseCode had the potential to trigger an use after free exception with a malformed DXF file.", "idx": 11}
{"func": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\t/* Just ioremap, as this MDIO block is usually integrated into an\n\t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-476"], "project": "linux", "commit_id": "297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5", "hash": 215656745502851558378741979196750443806, "size": 64, "message": "net: phy: mdio-bcm-unimac: fix potential NULL dereference in unimac_mdio_probe()\n\nplatform_get_resource() may fail and return NULL, so we should\nbetter check it's return value to avoid a NULL pointer dereference\na bit later in the code.\n\nThis is detected by Coccinelle semantic patch.\n\n@@\nexpression pdev, res, n, t, e, e1, e2;\n@@\n\nres = platform_get_resource(pdev, t, n);\n+ if (!res)\n+   return -EINVAL;\n... when != res == NULL\ne = devm_ioremap(e1, res->start, e2);\n\nSigned-off-by: Wei Yongjun <weiyongjun1@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 12}
{"func": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-416"], "project": "linux", "commit_id": "9060cb719e61b685ec0102574e10337fa5f445ea", "hash": 127288569779227598533209542262262122687, "size": 6, "message": "net: crypto set sk to NULL when af_alg_release.\n\nKASAN has found use-after-free in sockfs_setattr.\nThe existed commit 6d8c50dcb029 (\"socket: close race condition between sock_close()\nand sockfs_setattr()\") is to fix this simillar issue, but it seems to ignore\nthat crypto module forgets to set the sk to NULL after af_alg_release.\n\nKASAN report details as below:\nBUG: KASAN: use-after-free in sockfs_setattr+0x120/0x150\nWrite of size 4 at addr ffff88837b956128 by task syz-executor0/4186\n\nCPU: 2 PID: 4186 Comm: syz-executor0 Not tainted xxx + #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n dump_stack+0xca/0x13e\n print_address_description+0x79/0x330\n ? vprintk_func+0x5e/0xf0\n kasan_report+0x18a/0x2e0\n ? sockfs_setattr+0x120/0x150\n sockfs_setattr+0x120/0x150\n ? sock_register+0x2d0/0x2d0\n notify_change+0x90c/0xd40\n ? chown_common+0x2ef/0x510\n chown_common+0x2ef/0x510\n ? chmod_common+0x3b0/0x3b0\n ? __lock_is_held+0xbc/0x160\n ? __sb_start_write+0x13d/0x2b0\n ? __mnt_want_write+0x19a/0x250\n do_fchownat+0x15c/0x190\n ? __ia32_sys_chmod+0x80/0x80\n ? trace_hardirqs_on_thunk+0x1a/0x1c\n __x64_sys_fchownat+0xbf/0x160\n ? lockdep_hardirqs_on+0x39a/0x5e0\n do_syscall_64+0xc8/0x580\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\nRIP: 0033:0x462589\nCode: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89\nf7 48 89 d6 48 89\nca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3\n48 c7 c1 bc ff ff\nff f7 d8 64 89 01 48\nRSP: 002b:00007fb4b2c83c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000104\nRAX: ffffffffffffffda RBX: 000000000072bfa0 RCX: 0000000000462589\nRDX: 0000000000000000 RSI: 00000000200000c0 RDI: 0000000000000007\nRBP: 0000000000000005 R08: 0000000000001000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007fb4b2c846bc\nR13: 00000000004bc733 R14: 00000000006f5138 R15: 00000000ffffffff\n\nAllocated by task 4185:\n kasan_kmalloc+0xa0/0xd0\n __kmalloc+0x14a/0x350\n sk_prot_alloc+0xf6/0x290\n sk_alloc+0x3d/0xc00\n af_alg_accept+0x9e/0x670\n hash_accept+0x4a3/0x650\n __sys_accept4+0x306/0x5c0\n __x64_sys_accept4+0x98/0x100\n do_syscall_64+0xc8/0x580\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nFreed by task 4184:\n __kasan_slab_free+0x12e/0x180\n kfree+0xeb/0x2f0\n __sk_destruct+0x4e6/0x6a0\n sk_destruct+0x48/0x70\n __sk_free+0xa9/0x270\n sk_free+0x2a/0x30\n af_alg_release+0x5c/0x70\n __sock_release+0xd3/0x280\n sock_close+0x1a/0x20\n __fput+0x27f/0x7f0\n task_work_run+0x136/0x1b0\n exit_to_usermode_loop+0x1a7/0x1d0\n do_syscall_64+0x461/0x580\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nSyzkaller reproducer:\nr0 = perf_event_open(&(0x7f0000000000)={0x0, 0x70, 0x0, 0x0, 0x0, 0x0,\n0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, @perf_config_ext}, 0x0, 0x0,\n0xffffffffffffffff, 0x0)\nr1 = socket$alg(0x26, 0x5, 0x0)\ngetrusage(0x0, 0x0)\nbind(r1, &(0x7f00000001c0)=@alg={0x26, 'hash\\x00', 0x0, 0x0,\n'sha256-ssse3\\x00'}, 0x80)\nr2 = accept(r1, 0x0, 0x0)\nr3 = accept4$unix(r2, 0x0, 0x0, 0x0)\nr4 = dup3(r3, r0, 0x0)\nfchownat(r4, &(0x7f00000000c0)='\\x00', 0x0, 0x0, 0x1000)\n\nFixes: 6d8c50dcb029 (\"socket: close race condition between sock_close() and sockfs_setattr()\")\nSigned-off-by: Mao Wenan <maowenan@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 13}
{"func": "static int StreamTcpTest04 (void)\n{\n    Packet *p = SCMalloc(SIZE_OF_PACKET);\n    if (unlikely(p == NULL))\n        return 0;\n    Flow f;\n    ThreadVars tv;\n    StreamTcpThread stt;\n    TCPHdr tcph;\n    memset(p, 0, SIZE_OF_PACKET);\n    PacketQueue pq;\n    memset(&pq,0,sizeof(PacketQueue));\n    memset (&f, 0, sizeof(Flow));\n    memset(&tv, 0, sizeof (ThreadVars));\n    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = htonl(20);\n    tcph.th_flags = TH_ACK;\n    p->tcph = &tcph;\n\n    int ret = 0;\n\n    if (StreamTcpPacket(&tv, p, &stt, &pq) == -1)\n        goto end;\n\n    p->tcph->th_seq = htonl(9);\n    p->tcph->th_ack = htonl(19);\n    p->tcph->th_flags = TH_ACK|TH_PUSH;\n    p->flowflags = FLOW_PKT_TOSERVER;\n\n    if (StreamTcpPacket(&tv, p, &stt, &pq) == -1)\n        goto end;\n\n    if (stream_config.midstream != TRUE) {\n        ret = 1;\n        goto end;\n    }\n    if (((TcpSession *)(p->flow->protoctx))->state != TCP_ESTABLISHED)\n        goto end;\n\n    if (((TcpSession *)(p->flow->protoctx))->client.next_seq != 10 &&\n            ((TcpSession *)(p->flow->protoctx))->server.next_seq != 20)\n        goto end;\n\n    StreamTcpSessionClear(p->flow->protoctx);\n\n    ret = 1;\nend:\n    SCFree(p);\n    FLOW_DESTROY(&f);\n    StreamTcpUTDeinit(stt.ra_ctx);\n    return ret;\n}", "target": 0, "cwe": [], "project": "suricata", "commit_id": "843d0b7a10bb45627f94764a6c5d468a24143345", "hash": 126399452252065354612468439080702030374, "size": 60, "message": "stream: support RST getting lost/ignored\n\nIn case of a valid RST on a SYN, the state is switched to 'TCP_CLOSED'.\nHowever, the target of the RST may not have received it, or may not\nhave accepted it. Also, the RST may have been injected, so the supposed\nsender may not actually be aware of the RST that was sent in it's name.\n\nIn this case the previous behavior was to switch the state to CLOSED and\naccept no further TCP updates or stream reassembly.\n\nThis patch changes this. It still switches the state to CLOSED, as this\nis by far the most likely to be correct. However, it will reconsider\nthe state if the receiver continues to talk.\n\nTo do this on each state change the previous state will be recorded in\nTcpSession::pstate. If a non-RST packet is received after a RST, this\nTcpSession::pstate is used to try to continue the conversation.\n\nIf the (supposed) sender of the RST is also continueing the conversation\nas normal, it's highly likely it didn't send the RST. In this case\na stream event is generated.\n\nTicket: #2501\n\nReported-By: Kirill Shipulin", "idx": 14}
{"func": "int tcp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint err = 0;\n\tint old_state = sk->sk_state;\n\n\tif (old_state != TCP_CLOSE)\n\t\ttcp_set_state(sk, TCP_CLOSE);\n\n\t/* ABORT function of RFC793 */\n\tif (old_state == TCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (unlikely(tp->repair)) {\n\t\tsk->sk_err = ECONNABORTED;\n\t} else if (tcp_need_reset(old_state) ||\n\t\t   (tp->snd_nxt != tp->write_seq &&\n\t\t    (1 << old_state) & (TCPF_CLOSING | TCPF_LAST_ACK))) {\n\t\t/* The last check adjusts for discrepancy of Linux wrt. RFC\n\t\t * states\n\t\t */\n\t\ttcp_send_active_reset(sk, gfp_any());\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == TCP_SYN_SENT)\n\t\tsk->sk_err = ECONNRESET;\n\n\ttcp_clear_xmit_timers(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\ttcp_write_queue_purge(sk);\n\ttcp_fastopen_active_disable_ofo_check(sk);\n\tskb_rbtree_purge(&tp->out_of_order_queue);\n\n\tinet->inet_dport = 0;\n\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ttp->srtt_us = 0;\n\ttp->write_seq += tp->max_window + 2;\n\tif (tp->write_seq == 0)\n\t\ttp->write_seq = 1;\n\ticsk->icsk_backoff = 0;\n\ttp->snd_cwnd = 2;\n\ticsk->icsk_probes_out = 0;\n\ttp->packets_out = 0;\n\ttp->snd_ssthresh = TCP_INFINITE_SSTHRESH;\n\ttp->snd_cwnd_cnt = 0;\n\ttp->window_clamp = 0;\n\ttcp_set_ca_state(sk, TCP_CA_Open);\n\ttcp_clear_retrans(tp);\n\tinet_csk_delack_init(sk);\n\ttcp_init_send_head(sk);\n\tmemset(&tp->rx_opt, 0, sizeof(tp->rx_opt));\n\t__sk_dst_reset(sk);\n\ttcp_saved_syn_free(tp);\n\n\t/* Clean up fastopen related fields */\n\ttcp_free_fastopen_req(tp);\n\tinet->defer_connect = 0;\n\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\n\tsk->sk_error_report(sk);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-369"], "project": "linux", "commit_id": "499350a5a6e7512d9ed369ed63a4244b6536f4f8", "hash": 311326100035970681911318850369006398537, "size": 68, "message": "tcp: initialize rcv_mss to TCP_MIN_MSS instead of 0\n\nWhen tcp_disconnect() is called, inet_csk_delack_init() sets\nicsk->icsk_ack.rcv_mss to 0.\nThis could potentially cause tcp_recvmsg() => tcp_cleanup_rbuf() =>\n__tcp_select_window() call path to have division by 0 issue.\nSo this patch initializes rcv_mss to TCP_MIN_MSS instead of 0.\n\nReported-by: Andrey Konovalov  <andreyknvl@google.com>\nSigned-off-by: Wei Wang <weiwan@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Neal Cardwell <ncardwell@google.com>\nSigned-off-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 15}
{"func": "const char* GetOneCertName(CertName* name, int idx)\n{\n    switch (idx) {\n    case 0:\n       return name->country;\n\n    case 1:\n       return name->state;\n\n    case 2:\n       return name->locality;\n\n    case 3:\n       return name->sur;\n\n    case 4:\n       return name->org;\n\n    case 5:\n       return name->unit;\n\n    case 6:\n       return name->commonName;\n\n    case 7:\n       return name->serialDev;\n\n#ifdef WOLFSSL_CERT_EXT\n    case 8:\n       return name->busCat;\n\n    case 9:\n#else\n    case 8:\n#endif\n       return name->email;\n\n    default:\n       return 0;\n    }\n}", "target": 0, "cwe": ["CWE-125", "CWE-345"], "project": "wolfssl", "commit_id": "f93083be72a3b3d956b52a7ec13f307a27b6e093", "hash": 81132180198604386913210580819282171289, "size": 41, "message": "OCSP: improve handling of OCSP no check extension", "idx": 16}
{"func": "virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,\n                                    pid_t pid,\n                                    virStorageSource *src,\n                                    virStorageSource *dst)\n{\n    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };\n    int rc;\n\n    if (src && virStorageSourceIsLocalStorage(src))\n        data.src = src->path;\n\n    if (dst && virStorageSourceIsLocalStorage(dst))\n        data.dst = dst->path;\n\n    if (!data.src)\n        return 0;\n\n    if (pid == -1) {\n        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,\n                                 &data);\n    } else {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecuritySELinuxMoveImageMetadataHelper,\n                                           &data);\n    }\n\n    return rc;\n}", "target": 0, "cwe": ["CWE-732"], "project": "libvirt", "commit_id": "15073504dbb624d3f6c911e85557019d3620fdb2", "hash": 69848454194213287881561667087297391204, "size": 28, "message": "security: fix SELinux label generation logic\n\nA process can access a file if the set of MCS categories\nfor the file is equal-to *or* a subset-of, the set of\nMCS categories for the process.\n\nIf there are two VMs:\n\n  a) svirt_t:s0:c117\n  b) svirt_t:s0:c117,c720\n\nThen VM (b) is able to access files labelled for VM (a).\n\nIOW, we must discard case where the categories are equal\nbecause that is a subset of many other valid category pairs.\n\nFixes: https://gitlab.com/libvirt/libvirt/-/issues/153\nCVE-2021-3631\nReviewed-by: Peter Krempa <pkrempa@redhat.com>\nSigned-off-by: Daniel P. Berrangé <berrange@redhat.com>", "idx": 17}
{"func": "free_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}", "target": 0, "cwe": ["CWE-416"], "project": "vim", "commit_id": "9b4a80a66544f2782040b641498754bcb5b8d461", "hash": 296121535015818261979284677596604348836, "size": 11, "message": "patch 8.2.4281: using freed memory with :lopen and :bwipe\n\nProblem:    Using freed memory with :lopen and :bwipe.\nSolution:   Do not use a wiped out buffer.", "idx": 18}
{"func": "static bool tight_can_send_png_rect(VncState *vs, int w, int h)\n{\n    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {\n        return false;\n    }\n\n    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n        vs->client_pf.bytes_per_pixel == 1) {\n        return false;\n    }\n\n    return true;\n}", "target": 0, "cwe": ["CWE-125"], "project": "qemu", "commit_id": "9f64916da20eea67121d544698676295bbb105a7", "hash": 181373301286194270267827027704901818002, "size": 13, "message": "pixman/vnc: use pixman images in vnc.\n\nThe vnc code uses *three* DisplaySurfaces:\n\nFirst is the surface of the actual QemuConsole, usually the guest\nscreen, but could also be a text console (monitor/serial reachable via\nCtrl-Alt-<nr> keys).  This is left as-is.\n\nSecond is the current server's view of the screen content.  The vnc code\nuses this to figure which parts of the guest screen did _really_ change\nto reduce the amount of updates sent to the vnc clients.  It is also\nused as data source when sending out the updates to the clients.  This\nsurface gets replaced by a pixman image.  The format changes too,\ninstead of using the guest screen format we'll use fixed 32bit rgb\nframebuffer and convert the pixels on the fly when comparing and\nupdating the server framebuffer.\n\nThird surface carries the format expected by the vnc client.  That isn't\nused to store image data.  This surface is switched to PixelFormat and a\nboolean for bigendian byte order.\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>", "idx": 19}
{"func": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalMul<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n             output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(context,\n                         \"Mul only supports FLOAT32, INT32 and quantized UINT8,\"\n                         \" INT8 and INT16 now, got %d.\",\n                         output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tensorflow", "commit_id": "1970c2158b1ffa416d159d03c3370b9a462aee35", "hash": 320636433887139205254046854605012004269, "size": 25, "message": "[tflite]: Insert `nullptr` checks when obtaining tensors.\n\nAs part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.\n\nWe also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).\n\nPiperOrigin-RevId: 332521299\nChange-Id: I29af455bcb48d0b92e58132d951a3badbd772d56", "idx": 20}
{"func": "GF_Err avcc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_Err e;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->config->configurationVersion);\n\tgf_bs_write_u8(bs, ptr->config->AVCProfileIndication);\n\tgf_bs_write_u8(bs, ptr->config->profile_compatibility);\n\tgf_bs_write_u8(bs, ptr->config->AVCLevelIndication);\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->config->complete_representation, 1);\n\t\tgf_bs_write_int(bs, 0x1F, 5);\n\t}\n\tgf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);\n\tgf_bs_write_int(bs, 0x7, 3);\n\tcount = gf_list_count(ptr->config->sequenceParameterSets);\n\tgf_bs_write_int(bs, count, 5);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\tcount = gf_list_count(ptr->config->pictureParameterSets);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tif (gf_avc_is_rext_profile(ptr->config->AVCProfileIndication)) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_bit_depth - 8, 3);\n\n\t\t\tcount = ptr->config->sequenceParameterSetExtensions ? gf_list_count(ptr->config->sequenceParameterSetExtensions) : 0;\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSetExtensions, i);\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "gpac", "commit_id": "90dc7f853d31b0a4e9441cba97feccf36d8b69a4", "hash": 261636204659864860879030128863941918953, "size": 59, "message": "fix some exploitable overflows (#994, #997)", "idx": 21}
{"func": "static int init_dumping(char *database, int init_func(char*))\n{\n  if (mysql_select_db(mysql, database))\n  {\n    DB_error(mysql, \"when selecting the database\");\n    return 1;                   /* If --force */\n  }\n  if (!path && !opt_xml)\n  {\n    if (opt_databases || opt_alldbs)\n    {\n      /*\n        length of table name * 2 (if name contains quotes), 2 quotes and 0\n      */\n      char quoted_database_buf[NAME_LEN*2+3];\n      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);\n\n      print_comment(md_result_file, 0,\n                    \"\\n--\\n-- Current Database: %s\\n--\\n\", qdatabase);\n\n      /* Call the view or table specific function */\n      init_func(qdatabase);\n\n      fprintf(md_result_file,\"\\nUSE %s;\\n\", qdatabase);\n      check_io(md_result_file);\n    }\n  }\n  return 0;\n} /* init_dumping */", "target": 1, "cwe": [], "project": "server", "commit_id": "5a43a31ee81bc181eeb5ef2bf0704befa6e0594d", "hash": 288188606584538931620297692439209243258, "size": 29, "message": "mysqldump: comments and identifiers with new lines\n\ndon't let identifiers with new lines to break a comment", "idx": 22}
{"func": "SCK_RemoveSocket(int sock_fd)\n{\n  union sockaddr_all saddr;\n  socklen_t saddr_len;\n\n  saddr_len = sizeof (saddr);\n\n  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {\n    DEBUG_LOG(\"getsockname() failed : %s\", strerror(errno));\n    return 0;\n  }\n\n  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||\n      saddr.sa.sa_family != AF_UNIX)\n    return 0;\n\n  if (unlink(saddr.un.sun_path) < 0) {\n    DEBUG_LOG(\"unlink(%s) failed : %s\", saddr.un.sun_path, strerror(errno));\n    return 0;\n  }\n\n  DEBUG_LOG(\"Removed %s\", saddr.un.sun_path);\n\n  return 1;\n}", "target": 1, "cwe": ["CWE-59"], "project": "chrony", "commit_id": "e18903a6b56341481a2e08469c0602010bf7bfe3", "hash": 35230413175058703309603200753645148148, "size": 25, "message": "switch to new util file functions\n\nReplace all fopen(), rename(), and unlink() calls with the new util\nfunctions.", "idx": 23}
{"func": "\nstatic int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n{\n    if (pkt->size >= 7 &&\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n        uint8_t desc[256];\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n        AVIStream *ast = st->priv_data;\n        AVInputFormat *sub_demuxer;\n        AVRational time_base;\n        int size;\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n                                             pkt->size - 7,\n                                             0, NULL, NULL, NULL, NULL);\n        AVProbeData pd;\n        unsigned int desc_len = avio_rl32(pb);\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n            goto error;\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n        avio_skip(pb, desc_len - ret);\n        if (*desc)\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n        avio_rl16(pb);   /* flags? */\n        avio_rl32(pb);   /* data size */\n\n        size = pb->buf_end - pb->buf_ptr;\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n                             .buf_size = size };\n        if (!pd.buf)\n            goto error;\n        memcpy(pd.buf, pb->buf_ptr, size);\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n        av_freep(&pd.buf);\n        if (!sub_demuxer)\n            goto error;\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n            goto error;\n\n        ast->sub_ctx->pb = pb;\n\n        if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)\n            goto error;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n            if (ast->sub_ctx->nb_streams != 1)\n                goto error;\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n            avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);\n            time_base = ast->sub_ctx->streams[0]->time_base;\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n        }\n        ast->sub_buffer = pkt->data;\n        memset(pkt, 0, sizeof(*pkt));\n        return 1;\n\nerror:\n        av_freep(&ast->sub_ctx);\n        av_freep(&pb);\n    }\n    return 0;", "target": 1, "cwe": ["CWE-200"], "project": "FFmpeg", "commit_id": "a5d849b149ca67ced2d271dc84db0bc95a548abb", "hash": 339657892829705179053459101103104389170, "size": 65, "message": "avformat/avidec: Limit formats in gab2 to srt and ass/ssa\n\nThis prevents part of one exploit leading to an information leak\n\nFound-by: Emil Lerner and Pavel Cheremushkin\nReported-by: Thierry Foucu <tfoucu@google.com>\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>", "idx": 24}
{"func": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif /*DEBUG*/\n\n\t\t/* Read the image in. This may involve a long computation and\n\t\t * will finish with load->real holding the decompressed image. \n\t\t *\n\t\t * We want our caller to be able to see this computation on\n\t\t * @out, so eval signals on ->real need to appear on ->out.\n\t\t */\n\t\tload->real->progress_signal = load->out;\n\n\t\t/* Note the load object on the image. Loaders can use \n\t\t * this to signal invalidate if they hit a load error. See\n\t\t * vips_foreign_load_invalidate() below.\n\t\t */\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\n\t\t/* ->header() read the header into @out, load has read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t */\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\n\t\t/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t */\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\n\treturn( vips_region_new( load->real ) );\n}", "target": 1, "cwe": ["CWE-362", "CWE-476"], "project": "libvips", "commit_id": "20d840e6da15c1574b3ed998bc92f91d1e36c2a5", "hash": 120845744665840745177368900871758501152, "size": 51, "message": "fix a crash with delayed load\n\nIf a delayed load failed, it could leave the pipeline only half-set up.\nSebsequent threads could then segv.\n\nSet a load-has-failed flag and test before generate.\n\nSee https://github.com/jcupitt/libvips/issues/893", "idx": 25}
{"func": "void MonCap::dump(Formatter *f) const\n{\n  f->dump_string(\"text\", text);\n}", "target": 0, "cwe": ["CWE-285"], "project": "ceph", "commit_id": "a2acedd2a7e12d58af6db35edbd8a9d29c557578", "hash": 136403641133630584862993400119255284985, "size": 4, "message": "mon/config-key: limit caps allowed to access the store\n\nHenceforth, we'll require explicit `allow` caps for commands, or for the\nconfig-key service. Blanket caps are no longer allowed for the\nconfig-key service, except for 'allow *'.\n\n(for luminous and mimic, we're also ensuring MonCap's parser is able to\nunderstand forward slashes '/' when parsing prefixes)\n\nSigned-off-by: Joao Eduardo Luis <joao@suse.de>\n(cherry picked from commit 5fff611041c5afeaf3c8eb09e4de0cc919d69237)", "idx": 26}
{"func": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-78"], "project": "radare2", "commit_id": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9", "hash": 323584353176450349779950574117385716745, "size": 3, "message": "Fix command injection on PDB download (#16966)\n\n* Fix r_sys_mkdirp with absolute path on Windows\r\n* Fix build with --with-openssl\r\n* Use RBuffer in r_socket_http_answer()\r\n* r_socket_http_answer: Fix read for big responses\r\n* Implement r_str_escape_sh()\r\n* Cleanup r_socket_connect() on Windows\r\n* Fix socket being created without a protocol\r\n* Fix socket connect with SSL ##socket\r\n* Use select() in r_socket_ready()\r\n* Fix read failing if received only protocol answer\r\n* Fix double-free\r\n* r_socket_http_get: Fail if req. SSL with no support\r\n* Follow redirects in r_socket_http_answer()\r\n* Fix r_socket_http_get result length with R2_CURL=1\r\n* Also follow redirects\r\n* Avoid using curl for downloading PDBs\r\n* Use r_socket_http_get() on UNIXs\r\n* Use WinINet API on Windows for r_socket_http_get()\r\n* Fix command injection\r\n* Fix r_sys_cmd_str_full output for binary data\r\n* Validate GUID on PDB download\r\n* Pass depth to socket_http_get_recursive()\r\n* Remove 'r_' and '__' from static function names\r\n* Fix is_valid_guid\r\n* Fix for comments", "idx": 27}
{"func": "R_API const char *r_str_sep(const char *base, const char *sep) {\n\tint i;\n\twhile (*base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*base == sep[i]) {\n\t\t\t\treturn base;\n\t\t\t}\n\t\t}\n\t\tbase++;\n\t}\n\treturn NULL;\n}", "target": 0, "cwe": ["CWE-78"], "project": "radare2", "commit_id": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9", "hash": 101896213544230505522001122073345273519, "size": 12, "message": "Fix command injection on PDB download (#16966)\n\n* Fix r_sys_mkdirp with absolute path on Windows\r\n* Fix build with --with-openssl\r\n* Use RBuffer in r_socket_http_answer()\r\n* r_socket_http_answer: Fix read for big responses\r\n* Implement r_str_escape_sh()\r\n* Cleanup r_socket_connect() on Windows\r\n* Fix socket being created without a protocol\r\n* Fix socket connect with SSL ##socket\r\n* Use select() in r_socket_ready()\r\n* Fix read failing if received only protocol answer\r\n* Fix double-free\r\n* r_socket_http_get: Fail if req. SSL with no support\r\n* Follow redirects in r_socket_http_answer()\r\n* Fix r_socket_http_get result length with R2_CURL=1\r\n* Also follow redirects\r\n* Avoid using curl for downloading PDBs\r\n* Use r_socket_http_get() on UNIXs\r\n* Use WinINet API on Windows for r_socket_http_get()\r\n* Fix command injection\r\n* Fix r_sys_cmd_str_full output for binary data\r\n* Validate GUID on PDB download\r\n* Pass depth to socket_http_get_recursive()\r\n* Remove 'r_' and '__' from static function names\r\n* Fix is_valid_guid\r\n* Fix for comments", "idx": 28}
{"func": "  ConnectionCallbacks& callbacks() override { return callbacks_; }", "target": 0, "cwe": ["CWE-400"], "project": "envoy", "commit_id": "0e49a495826ea9e29134c1bd54fdeb31a034f40c", "hash": 4963654012183071090083849923773496684, "size": 1, "message": "http/2: add stats and stream flush timeout (#139)\n\nThis commit adds a new stream flush timeout to guard against a\nremote server that does not open window once an entire stream has\nbeen buffered for flushing. Additional stats have also been added\nto better understand the codecs view of active streams as well as\namount of data buffered.\n\nSigned-off-by: Matt Klein <mklein@lyft.com>", "idx": 29}
{"func": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1, "cwe": ["CWE-476", "CWE-119"], "project": "libgit2", "commit_id": "2fdef641fd0dd2828bd948234ae86de75221a11a", "hash": 264973995053617208407365129092917795057, "size": 61, "message": "smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.", "idx": 30}
{"func": "static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    cache_filename[MagickPathExtent],\n    id[MagickPathExtent],\n    keyword[MagickPathExtent],\n    *options;\n\n  const unsigned char\n    *p;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  LinkedListInfo\n    *profiles;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    flags;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    signature;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  *id='\\0';\n  (void) ResetMagickMemory(keyword,0,sizeof(keyword));\n  offset=0;\n  do\n  {\n    /*\n      Decode image header;  header terminates one character beyond a ':'.\n    */\n    profiles=(LinkedListInfo *) NULL;\n    length=MagickPathExtent;\n    options=AcquireString((char *) NULL);\n    signature=GetMagickSignature((const StringInfo *) NULL);\n    image->depth=8;\n    image->compression=NoCompression;\n    while ((isgraph(c) != MagickFalse) && (c != (int) ':'))\n    {\n      register char\n        *p;\n\n      if (c == (int) '{')\n        {\n          char\n            *comment;\n\n          /*\n            Read comment-- any text between { }.\n          */\n          length=MagickPathExtent;\n          comment=AcquireString((char *) NULL);\n          for (p=comment; comment != (char *) NULL; p++)\n          {\n            c=ReadBlobByte(image);\n            if (c == (int) '\\\\')\n              c=ReadBlobByte(image);\n            else\n              if ((c == EOF) || (c == (int) '}'))\n                break;\n            if ((size_t) (p-comment+1) >= length)\n              {\n                *p='\\0';\n                length<<=1;\n                comment=(char *) ResizeQuantumMemory(comment,length+\n                  MagickPathExtent,sizeof(*comment));\n                if (comment == (char *) NULL)\n                  break;\n                p=comment+strlen(comment);\n              }\n            *p=(char) c;\n          }\n          if (comment == (char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          *p='\\0';\n          (void) SetImageProperty(image,\"comment\",comment,exception);\n          comment=DestroyString(comment);\n          c=ReadBlobByte(image);\n        }\n      else\n        if (isalnum(c) != MagickFalse)\n          {\n            /*\n              Get the keyword.\n            */\n            length=MagickPathExtent;\n            p=keyword;\n            do\n            {\n              if (c == (int) '=')\n                break;\n              if ((size_t) (p-keyword) < (MagickPathExtent-1))\n                *p++=(char) c;\n              c=ReadBlobByte(image);\n            } while (c != EOF);\n            *p='\\0';\n            p=options;\n            while (isspace((int) ((unsigned char) c)) != 0)\n              c=ReadBlobByte(image);\n            if (c == (int) '=')\n              {\n                /*\n                  Get the keyword value.\n                */\n                c=ReadBlobByte(image);\n                while ((c != (int) '}') && (c != EOF))\n                {\n                  if ((size_t) (p-options+1) >= length)\n                    {\n                      *p='\\0';\n                      length<<=1;\n                      options=(char *) ResizeQuantumMemory(options,length+\n                        MagickPathExtent,sizeof(*options));\n                      if (options == (char *) NULL)\n                        break;\n                      p=options+strlen(options);\n                    }\n                  *p++=(char) c;\n                  c=ReadBlobByte(image);\n                  if (c == '\\\\')\n                    {\n                      c=ReadBlobByte(image);\n                      if (c == (int) '}')\n                        {\n                          *p++=(char) c;\n                          c=ReadBlobByte(image);\n                        }\n                    }\n                  if (*options != '{')\n                    if (isspace((int) ((unsigned char) c)) != 0)\n                      break;\n                }\n                if (options == (char *) NULL)\n                  ThrowReaderException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n              }\n            *p='\\0';\n            if (*options == '{')\n              (void) CopyMagickString(options,options+1,strlen(options));\n            /*\n              Assign a value to the specified keyword.\n            */\n            switch (*keyword)\n            {\n              case 'a':\n              case 'A':\n              {\n                if (LocaleCompare(keyword,\"alpha-trait\") == 0)\n                  {\n                    ssize_t\n                      alpha_trait;\n\n                    alpha_trait=ParseCommandOption(MagickPixelTraitOptions,\n                      MagickFalse,options);\n                    if (alpha_trait < 0)\n                      break;\n                    image->alpha_trait=(PixelTrait) alpha_trait;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'b':\n              case 'B':\n              {\n                if (LocaleCompare(keyword,\"background-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->background_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"blue-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.blue_primary.x=geometry_info.rho;\n                    image->chromaticity.blue_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.blue_primary.y=\n                        image->chromaticity.blue_primary.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"border-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->border_color,exception);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'c':\n              case 'C':\n              {\n                if (LocaleCompare(keyword,\"class\") == 0)\n                  {\n                    ssize_t\n                      storage_class;\n\n                    storage_class=ParseCommandOption(MagickClassOptions,\n                      MagickFalse,options);\n                    if (storage_class < 0)\n                      break;\n                    image->storage_class=(ClassType) storage_class;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colors\") == 0)\n                  {\n                    image->colors=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colorspace\") == 0)\n                  {\n                    ssize_t\n                      colorspace;\n\n                    colorspace=ParseCommandOption(MagickColorspaceOptions,\n                      MagickFalse,options);\n                    if (colorspace < 0)\n                      break;\n                    image->colorspace=(ColorspaceType) colorspace;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"compression\") == 0)\n                  {\n                    ssize_t\n                      compression;\n\n                    compression=ParseCommandOption(MagickCompressOptions,\n                      MagickFalse,options);\n                    if (compression < 0)\n                      break;\n                    image->compression=(CompressionType) compression;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"columns\") == 0)\n                  {\n                    image->columns=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'd':\n              case 'D':\n              {\n                if (LocaleCompare(keyword,\"delay\") == 0)\n                  {\n                    image->delay=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"depth\") == 0)\n                  {\n                    image->depth=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"dispose\") == 0)\n                  {\n                    ssize_t\n                      dispose;\n\n                    dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,\n                      options);\n                    if (dispose < 0)\n                      break;\n                    image->dispose=(DisposeType) dispose;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'e':\n              case 'E':\n              {\n                if (LocaleCompare(keyword,\"endian\") == 0)\n                  {\n                    ssize_t\n                      endian;\n\n                    endian=ParseCommandOption(MagickEndianOptions,MagickFalse,\n                      options);\n                    if (endian < 0)\n                      break;\n                    image->endian=(EndianType) endian;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"error\") == 0)\n                  {\n                    image->error.mean_error_per_pixel=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'g':\n              case 'G':\n              {\n                if (LocaleCompare(keyword,\"gamma\") == 0)\n                  {\n                    image->gamma=StringToDouble(options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"green-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.green_primary.x=geometry_info.rho;\n                    image->chromaticity.green_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.green_primary.y=\n                        image->chromaticity.green_primary.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'i':\n              case 'I':\n              {\n                if (LocaleCompare(keyword,\"id\") == 0)\n                  {\n                    (void) CopyMagickString(id,options,MagickPathExtent);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"iterations\") == 0)\n                  {\n                    image->iterations=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'm':\n              case 'M':\n              {\n                if (LocaleCompare(keyword,\"magick-signature\") == 0)\n                  {\n                    signature=(unsigned int) StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mattecolor\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->matte_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"maximum-error\") == 0)\n                  {\n                    image->error.normalized_maximum_error=StringToDouble(\n                      options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mean-error\") == 0)\n                  {\n                    image->error.normalized_mean_error=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"montage\") == 0)\n                  {\n                    (void) CloneString(&image->montage,options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'n':\n              case 'N':\n              {\n                if (LocaleCompare(keyword,\"number-channels\") == 0)\n                  {\n                    image->number_channels=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"number-meta-channels\") == 0)\n                  {\n                    image->number_meta_channels=StringToUnsignedLong(options);\n                    if (image->number_meta_channels > MaxPixelChannels)\n                      ThrowReaderException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                    break;\n                  }\n                break;\n              }\n              case 'o':\n              case 'O':\n              {\n                if (LocaleCompare(keyword,\"orientation\") == 0)\n                  {\n                    ssize_t\n                      orientation;\n\n                    orientation=ParseCommandOption(MagickOrientationOptions,\n                      MagickFalse,options);\n                    if (orientation < 0)\n                      break;\n                    image->orientation=(OrientationType) orientation;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'p':\n              case 'P':\n              {\n                if (LocaleCompare(keyword,\"page\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->page);\n                    geometry=DestroyString(geometry);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"pixel-intensity\") == 0)\n                  {\n                    ssize_t\n                      intensity;\n\n                    intensity=ParseCommandOption(MagickPixelIntensityOptions,\n                      MagickFalse,options);\n                    if (intensity < 0)\n                      break;\n                    image->intensity=(PixelIntensityMethod) intensity;\n                    break;\n                  }\n                if ((LocaleNCompare(keyword,\"profile:\",8) == 0) ||\n                    (LocaleNCompare(keyword,\"profile-\",8) == 0))\n                  {\n                    if (profiles == (LinkedListInfo *) NULL)\n                      profiles=NewLinkedList(0);\n                    (void) AppendValueToLinkedList(profiles,\n                      AcquireString(keyword+8));\n                    profile=BlobToStringInfo((const void *) NULL,(size_t)\n                      StringToLong(options));\n                    if (profile == (StringInfo *) NULL)\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    (void) SetImageProfile(image,keyword+8,profile,exception);\n                    profile=DestroyStringInfo(profile);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'q':\n              case 'Q':\n              {\n                if (LocaleCompare(keyword,\"quality\") == 0)\n                  {\n                    image->quality=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'r':\n              case 'R':\n              {\n                if (LocaleCompare(keyword,\"red-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.red_primary.x=geometry_info.rho;\n                    if ((flags & SigmaValue) != 0)\n                      image->chromaticity.red_primary.y=geometry_info.sigma;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rendering-intent\") == 0)\n                  {\n                    ssize_t\n                      rendering_intent;\n\n                    rendering_intent=ParseCommandOption(MagickIntentOptions,\n                      MagickFalse,options);\n                    if (rendering_intent < 0)\n                      break;\n                    image->rendering_intent=(RenderingIntent) rendering_intent;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"resolution\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->resolution.x=geometry_info.rho;\n                    image->resolution.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->resolution.y=image->resolution.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rows\") == 0)\n                  {\n                    image->rows=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 's':\n              case 'S':\n              {\n                if (LocaleCompare(keyword,\"scene\") == 0)\n                  {\n                    image->scene=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 't':\n              case 'T':\n              {\n                if (LocaleCompare(keyword,\"ticks-per-second\") == 0)\n                  {\n                    image->ticks_per_second=(ssize_t) StringToLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"tile-offset\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);\n                    geometry=DestroyString(geometry);\n                  }\n                if (LocaleCompare(keyword,\"type\") == 0)\n                  {\n                    ssize_t\n                      type;\n\n                    type=ParseCommandOption(MagickTypeOptions,MagickFalse,\n                      options);\n                    if (type < 0)\n                      break;\n                    image->type=(ImageType) type;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'u':\n              case 'U':\n              {\n                if (LocaleCompare(keyword,\"units\") == 0)\n                  {\n                    ssize_t\n                      units;\n\n                    units=ParseCommandOption(MagickResolutionOptions,\n                      MagickFalse,options);\n                    if (units < 0)\n                      break;\n                    image->units=(ResolutionType) units;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'w':\n              case 'W':\n              {\n                if (LocaleCompare(keyword,\"white-point\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.white_point.x=geometry_info.rho;\n                    image->chromaticity.white_point.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.white_point.y=\n                        image->chromaticity.white_point.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              default:\n              {\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n            }\n          }\n        else\n          c=ReadBlobByte(image);\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n    }\n    options=DestroyString(options);\n    (void) ReadBlobByte(image);\n    /*\n      Verify that required image information is defined.\n    */\n    if ((LocaleCompare(id,\"MagickCache\") != 0) ||\n        (image->storage_class == UndefinedClass) ||\n        (image->compression == UndefinedCompression) || (image->columns == 0) ||\n        (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (signature != GetMagickSignature((const StringInfo *) NULL))\n      ThrowReaderException(CacheError,\"IncompatibleAPI\");\n    if (image->montage != (char *) NULL)\n      {\n        register char\n          *p;\n\n        /*\n          Image directory.\n        */\n        length=MagickPathExtent;\n        image->directory=AcquireString((char *) NULL);\n        p=image->directory;\n        do\n        {\n          *p='\\0';\n          if ((strlen(image->directory)+MagickPathExtent) >= length)\n            {\n              /*\n                Allocate more memory for the image directory.\n              */\n              length<<=1;\n              image->directory=(char *) ResizeQuantumMemory(image->directory,\n                length+MagickPathExtent,sizeof(*image->directory));\n              if (image->directory == (char *) NULL)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              p=image->directory+strlen(image->directory);\n            }\n          c=ReadBlobByte(image);\n          *p++=(char) c;\n        } while (c != (int) '\\0');\n      }\n    if (profiles != (LinkedListInfo *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        register unsigned char\n          *p;\n\n        /*\n          Read image profiles.\n        */\n        ResetLinkedListIterator(profiles);\n        name=(const char *) GetNextValueInLinkedList(profiles);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              p=GetStringInfoDatum(profile);\n              count=ReadBlob(image,GetStringInfoLength(profile),p);\n            }\n          name=(const char *) GetNextValueInLinkedList(profiles);\n        }\n        profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);\n      }\n    depth=GetImageQuantumDepth(image,MagickFalse);\n    if (image->storage_class == PseudoClass)\n      {\n        /*\n          Create image colormap.\n        */\n        image->colormap=(PixelInfo *) AcquireQuantumMemory(image->colors+1,\n          sizeof(*image->colormap));\n        if (image->colormap == (PixelInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (image->colors != 0)\n          {\n            size_t\n              packet_size;\n\n            unsigned char\n              *colormap;\n\n            /*\n              Read image colormap from file.\n            */\n            packet_size=(size_t) (3UL*depth/8UL);\n            colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n              packet_size*sizeof(*colormap));\n            if (colormap == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,packet_size*image->colors,colormap);\n            if (count != (ssize_t) (packet_size*image->colors))\n              {\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"InsufficientImageDataInFile\");\n              }\n            p=colormap;\n            switch (depth)\n            {\n              default:\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"ImageDepthNotSupported\");\n              case 8:\n              {\n                unsigned char\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].red=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].green=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].blue=ScaleCharToQuantum(pixel);\n                }\n                break;\n              }\n              case 16:\n              {\n                unsigned short\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleShortToQuantum(pixel);\n                }\n                break;\n              }\n              case 32:\n              {\n                unsigned int\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleLongToQuantum(pixel);\n                }\n                break;\n              }\n            }\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n        (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n      ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n    /*\n      Attach persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickTrue,&offset,exception);\n    if (status == MagickFalse)\n      ThrowReaderException(CacheError,\"UnableToPersistPixelCache\");\n    /*\n      Proceed to next image.\n    */\n    do\n    {\n      c=ReadBlobByte(image);\n    } while ((isgraph(c) == MagickFalse) && (c != EOF));\n    if (c != EOF)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (c != EOF);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "cwe": ["CWE-770"], "project": "ImageMagick", "commit_id": "98e5d0001cda195da0e8ea7650ab85c6f8333ff5", "hash": 18622657883639707965069762967882186735, "size": 843, "message": "https://github.com/ImageMagick/ImageMagick/issues/546", "idx": 31}
{"func": "static int xenvif_handle_frag_list(struct xenvif *vif, struct sk_buff *skb)\n{\n\tunsigned int offset = skb_headlen(skb);\n\tskb_frag_t frags[MAX_SKB_FRAGS];\n\tint i;\n\tstruct ubuf_info *uarg;\n\tstruct sk_buff *nskb = skb_shinfo(skb)->frag_list;\n\n\tvif->tx_zerocopy_sent += 2;\n\tvif->tx_frag_overflow++;\n\n\txenvif_fill_frags(vif, nskb);\n\t/* Subtract frags size, we will correct it later */\n\tskb->truesize -= skb->data_len;\n\tskb->len += nskb->len;\n\tskb->data_len += nskb->len;\n\n\t/* create a brand new frags array and coalesce there */\n\tfor (i = 0; offset < skb->len; i++) {\n\t\tstruct page *page;\n\t\tunsigned int len;\n\n\t\tBUG_ON(i >= MAX_SKB_FRAGS);\n\t\tpage = alloc_page(GFP_ATOMIC|__GFP_COLD);\n\t\tif (!page) {\n\t\t\tint j;\n\t\t\tskb->truesize += skb->data_len;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tput_page(frags[j].page.p);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (offset + PAGE_SIZE < skb->len)\n\t\t\tlen = PAGE_SIZE;\n\t\telse\n\t\t\tlen = skb->len - offset;\n\t\tif (skb_copy_bits(skb, offset, page_address(page), len))\n\t\t\tBUG();\n\n\t\toffset += len;\n\t\tfrags[i].page.p = page;\n\t\tfrags[i].page_offset = 0;\n\t\tskb_frag_size_set(&frags[i], len);\n\t}\n\t/* swap out with old one */\n\tmemcpy(skb_shinfo(skb)->frags,\n\t       frags,\n\t       i * sizeof(skb_frag_t));\n\tskb_shinfo(skb)->nr_frags = i;\n\tskb->truesize += i * PAGE_SIZE;\n\n\t/* remove traces of mapped pages and frag_list */\n\tskb_frag_list_init(skb);\n\tuarg = skb_shinfo(skb)->destructor_arg;\n\tuarg->callback(uarg, true);\n\tskb_shinfo(skb)->destructor_arg = NULL;\n\n\tskb_shinfo(nskb)->tx_flags |= SKBTX_DEV_ZEROCOPY;\n\tkfree_skb(nskb);\n\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-399"], "project": "net-next", "commit_id": "e9d8b2c2968499c1f96563e6522c56958d5a1d0d", "hash": 35610229352877502480628172512423648573, "size": 62, "message": "xen-netback: disable rogue vif in kthread context\n\nWhen netback discovers frontend is sending malformed packet it will\ndisables the interface which serves that frontend.\n\nHowever disabling a network interface involving taking a mutex which\ncannot be done in softirq context, so we need to defer this process to\nkthread context.\n\nThis patch does the following:\n1. introduce a flag to indicate the interface is disabled.\n2. check that flag in TX path, don't do any work if it's true.\n3. check that flag in RX path, turn off that interface if it's true.\n\nThe reason to disable it in RX path is because RX uses kthread. After\nthis change the behavior of netback is still consistent -- it won't do\nany TX work for a rogue frontend, and the interface will be eventually\nturned off.\n\nAlso change a \"continue\" to \"break\" after xenvif_fatal_tx_err, as it\ndoesn't make sense to continue processing packets if frontend is rogue.\n\nThis is a fix for XSA-90.\n\nReported-by: Török Edwin <edwin@etorok.net>\nSigned-off-by: Wei Liu <wei.liu2@citrix.com>\nCc: Ian Campbell <ian.campbell@citrix.com>\nReviewed-by: David Vrabel <david.vrabel@citrix.com>\nAcked-by: Ian Campbell <ian.campbell@citrix.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 32}
{"func": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\n\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux-2.6", "commit_id": "f6d8bd051c391c1c0458a30b2a7abcd939329259", "hash": 117635411254206160326456258770112202353, "size": 28, "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 33}
{"func": "queryin(char *buf)\n{\n\tQPRS_STATE\tstate;\n\tint32\t\ti;\n\tltxtquery  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n\n#ifdef BS_DEBUG\n\tchar\t\tpbuf[16384],\n\t\t\t   *cur;\n#endif\n\n\t/* init state */\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\n\t/* init list of operand */\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\n\t/* parse query & make polish notation (postfix, but in reverse order) */\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"syntax error\"),\n\t\t\t\t errdetail(\"Empty query.\")));\n\n\t/* make finish struct */\n\tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n\tquery = (ltxtquery *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\n\t/* set item in polish notation */\n\tfor (i = 0; i < state.num; i++)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\tptr[i].distance = state.str->distance;\n\t\tptr[i].length = state.str->length;\n\t\tptr[i].flag = state.str->flag;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\n\t/* set user friendly-operand view */\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\n\t/* set left operand's position for every operator */\n\tpos = 0;\n\tfindoprnd(ptr, &pos);\n\n\treturn query;\n}", "target": 1, "cwe": ["CWE-703", "CWE-189"], "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "hash": 187458479240996495174873383444159729030, "size": 66, "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "idx": 34}
{"func": "bool DISOpticalFlowImpl::ocl_calc(InputArray I0, InputArray I1, InputOutputArray flow)\n{\n    UMat I0Mat = I0.getUMat();\n    UMat I1Mat = I1.getUMat();\n    bool use_input_flow = false;\n    if (flow.sameSize(I0) && flow.depth() == CV_32F && flow.channels() == 2)\n        use_input_flow = true;\n    else\n        flow.create(I1Mat.size(), CV_32FC2);\n    UMat &u_flowMat = flow.getUMatRef();\n    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */\n                         (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n\n    ocl_prepareBuffers(I0Mat, I1Mat, u_flowMat, use_input_flow);\n    u_Ux[coarsest_scale].setTo(0.0f);\n    u_Uy[coarsest_scale].setTo(0.0f);\n\n    for (int i = coarsest_scale; i >= finest_scale; i--)\n    {\n        w = u_I0s[i].cols;\n        h = u_I0s[i].rows;\n        ws = 1 + (w - patch_size) / patch_stride;\n        hs = 1 + (h - patch_size) / patch_stride;\n\n        if (!ocl_precomputeStructureTensor(u_I0xx_buf, u_I0yy_buf, u_I0xy_buf,\n                                           u_I0x_buf, u_I0y_buf, u_I0xs[i], u_I0ys[i]))\n            return false;\n\n        if (!ocl_PatchInverseSearch(u_Ux[i], u_Uy[i], u_I0s[i], u_I1s_ext[i], u_I0xs[i], u_I0ys[i], 2, i))\n            return false;\n\n        if (!ocl_Densification(u_Ux[i], u_Uy[i], u_Sx, u_Sy, u_I0s[i], u_I1s[i]))\n            return false;\n\n        if (variational_refinement_iter > 0)\n            variational_refinement_processors[i]->calcUV(u_I0s[i], u_I1s[i],\n                                                         u_Ux[i].getMat(ACCESS_WRITE), u_Uy[i].getMat(ACCESS_WRITE));\n\n        if (i > finest_scale)\n        {\n            resize(u_Ux[i], u_Ux[i - 1], u_Ux[i - 1].size());\n            resize(u_Uy[i], u_Uy[i - 1], u_Uy[i - 1].size());\n            multiply(u_Ux[i - 1], 2, u_Ux[i - 1]);\n            multiply(u_Uy[i - 1], 2, u_Uy[i - 1]);\n        }\n    }\n    vector<UMat> uxy(2);\n    uxy[0] = u_Ux[finest_scale];\n    uxy[1] = u_Uy[finest_scale];\n    merge(uxy, u_U);\n    resize(u_U, u_flowMat, u_flowMat.size());\n    multiply(u_flowMat, 1 << finest_scale, u_flowMat);\n\n    return true;\n}", "target": 1, "cwe": ["CWE-125", "CWE-369"], "project": "opencv", "commit_id": "d1615ba11a93062b1429fce9f0f638d1572d3418", "hash": 258326920177535192259434373411063875442, "size": 55, "message": "video:fixed DISOpticalFlow segfault from small img", "idx": 35}
{"func": "void GENERAL_NAME_set0_value(GENERAL_NAME *a, int type, void *value)\n{\n    switch (type) {\n    case GEN_X400:\n    case GEN_EDIPARTY:\n        a->d.other = value;\n        break;\n\n    case GEN_OTHERNAME:\n        a->d.otherName = value;\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        a->d.ia5 = value;\n        break;\n\n    case GEN_DIRNAME:\n        a->d.dirn = value;\n        break;\n\n    case GEN_IPADD:\n        a->d.ip = value;\n        break;\n\n    case GEN_RID:\n        a->d.rid = value;\n        break;\n    }\n    a->type = type;\n}", "target": 1, "cwe": ["CWE-476"], "project": "openssl", "commit_id": "b33c48b75aaf33c93aeda42d7138616b9e6a64cb", "hash": 48456965389891835636822926650833701497, "size": 32, "message": "Correctly compare EdiPartyName in GENERAL_NAME_cmp()\n\nIf a GENERAL_NAME field contained EdiPartyName data then it was\nincorrectly being handled as type \"other\". This could lead to a\nsegmentation fault.\n\nMany thanks to David Benjamin from Google for reporting this issue.\n\nCVE-2020-1971\n\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>", "idx": 36}
{"func": "gif_set_get_colormap (GifContext *context)\n{\n\tcontext->global_colormap_size = 0;\n\tcontext->state = GIF_GET_COLORMAP;\n}", "target": 0, "cwe": [], "project": "gdk-pixbuf", "commit_id": "f8569bb13e2aa1584dde61ca545144750f7a7c98", "hash": 257559583021413897657947088658541596791, "size": 5, "message": "GIF: Don't return a partially initialized pixbuf structure\n\nIt was found that gdk-pixbuf GIF image loader gdk_pixbuf__gif_image_load()\nroutine did not properly handle certain return values from their subroutines.\nA remote attacker could provide a specially-crafted GIF image, which once\nopened in an application, linked against gdk-pixbuf would lead to gdk-pixbuf\nto return partially initialized pixbuf structure, possibly having huge\nwidth and height, leading to that particular application termination due\nexcessive memory use.\n\nThe CVE identifier of CVE-2011-2485 has been assigned to this issue.", "idx": 37}
{"func": "bool samba_private_attr_name(const char *unix_ea_name)\n{\n\tstatic const char * const prohibited_ea_names[] = {\n\t\tSAMBA_POSIX_INHERITANCE_EA_NAME,\n\t\tSAMBA_XATTR_DOS_ATTRIB,\n\t\tSAMBA_XATTR_MARKER,\n\t\tXATTR_NTACL_NAME,\n\t\tNULL\n\t};\n\n\tint i;\n\n\tfor (i = 0; prohibited_ea_names[i]; i++) {\n\t\tif (strequal( prohibited_ea_names[i], unix_ea_name))\n\t\t\treturn true;\n\t}\n\tif (strncasecmp_m(unix_ea_name, SAMBA_XATTR_DOSSTREAM_PREFIX,\n\t\t\tstrlen(SAMBA_XATTR_DOSSTREAM_PREFIX)) == 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1, "cwe": ["CWE-787"], "project": "samba", "commit_id": "22b4091924977f6437b59627f33a8e6f02b41011", "hash": 89952104762470837844120825106577781073, "size": 22, "message": "CVE-2021-44142: smbd: add Netatalk xattr used by vfs_fruit to the list of private Samba xattrs\n\nThis is an internal xattr that should not be user visible.\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=14914\n\nSigned-off-by: Ralph Boehme <slow@samba.org>\nReviewed-by: Jeremy Allison <jra@samba.org>", "idx": 38}
{"func": "static int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tint retval = 0;\n\tint rc;\n\tint i;\n\tunsigned long line_state;\n\tstruct klsi_105_port_settings *cfg;\n\tunsigned long flags;\n\n\t/* Do a defined restart:\n\t * Set up sane default baud rate and send the 'READ_ON'\n\t * vendor command.\n\t * FIXME: set modem line control (how?)\n\t * Then read the modem line control and store values in\n\t * priv->line_state.\n\t */\n\tcfg = kmalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tcfg->pktlen   = 5;\n\tcfg->baudrate = kl5kusb105a_sio_b9600;\n\tcfg->databits = kl5kusb105a_dtb_8;\n\tcfg->unknown1 = 0;\n\tcfg->unknown2 = 1;\n\tklsi_105_chg_port_settings(port, cfg);\n\n\t/* set up termios structure */\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->termios.c_iflag = tty->termios.c_iflag;\n\tpriv->termios.c_oflag = tty->termios.c_oflag;\n\tpriv->termios.c_cflag = tty->termios.c_cflag;\n\tpriv->termios.c_lflag = tty->termios.c_lflag;\n\tfor (i = 0; i < NCCS; i++)\n\t\tpriv->termios.c_cc[i] = tty->termios.c_cc[i];\n\tpriv->cfg.pktlen   = cfg->pktlen;\n\tpriv->cfg.baudrate = cfg->baudrate;\n\tpriv->cfg.databits = cfg->databits;\n\tpriv->cfg.unknown1 = cfg->unknown1;\n\tpriv->cfg.unknown2 = cfg->unknown2;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t/* READ_ON and urb submission */\n\trc = usb_serial_generic_open(tty, port);\n\tif (rc) {\n\t\tretval = rc;\n\t\tgoto err_free_cfg;\n\t}\n\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR|USB_DIR_OUT|USB_RECIP_INTERFACE,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_ON,\n\t\t\t     0, /* index */\n\t\t\t     NULL,\n\t\t\t     0,\n\t\t\t     KLSI_TIMEOUT);\n\tif (rc < 0) {\n\t\tdev_err(&port->dev, \"Enabling read failed (error = %d)\\n\", rc);\n\t\tretval = rc;\n\t\tgoto err_generic_close;\n\t} else\n\t\tdev_dbg(&port->dev, \"%s - enabled reading\\n\", __func__);\n\n\trc = klsi_105_get_line_state(port, &line_state);\n\tif (rc < 0) {\n\t\tretval = rc;\n\t\tgoto err_disable_read;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->line_state = line_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tdev_dbg(&port->dev, \"%s - read line state 0x%lx\\n\", __func__,\n\t\t\tline_state);\n\n\treturn 0;\n\nerr_disable_read:\n\tusb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_OFF,\n\t\t\t     0, /* index */\n\t\t\t     NULL, 0,\n\t\t\t     KLSI_TIMEOUT);\nerr_generic_close:\n\tusb_serial_generic_close(port);\nerr_free_cfg:\n\tkfree(cfg);\n\n\treturn retval;\n}", "target": 0, "cwe": ["CWE-532"], "project": "linux", "commit_id": "146cc8a17a3b4996f6805ee5c080e7101277c410", "hash": 321636146651456080003776928136983001010, "size": 96, "message": "USB: serial: kl5kusb105: fix line-state error handling\n\nThe current implementation failed to detect short transfers when\nattempting to read the line state, and also, to make things worse,\nlogged the content of the uninitialised heap transfer buffer.\n\nFixes: abf492e7b3ae (\"USB: kl5kusb105: fix DMA buffers on stack\")\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nCc: stable <stable@vger.kernel.org>\nReviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Johan Hovold <johan@kernel.org>", "idx": 39}
{"func": "static int link_set_ipv4_forward(Link *link) {\n        const char *p = NULL, *v;\n        int r;\n\n        if (link->flags & IFF_LOOPBACK)\n                return 0;\n\n        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)\n                return 0;\n\n        p = strjoina(\"/proc/sys/net/ipv4/conf/\", link->ifname, \"/forwarding\");\n        v = one_zero(link_ipv4_forward_enabled(link));\n\n        r = write_string_file(p, v, 0);\n        if (r < 0) {\n                /* If the right value is set anyway, don't complain */\n                if (verify_one_line_file(p, v) > 0)\n                        return 0;\n\n                log_link_warning_errno(link, r, \"Cannot configure IPv4 forwarding for interface %s: %m\", link->ifname);\n        }\n\n        return 0;\n}", "target": 0, "cwe": ["CWE-120"], "project": "systemd", "commit_id": "f5a8c43f39937d97c9ed75e3fe8621945b42b0db", "hash": 169433504162328632983964713811465473550, "size": 24, "message": "networkd: IPv6 router discovery - follow IPv6AcceptRouterAdvertisemnt=\n\nThe previous behavior:\nWhen DHCPv6 was enabled, router discover was performed first, and then DHCPv6 was\nenabled only if the relevant flags were passed in the Router Advertisement message.\nMoreover, router discovery was performed even if AcceptRouterAdvertisements=false,\nmoreover, even if router advertisements were accepted (by the kernel) the flags\nindicating that DHCPv6 should be performed were ignored.\n\nNew behavior:\nIf RouterAdvertisements are accepted, and either no routers are found, or an\nadvertisement is received indicating DHCPv6 should be performed, the DHCPv6\nclient is started. Moreover, the DHCP option now truly enables the DHCPv6\nclient regardless of router discovery (though it will probably not be\nvery useful to get a lease withotu any routes, this seems the more consistent\napproach).\n\nThe recommended default setting should be to set DHCP=ipv4 and to leave\nIPv6AcceptRouterAdvertisements unset.", "idx": 40}
{"func": "AlgorithmEnum* ZRtp::findBestSASType(ZrtpPacketHello *hello) {\n\n    int  i;\n    int ii;\n    int numAlgosOffered;\n    AlgorithmEnum* algosOffered[ZrtpConfigure::maxNoOfAlgos+1];\n\n    int numAlgosConf;\n    AlgorithmEnum* algosConf[ZrtpConfigure::maxNoOfAlgos+1];\n\n    int num = hello->getNumSas();\n    if (num == 0) {\n        return &zrtpSasTypes.getByName(mandatorySasType);\n    }\n    // Buildlist of configured SAS algorithm names\n    numAlgosConf = configureAlgos.getNumConfiguredAlgos(SasType);\n    for (i = 0; i < numAlgosConf; i++) {\n        algosConf[i] = &configureAlgos.getAlgoAt(SasType, i);\n    }\n    // Build list of offered known algos in Hello,\n    for (numAlgosOffered = 0, i = 0; i < num; i++) {\n        algosOffered[numAlgosOffered] = &zrtpSasTypes.getByName((const char*)hello->getSasType(i++));\n        if (!algosOffered[numAlgosOffered]->isValid())\n            continue;\n        numAlgosOffered++;\n    }\n    // Lookup offered algos in configured algos. Prefer algorithms that appear first in Hello packet (offered).\n    for (i = 0; i < numAlgosOffered; i++) {\n        for (ii = 0; ii < numAlgosConf; ii++) {\n            if (*(int32_t*)(algosOffered[i]->getName()) == *(int32_t*)(algosConf[ii]->getName())) {\n                return algosConf[ii];\n            }\n        }\n    }\n    // If we don't have a match - use the mandatory algorithm\n    return &zrtpSasTypes.getByName(mandatorySasType);\n}", "target": 1, "cwe": ["CWE-119"], "project": "ZRTPCPP", "commit_id": "c8617100f359b217a974938c5539a1dd8a120b0e", "hash": 267838504488743014744811099404624294941, "size": 37, "message": "Fix vulnerabilities found and reported by Mark Dowd\n\n- limit length of memcpy\n- limit number of offered algorithms in Hello packet\n- length check in PING packet\n- fix a small coding error", "idx": 41}
{"func": "void gps_tracker( void )\n{\n\tssize_t unused;\n    int gpsd_sock;\n    char line[256], *temp;\n    struct sockaddr_in gpsd_addr;\n    int ret, is_json, pos;\n    fd_set read_fd;\n    struct timeval timeout;\n\n    /* attempt to connect to localhost, port 2947 */\n\n    pos = 0;\n    gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );\n\n    if( gpsd_sock < 0 ) {\n        return;\n    }\n\n    gpsd_addr.sin_family      = AF_INET;\n    gpsd_addr.sin_port        = htons( 2947 );\n    gpsd_addr.sin_addr.s_addr = inet_addr( \"127.0.0.1\" );\n\n    if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr,\n                 sizeof( gpsd_addr ) ) < 0 ) {\n        return;\n    }\n\n    // Check if it's GPSd < 2.92 or the new one\n    // 2.92+ immediately send stuff\n    // < 2.92 requires to send PVTAD command\n    FD_ZERO(&read_fd);\n    FD_SET(gpsd_sock, &read_fd);\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n    is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout);\n    if (is_json) {\n    \t/*\n\t\t\t{\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n\t\t\t?WATCH={\"json\":true};\n\t\t\t{\"class\":\"DEVICES\",\"devices\":[]}\n    \t */\n\n\n    \t// Get the crap and ignore it: {\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n    \tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n    \t\treturn;\n\n    \tis_json = (line[0] == '{');\n    \tif (is_json) {\n\t\t\t// Send ?WATCH={\"json\":true};\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tstrcpy(line, \"?WATCH={\\\"json\\\":true};\\n\");\n\t\t\tif( send( gpsd_sock, line, 22, 0 ) != 22 )\n\t\t\t\treturn;\n\n\t\t\t// Check that we have devices\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\t// Stop processing if there is no device\n\t\t\tif (strncmp(line, \"{\\\"class\\\":\\\"DEVICES\\\",\\\"devices\\\":[]}\", 32) == 0) {\n\t\t\t\tclose(gpsd_sock);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos = strlen(line);\n\t\t\t}\n    \t}\n    }\n\n    /* loop reading the GPS coordinates */\n\n    while( G.do_exit == 0 )\n    {\n        usleep( 500000 );\n        memset( G.gps_loc, 0, sizeof( float ) * 5 );\n\n        /* read position, speed, heading, altitude */\n        if (is_json) {\n        \t// Format definition: http://catb.org/gpsd/gpsd_json.html\n\n        \tif (pos == sizeof( line )) {\n        \t\tmemset(line, 0, sizeof(line));\n        \t\tpos = 0;\n        \t}\n\n        \t// New version, JSON\n        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - 1, 0 ) <= 0 )\n        \t\treturn;\n\n        \t// search for TPV class: {\"class\":\"TPV\"\n        \ttemp = strstr(line, \"{\\\"class\\\":\\\"TPV\\\"\");\n        \tif (temp == NULL) {\n        \t\tcontinue;\n        \t}\n\n        \t// Make sure the data we have is complete\n        \tif (strchr(temp, '}') == NULL) {\n        \t\t// Move the data at the beginning of the buffer;\n        \t\tpos = strlen(temp);\n        \t\tif (temp != line) {\n        \t\t\tmemmove(line, temp, pos);\n        \t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n        \t\t}\n        \t}\n\n\t\t\t// Example line: {\"class\":\"TPV\",\"tag\":\"MID2\",\"device\":\"/dev/ttyUSB0\",\"time\":1350957517.000,\"ept\":0.005,\"lat\":46.878936576,\"lon\":-115.832602964,\"alt\":1968.382,\"track\":0.0000,\"speed\":0.000,\"climb\":0.000,\"mode\":3}\n\n        \t// Latitude\n        \ttemp = strstr(temp, \"\\\"lat\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[0]);\n\n\t\t\t// Longitude\n\t\t\ttemp = strstr(temp, \"\\\"lon\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[1]);\n\n\t\t\t// Altitude\n\t\t\ttemp = strstr(temp, \"\\\"alt\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[4]);\n\n\t\t\t// Speed\n\t\t\ttemp = strstr(temp, \"\\\"speed\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[2]);\n\n\t\t\t// No more heading\n\n\t\t\t// Get the next TPV class\n\t\t\ttemp = strstr(temp, \"{\\\"class\\\":\\\"TPV\\\"\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\t\tpos = 0;\n\t\t\t} else {\n\t\t\t\tpos = strlen(temp);\n\t\t\t\tmemmove(line, temp, pos);\n\t\t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n\t\t\t}\n\n        } else {\n        \tmemset( line, 0, sizeof( line ) );\n\n\t\t\tsnprintf( line,  sizeof( line ) - 1, \"PVTAD\\r\\n\" );\n\t\t\tif( send( gpsd_sock, line, 7, 0 ) != 7 )\n\t\t\t\treturn;\n\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\tif( memcmp( line, \"GPSD,P=\", 7 ) != 0 )\n\t\t\t\tcontinue;\n\n\t\t\t/* make sure the coordinates are present */\n\n\t\t\tif( line[7] == '?' )\n\t\t\t\tcontinue;\n\n\t\t\tret = sscanf( line + 7, \"%f %f\", &G.gps_loc[0], &G.gps_loc[1] );\n\n\t\t\tif( ( temp = strstr( line, \"V=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[2] ); /* speed */\n\n\t\t\tif( ( temp = strstr( line, \"T=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[3] ); /* heading */\n\n\t\t\tif( ( temp = strstr( line, \"A=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[4] ); /* altitude */\n        }\n\n        if (G.record_data)\n\t\t\tfputs( line, G.f_gps );\n\n\t\tG.save_gps = 1;\n\n        if (G.do_exit == 0)\n\t\t{\n\t\t\tunused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );\n\t\t\tkill( getppid(), SIGUSR2 );\n\t\t}\n    }\n}", "target": 1, "cwe": ["CWE-787"], "project": "aircrack-ng", "commit_id": "ff70494dd389ba570dbdbf36f217c28d4381c6b5", "hash": 289398003672998099421553752302344985942, "size": 197, "message": "Airodump-ng: Fixed GPS stack overflow (Closes #13 on GitHub).\n\ngit-svn-id: http://svn.aircrack-ng.org/trunk@2416 28c6078b-6c39-48e3-add9-af49d547ecab", "idx": 42}
{"func": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\n\treturn (1);\n}", "target": 1, "cwe": ["CWE-772", "CWE-401"], "project": "src", "commit_id": "79a034b4aed29e965f45a13409268290c9910043", "hash": 134955981984600634024647053081479880826, "size": 18, "message": "Use regfree after we're done with preg.\n\nFrom gilles@", "idx": 43}
{"func": "void cil_destroy_nodecon(struct cil_nodecon *nodecon)\n{\n\tif (nodecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (nodecon->addr_str == NULL && nodecon->addr != NULL) {\n\t\tcil_destroy_ipaddr(nodecon->addr);\n\t}\n\n\tif (nodecon->mask_str == NULL && nodecon->mask != NULL) {\n\t\tcil_destroy_ipaddr(nodecon->mask);\n\t}\n\n\tif (nodecon->context_str == NULL && nodecon->context != NULL) {\n\t\tcil_destroy_context(nodecon->context);\n\t}\n\n\tfree(nodecon);\n}", "target": 0, "cwe": ["CWE-125"], "project": "selinux", "commit_id": "340f0eb7f3673e8aacaf0a96cbfcd4d12a405521", "hash": 67373150538101472388925613199888266867, "size": 20, "message": "libsepol/cil: Check for statements not allowed in optional blocks\n\nWhile there are some checks for invalid statements in an optional\nblock when resolving the AST, there are no checks when building the\nAST.\n\nOSS-Fuzz found the following policy which caused a null dereference\nin cil_tree_get_next_path().\n  (blockinherit b3)\n  (sid SID)\n  (sidorder(SID))\n  (optional o\n    (ibpkeycon :(1 0)s)\n    (block b3\n      (filecon\"\"block())\n      (filecon\"\"block())))\n\nThe problem is that the blockinherit copies block b3 before\nthe optional block is disabled. When the optional is disabled,\nblock b3 is deleted along with everything else in the optional.\nLater, when filecon statements with the same path are found an\nerror message is produced and in trying to find out where the block\nwas copied from, the reference to the deleted block is used. The\nerror handling code assumes (rightly) that if something was copied\nfrom a block then that block should still exist.\n\nIt is clear that in-statements, blocks, and macros cannot be in an\noptional, because that allows nodes to be copied from the optional\nblock to somewhere outside even though the optional could be disabled\nlater. When optionals are disabled the AST is reset and the\nresolution is restarted at the point of resolving macro calls, so\nanything resolved before macro calls will never be re-resolved.\nThis includes tunableifs, in-statements, blockinherits,\nblockabstracts, and macro definitions. Tunable declarations also\ncannot be in an optional block because they are needed to resolve\ntunableifs. It should be fine to allow blockinherit statements in\nan optional, because that is copying nodes from outside the optional\nto the optional and if the optional is later disabled, everything\nwill be deleted anyway.\n\nCheck and quit with an error if a tunable declaration, in-statement,\nblock, blockabstract, or macro definition is found within an\noptional when either building or resolving the AST.\n\nSigned-off-by: James Carter <jwcart2@gmail.com>", "idx": 44}
{"func": "static void sd_read_block_characteristics(struct scsi_disk *sdkp)\n{\n\tunsigned char *buffer;\n\tu16 rot;\n\tconst int vpd_len = 64;\n\n\tbuffer = kmalloc(vpd_len, GFP_KERNEL);\n\n\tif (!buffer ||\n\t    /* Block Device Characteristics VPD */\n\t    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))\n\t\tgoto out;\n\n\trot = get_unaligned_be16(&buffer[4]);\n\n\tif (rot == 1)\n\t\tqueue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);\n\n out:\n\tkfree(buffer);\n}", "target": 0, "cwe": ["CWE-284", "CWE-264"], "project": "linux", "commit_id": "0bfc96cb77224736dfa35c3c555d37b3646ef35e", "hash": 54808935711127512647448014934457921208, "size": 21, "message": "block: fail SCSI passthrough ioctls on partition devices\n\nLinux allows executing the SG_IO ioctl on a partition or LVM volume, and\nwill pass the command to the underlying block device.  This is\nwell-known, but it is also a large security problem when (via Unix\npermissions, ACLs, SELinux or a combination thereof) a program or user\nneeds to be granted access only to part of the disk.\n\nThis patch lets partitions forward a small set of harmless ioctls;\nothers are logged with printk so that we can see which ioctls are\nactually sent.  In my tests only CDROM_GET_CAPABILITY actually occurred.\nOf course it was being sent to a (partition on a) hard disk, so it would\nhave failed with ENOTTY and the patch isn't changing anything in\npractice.  Still, I'm treating it specially to avoid spamming the logs.\n\nIn principle, this restriction should include programs running with\nCAP_SYS_RAWIO.  If for example I let a program access /dev/sda2 and\n/dev/sdb, it still should not be able to read/write outside the\nboundaries of /dev/sda2 independent of the capabilities.  However, for\nnow programs with CAP_SYS_RAWIO will still be allowed to send the\nioctls.  Their actions will still be logged.\n\nThis patch does not affect the non-libata IDE driver.  That driver\nhowever already tests for bd != bd->bd_contains before issuing some\nioctl; it could be restricted further to forbid these ioctls even for\nprograms running with CAP_SYS_ADMIN/CAP_SYS_RAWIO.\n\nCc: linux-scsi@vger.kernel.org\nCc: Jens Axboe <axboe@kernel.dk>\nCc: James Bottomley <JBottomley@parallels.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n[ Make it also print the command name when warning - Linus ]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 45}
{"func": "lex (void)\n{\n  unsigned int c, c2;\n  int backslash = 0;\n  charclass ccl;\n  int i;\n\n  /* Basic plan: We fetch a character.  If it's a backslash,\n     we set the backslash flag and go through the loop again.\n     On the plus side, this avoids having a duplicate of the\n     main switch inside the backslash case.  On the minus side,\n     it means that just about every case begins with\n     \"if (backslash) ...\".  */\n  for (i = 0; i < 2; ++i)\n    {\n      if (MB_CUR_MAX > 1)\n        {\n          FETCH_WC (c, wctok, NULL);\n          if ((int)c == EOF)\n            goto normal_char;\n        }\n      else\n        FETCH(c, NULL);\n\n      switch (c)\n        {\n        case '\\\\':\n          if (backslash)\n            goto normal_char;\n          if (lexleft == 0)\n            dfaerror(_(\"unfinished \\\\ escape\"));\n          backslash = 1;\n          break;\n\n        case '^':\n          if (backslash)\n            goto normal_char;\n          if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || lasttok == END\n              || lasttok == LPAREN\n              || lasttok == OR)\n            return lasttok = BEGLINE;\n          goto normal_char;\n\n        case '$':\n          if (backslash)\n            goto normal_char;\n          if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || lexleft == 0\n              || (syntax_bits & RE_NO_BK_PARENS\n                  ? lexleft > 0 && *lexptr == ')'\n                  : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == ')')\n              || (syntax_bits & RE_NO_BK_VBAR\n                  ? lexleft > 0 && *lexptr == '|'\n                  : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == '|')\n              || ((syntax_bits & RE_NEWLINE_ALT)\n                  && lexleft > 0 && *lexptr == '\\n'))\n            return lasttok = ENDLINE;\n          goto normal_char;\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (backslash && !(syntax_bits & RE_NO_BK_REFS))\n            {\n              laststart = 0;\n              return lasttok = BACKREF;\n            }\n          goto normal_char;\n\n        case '`':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = BEGLINE;\t/* FIXME: should be beginning of string */\n          goto normal_char;\n\n        case '\\'':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = ENDLINE;\t/* FIXME: should be end of string */\n          goto normal_char;\n\n        case '<':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = BEGWORD;\n          goto normal_char;\n\n        case '>':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = ENDWORD;\n          goto normal_char;\n\n        case 'b':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = LIMWORD;\n          goto normal_char;\n\n        case 'B':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = NOTLIMWORD;\n          goto normal_char;\n\n        case '?':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n          return lasttok = QMARK;\n\n        case '*':\n          if (backslash)\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n          return lasttok = STAR;\n\n        case '+':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n          return lasttok = PLUS;\n\n        case '{':\n          if (!(syntax_bits & RE_INTERVALS))\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n\n          if (syntax_bits & RE_NO_BK_BRACES)\n            {\n              /* Scan ahead for a valid interval; if it's not valid,\n                 treat it as a literal '{'.  */\n              int lo = -1, hi = -1;\n              char const *p = lexptr;\n              char const *lim = p + lexleft;\n              for (;  p != lim && ISASCIIDIGIT (*p);  p++)\n                lo = (lo < 0 ? 0 : lo * 10) + *p - '0';\n              if (p != lim && *p == ',')\n                while (++p != lim && ISASCIIDIGIT (*p))\n                  hi = (hi < 0 ? 0 : hi * 10) + *p - '0';\n              else\n                hi = lo;\n              if (p == lim || *p != '}'\n                  || lo < 0 || RE_DUP_MAX < hi || (0 <= hi && hi < lo))\n                goto normal_char;\n            }\n\n          minrep = 0;\n          /* Cases:\n             {M} - exact count\n             {M,} - minimum count, maximum is infinity\n             {M,N} - M through N */\n          FETCH(c, _(\"unfinished repeat count\"));\n          if (ISASCIIDIGIT (c))\n            {\n              minrep = c - '0';\n              for (;;)\n                {\n                  FETCH(c, _(\"unfinished repeat count\"));\n                  if (! ISASCIIDIGIT (c))\n                    break;\n                  minrep = 10 * minrep + c - '0';\n                }\n            }\n          else\n            dfaerror(_(\"malformed repeat count\"));\n          if (c == ',')\n            {\n              FETCH (c, _(\"unfinished repeat count\"));\n              if (! ISASCIIDIGIT (c))\n                maxrep = -1;\n              else\n                {\n                  maxrep = c - '0';\n                  for (;;)\n                    {\n                      FETCH (c, _(\"unfinished repeat count\"));\n                      if (! ISASCIIDIGIT (c))\n                        break;\n                      maxrep = 10 * maxrep + c - '0';\n                    }\n                  if (0 <= maxrep && maxrep < minrep)\n                    dfaerror (_(\"malformed repeat count\"));\n                }\n            }\n          else\n            maxrep = minrep;\n          if (!(syntax_bits & RE_NO_BK_BRACES))\n            {\n              if (c != '\\\\')\n                dfaerror(_(\"malformed repeat count\"));\n              FETCH(c, _(\"unfinished repeat count\"));\n            }\n          if (c != '}')\n            dfaerror(_(\"malformed repeat count\"));\n          laststart = 0;\n          return lasttok = REPMN;\n\n        case '|':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))\n            goto normal_char;\n          laststart = 1;\n          return lasttok = OR;\n\n        case '\\n':\n          if (syntax_bits & RE_LIMITED_OPS\n              || backslash\n              || !(syntax_bits & RE_NEWLINE_ALT))\n            goto normal_char;\n          laststart = 1;\n          return lasttok = OR;\n\n        case '(':\n          if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          ++parens;\n          laststart = 1;\n          return lasttok = LPAREN;\n\n        case ')':\n          if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)\n            goto normal_char;\n          --parens;\n          laststart = 0;\n          return lasttok = RPAREN;\n\n        case '.':\n          if (backslash)\n            goto normal_char;\n          if (MB_CUR_MAX > 1)\n            {\n              /* In multibyte environment period must match with a single\n                 character not a byte.  So we use ANYCHAR.  */\n              laststart = 0;\n              return lasttok = ANYCHAR;\n            }\n          zeroset(ccl);\n          notset(ccl);\n          if (!(syntax_bits & RE_DOT_NEWLINE))\n            clrbit(eolbyte, ccl);\n          if (syntax_bits & RE_DOT_NOT_NULL)\n            clrbit('\\0', ccl);\n          laststart = 0;\n          return lasttok = CSET + charclass_index(ccl);\n\n        case 's':\n        case 'S':\n          if (!backslash || (syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n          zeroset(ccl);\n          for (c2 = 0; c2 < NOTCHAR; ++c2)\n            if (isspace(c2))\n              setbit(c2, ccl);\n          if (c == 'S')\n            notset(ccl);\n          laststart = 0;\n          return lasttok = CSET + charclass_index(ccl);\n\n        case 'w':\n        case 'W':\n          if (!backslash || (syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n          zeroset(ccl);\n          for (c2 = 0; c2 < NOTCHAR; ++c2)\n            if (IS_WORD_CONSTITUENT(c2))\n              setbit(c2, ccl);\n          if (c == 'W')\n            notset(ccl);\n          laststart = 0;\n          return lasttok = CSET + charclass_index(ccl);\n\n        case '[':\n          if (backslash)\n            goto normal_char;\n          laststart = 0;\n          return lasttok = parse_bracket_exp();\n\n        default:\n        normal_char:\n          laststart = 0;\n          /* For multibyte character sets, folding is done in atom.  Always\n             return WCHAR.  */\n          if (MB_CUR_MAX > 1)\n            return lasttok = WCHAR;\n\n          if (case_fold && isalpha(c))\n            {\n              zeroset(ccl);\n              setbit_case_fold_c (c, ccl);\n              return lasttok = CSET + charclass_index(ccl);\n            }\n\n          return lasttok = c;\n        }\n    }\n\n  /* The above loop should consume at most a backslash\n     and some other character. */\n  abort();\n  return END;\t/* keeps pedantic compilers happy. */\n}", "target": 1, "cwe": ["CWE-189"], "project": "grep", "commit_id": "cbbc1a45b9f843c811905c97c90a5d31f8e6c189", "hash": 89971027289024583441598476825776835130, "size": 316, "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int.", "idx": 46}
{"func": "rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)\n{\n    GError *real_error = NULL;\n    int result;\n\n    rsvg_return_val_if_fail (handle != NULL, FALSE, error);\n\n    handle->priv->error = &real_error;\n    if (handle->priv->ctxt == NULL) {\n        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,\n                                                      rsvg_handle_get_base_uri (handle));\n\n        /* if false, external entities work, but internal ones don't. if true, internal entities\n           work, but external ones don't. favor internal entities, in order to not cause a\n           regression */\n        handle->priv->ctxt->replaceEntities = TRUE;\n    }\n\n    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);\n    if (result != 0) {\n        rsvg_set_error (error, handle->priv->ctxt);\n        return FALSE;\n    }\n\n    handle->priv->error = NULL;\n\n    if (real_error != NULL) {\n        g_propagate_error (error, real_error);\n        return FALSE;\n    }\n\n    return TRUE;\n}", "target": 1, "cwe": ["CWE-20"], "project": "librsvg", "commit_id": "d83e426fff3f6d0fa6042d0930fb70357db24125", "hash": 238366599651541637646389501288967381711, "size": 33, "message": "io: Use XML_PARSE_NONET\n\nWe don't want to load resources off the net.\n\nBug #691708.", "idx": 47}
{"func": "NO_INLINE JsVar *jspeStatementFor() {\n  JSP_ASSERT_MATCH(LEX_R_FOR);\n  JSP_MATCH('(');\n  bool wasInLoop = (execInfo.execute&EXEC_IN_LOOP)!=0;\n  execInfo.execute |= EXEC_FOR_INIT;\n  // initialisation\n  JsVar *forStatement = 0;\n  // we could have 'for (;;)' - so don't munch up our semicolon if that's all we have\n  if (lex->tk != ';')\n    forStatement = jspeStatement();\n  if (jspIsInterrupted()) {\n    jsvUnLock(forStatement);\n    return 0;\n  }\n  execInfo.execute &= (JsExecFlags)~EXEC_FOR_INIT;\n  if (lex->tk == LEX_R_IN) {\n    // for (i in array)\n    // where i = jsvUnLock(forStatement);\n    if (JSP_SHOULD_EXECUTE && !jsvIsName(forStatement)) {\n      jsvUnLock(forStatement);\n      jsExceptionHere(JSET_ERROR, \"FOR a IN b - 'a' must be a variable name, not %t\", forStatement);\n      return 0;\n    }\n    bool addedIteratorToScope = false;\n    if (JSP_SHOULD_EXECUTE && !jsvGetRefs(forStatement)) {\n      // if the variable did not exist, add it to the scope\n      addedIteratorToScope = true;\n      jsvAddName(execInfo.root, forStatement);\n    }\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_IN, jsvUnLock(forStatement), 0);\n    JsVar *array = jsvSkipNameAndUnLock(jspeExpression());\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array), 0);\n    JslCharPos forBodyStart = jslCharPosClone(&lex->tokenStart);\n    JSP_SAVE_EXECUTE();\n    jspSetNoExecute();\n    execInfo.execute |= EXEC_IN_LOOP;\n    jsvUnLock(jspeBlockOrStatement());\n    JslCharPos forBodyEnd = jslCharPosClone(&lex->tokenStart);\n    if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n    JSP_RESTORE_EXECUTE();\n\n    if (JSP_SHOULD_EXECUTE) {\n      if (jsvIsIterable(array)) {\n        JsvIsInternalChecker checkerFunction = jsvGetInternalFunctionCheckerFor(array);\n        JsVar *foundPrototype = 0;\n\n        JsvIterator it;\n        jsvIteratorNew(&it, array, JSIF_DEFINED_ARRAY_ElEMENTS);\n        bool hasHadBreak = false;\n        while (JSP_SHOULD_EXECUTE && jsvIteratorHasElement(&it) && !hasHadBreak) {\n          JsVar *loopIndexVar = jsvIteratorGetKey(&it);\n          bool ignore = false;\n          if (checkerFunction && checkerFunction(loopIndexVar)) {\n            ignore = true;\n            if (jsvIsString(loopIndexVar) &&\n                jsvIsStringEqual(loopIndexVar, JSPARSE_INHERITS_VAR))\n              foundPrototype = jsvSkipName(loopIndexVar);\n          }\n          if (!ignore) {\n            JsVar *indexValue = jsvIsName(loopIndexVar) ?\n                jsvCopyNameOnly(loopIndexVar, false/*no copy children*/, false/*not a name*/) :\n                loopIndexVar;\n            if (indexValue) { // could be out of memory\n              assert(!jsvIsName(indexValue) && jsvGetRefs(indexValue)==0);\n              jsvSetValueOfName(forStatement, indexValue);\n              if (indexValue!=loopIndexVar) jsvUnLock(indexValue);\n\n              jsvIteratorNext(&it);\n\n              jslSeekToP(&forBodyStart);\n              execInfo.execute |= EXEC_IN_LOOP;\n              jspDebuggerLoopIfCtrlC();\n              jsvUnLock(jspeBlockOrStatement());\n              if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n\n              if (execInfo.execute & EXEC_CONTINUE)\n                execInfo.execute = EXEC_YES;\n              else if (execInfo.execute & EXEC_BREAK) {\n                execInfo.execute = EXEC_YES;\n                hasHadBreak = true;\n              }\n            }\n          } else\n            jsvIteratorNext(&it);\n          jsvUnLock(loopIndexVar);\n\n          if (!jsvIteratorHasElement(&it) && foundPrototype) {\n            jsvIteratorFree(&it);\n            jsvIteratorNew(&it, foundPrototype, JSIF_DEFINED_ARRAY_ElEMENTS);\n            jsvUnLock(foundPrototype);\n            foundPrototype = 0;\n          }\n        }\n        assert(!foundPrototype);\n        jsvIteratorFree(&it);\n      } else if (!jsvIsUndefined(array)) {\n        jsExceptionHere(JSET_ERROR, \"FOR loop can only iterate over Arrays, Strings or Objects, not %t\", array);\n      }\n    }\n    jslSeekToP(&forBodyEnd);\n    jslCharPosFree(&forBodyStart);\n    jslCharPosFree(&forBodyEnd);\n\n    if (addedIteratorToScope) {\n      jsvRemoveChild(execInfo.root, forStatement);\n    }\n    jsvUnLock2(forStatement, array);\n  } else { // ----------------------------------------------- NORMAL FOR LOOP\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n    int loopCount = JSPARSE_MAX_LOOP_ITERATIONS;\n#endif\n    bool loopCond = true;\n    bool hasHadBreak = false;\n\n    jsvUnLock(forStatement);\n    JSP_MATCH(';');\n    JslCharPos forCondStart = jslCharPosClone(&lex->tokenStart);\n    if (lex->tk != ';') {\n      JsVar *cond = jspeAssignmentExpression(); // condition\n      loopCond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(cond));\n      jsvUnLock(cond);\n    }\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(';',jslCharPosFree(&forCondStart);,0);\n    JslCharPos forIterStart = jslCharPosClone(&lex->tokenStart);\n    if (lex->tk != ')')  { // we could have 'for (;;)'\n      JSP_SAVE_EXECUTE();\n      jspSetNoExecute();\n      jsvUnLock(jspeExpression()); // iterator\n      JSP_RESTORE_EXECUTE();\n    }\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')',jslCharPosFree(&forCondStart);jslCharPosFree(&forIterStart);,0);\n\n    JslCharPos forBodyStart = jslCharPosClone(&lex->tokenStart); // actual for body\n    JSP_SAVE_EXECUTE();\n    if (!loopCond) jspSetNoExecute();\n    execInfo.execute |= EXEC_IN_LOOP;\n    jsvUnLock(jspeBlockOrStatement());\n    JslCharPos forBodyEnd = jslCharPosClone(&lex->tokenStart);\n    if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n    if (loopCond || !JSP_SHOULD_EXECUTE) {\n      if (execInfo.execute & EXEC_CONTINUE)\n        execInfo.execute = EXEC_YES;\n      else if (execInfo.execute & EXEC_BREAK) {\n        execInfo.execute = EXEC_YES;\n        hasHadBreak = true;\n      }\n    }\n    if (!loopCond) JSP_RESTORE_EXECUTE();\n    if (loopCond) {\n      jslSeekToP(&forIterStart);\n      if (lex->tk != ')') jsvUnLock(jspeExpression());\n    }\n    while (!hasHadBreak && JSP_SHOULD_EXECUTE && loopCond\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n        && loopCount-->0\n#endif\n    ) {\n      jslSeekToP(&forCondStart);\n      ;\n      if (lex->tk == ';') {\n        loopCond = true;\n      } else {\n        JsVar *cond = jspeAssignmentExpression();\n        loopCond = jsvGetBoolAndUnLock(jsvSkipName(cond));\n        jsvUnLock(cond);\n      }\n      if (JSP_SHOULD_EXECUTE && loopCond) {\n        jslSeekToP(&forBodyStart);\n        execInfo.execute |= EXEC_IN_LOOP;\n        jspDebuggerLoopIfCtrlC();\n        jsvUnLock(jspeBlockOrStatement());\n        if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n        if (execInfo.execute & EXEC_CONTINUE)\n          execInfo.execute = EXEC_YES;\n        else if (execInfo.execute & EXEC_BREAK) {\n          execInfo.execute = EXEC_YES;\n          hasHadBreak = true;\n        }\n      }\n      if (JSP_SHOULD_EXECUTE && loopCond && !hasHadBreak) {\n        jslSeekToP(&forIterStart);\n        if (lex->tk != ')') jsvUnLock(jspeExpression());\n      }\n    }\n    jslSeekToP(&forBodyEnd);\n\n    jslCharPosFree(&forCondStart);\n    jslCharPosFree(&forIterStart);\n    jslCharPosFree(&forBodyStart);\n    jslCharPosFree(&forBodyEnd);\n\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n    if (loopCount<=0) {\n      jsExceptionHere(JSET_ERROR, \"FOR Loop exceeded the maximum number of iterations (\"STRINGIFY(JSPARSE_MAX_LOOP_ITERATIONS)\")\");\n    }\n#endif\n  }\n  return 0;\n}", "target": 1, "cwe": ["CWE-125"], "project": "Espruino", "commit_id": "bf4416ab9129ee3afd56739ea4e3cd0da5484b6b", "hash": 68003434748018772058197252631117938142, "size": 199, "message": "Fix bug if using an undefined member of an object for for..in (fix #1437)", "idx": 48}
{"func": "void cil_destroy_default(struct cil_default *def)\n{\n\tif (def == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&def->class_strs, CIL_TRUE);\n\n\tcil_list_destroy(&def->class_datums, CIL_FALSE);\n\n\tfree(def);\n}", "target": 0, "cwe": ["CWE-125"], "project": "selinux", "commit_id": "340f0eb7f3673e8aacaf0a96cbfcd4d12a405521", "hash": 241673858653635798950313724331019005077, "size": 12, "message": "libsepol/cil: Check for statements not allowed in optional blocks\n\nWhile there are some checks for invalid statements in an optional\nblock when resolving the AST, there are no checks when building the\nAST.\n\nOSS-Fuzz found the following policy which caused a null dereference\nin cil_tree_get_next_path().\n  (blockinherit b3)\n  (sid SID)\n  (sidorder(SID))\n  (optional o\n    (ibpkeycon :(1 0)s)\n    (block b3\n      (filecon\"\"block())\n      (filecon\"\"block())))\n\nThe problem is that the blockinherit copies block b3 before\nthe optional block is disabled. When the optional is disabled,\nblock b3 is deleted along with everything else in the optional.\nLater, when filecon statements with the same path are found an\nerror message is produced and in trying to find out where the block\nwas copied from, the reference to the deleted block is used. The\nerror handling code assumes (rightly) that if something was copied\nfrom a block then that block should still exist.\n\nIt is clear that in-statements, blocks, and macros cannot be in an\noptional, because that allows nodes to be copied from the optional\nblock to somewhere outside even though the optional could be disabled\nlater. When optionals are disabled the AST is reset and the\nresolution is restarted at the point of resolving macro calls, so\nanything resolved before macro calls will never be re-resolved.\nThis includes tunableifs, in-statements, blockinherits,\nblockabstracts, and macro definitions. Tunable declarations also\ncannot be in an optional block because they are needed to resolve\ntunableifs. It should be fine to allow blockinherit statements in\nan optional, because that is copying nodes from outside the optional\nto the optional and if the optional is later disabled, everything\nwill be deleted anyway.\n\nCheck and quit with an error if a tunable declaration, in-statement,\nblock, blockabstract, or macro definition is found within an\noptional when either building or resolving the AST.\n\nSigned-off-by: James Carter <jwcart2@gmail.com>", "idx": 49}
{"func": "static int open_user_journal_directory(Server *s, DIR **ret_dir, char **ret_path) {\n        _cleanup_closedir_ DIR *dir = NULL;\n        _cleanup_free_ char *path = NULL;\n        sd_id128_t machine;\n        int r;\n\n        assert(s);\n\n        r = sd_id128_get_machine(&machine);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine machine ID, ignoring: %m\");\n\n        if (asprintf(&path, \"/var/log/journal/\" SD_ID128_FORMAT_STR \"/\", SD_ID128_FORMAT_VAL(machine)) < 0)\n                return log_oom();\n\n        dir = opendir(path);\n        if (!dir)\n                return log_error_errno(errno, \"Failed to open user journal directory '%s': %m\", path);\n\n        if (ret_dir)\n                *ret_dir = TAKE_PTR(dir);\n        if (ret_path)\n                *ret_path = TAKE_PTR(path);\n\n        return 0;\n}", "target": 0, "cwe": ["CWE-770"], "project": "systemd", "commit_id": "084eeb865ca63887098e0945fb4e93c852b91b0f", "hash": 325077570371582217088030642446811809152, "size": 26, "message": "journald: do not store the iovec entry for process commandline on stack\n\nThis fixes a crash where we would read the commandline, whose length is under\ncontrol of the sending program, and then crash when trying to create a stack\nallocation for it.\n\nCVE-2018-16864\nhttps://bugzilla.redhat.com/show_bug.cgi?id=1653855\n\nThe message actually doesn't get written to disk, because\njournal_file_append_entry() returns -E2BIG.", "idx": 50}
{"func": "void lex_start(THD *thd)\n{\n  LEX *lex= thd->lex;\n  DBUG_ENTER(\"lex_start\");\n  DBUG_PRINT(\"info\", (\"Lex %p\", thd->lex));\n\n  lex->thd= lex->unit.thd= thd;\n\n  lex->stmt_lex= lex; // default, should be rewritten for VIEWs And CTEs\n  DBUG_ASSERT(!lex->explain);\n\n  lex->context_stack.empty();\n  lex->unit.init_query();\n  lex->unit.init_select();\n  /* 'parent_lex' is used in init_query() so it must be before it. */\n  lex->select_lex.parent_lex= lex;\n  lex->select_lex.init_query();\n  lex->current_select_number= 1;\n  lex->curr_with_clause= 0;\n  lex->with_clauses_list= 0;\n  lex->with_clauses_list_last_next= &lex->with_clauses_list;\n  lex->clone_spec_offset= 0;\n  lex->value_list.empty();\n  lex->update_list.empty();\n  lex->set_var_list.empty();\n  lex->param_list.empty();\n  lex->view_list.empty();\n  lex->with_column_list.empty();\n  lex->with_persistent_for_clause= FALSE;\n  lex->column_list= NULL;\n  lex->index_list= NULL;\n  lex->prepared_stmt_params.empty();\n  lex->auxiliary_table_list.empty();\n  lex->unit.next= lex->unit.master=\n    lex->unit.link_next= lex->unit.return_to= 0;\n  lex->unit.prev= lex->unit.link_prev= 0;\n  lex->unit.slave= lex->current_select=\n    lex->all_selects_list= &lex->select_lex;\n  lex->select_lex.master= &lex->unit;\n  lex->select_lex.prev= &lex->unit.slave;\n  lex->select_lex.link_next= lex->select_lex.slave= lex->select_lex.next= 0;\n  lex->select_lex.link_prev= (st_select_lex_node**)&(lex->all_selects_list);\n  lex->select_lex.options= 0;\n  lex->select_lex.sql_cache= SELECT_LEX::SQL_CACHE_UNSPECIFIED;\n  lex->select_lex.init_order();\n  lex->select_lex.group_list.empty();\n  if (lex->select_lex.group_list_ptrs)\n    lex->select_lex.group_list_ptrs->clear();\n  lex->describe= 0;\n  lex->analyze_stmt= 0;\n  lex->explain_json= false;\n  lex->subqueries= FALSE;\n  lex->context_analysis_only= 0;\n  lex->derived_tables= 0;\n  lex->with_cte_resolution= false;\n  lex->only_cte_resolution= false;\n  lex->safe_to_cache_query= 1;\n  lex->parsing_options.reset();\n  lex->empty_field_list_on_rset= 0;\n  lex->select_lex.select_number= 1;\n  lex->part_info= 0;\n  lex->select_lex.in_sum_expr=0;\n  lex->select_lex.ftfunc_list_alloc.empty();\n  lex->select_lex.ftfunc_list= &lex->select_lex.ftfunc_list_alloc;\n  lex->select_lex.group_list.empty();\n  lex->select_lex.order_list.empty();\n  lex->select_lex.gorder_list.empty();\n  lex->m_sql_cmd= NULL;\n  lex->duplicates= DUP_ERROR;\n  lex->ignore= 0;\n  lex->spname= NULL;\n  lex->spcont= NULL;\n  lex->proc_list.first= 0;\n  lex->escape_used= FALSE;\n  lex->query_tables= 0;\n  lex->reset_query_tables_list(FALSE);\n  lex->expr_allows_subselect= TRUE;\n  lex->use_only_table_context= FALSE;\n  lex->parse_vcol_expr= FALSE;\n  lex->check_exists= FALSE;\n  lex->create_info.lex_start();\n  lex->verbose= 0;\n\n  lex->name= null_lex_str;\n  lex->event_parse_data= NULL;\n  lex->profile_options= PROFILE_NONE;\n  lex->nest_level=0 ;\n  lex->select_lex.nest_level_base= &lex->unit;\n  lex->allow_sum_func= 0;\n  lex->in_sum_func= NULL;\n\n  lex->used_tables= 0;\n  lex->only_view= FALSE;\n  lex->reset_slave_info.all= false;\n  lex->limit_rows_examined= 0;\n  lex->limit_rows_examined_cnt= ULONGLONG_MAX;\n  lex->var_list.empty();\n  lex->stmt_var_list.empty();\n  lex->proc_list.elements=0;\n\n  lex->save_group_list.empty();\n  lex->save_order_list.empty();\n  lex->win_ref= NULL;\n  lex->win_frame= NULL;\n  lex->frame_top_bound= NULL;\n  lex->frame_bottom_bound= NULL;\n  lex->win_spec= NULL;\n\n  lex->is_lex_started= TRUE;\n  DBUG_VOID_RETURN;\n}", "target": 0, "cwe": ["CWE-476"], "project": "server", "commit_id": "3a52569499e2f0c4d1f25db1e81617a9d9755400", "hash": 72462705629707934870000245940956418415, "size": 111, "message": "MDEV-25636: Bug report: abortion in sql/sql_parse.cc:6294\n\nThe asserion failure was caused by this query\n\n  select /*id=1*/ from t1\n  where\n   col= ( select /*id=2*/ from ... where corr_cond1\n          union\n          select /*id=4*/ from ... where corr_cond2)\n\nHere,\n- select with id=2 was correlated due to corr_cond1.\n- select with id=4 was initially correlated due to corr_cond2, but then\n  the optimizer optimized away the correlation, making the select with id=4\n  uncorrelated.\n\nHowever, since select with id=2 remained correlated, the execution had to\nre-compute the whole UNION. When it tried to execute select with id=4, it\nhit an assertion  (join buffer already free'd).\n\nThis is because select with id=4 has freed its execution structures after\nit has been executed once. The select is uncorrelated, so it did not expect\nit would need to be executed for the second time.\n\nFixed this by adding this logic in\nst_select_lex::optimize_unflattened_subqueries():\n\n  If a member of a UNION is correlated, mark all its members as\n  correlated, so that they are prepared to be executed multiple times.", "idx": 51}
{"func": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p = \\\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t// this is the \"new\" ABI, the old was reverse order\n\t\t\"=A0\tr12\\n\"\n\t\t\"=A1\tr13\\n\"\n\t\t\"=A2\tr14\\n\"\n\t\t\"=A3\tr15\\n\"\n\t\t\"gpr\tr0\t.16 0   0\\n\"\n\t\t\"gpr\tr1\t.16 2   0\\n\"\n\t\t\"gpr\tr2\t.16 4   0\\n\"\n\t\t\"gpr\tr3\t.16 6   0\\n\"\n\t\t\"gpr\tr4\t.16 8   0\\n\"\n\t\t\"gpr\tr5\t.16 10  0\\n\"\n\t\t\"gpr\tr6\t.16 12  0\\n\"\n\t\t\"gpr\tr7\t.16 14  0\\n\"\n\t\t\"gpr\tr8\t.16 16  0\\n\"\n\t\t\"gpr\tr9\t.16 18  0\\n\"\n\t\t\"gpr\tr10   .16 20  0\\n\"\n\t\t\"gpr\tr11   .16 22  0\\n\"\n\t\t\"gpr\tr12   .16 24  0\\n\"\n\t\t\"gpr\tr13   .16 26  0\\n\"\n\t\t\"gpr\tr14   .16 28  0\\n\"\n\t\t\"gpr\tr15   .16 30  0\\n\"\n\n\t\t\"gpr\tpc\t.16 0 0\\n\" // same as r0\n\t\t\"gpr\tsp\t.16 2 0\\n\" // same as r1\n\t\t\"flg\tsr\t.16 4 0\\n\" // same as r2\n\t\t\"flg\tc\t.1  4 0\\n\"\n\t\t\"flg\tz\t.1  4.1 0\\n\"\n\t\t\"flg\tn\t.1  4.2 0\\n\"\n\t\t// between is SCG1 SCG0 OSOFF CPUOFF GIE\n\t\t\"flg\tv\t.1  4.8 0\\n\";\n\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 1, "cwe": ["CWE-787"], "project": "radare2", "commit_id": "3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e", "hash": 283385350642788613028766501756073081634, "size": 37, "message": "Fix 4 byte oobread in msp430 disassembler ##crash\n\n* Only crashes with asan builds\n* Add missing =SN register\n* Reported by cnitlrt via huntrdev\n* BountyID: 1c22055b-b015-47a8-a57b-4982978751d0", "idx": 52}
{"func": "int git_path_cmp(\n\tconst char *name1, size_t len1, int isdir1,\n\tconst char *name2, size_t len2, int isdir2,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\tunsigned char c1, c2;\n\tsize_t len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = compare(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\n\tc1 = name1[len];\n\tc2 = name2[len];\n\n\tif (c1 == '\\0' && isdir1)\n\t\tc1 = '/';\n\n\tif (c2 == '\\0' && isdir2)\n\t\tc2 = '/';\n\n\treturn (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;\n}", "target": 0, "cwe": ["CWE-20", "CWE-706"], "project": "libgit2", "commit_id": "3f7851eadca36a99627ad78cbe56a40d3776ed01", "hash": 222428609162381631516836491110564867537, "size": 24, "message": "Disallow NTFS Alternate Data Stream attacks, even on Linux/macOS\n\nA little-known feature of NTFS is that it offers to store metadata in\nso-called \"Alternate Data Streams\" (inspired by Apple's \"resource\nforks\") that are copied together with the file they are associated with.\nThese Alternate Data Streams can be accessed via `<file name>:<stream\nname>:<stream type>`.\n\nDirectories, too, have Alternate Data Streams, and they even have a\ndefault stream type `$INDEX_ALLOCATION`. Which means that `abc/` and\n`abc::$INDEX_ALLOCATION/` are actually equivalent.\n\nThis is of course another attack vector on the Git directory that we\ndefinitely want to prevent.\n\nOn Windows, we already do this incidentally, by disallowing colons in\nfile/directory names.\n\nWhile it looks as if files'/directories' Alternate Data Streams are not\naccessible in the Windows Subsystem for Linux, and neither via\nCIFS/SMB-mounted network shares in Linux, it _is_ possible to access\nthem on SMB-mounted network shares on macOS.\n\nTherefore, let's go the extra mile and prevent this particular attack\n_everywhere_. To keep things simple, let's just disallow *any* Alternate\nData Stream of `.git`.\n\nThis is libgit2's variant of CVE-2019-1352.\n\nSigned-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>", "idx": 53}
{"func": "MOBI_RET mobi_reconstruct_infl(char *outstring, const MOBIIndx *infl, const MOBIIndexEntry *orth_entry) {\n    const char *label = orth_entry->label;\n    uint32_t *infl_groups = NULL;\n    size_t infl_count = mobi_get_indxentry_tagarray(&infl_groups, orth_entry, INDX_TAGARR_ORTH_INFL);\n    \n    if (infl_count == 0 || !infl_groups) {\n        return MOBI_SUCCESS;\n    }    \n    const char *start_tag = \"<idx:infl>\";\n    const char *end_tag = \"</idx:infl>\";\n    const char *iform_tag = \"<idx:iform%s value=\\\"%s\\\"/>\";\n    char name_attr[INDX_INFLBUF_SIZEMAX + 1];\n    char infl_tag[INDX_INFLBUF_SIZEMAX + 1];\n    strcpy(outstring, start_tag);\n    size_t initlen = strlen(start_tag) + strlen(end_tag);\n    size_t outlen = initlen;\n    size_t label_length = strlen(label);\n    if (label_length > INDX_INFLBUF_SIZEMAX) {\n        debug_print(\"Entry label too long (%s)\\n\", label);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (infl->cncx_record == NULL) {\n        debug_print(\"%s\\n\", \"Missing cncx record\");\n        return MOBI_DATA_CORRUPT;\n    }\n    for (size_t i = 0; i < infl_count; i++) {\n        size_t offset = infl_groups[i];\n        if (offset >= infl->entries_count) {\n            debug_print(\"%s\\n\", \"Invalid entry offset\");\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t *groups;\n        size_t group_cnt = mobi_get_indxentry_tagarray(&groups, &infl->entries[offset], INDX_TAGARR_INFL_GROUPS);\n        uint32_t *parts;\n        size_t part_cnt = mobi_get_indxentry_tagarray(&parts, &infl->entries[offset], INDX_TAGARR_INFL_PARTS_V2);\n        if (group_cnt != part_cnt) {\n            return MOBI_DATA_CORRUPT;\n        }\n        for (size_t j = 0; j < part_cnt; j++) {\n            name_attr[0] = '\\0';\n            char *group_name = mobi_get_cncx_string(infl->cncx_record, groups[j]);\n            if (group_name == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            if (strlen(group_name)) {\n                snprintf(name_attr, INDX_INFLBUF_SIZEMAX, \" name=\\\"%s\\\"\", group_name);\n            }\n            free(group_name);\n            \n            unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];\n            memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);\n            unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;\n            memcpy(decoded, label, label_length);\n            int decoded_length = (int) label_length;\n            MOBI_RET ret = mobi_decode_infl(decoded, &decoded_length, rule);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            if (decoded_length == 0) {\n                continue;\n            }\n            int n = snprintf(infl_tag, INDX_INFLBUF_SIZEMAX, iform_tag, name_attr, decoded);\n            if (n > INDX_INFLBUF_SIZEMAX) {\n                debug_print(\"Skipping truncated tag: %s\\n\", infl_tag);\n                continue;\n            }\n            outlen += strlen(infl_tag);\n            if (outlen > INDX_INFLTAG_SIZEMAX) {\n                debug_print(\"Inflections text in %s too long (%zu)\\n\", label, outlen);\n                return MOBI_ERROR;\n            }\n            strcat(outstring, infl_tag);\n        }\n    }\n    if (outlen == initlen) {\n        outstring[0] = '\\0';\n    } else {\n        strcat(outstring, end_tag);\n    }\n    return MOBI_SUCCESS;\n}", "target": 1, "cwe": ["CWE-703", "CWE-125"], "project": "libmobi", "commit_id": "fb1ab50e448ddbed746fd27ae07469bc506d838b", "hash": 308778925981838546847974342798871389238, "size": 82, "message": "Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input", "idx": 54}
{"func": "static void ssl3_take_mac(SSL *s)\n\t{\n\tconst char *sender;\n\tint slen;\n\n\tif (s->state & SSL_ST_CONNECT)\n\t\t{\n\t\tsender=s->method->ssl3_enc->server_finished_label;\n\t\tslen=s->method->ssl3_enc->server_finished_label_len;\n\t\t}\n\telse\n\t\t{\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\t}", "target": 1, "cwe": ["CWE-20"], "project": "openssl", "commit_id": "197e0ea817ad64820789d86711d55ff50d71f631", "hash": 40377441135256871731909623781044224626, "size": 19, "message": "Fix for TLS record tampering bug CVE-2013-4353", "idx": 55}
{"func": "static errno_t sssctl_manage_service(enum sssctl_svc_action action)\n{\n#ifdef HAVE_SYSTEMD\n    switch (action) {\n    case SSSCTL_SVC_START:\n        return sssctl_systemd_start();\n    case SSSCTL_SVC_STOP:\n        return sssctl_systemd_stop();\n    case SSSCTL_SVC_RESTART:\n        return sssctl_systemd_restart();\n    }\n#elif defined(HAVE_SERVICE)\n    switch (action) {\n    case SSSCTL_SVC_START:\n        return sssctl_run_command(SERVICE_PATH\" sssd start\");\n    case SSSCTL_SVC_STOP:\n        return sssctl_run_command(SERVICE_PATH\" sssd stop\");\n    case SSSCTL_SVC_RESTART:\n        return sssctl_run_command(SERVICE_PATH\" sssd restart\");\n    }\n#endif\n\n    return ENOSYS;\n}", "target": 1, "cwe": ["CWE-78"], "project": "sssd", "commit_id": "7ab83f97e1cbefb78ece17232185bdd2985f0bbe", "hash": 311936873159645090813210593019143787073, "size": 24, "message": "TOOLS: replace system() with execvp() to avoid execution of user supplied command\n\n:relnote: A flaw was found in SSSD, where the sssctl command was\nvulnerable to shell command injection via the logs-fetch and\ncache-expire subcommands. This flaw allows an attacker to trick\nthe root user into running a specially crafted sssctl command,\nsuch as via sudo, to gain root access. The highest threat from this\nvulnerability is to confidentiality, integrity, as well as system\navailability.\nThis patch fixes a flaw by replacing system() with execvp().\n\n:fixes: CVE-2021-3621\n\nReviewed-by: Pavel Březina <pbrezina@redhat.com>", "idx": 56}
{"func": "TEST_F(OAuth2Test, OAuthTestFullFlowPostWithParameters) {\n  // First construct the initial request to the oauth filter with URI parameters.\n  Http::TestRequestHeaderMapImpl first_request_headers{\n      {Http::Headers::get().Path.get(), \"/test?name=admin&level=trace\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Post},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  // This is the immediate response - a redirect to the auth cluster.\n  Http::TestResponseHeaderMapImpl first_response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().Location.get(),\n       \"https://auth.example.com/oauth/\"\n       \"authorize/?client_id=\" +\n           TEST_CLIENT_ID + \"&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&response_type=code&\"\n           \"redirect_uri=https%3A%2F%2Ftraffic.example.com%2F\"\n           \"_oauth&state=https%3A%2F%2Ftraffic.example.com%2Ftest%\"\n           \"3Fname%3Dadmin%26level%3Dtrace\"\n           \"&resource=oauth2-resource&resource=http%3A%2F%2Fexample.com\"\n           \"&resource=https%3A%2F%2Fexample.com\"},\n  };\n\n  // Fail the validation to trigger the OAuth flow.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  // Check that the redirect includes the escaped parameter characters, '?', '&' and '='.\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&first_response_headers), true));\n\n  // This represents the beginning of the OAuth filter.\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(first_request_headers, false));\n\n  // This represents the callback request from the authorization server.\n  Http::TestRequestHeaderMapImpl second_request_headers{\n      {Http::Headers::get().Path.get(), \"/_oauth?code=123&state=https%3A%2F%2Ftraffic.example.com%\"\n                                        \"2Ftest%3Fname%3Dadmin%26level%3Dtrace\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  // Deliberately fail the HMAC validation check.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(*oauth_client_, asyncGetAccessToken(\"123\", TEST_CLIENT_ID, \"asdf_client_secret_fdsa\",\n                                                  \"https://traffic.example.com\" + TEST_CALLBACK));\n\n  // Invoke the callback logic. As a side effect, state_ will be populated.\n  EXPECT_EQ(Http::FilterHeadersStatus::StopAllIterationAndBuffer,\n            filter_->decodeHeaders(second_request_headers, false));\n\n  EXPECT_EQ(1, config_->stats().oauth_unauthorized_rq_.value());\n  EXPECT_EQ(config_->clusterName(), \"auth.example.com\");\n\n  // Expected response after the callback & validation is complete - verifying we kept the\n  // state and method of the original request, including the query string parameters.\n  Http::TestRequestHeaderMapImpl second_response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"OauthHMAC=\"\n       \"NWUzNzE5MWQwYTg0ZjA2NjIyMjVjMzk3MzY3MzMyZmE0NjZmMWI2MjI1NWFhNDhkYjQ4NDFlZmRiMTVmMTk0MQ==;\"\n       \"version=1;path=/;Max-Age=;secure;HttpOnly\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"OauthExpires=;version=1;path=/;Max-Age=;secure;HttpOnly\"},\n      {Http::Headers::get().SetCookie.get(), \"BearerToken=;version=1;path=/;Max-Age=;secure\"},\n      {Http::Headers::get().Location.get(),\n       \"https://traffic.example.com/test?name=admin&level=trace\"},\n  };\n\n  EXPECT_CALL(decoder_callbacks_,\n              encodeHeaders_(HeaderMapEqualRef(&second_response_headers), true));\n  EXPECT_CALL(decoder_callbacks_, continueDecoding());\n\n  filter_->finishFlow();\n}", "target": 1, "cwe": ["CWE-416"], "project": "envoy", "commit_id": "7ffda4e809dec74449ebc330cebb9d2f4ab61360", "hash": 92455862527147651370415988121914046368, "size": 79, "message": "oauth2: do not blindly accept requests with a token in the Authorization headera (781)\n\nThe logic was broken because it assumed an additional call would be\nperformed to the auth server, which isn't the case. Per the filter\ndocumentation, a request is only considered subsequently authenticated\nif there's valid cookie that was set after the access token was received\nfrom the auth server:\n\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/oauth2_filter\n\nMore info about how to validate an access token (which we don't do, per\nabove):\n\nhttps://www.oauth.com/oauth2-servers/token-introspection-endpoint/\nhttps://datatracker.ietf.org/doc/html/rfc7662\n\nAlso fix the fact that ee shouldn't be calling continueDecoding() after\ndecoder_callbacks_->encodeHeaders().\n\nSigned-off-by: Raul Gutierrez Segales <rgs@pinterest.com>\nSigned-off-by: Matt Klein <mklein@lyft.com>\nSigned-off-by: Pradeep Rao <pcrao@google.com>", "idx": 57}
{"func": "Suffix(myword, suffix)\n    char *myword;\n    char *suffix;\n{\n    register int i;\n    register int j;\n    i = strlen(myword);\n    j = strlen(suffix);\n\n    if (i > j)\n    {\n\treturn (STRCMP((myword + i - j), suffix));\n    } else\n    {\n\treturn (-1);\n    }\n}", "target": 0, "cwe": ["CWE-787"], "project": "cracklib", "commit_id": "33d7fa4585247cd2247a1ffa032ad245836c6edb", "hash": 58645754601008845757376164610325051025, "size": 17, "message": "Fix a buffer overflow processing long words\n\nA buffer overflow processing long words has been discovered. This commit\napplies the patch from\nhttps://build.opensuse.org/package/view_file/Base:System/cracklib/0004-overflow-processing-long-words.patch\nby Howard Guo.\n\nSee https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=835386 and\nhttp://www.openwall.com/lists/oss-security/2016/08/23/8", "idx": 58}
{"func": "bool MDSDaemon::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t     bool& is_valid, CryptoKey& session_key,\n\t\t\t\t     std::unique_ptr<AuthAuthorizerChallenge> *challenge)\n{\n  Mutex::Locker l(mds_lock);\n  if (stopping) {\n    return false;\n  }\n  if (beacon.get_want_state() == CEPH_MDS_STATE_DNE)\n    return false;\n\n  AuthAuthorizeHandler *authorize_handler = 0;\n  switch (peer_type) {\n  case CEPH_ENTITY_TYPE_MDS:\n    authorize_handler = authorize_handler_cluster_registry->get_handler(protocol);\n    break;\n  default:\n    authorize_handler = authorize_handler_service_registry->get_handler(protocol);\n  }\n  if (!authorize_handler) {\n    dout(0) << \"No AuthAuthorizeHandler found for protocol \" << protocol << dendl;\n    is_valid = false;\n    return true;\n  }\n\n  AuthCapsInfo caps_info;\n  EntityName name;\n  uint64_t global_id;\n\n  RotatingKeyRing *keys = monc->rotating_secrets.get();\n  if (keys) {\n    is_valid = authorize_handler->verify_authorizer(\n      cct, keys,\n      authorizer_data, authorizer_reply, name, global_id, caps_info,\n      session_key, nullptr, challenge);\n  } else {\n    dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n    is_valid = false;\n  }\n\n  if (is_valid) {\n    entity_name_t n(con->get_peer_type(), global_id);\n\n    // We allow connections and assign Session instances to connections\n    // even if we have not been assigned a rank, because clients with\n    // \"allow *\" are allowed to connect and do 'tell' operations before\n    // we have a rank.\n    Session *s = NULL;\n    if (mds_rank) {\n      // If we do hold a rank, see if this is an existing client establishing\n      // a new connection, rather than a new client\n      s = mds_rank->sessionmap.get_session(n);\n    }\n\n    // Wire up a Session* to this connection\n    // It doesn't go into a SessionMap instance until it sends an explicit\n    // request to open a session (initial state of Session is `closed`)\n    if (!s) {\n      s = new Session;\n      s->info.auth_name = name;\n      s->info.inst.addr = con->get_peer_addr();\n      s->info.inst.name = n;\n      dout(10) << \" new session \" << s << \" for \" << s->info.inst << \" con \" << con << dendl;\n      con->set_priv(s);\n      s->connection = con;\n    } else {\n      dout(10) << \" existing session \" << s << \" for \" << s->info.inst << \" existing con \" << s->connection\n\t       << \", new/authorizing con \" << con << dendl;\n      con->set_priv(s->get());\n\n\n\n      // Wait until we fully accept the connection before setting\n      // s->connection.  In particular, if there are multiple incoming\n      // connection attempts, they will all get their authorizer\n      // validated, but some of them may \"lose the race\" and get\n      // dropped.  We only want to consider the winner(s).  See\n      // ms_handle_accept().  This is important for Sessions we replay\n      // from the journal on recovery that don't have established\n      // messenger state; we want the con from only the winning\n      // connect attempt(s).  (Normal reconnects that don't follow MDS\n      // recovery are reconnected to the existing con by the\n      // messenger.)\n    }\n\n    if (caps_info.allow_all) {\n      // Flag for auth providers that don't provide cap strings\n      s->auth_caps.set_allow_all();\n    } else {\n      bufferlist::iterator p = caps_info.caps.begin();\n      string auth_cap_str;\n      try {\n        ::decode(auth_cap_str, p);\n\n        dout(10) << __func__ << \": parsing auth_cap_str='\" << auth_cap_str << \"'\" << dendl;\n        std::ostringstream errstr;\n        if (!s->auth_caps.parse(g_ceph_context, auth_cap_str, &errstr)) {\n          dout(1) << __func__ << \": auth cap parse error: \" << errstr.str()\n\t\t  << \" parsing '\" << auth_cap_str << \"'\" << dendl;\n\t  clog->warn() << name << \" mds cap '\" << auth_cap_str\n\t\t       << \"' does not parse: \" << errstr.str();\n          is_valid = false;\n        }\n      } catch (buffer::error& e) {\n        // Assume legacy auth, defaults to:\n        //  * permit all filesystem ops\n        //  * permit no `tell` ops\n        dout(1) << __func__ << \": cannot decode auth caps bl of length \" << caps_info.caps.length() << dendl;\n        is_valid = false;\n      }\n    }\n  }\n\n  return true;  // we made a decision (see is_valid)\n}", "target": 0, "cwe": ["CWE-287", "CWE-284"], "project": "ceph", "commit_id": "5ead97120e07054d80623dada90a5cc764c28468", "hash": 301227377580180153469868140348226281488, "size": 116, "message": "auth/cephx: add authorizer challenge\n\nAllow the accepting side of a connection to reject an initial authorizer\nwith a random challenge.  The connecting side then has to respond with an\nupdated authorizer proving they are able to decrypt the service's challenge\nand that the new authorizer was produced for this specific connection\ninstance.\n\nThe accepting side requires this challenge and response unconditionally\nif the client side advertises they have the feature bit.  Servers wishing\nto require this improved level of authentication simply have to require\nthe appropriate feature.\n\nSigned-off-by: Sage Weil <sage@redhat.com>\n(cherry picked from commit f80b848d3f830eb6dba50123e04385173fa4540b)\n\n# Conflicts:\n#\tsrc/auth/Auth.h\n#\tsrc/auth/cephx/CephxProtocol.cc\n#\tsrc/auth/cephx/CephxProtocol.h\n#\tsrc/auth/none/AuthNoneProtocol.h\n#\tsrc/msg/Dispatcher.h\n#\tsrc/msg/async/AsyncConnection.cc\n\n- const_iterator\n- ::decode vs decode\n- AsyncConnection ctor arg noise\n- get_random_bytes(), not cct->random()", "idx": 59}
{"func": "sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char *buf = NULL;\n\tsize_t buf_len;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tif (df->enumerated)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\trv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: read private objects info failed\");\n\n\trv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);\n\n\tif (buf)\n\t\tfree(buf);\n\n\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: private info parse error\");\n\tdf->enumerated = 1;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0, "cwe": ["CWE-787"], "project": "OpenSC", "commit_id": "6903aebfddc466d966c7b865fae34572bf3ed23e", "hash": 55332694305653857702712485092716248016, "size": 30, "message": "Heap-buffer-overflow WRITE\n\nfixes https://oss-fuzz.com/testcase-detail/5088104168554496", "idx": 60}
{"func": "pair<string, string> splitField(const string& inp, char sepa)\n{\n  pair<string, string> ret;\n  string::size_type cpos=inp.find(sepa);\n  if(cpos==string::npos)\n    ret.first=inp;\n  else {\n    ret.first=inp.substr(0, cpos);\n    ret.second=inp.substr(cpos+1);\n  }\n  return ret;\n}", "target": 0, "cwe": ["CWE-399"], "project": "pdns", "commit_id": "881b5b03a590198d03008e4200dd00cc537712f3", "hash": 276720273973340536642109114283263917030, "size": 12, "message": "Reject qname's wirelength > 255, `chopOff()` handle dot inside labels", "idx": 61}
{"func": "static void vp8_release_frame(VP8Context *s, VP8Frame *f)\n{\n    av_buffer_unref(&f->seg_map);\n    ff_thread_release_buffer(s->avctx, &f->tf);\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "FFmpeg", "commit_id": "6b5d3fb26fb4be48e4966e4b1d97c2165538d4ef", "hash": 143540841400676209816172195702820813276, "size": 5, "message": "avcodec/webp: Always set pix_fmt\n\nFixes: out of array access\nFixes: 1434/clusterfuzz-testcase-minimized-6314998085189632\nFixes: 1435/clusterfuzz-testcase-minimized-6483783723253760\n\nFound-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/targets/ffmpeg\nReviewed-by: \"Ronald S. Bultje\" <rsbultje@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>", "idx": 62}
{"func": "static int iscsi_check_acceptor_state(struct iscsi_param *param, char *value,\n\t\t\t\tstruct iscsi_conn *conn)\n{\n\tu8 acceptor_boolean_value = 0, proposer_boolean_value = 0;\n\tchar *negoitated_value = NULL;\n\n\tif (IS_PSTATE_ACCEPTOR(param)) {\n\t\tpr_err(\"Received key \\\"%s\\\" twice, protocol error.\\n\",\n\t\t\t\tparam->name);\n\t\treturn -1;\n\t}\n\n\tif (IS_PSTATE_REJECT(param))\n\t\treturn 0;\n\n\tif (IS_TYPE_BOOL_AND(param)) {\n\t\tif (!strcmp(value, YES))\n\t\t\tproposer_boolean_value = 1;\n\t\tif (!strcmp(param->value, YES))\n\t\t\tacceptor_boolean_value = 1;\n\t\tif (acceptor_boolean_value && proposer_boolean_value)\n\t\t\tdo {} while (0);\n\t\telse {\n\t\t\tif (iscsi_update_param_value(param, NO) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (!proposer_boolean_value)\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_TYPE_BOOL_OR(param)) {\n\t\tif (!strcmp(value, YES))\n\t\t\tproposer_boolean_value = 1;\n\t\tif (!strcmp(param->value, YES))\n\t\t\tacceptor_boolean_value = 1;\n\t\tif (acceptor_boolean_value || proposer_boolean_value) {\n\t\t\tif (iscsi_update_param_value(param, YES) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (proposer_boolean_value)\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_TYPE_NUMBER(param)) {\n\t\tchar *tmpptr, buf[11];\n\t\tu32 acceptor_value = simple_strtoul(param->value, &tmpptr, 0);\n\t\tu32 proposer_value = simple_strtoul(value, &tmpptr, 0);\n\n\t\tmemset(buf, 0, sizeof(buf));\n\n\t\tif (!strcmp(param->name, MAXCONNECTIONS) ||\n\t\t    !strcmp(param->name, MAXBURSTLENGTH) ||\n\t\t    !strcmp(param->name, FIRSTBURSTLENGTH) ||\n\t\t    !strcmp(param->name, MAXOUTSTANDINGR2T) ||\n\t\t    !strcmp(param->name, DEFAULTTIME2RETAIN) ||\n\t\t    !strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tif (proposer_value > acceptor_value) {\n\t\t\t\tsprintf(buf, \"%u\", acceptor_value);\n\t\t\t\tif (iscsi_update_param_value(param,\n\t\t\t\t\t\t&buf[0]) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tif (acceptor_value > proposer_value) {\n\t\t\t\tsprintf(buf, \"%u\", acceptor_value);\n\t\t\t\tif (iscsi_update_param_value(param,\n\t\t\t\t\t\t&buf[0]) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\tstruct iscsi_param *param_mxdsl;\n\t\t\tunsigned long long tmp;\n\t\t\tint rc;\n\n\t\t\trc = strict_strtoull(param->value, 0, &tmp);\n\t\t\tif (rc < 0)\n\t\t\t\treturn -1;\n\n\t\t\tconn->conn_ops->MaxRecvDataSegmentLength = tmp;\n\t\t\tpr_debug(\"Saving op->MaxRecvDataSegmentLength from\"\n\t\t\t\t\" original initiator received value: %u\\n\",\n\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength);\n\n\t\t\tparam_mxdsl = iscsi_find_param_from_key(\n\t\t\t\t\t\tMAXXMITDATASEGMENTLENGTH,\n\t\t\t\t\t\tconn->param_list);\n\t\t\tif (!param_mxdsl)\n\t\t\t\treturn -1;\n\n\t\t\trc = iscsi_update_param_value(param,\n\t\t\t\t\t\tparam_mxdsl->value);\n\t\t\tif (rc < 0)\n\t\t\t\treturn -1;\n\n\t\t\tpr_debug(\"Updated %s to target MXDSL value: %s\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\n\t} else if (IS_TYPE_NUMBER_RANGE(param)) {\n\t\tnegoitated_value = iscsi_get_value_from_number_range(\n\t\t\t\t\tparam, value);\n\t\tif (!negoitated_value)\n\t\t\treturn -1;\n\t\tif (iscsi_update_param_value(param, negoitated_value) < 0)\n\t\t\treturn -1;\n\t} else if (IS_TYPE_VALUE_LIST(param)) {\n\t\tnegoitated_value = iscsi_check_valuelist_for_support(\n\t\t\t\t\tparam, value);\n\t\tif (!negoitated_value) {\n\t\t\tpr_err(\"Proposer's value list \\\"%s\\\" contains\"\n\t\t\t\t\" no valid values from Acceptor's value list\"\n\t\t\t\t\" \\\"%s\\\".\\n\", value, param->value);\n\t\t\treturn -1;\n\t\t}\n\t\tif (iscsi_update_param_value(param, negoitated_value) < 0)\n\t\t\treturn -1;\n\t} else if (IS_PHASE_DECLARATIVE(param)) {\n\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\treturn -1;\n\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t}\n\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-119"], "project": "target-pending", "commit_id": "cea4dcfdad926a27a18e188720efe0f2c9403456", "hash": 127357760228612529003393335163540411716, "size": 131, "message": "iscsi-target: fix heap buffer overflow on error\n\nIf a key was larger than 64 bytes, as checked by iscsi_check_key(), the\nerror response packet, generated by iscsi_add_notunderstood_response(),\nwould still attempt to copy the entire key into the packet, overflowing\nthe structure on the heap.\n\nRemote preauthentication kernel memory corruption was possible if a\ntarget was configured and listening on the network.\n\nCVE-2013-2850\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>", "idx": 63}
{"func": "plan_a (char const *filename)\n{\n  char const *s;\n  char const *lim;\n  char const **ptr;\n  char *buffer;\n  lin iline;\n  size_t size = instat.st_size;\n\n  /* Fail if the file size doesn't fit in a size_t,\n     or if storage isn't available.  */\n  if (! (size == instat.st_size\n\t && (buffer = malloc (size ? size : (size_t) 1))))\n    return false;\n\n  /* Read the input file, but don't bother reading it if it's empty.\n     When creating files, the files do not actually exist.  */\n  if (size)\n    {\n      if (S_ISREG (instat.st_mode))\n        {\n\t  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);\n\t  size_t buffered = 0, n;\n\t  if (ifd < 0)\n\t    pfatal (\"can't open file %s\", quotearg (filename));\n\n\t  while (size - buffered != 0)\n\t    {\n\t      n = read (ifd, buffer + buffered, size - buffered);\n\t      if (n == 0)\n\t\t{\n\t\t  /* Some non-POSIX hosts exaggerate st_size in text mode;\n\t\t     or the file may have shrunk!  */\n\t\t  size = buffered;\n\t\t  break;\n\t\t}\n\t      if (n == (size_t) -1)\n\t\t{\n\t\t  /* Perhaps size is too large for this host.  */\n\t\t  close (ifd);\n\t\t  free (buffer);\n\t\t  return false;\n\t\t}\n\t      buffered += n;\n\t    }\n\n\t  if (close (ifd) != 0)\n\t    read_fatal ();\n\t}\n      else if (S_ISLNK (instat.st_mode))\n\t{\n\t  ssize_t n;\n\t  n = safe_readlink (filename, buffer, size);\n\t  if (n < 0)\n\t    pfatal (\"can't read %s %s\", \"symbolic link\", quotearg (filename));\n\t  size = n;\n\t}\n      else\n\t{\n\t  free (buffer);\n\t  return false;\n\t}\n  }\n\n  /* Scan the buffer and build array of pointers to lines.  */\n  lim = buffer + size;\n  iline = 3; /* 1 unused, 1 for SOF, 1 for EOF if last line is incomplete */\n  for (s = buffer;  (s = (char *) memchr (s, '\\n', lim - s));  s++)\n    if (++iline < 0)\n      too_many_lines (filename);\n  if (! (iline == (size_t) iline\n\t && (size_t) iline * sizeof *ptr / sizeof *ptr == (size_t) iline\n\t && (ptr = (char const **) malloc ((size_t) iline * sizeof *ptr))))\n    {\n      free (buffer);\n      return false;\n    }\n  iline = 0;\n  for (s = buffer;  ;  s++)\n    {\n      ptr[++iline] = s;\n      if (! (s = (char *) memchr (s, '\\n', lim - s)))\n\tbreak;\n    }\n  if (size && lim[-1] != '\\n')\n    ptr[++iline] = lim;\n  input_lines = iline - 1;\n\n  if (revision)\n    {\n      char const *rev = revision;\n      int rev0 = rev[0];\n      bool found_revision = false;\n      size_t revlen = strlen (rev);\n\n      if (revlen <= size)\n\t{\n\t  char const *limrev = lim - revlen;\n\n\t  for (s = buffer;  (s = (char *) memchr (s, rev0, limrev - s));  s++)\n\t    if (memcmp (s, rev, revlen) == 0\n\t\t&& (s == buffer || ISSPACE ((unsigned char) s[-1]))\n\t\t&& (s + 1 == limrev || ISSPACE ((unsigned char) s[revlen])))\n\t      {\n\t\tfound_revision = true;\n\t\tbreak;\n\t      }\n\t}\n\n      report_revision (found_revision);\n    }\n\n  /* Plan A will work.  */\n  i_buffer = buffer;\n  i_ptr = ptr;\n  return true;\n}", "target": 1, "cwe": ["CWE-59"], "project": "patch", "commit_id": "dce4683cbbe107a95f1f0d45fabc304acfb5d71a", "hash": 176392324421738538360853972947671410660, "size": 117, "message": "Don't follow symlinks unless --follow-symlinks is given\n\n* src/inp.c (plan_a, plan_b), src/util.c (copy_to_fd, copy_file,\nappend_to_file): Unless the --follow-symlinks option is given, open files with\nthe O_NOFOLLOW flag to avoid following symlinks.  So far, we were only doing\nthat consistently for input files.\n* src/util.c (create_backup): When creating empty backup files, (re)create them\nwith O_CREAT | O_EXCL to avoid following symlinks in that case as well.", "idx": 64}
{"func": "\tDlfcnModule(void* m)\n\t\t: module(m)\n\t{}", "target": 1, "cwe": ["CWE-89"], "project": "firebird", "commit_id": "56e9a73c16803c3544076edb2d6c4ca25815e541", "hash": 183276739990439598623300429720837752646, "size": 3, "message": "Backported fix for CORE-5474: 'Restrict UDF' is not effective, because fbudf.so is dynamically linked against libc", "idx": 65}
{"func": "static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->ref) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n                goto fail;\n            }\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            s->overlap ++;\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \"First slice in a frame missing.\\n\");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Non-matching NAL types of the VCL NALUs: %d %d\\n\",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Error constructing the reference lists for the current slice.\\n\");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \"Skipping NAL unit %d\\n\", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}", "target": 1, "cwe": ["CWE-476"], "project": "FFmpeg", "commit_id": "54655623a82632e7624714d7b2a3e039dc5faa7e", "hash": 91148027119534184512729378523153568427, "size": 185, "message": "avcodec/hevcdec: Avoid only partly skiping duplicate first slices\n\nFixes: NULL pointer dereference and out of array access\nFixes: 13871/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5746167087890432\nFixes: 13845/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5650370728034304\n\nThis also fixes the return code for explode mode\n\nFound-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg\nReviewed-by: James Almer <jamrial@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>", "idx": 66}
{"func": "static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)\n{\n\tu32 mbx_size = IXGBE_VFMAILBOX_SIZE;\n\tu32 msgbuf[IXGBE_VFMAILBOX_SIZE];\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\ts32 retval;\n\n\tretval = ixgbe_read_mbx(hw, msgbuf, mbx_size, vf);\n\n\tif (retval) {\n\t\tpr_err(\"Error receiving message from VF\\n\");\n\t\treturn retval;\n\t}\n\n\t/* this is a message we already processed, do nothing */\n\tif (msgbuf[0] & (IXGBE_VT_MSGTYPE_ACK | IXGBE_VT_MSGTYPE_NACK))\n\t\treturn 0;\n\n\t/* flush the ack before we write any messages back */\n\tIXGBE_WRITE_FLUSH(hw);\n\n\tif (msgbuf[0] == IXGBE_VF_RESET)\n\t\treturn ixgbe_vf_reset_msg(adapter, vf);\n\n\t/*\n\t * until the vf completes a virtual function reset it should not be\n\t * allowed to start any configuration.\n\t */\n\tif (!adapter->vfinfo[vf].clear_to_send) {\n\t\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;\n\t\tixgbe_write_mbx(hw, msgbuf, 1, vf);\n\t\treturn 0;\n\t}\n\n\tswitch ((msgbuf[0] & 0xFFFF)) {\n\tcase IXGBE_VF_SET_MAC_ADDR:\n\t\tretval = ixgbe_set_vf_mac_addr(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_SET_MULTICAST:\n\t\tretval = ixgbe_set_vf_multicasts(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_SET_VLAN:\n\t\tretval = ixgbe_set_vf_vlan_msg(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_SET_LPE:\n\t\tretval = ixgbe_set_vf_lpe(adapter, msgbuf[1], vf);\n\t\tbreak;\n\tcase IXGBE_VF_SET_MACVLAN:\n\t\tretval = ixgbe_set_vf_macvlan_msg(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_API_NEGOTIATE:\n\t\tretval = ixgbe_negotiate_vf_api(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_GET_QUEUES:\n\t\tretval = ixgbe_get_vf_queues(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_GET_RETA:\n\t\tretval = ixgbe_get_vf_reta(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_GET_RSS_KEY:\n\t\tretval = ixgbe_get_vf_rss_key(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_UPDATE_XCAST_MODE:\n\t\tretval = ixgbe_update_vf_xcast_mode(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_IPSEC_ADD:\n\t\tretval = ixgbe_ipsec_vf_add_sa(adapter, msgbuf, vf);\n\t\tbreak;\n\tcase IXGBE_VF_IPSEC_DEL:\n\t\tretval = ixgbe_ipsec_vf_del_sa(adapter, msgbuf, vf);\n\t\tbreak;\n\tdefault:\n\t\te_err(drv, \"Unhandled Msg %8.8x\\n\", msgbuf[0]);\n\t\tretval = IXGBE_ERR_MBX;\n\t\tbreak;\n\t}\n\n\t/* notify the VF of the results of what it sent us */\n\tif (retval)\n\t\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;\n\telse\n\t\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_ACK;\n\n\tmsgbuf[0] |= IXGBE_VT_MSGTYPE_CTS;\n\n\tixgbe_write_mbx(hw, msgbuf, mbx_size, vf);\n\n\treturn retval;\n}", "target": 0, "cwe": ["CWE-20"], "project": "linux", "commit_id": "63e39d29b3da02e901349f6cd71159818a4737a6", "hash": 262705902133441823488454981646592284987, "size": 89, "message": "ixgbe: fix large MTU request from VF\n\nCheck that the MTU value requested by the VF is in the supported\nrange of MTUs before attempting to set the VF large packet enable,\notherwise reject the request. This also avoids unnecessary\nregister updates in the case of the 82599 controller.\n\nFixes: 872844ddb9e4 (\"ixgbe: Enable jumbo frames support w/ SR-IOV\")\nCo-developed-by: Piotr Skajewski <piotrx.skajewski@intel.com>\nSigned-off-by: Piotr Skajewski <piotrx.skajewski@intel.com>\nSigned-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>\nCo-developed-by: Mateusz Palczewski <mateusz.palczewski@intel.com>\nSigned-off-by: Mateusz Palczewski <mateusz.palczewski@intel.com>\nTested-by: Konrad Jankowski <konrad0.jankowski@intel.com>\nSigned-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 67}
{"func": "find_compressor(int type)\n{\n\tstruct compressor_entry *ce;\n\tstruct compressor *cp = NULL;\n\n\tspin_lock(&compressor_list_lock);\n\tce = find_comp_entry(type);\n\tif (ce) {\n\t\tcp = ce->comp;\n\t\tif (!try_module_get(cp->owner))\n\t\t\tcp = NULL;\n\t}\n\tspin_unlock(&compressor_list_lock);\n\treturn cp;\n}", "target": 0, "cwe": [], "project": "linux", "commit_id": "4ab42d78e37a294ac7bc56901d563c642e03c4ae", "hash": 79256893719718133812880333718408938754, "size": 15, "message": "ppp, slip: Validate VJ compression slot parameters completely\n\nCurrently slhc_init() treats out-of-range values of rslots and tslots\nas equivalent to 0, except that if tslots is too large it will\ndereference a null pointer (CVE-2015-7799).\n\nAdd a range-check at the top of the function and make it return an\nERR_PTR() on error instead of NULL.  Change the callers accordingly.\n\nCompile-tested only.\n\nReported-by: 郭永刚 <guoyonggang@360.cn>\nReferences: http://article.gmane.org/gmane.comp.security.oss.general/17908\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 68}
{"func": "void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct sk_buff *skb_copy = NULL;\n\n\tBT_DBG(\"hdev %p len %d\", hdev, skb->len);\n\n\tread_lock(&hci_sk_list.lock);\n\n\tsk_for_each(sk, &hci_sk_list.head) {\n\t\tstruct sk_buff *nskb;\n\n\t\tif (sk->sk_state != BT_BOUND || hci_pi(sk)->hdev != hdev)\n\t\t\tcontinue;\n\n\t\t/* Don't send frame to the socket it came from */\n\t\tif (skb->sk == sk)\n\t\t\tcontinue;\n\n\t\tif (hci_pi(sk)->channel == HCI_CHANNEL_RAW) {\n\t\t\tif (is_filtered_packet(sk, skb))\n\t\t\t\tcontinue;\n\t\t} else if (hci_pi(sk)->channel == HCI_CHANNEL_USER) {\n\t\t\tif (!bt_cb(skb)->incoming)\n\t\t\t\tcontinue;\n\t\t\tif (bt_cb(skb)->pkt_type != HCI_EVENT_PKT &&\n\t\t\t    bt_cb(skb)->pkt_type != HCI_ACLDATA_PKT &&\n\t\t\t    bt_cb(skb)->pkt_type != HCI_SCODATA_PKT)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Don't send frame to other channel types */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!skb_copy) {\n\t\t\t/* Create a private copy with headroom */\n\t\t\tskb_copy = __pskb_copy(skb, 1, GFP_ATOMIC);\n\t\t\tif (!skb_copy)\n\t\t\t\tcontinue;\n\n\t\t\t/* Put type byte before the data */\n\t\t\tmemcpy(skb_push(skb_copy, 1), &bt_cb(skb)->pkt_type, 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&hci_sk_list.lock);\n\n\tkfree_skb(skb_copy);\n}", "target": 0, "cwe": ["CWE-20", "CWE-269"], "project": "linux", "commit_id": "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c", "hash": 306433400497383560824453518775507453116, "size": 56, "message": "net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include/linux/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 69}
{"func": "struct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\tput_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}", "target": 0, "cwe": ["CWE-400", "CWE-703", "CWE-264"], "project": "linux", "commit_id": "57e68e9cd65b4b8eb4045a1e0d0746458502554c", "hash": 300591953661097923725343358227658734592, "size": 34, "message": "mm: try_to_unmap_cluster() should lock_page() before mlocking\n\nA BUG_ON(!PageLocked) was triggered in mlock_vma_page() by Sasha Levin\nfuzzing with trinity.  The call site try_to_unmap_cluster() does not lock\nthe pages other than its check_page parameter (which is already locked).\n\nThe BUG_ON in mlock_vma_page() is not documented and its purpose is\nsomewhat unclear, but apparently it serializes against page migration,\nwhich could otherwise fail to transfer the PG_mlocked flag.  This would\nnot be fatal, as the page would be eventually encountered again, but\nNR_MLOCK accounting would become distorted nevertheless.  This patch adds\na comment to the BUG_ON in mlock_vma_page() and munlock_vma_page() to that\neffect.\n\nThe call site try_to_unmap_cluster() is fixed so that for page !=\ncheck_page, trylock_page() is attempted (to avoid possible deadlocks as we\nalready have check_page locked) and mlock_vma_page() is performed only\nupon success.  If the page lock cannot be obtained, the page is left\nwithout PG_mlocked, which is again not a problem in the whole unevictable\nmemory design.\n\nSigned-off-by: Vlastimil Babka <vbabka@suse.cz>\nSigned-off-by: Bob Liu <bob.liu@oracle.com>\nReported-by: Sasha Levin <sasha.levin@oracle.com>\nCc: Wanpeng Li <liwanp@linux.vnet.ibm.com>\nCc: Michel Lespinasse <walken@google.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Joonsoo Kim <iamjoonsoo.kim@lge.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 70}
{"func": "AnyP::Uri::path() const\n{\n    // RFC 3986 section 3.3 says path can be empty (path-abempty).\n    // RFC 7230 sections 2.7.3, 5.3.1, 5.7.2 - says path cannot be empty, default to \"/\"\n    // at least when sending and using. We must still accept path-abempty as input.\n    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))\n        return SlashPath();\n\n    return path_;\n}", "target": 0, "cwe": ["CWE-20"], "project": "squid", "commit_id": "dfd818595b54942cb1adc45f6aed95c9b706e3a8", "hash": 230444655105007978523706492532205600900, "size": 10, "message": "Merge pull request from GHSA-jvf6-h9gj-pmj6\n\n* Add slash prefix to path-rootless or path-noscheme URLs\n\n* Update src/anyp/Uri.cc\n\nCo-authored-by: Alex Rousskov <rousskov@measurement-factory.com>\n\n* restore file trailer GH auto-removes\n\n* Remove redundant path-empty check\n\n* Removed stale comment left behind by b2ab59a\n\nMany things imply a leading `/` in a URI. Their enumeration is likely to\r\n(and did) become stale, misleading the reader.\n\n* fixup: Remind that the `src` iterator may be at its end\n\nWe are dereferencing `src` without comparing it to `\\0`.\r\nTo many readers that (incorrectly) implies that we are not done iterating yet.\r\n\r\nAlso fixed branch-added comment indentation.\n\nCo-authored-by: Alex Rousskov <rousskov@measurement-factory.com>", "idx": 71}
{"func": "void device_links_driver_cleanup(struct device *dev)\n{\n\tstruct device_link *link, *ln;\n\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\tWARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);\n\t\tWARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);\n\n\t\t/*\n\t\t * autoremove the links between this @dev and its consumer\n\t\t * devices that are not active, i.e. where the link state\n\t\t * has moved to DL_STATE_SUPPLIER_UNBIND.\n\t\t */\n\t\tif (link->status == DL_STATE_SUPPLIER_UNBIND &&\n\t\t    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)\n\t\t\tdevice_link_drop_managed(link);\n\n\t\tWRITE_ONCE(link->status, DL_STATE_DORMANT);\n\t}\n\n\tlist_del_init(&dev->links.defer_hook);\n\t__device_links_no_driver(dev);\n\n\tdevice_links_write_unlock();\n}", "target": 0, "cwe": ["CWE-787"], "project": "linux", "commit_id": "aa838896d87af561a33ecefea1caa4c15a68bc47", "hash": 220191583780870939358147458339008674964, "size": 30, "message": "drivers core: Use sysfs_emit and sysfs_emit_at for show(device *...) functions\n\nConvert the various sprintf fmaily calls in sysfs device show functions\nto sysfs_emit and sysfs_emit_at for PAGE_SIZE buffer safety.\n\nDone with:\n\n$ spatch -sp-file sysfs_emit_dev.cocci --in-place --max-width=80 .\n\nAnd cocci script:\n\n$ cat sysfs_emit_dev.cocci\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tstrcpy(buf, chr);\n+\tsysfs_emit(buf, chr);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n-\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n+\tlen += sysfs_emit_at(buf, len,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t...\n-\tstrcpy(buf, chr);\n-\treturn strlen(buf);\n+\treturn sysfs_emit(buf, chr);\n}\n\nSigned-off-by: Joe Perches <joe@perches.com>\nLink: https://lore.kernel.org/r/3d033c33056d88bbe34d4ddb62afd05ee166ab9a.1600285923.git.joe@perches.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 72}
{"func": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\n\t/* Our ID is an index into the kvm_regs struct. */\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 1, "cwe": ["CWE-20"], "project": "linux", "commit_id": "d26c25a9d19b5976b319af528886f89cf455692d", "hash": 284292064506048190119220912995786793066, "size": 47, "message": "arm64: KVM: Tighten guest core register access from userspace\n\nWe currently allow userspace to access the core register file\nin about any possible way, including straddling multiple\nregisters and doing unaligned accesses.\n\nThis is not the expected use of the ABI, and nobody is actually\nusing it that way. Let's tighten it by explicitly checking\nthe size and alignment for each field of the register file.\n\nCc: <stable@vger.kernel.org>\nFixes: 2f4a07c5f9fe (\"arm64: KVM: guest one-reg interface\")\nReviewed-by: Christoffer Dall <christoffer.dall@arm.com>\nReviewed-by: Mark Rutland <mark.rutland@arm.com>\nSigned-off-by: Dave Martin <Dave.Martin@arm.com>\n[maz: rewrote Dave's initial patch to be more easily backported]\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>", "idx": 73}
{"func": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n\n    PROCNAME(\"gplotMakeOutput\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  /* _WIN32 */\n\n#ifndef OS_IOS /* iOS 11 does not support system() */\n    ignore = system(buf);  /* gnuplot || wgnuplot */\n#endif /* !OS_IOS */\n\n    LEPT_FREE(cmdname);\n    return 0;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "leptonica", "commit_id": "ee301cb2029db8a6289c5295daa42bba7715e99a", "hash": 89079432684144804428670951518959823842, "size": 28, "message": "Security fixes: expect final changes for release 1.75.3.\n* Fixed a debian security issue with fscanf() reading a string with\n  possible buffer overflow.\n* There were also a few similar situations with sscanf().", "idx": 74}
{"func": "int x509_verify(const CA_CERT_CTX *ca_cert_ctx, const X509_CTX *cert, \n        int *pathLenConstraint) \n{\n    int ret = X509_OK, i = 0;\n    bigint *cert_sig;\n    X509_CTX *next_cert = NULL;\n    BI_CTX *ctx = NULL;\n    bigint *mod = NULL, *expn = NULL;\n    int match_ca_cert = 0;\n    struct timeval tv;\n    uint8_t is_self_signed = 0;\n\n    if (cert == NULL)\n    {\n        ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n        goto end_verify;\n    }\n\n    /* a self-signed certificate that is not in the CA store - use this \n       to check the signature */\n    if (asn1_compare_dn(cert->ca_cert_dn, cert->cert_dn) == 0)\n    {\n        is_self_signed = 1;\n        ctx = cert->rsa_ctx->bi_ctx;\n        mod = cert->rsa_ctx->m;\n        expn = cert->rsa_ctx->e;\n    }\n\n    gettimeofday(&tv, NULL);\n\n    /* check the not before date */\n    if (tv.tv_sec < cert->not_before)\n    {\n        ret = X509_VFY_ERROR_NOT_YET_VALID;\n        goto end_verify;\n    }\n\n    /* check the not after date */\n    if (tv.tv_sec > cert->not_after)\n    {\n        ret = X509_VFY_ERROR_EXPIRED;\n        goto end_verify;\n    }\n\n    if (cert->basic_constraint_present)\n    {\n        /* If the cA boolean is not asserted,\n           then the keyCertSign bit in the key usage extension MUST NOT be\n           asserted. */\n        if (!cert->basic_constraint_cA &&\n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN))\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n\n        /* The pathLenConstraint field is meaningful only if the cA boolean is\n           asserted and the key usage extension, if present, asserts the\n           keyCertSign bit.  In this case, it gives the maximum number of \n           non-self-issued intermediate certificates that may follow this \n           certificate in a valid certification path. */\n        if (cert->basic_constraint_cA &&\n            (!cert->key_usage_present || \n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN)) &&\n            (cert->basic_constraint_pathLenConstraint+1) < *pathLenConstraint)\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n    }\n\n    next_cert = cert->next;\n\n    /* last cert in the chain - look for a trusted cert */\n    if (next_cert == NULL)\n    {\n       if (ca_cert_ctx != NULL) \n       {\n            /* go thru the CA store */\n            while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i])\n            {\n                /* the extension is present but the cA boolean is not \n                   asserted, then the certified public key MUST NOT be used \n                   to verify certificate signatures. */\n                if (cert->basic_constraint_present && \n                        !ca_cert_ctx->cert[i]->basic_constraint_cA)\n                    continue;\n                        \n                if (asn1_compare_dn(cert->ca_cert_dn,\n                                            ca_cert_ctx->cert[i]->cert_dn) == 0)\n                {\n                    /* use this CA certificate for signature verification */\n                    match_ca_cert = true;\n                    ctx = ca_cert_ctx->cert[i]->rsa_ctx->bi_ctx;\n                    mod = ca_cert_ctx->cert[i]->rsa_ctx->m;\n                    expn = ca_cert_ctx->cert[i]->rsa_ctx->e;\n\n\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        /* couldn't find a trusted cert (& let self-signed errors \n           be returned) */\n        if (!match_ca_cert && !is_self_signed)\n        {\n            ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n            goto end_verify;\n        }\n    }\n    else if (asn1_compare_dn(cert->ca_cert_dn, next_cert->cert_dn) != 0)\n    {\n        /* check the chain */\n        ret = X509_VFY_ERROR_INVALID_CHAIN;\n        goto end_verify;\n    }\n    else /* use the next certificate in the chain for signature verify */\n    {\n        ctx = next_cert->rsa_ctx->bi_ctx;\n        mod = next_cert->rsa_ctx->m;\n        expn = next_cert->rsa_ctx->e;\n    }\n\n    /* cert is self signed */\n    if (!match_ca_cert && is_self_signed)\n    {\n        ret = X509_VFY_ERROR_SELF_SIGNED;\n        goto end_verify;\n    }\n\n    /* check the signature */\n    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, \n                        bi_clone(ctx, mod), bi_clone(ctx, expn));\n\n    if (cert_sig && cert->digest)\n    {\n        if (bi_compare(cert_sig, cert->digest) != 0)\n            ret = X509_VFY_ERROR_BAD_SIGNATURE;\n\n\n        bi_free(ctx, cert_sig);\n    }\n    else\n    {\n        ret = X509_VFY_ERROR_BAD_SIGNATURE;\n    }\n\n    bi_clear_cache(ctx);\n\n    if (ret)\n        goto end_verify;\n\n    /* go down the certificate chain using recursion. */\n    if (next_cert != NULL)\n    {\n        (*pathLenConstraint)++; /* don't include last certificate */\n        ret = x509_verify(ca_cert_ctx, next_cert, pathLenConstraint);\n    }\n\nend_verify:\n    return ret;\n}", "target": 1, "cwe": ["CWE-347"], "project": "axtls-8266", "commit_id": "5efe2947ab45e81d84b5f707c51d1c64be52f36c", "hash": 40645084349640457416034856936361803748, "size": 165, "message": "Apply CVE fixes for X509 parsing\n\nApply patches developed by Sze Yiu which correct a vulnerability in\nX509 parsing.  See CVE-2018-16150 and CVE-2018-16149 for more info.", "idx": 75}
{"func": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\t/* explored state didn't use this */\n\t\treturn true;\n\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\n\tif (rold->type == NOT_INIT)\n\t\t/* explored state can't have used this */\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n\t\t\t/* new val must satisfy old val knowledge */\n\t\t\treturn range_within(rold, rcur) &&\n\t\t\t       tnum_in(rold->var_off, rcur->var_off);\n\t\t} else {\n\t\t\t/* if we knew anything about the old value, we're not\n\t\t\t * equal, because we can't know anything about the\n\t\t\t * scalar value of the pointer in the new value.\n\t\t\t */\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n\t\t}\n\tcase PTR_TO_MAP_VALUE:\n\t\t/* If the new min/max/var_off satisfy the old ones and\n\t\t * everything else matches, we are OK.\n\t\t * We don't care about the 'id' value, because nothing\n\t\t * uses it for PTR_TO_MAP_VALUE (only for ..._OR_NULL)\n\t\t */\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\t/* a PTR_TO_MAP_VALUE could be safe to use as a\n\t\t * PTR_TO_MAP_VALUE_OR_NULL into the same map.\n\t\t * However, if the old PTR_TO_MAP_VALUE_OR_NULL then got NULL-\n\t\t * checked, doing so could have affected others with the same\n\t\t * id, and we can't check for that because we lost the id when\n\t\t * we converted to a PTR_TO_MAP_VALUE.\n\t\t */\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\t/* Check our ids match any regs they're supposed to */\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\t/* We must have at least as much range as the old ptr\n\t\t * did, so that any accesses which were safe before are\n\t\t * still safe.  This is true even if old range < old off,\n\t\t * since someone could have accessed through (ptr - k), or\n\t\t * even done ptr -= k in a register, to get a safe access.\n\t\t */\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\t/* If the offsets don't match, we can't trust our alignment;\n\t\t * nor can we be sure that we won't fall out of range.\n\t\t */\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\t/* id relations must be preserved */\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\t/* new val must satisfy old val knowledge */\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\t\t/* Only valid matches are exact, which memcmp() above\n\t\t * would have accepted\n\t\t */\n\tdefault:\n\t\t/* Don't know what's going on, just say it's not safe */\n\t\treturn false;\n\t}\n\n\t/* Shouldn't get here; if we do, say it's not safe */\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1, "cwe": ["CWE-200", "CWE-119"], "project": "linux", "commit_id": "179d1c5602997fef5a940c6ddcf31212cbfebd14", "hash": 106502002838545994696616768979371277760, "size": 94, "message": "bpf: don't prune branches when a scalar is replaced with a pointer\n\nThis could be made safe by passing through a reference to env and checking\nfor env->allow_ptr_leaks, but it would only work one way and is probably\nnot worth the hassle - not doing it will not directly lead to program\nrejection.\n\nFixes: f1174f77b50c (\"bpf/verifier: rework value tracking\")\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>", "idx": 76}
{"func": "static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (strcasecmp(p1, \"On\") == 0) dcfg->auditlog_flag = AUDITLOG_ON;\n    else\n        if (strcasecmp(p1, \"Off\") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;\n        else\n            if (strcasecmp(p1, \"RelevantOnly\") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;\n            else\n                return (const char *)apr_psprintf(cmd->pool,\n                        \"ModSecurity: Unrecognised parameter value for SecAuditEngine: %s\", p1);\n\n    return NULL;\n}", "target": 0, "cwe": ["CWE-20", "CWE-611"], "project": "ModSecurity", "commit_id": "d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe", "hash": 252888574759224344899404065055679875449, "size": 15, "message": "Added SecXmlExternalEntity", "idx": 77}
{"func": "static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)\n{\n        __be32 *p;\n\n        RESERVE_SPACE(16);\n        WRITE32(OP_GETATTR);\n        WRITE32(2);\n        WRITE32(bm0);\n        WRITE32(bm1);\n        return 0;\n}", "target": 0, "cwe": ["CWE-703"], "project": "linux", "commit_id": "dc0b027dfadfcb8a5504f7d8052754bf8d501ab9", "hash": 33718820527204113271495679353486203986, "size": 11, "message": "NFSv4: Convert the open and close ops to use fmode\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>", "idx": 78}
{"func": "PHP_METHOD(Phar, __construct)\n{\n#if !HAVE_SPL\n\tzend_throw_exception_ex(zend_ce_exception, 0, \"Cannot instantiate Phar object without SPL extension\");\n#else\n\tchar *fname, *alias = NULL, *error, *arch = NULL, *entry = NULL, *save_fname;\n\tsize_t fname_len, alias_len = 0;\n\tint arch_len, entry_len, is_data;\n\tzend_long flags = SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS;\n\tzend_long format = 0;\n\tphar_archive_object *phar_obj;\n\tphar_archive_data   *phar_data;\n\tzval *zobj = getThis(), arg1, arg2;\n\n\tphar_obj = (phar_archive_object*)((char*)Z_OBJ_P(zobj) - Z_OBJ_P(zobj)->handlers->offset);\n\n\tis_data = instanceof_function(Z_OBJCE_P(zobj), phar_ce_data);\n\n\tif (is_data) {\n\t\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"s|ls!l\", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"s|ls!\", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (phar_obj->archive) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Cannot call constructor twice\");\n\t\treturn;\n\t}\n\n\tsave_fname = fname;\n\tif (SUCCESS == phar_split_fname(fname, (int)fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2)) {\n\t\t/* use arch (the basename for the archive) for fname instead of fname */\n\t\t/* this allows support for RecursiveDirectoryIterator of subdirectories */\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(arch, arch_len);\n#endif\n\t\tfname = arch;\n\t\tfname_len = arch_len;\n#ifdef PHP_WIN32\n\t} else {\n\t\tarch = estrndup(fname, fname_len);\n\t\tarch_len = fname_len;\n\t\tfname = arch;\n\t\tphar_unixify_path_separators(arch, arch_len);\n#endif\n\t}\n\n\tif (phar_open_or_create_filename(fname, fname_len, alias, alias_len, is_data, REPORT_ERRORS, &phar_data, &error) == FAILURE) {\n\n\t\tif (fname == arch && fname != save_fname) {\n\t\t\tefree(arch);\n\t\t\tfname = save_fname;\n\t\t}\n\n\t\tif (entry) {\n\t\t\tefree(entry);\n\t\t}\n\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0,\n\t\t\t\t\"%s\", error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0,\n\t\t\t\t\"Phar creation or opening failed\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (is_data && phar_data->is_tar && phar_data->is_brandnew && format == PHAR_FORMAT_ZIP) {\n\t\tphar_data->is_zip = 1;\n\t\tphar_data->is_tar = 0;\n\t}\n\n\tif (fname == arch) {\n\t\tefree(arch);\n\t\tfname = save_fname;\n\t}\n\n\tif ((is_data && !phar_data->is_data) || (!is_data && phar_data->is_data)) {\n\t\tif (is_data) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0,\n\t\t\t\t\"PharData class can only be used for non-executable tar and zip archives\");\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0,\n\t\t\t\t\"Phar class can only be used for executable tar and zip archives\");\n\t\t}\n\t\tefree(entry);\n\t\treturn;\n\t}\n\n\tis_data = phar_data->is_data;\n\n\tif (!phar_data->is_persistent) {\n\t\t++(phar_data->refcount);\n\t}\n\n\tphar_obj->archive = phar_data;\n\tphar_obj->spl.oth_handler = &phar_spl_foreign_handler;\n\n\tif (entry) {\n\t\tfname_len = spprintf(&fname, 0, \"phar://%s%s\", phar_data->fname, entry);\n\t\tefree(entry);\n\t} else {\n\t\tfname_len = spprintf(&fname, 0, \"phar://%s\", phar_data->fname);\n\t}\n\n\tZVAL_STRINGL(&arg1, fname, fname_len);\n\tZVAL_LONG(&arg2, flags);\n\n\tzend_call_method_with_2_params(zobj, Z_OBJCE_P(zobj),\n\t\t&spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg1, &arg2);\n\n\tzval_ptr_dtor(&arg1);\n\n\tif (!phar_data->is_persistent) {\n\t\tphar_obj->archive->is_data = is_data;\n\t} else if (!EG(exception)) {\n\t\t/* register this guy so we can modify if necessary */\n\t\tzend_hash_str_add_ptr(&PHAR_G(phar_persist_map), (const char *) phar_obj->archive, sizeof(phar_obj->archive), phar_obj);\n\t}\n\n\tphar_obj->spl.info_class = phar_ce_entry;\n\tefree(fname);\n#endif /* HAVE_SPL */\n}", "target": 1, "cwe": ["CWE-20"], "project": "php-src", "commit_id": "1e9b175204e3286d64dfd6c9f09151c31b5e099a", "hash": 40774388632945848404251681321129088322, "size": 131, "message": "Fix bug #71860: Require valid paths for phar filenames", "idx": 79}
{"func": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1, "cwe": ["CWE-918"], "project": "arangodb", "commit_id": "d9b7f019d2435f107b19a59190bf9cc27d5f34dd", "hash": 88922380629990301386767515839292150134, "size": 8, "message": "[APM-78] Disable installation from remote URL (#15292)", "idx": 80}
{"func": "iasecc_process_fci(struct sc_card *card, struct sc_file *file,\n\t\t const unsigned char *buf, size_t buflen)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tsize_t taglen;\n\tint rv, ii, offs;\n\tconst unsigned char *acls = NULL, *tag = NULL;\n\tunsigned char mask;\n\tunsigned char ops_DF[7] = {\n\t\tSC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_CREATE, 0xFF\n\t};\n\tunsigned char ops_EF[7] = {\n\t\tSC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_UPDATE, SC_AC_OP_READ\n\t};\n\n\tLOG_FUNC_CALLED(ctx);\n\n\ttag = sc_asn1_find_tag(ctx,  buf, buflen, 0x6F, &taglen);\n\tsc_log(ctx, \"processing FCI: 0x6F tag %p\", tag);\n\tif (tag != NULL) {\n\t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);\n\t\tbuf = tag;\n\t\tbuflen = taglen;\n\t}\n\n\ttag = sc_asn1_find_tag(ctx,  buf, buflen, 0x62, &taglen);\n\tsc_log(ctx, \"processing FCI: 0x62 tag %p\", tag);\n\tif (tag != NULL) {\n\t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);\n\t\tbuf = tag;\n\t\tbuflen = taglen;\n\t}\n\n\trv = iso_ops->process_fci(card, file, buf, buflen);\n\tLOG_TEST_RET(ctx, rv, \"ISO parse FCI failed\");\n/*\n\tGemalto:  6F 19 80 02 02 ED 82 01 01 83 02 B0 01 88 00\t8C 07 7B 17 17 17 17 17 00 8A 01 05 90 00\n\tSagem:    6F 17 62 15 80 02 00 7D 82 01 01                   8C 02 01 00 83 02 2F 00 88 01 F0 8A 01 05 90 00\n\tOberthur: 62 1B 80 02 05 DC 82 01 01 83 02 B0 01 88 00 A1 09 8C 07 7B 17 FF 17 17 17 00 8A 01 05 90 00\n*/\n\n\tsc_log(ctx, \"iasecc_process_fci() type %i; let's parse file ACLs\", file->type);\n\ttag = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS, &taglen);\n\tif (tag)\n\t\tacls = sc_asn1_find_tag(ctx, tag, taglen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);\n\telse\n\t\tacls = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);\n\n\tif (!acls)   {\n\t\tsc_log(ctx,\n\t\t       \"ACLs not found in data(%\"SC_FORMAT_LEN_SIZE_T\"u) %s\",\n\t\t       buflen, sc_dump_hex(buf, buflen));\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"ACLs tag missing\");\n\t}\n\n\tsc_log(ctx, \"ACLs(%\"SC_FORMAT_LEN_SIZE_T\"u) '%s'\", taglen,\n\t       sc_dump_hex(acls, taglen));\n\tmask = 0x40, offs = 1;\n\tfor (ii = 0; ii < 7; ii++, mask /= 2)  {\n\t\tunsigned char op = file->type == SC_FILE_TYPE_DF ? ops_DF[ii] : ops_EF[ii];\n\n\t\tif (!(mask & acls[0]))\n\t\t\tcontinue;\n\n\t\tsc_log(ctx, \"ACLs mask 0x%X, offs %i, op 0x%X, acls[offs] 0x%X\", mask, offs, op, acls[offs]);\n\t\tif (op == 0xFF)   {\n\t\t\t;\n\t\t}\n\t\telse if (acls[offs] == 0)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NONE, 0);\n\t\t}\n\t\telse if (acls[offs] == 0xFF)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);\n\t\t}\n\t\telse if ((acls[offs] & IASECC_SCB_METHOD_MASK) == IASECC_SCB_METHOD_USER_AUTH)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_SEN, acls[offs] & IASECC_SCB_METHOD_MASK_REF);\n\t\t}\n\t\telse if (acls[offs] & IASECC_SCB_METHOD_MASK)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_SCB, acls[offs]);\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Warning: non supported SCB method: %X\", acls[offs]);\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);\n\t\t}\n\n\t\toffs++;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}", "target": 1, "cwe": [], "project": "OpenSC", "commit_id": "ae1cf0be90396fb6c0be95829bf0d3eecbd2fd1c", "hash": 1203042640428953533461574342788821937, "size": 90, "message": "iasecc: Prevent stack buffer overflow when empty ACL is returned\n\nThanks oss-fuzz\n\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=30800", "idx": 81}
{"func": "g_file_poll_mountable_finish (GFile         *file,\n                              GAsyncResult  *result,\n                              GError       **error)\n{\n  GFileIface *iface;\n\n  g_return_val_if_fail (G_IS_FILE (file), FALSE);\n  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);\n\n  if (g_async_result_legacy_propagate_error (result, error))\n    return FALSE;\n  else if (g_async_result_is_tagged (result, g_file_poll_mountable))\n    return g_task_propagate_boolean (G_TASK (result), error);\n\n  iface = G_FILE_GET_IFACE (file);\n  return (* iface->poll_mountable_finish) (file, result, error);\n}", "target": 0, "cwe": ["CWE-362"], "project": "glib", "commit_id": "d8f8f4d637ce43f8699ba94c9b7648beda0ca174", "hash": 3068218313281315356631231986572574239, "size": 17, "message": "gfile: Limit access to files when copying\n\nfile_copy_fallback creates new files with default permissions and\nset the correct permissions after the operation is finished. This\nmight cause that the files can be accessible by more users during\nthe operation than expected. Use G_FILE_CREATE_PRIVATE for the new\nfiles to limit access to those files.", "idx": 82}
{"func": "void png_convert_4(\n\tunsigned pix_width, unsigned pix_height, unsigned pix_pixel, unsigned char* pix_ptr, unsigned pix_scanline,\n\tunsigned char* pal_ptr, unsigned pal_size,\n\tunsigned char** dst_ptr, unsigned* dst_pixel, unsigned* dst_scanline)\n{\n\t*dst_pixel = 4;\n\t*dst_scanline = 4 * pix_width;\n\t*dst_ptr = (unsigned char*)malloc(*dst_scanline * pix_height);\n\n\tif (pix_pixel == 3) {\n\t\tunsigned i, j;\n\t\tfor(i=0;i<pix_height;++i) {\n\t\t\tconst unsigned char* p0 = pix_ptr + i * pix_scanline;\n\t\t\tunsigned char* p1 = *dst_ptr + i * *dst_scanline;\n\t\t\tfor(j=0;j<pix_width;++j) {\n\t\t\t\tp1[0] = p0[0];\n\t\t\t\tp1[1] = p0[1];\n\t\t\t\tp1[2] = p0[2];\n\t\t\t\tp1[3] = 0xFF;\n\t\t\t\tp0 += 3;\n\t\t\t\tp1 += 4;\n\t\t\t}\n\t\t}\n\t} else if (pix_pixel == 1) {\n\t\tunsigned i, j;\n\t\tfor(i=0;i<pix_height;++i) {\n\t\t\tconst unsigned char* p0 = pix_ptr + i * pix_scanline;\n\t\t\tunsigned char* p1 = *dst_ptr + i * *dst_scanline;\n\t\t\tfor(j=0;j<pix_width;++j) {\n\t\t\t\tunsigned char* c = &pal_ptr[p0[0]*3];\n\t\t\t\tp1[0] = c[0];\n\t\t\t\tp1[1] = c[1];\n\t\t\t\tp1[2] = c[2];\n\t\t\t\tp1[3] = 0xFF;\n\t\t\t\tp0 += 1;\n\t\t\t\tp1 += 4;\n\t\t\t}\n\t\t}\n\t} else if (pix_pixel == 4) {\n\t\tunsigned i;\n\t\tfor(i=0;i<pix_height;++i) {\n\t\t\tconst unsigned char* p0 = pix_ptr + i * pix_scanline;\n\t\t\tunsigned char* p1 = *dst_ptr + i * *dst_scanline;\n\t\t\tmemcpy(p1, p0, *dst_scanline);\n\t\t}\n\t} else {\n\t\tthrow error_unsupported() << \"Unsupported format\";\n\t}\n}", "target": 0, "cwe": ["CWE-125"], "project": "advancecomp", "commit_id": "7894a6e684ce68ddff9f4f4919ab8e3911ac8040", "hash": 140121955297702552148001400222919066587, "size": 49, "message": "Fix a buffer overflow caused by invalid chunks", "idx": 83}
{"func": "int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)\n\t{\n\treturn PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());\n\t}", "target": 0, "cwe": ["CWE-310"], "project": "openssl", "commit_id": "270881316664396326c461ec7a124aec2c6cc081", "hash": 254282953358326499771713658909994096585, "size": 4, "message": "Add and use a constant-time memcmp.\n\nThis change adds CRYPTO_memcmp, which compares two vectors of bytes in\nan amount of time that's independent of their contents. It also changes\nseveral MAC compares in the code to use this over the standard memcmp,\nwhich may leak information about the size of a matching prefix.\n(cherry picked from commit 2ee798880a246d648ecddadc5b91367bee4a5d98)\n\nConflicts:\n\tcrypto/crypto.h\n\tssl/t1_lib.c\n(cherry picked from commit dc406b59f3169fe191e58906df08dce97edb727c)\n\nConflicts:\n\tcrypto/crypto.h\n\tssl/d1_pkt.c\n\tssl/s3_pkt.c", "idx": 84}
{"func": "static int empty_write_end(struct page *page, unsigned from,\n\t\t\t   unsigned to, int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh;\n\tunsigned offset, blksize = 1 << inode->i_blkbits;\n\tpgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;\n\n\tzero_user(page, from, to-from);\n\tmark_page_accessed(page);\n\n\tif (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tif (!gfs2_is_writeback(ip))\n\t\t\tgfs2_page_add_databufs(ip, page, from, to);\n\n\t\tblock_commit_write(page, from, to);\n\t\treturn 0;\n\t}\n\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tclear_buffer_new(bh);\n\t\t\twrite_dirty_buffer(bh, WRITE);\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\treturn -EIO;\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "linux", "commit_id": "64dd153c83743af81f20924c6343652d731eeecb", "hash": 45756546490387256143957245398803860354, "size": 46, "message": "GFS2: rewrite fallocate code to write blocks directly\n\nGFS2's fallocate code currently goes through the page cache. Since it's only\nwriting to the end of the file or to holes in it, it doesn't need to, and it\nwas causing issues on low memory environments. This patch pulls in some of\nSteve's block allocation work, and uses it to simply allocate the blocks for\nthe file, and zero them out at allocation time.  It provides a slight\nperformance increase, and it dramatically simplifies the code.\n\nSigned-off-by: Benjamin Marzinski <bmarzins@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>", "idx": 85}
{"func": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}", "target": 1, "cwe": [], "project": "linux", "commit_id": "7dac4a1726a9c64a517d595c40e95e2d0d135f6f", "hash": 32704002674168611951100583555220674535, "size": 48, "message": "ext4: add validity checks for bitmap block numbers\n\nAn privileged attacker can cause a crash by mounting a crafted ext4\nimage which triggers a out-of-bounds read in the function\next4_valid_block_bitmap() in fs/ext4/balloc.c.\n\nThis issue has been assigned CVE-2018-1093.\n\nBugLink: https://bugzilla.kernel.org/show_bug.cgi?id=199181\nBugLink: https://bugzilla.redhat.com/show_bug.cgi?id=1560782\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@vger.kernel.org", "idx": 86}
{"func": "TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {\n  initialize();\n\n  InSequence sequence;\n\n  MockRequestDecoder decoder;\n  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));\n\n  TestRequestHeaderMapImpl expected_headers{\n      {\":path\", \"/\"},\n      {\":method\", \"POST\"},\n      {\"transfer-encoding\", \"chunked\"},\n  };\n  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));\n  Buffer::OwnedImpl expected_data(\"Hello World\");\n  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));\n  // Call to decodeData(\"\", true) happens after.\n  Buffer::OwnedImpl empty(\"\");\n  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));\n\n  Buffer::OwnedImpl buffer(\"POST / HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n\"\n                           \"6\\r\\nHello \\r\\n\"\n                           \"5\\r\\nWorld\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n  auto status = codec_->dispatch(buffer);\n  EXPECT_TRUE(status.ok());\n  EXPECT_EQ(0U, buffer.length());\n}", "target": 0, "cwe": ["CWE-770"], "project": "envoy", "commit_id": "7ca28ff7d46454ae930e193d97b7d08156b1ba59", "hash": 308332715862605564083705231381971826549, "size": 28, "message": "[http1] Include request URL in request header size computation, and reject partial headers that exceed configured limits (#145)\n\nSigned-off-by: antonio <avd@google.com>", "idx": 87}
{"func": "tgs_build_reply(astgs_request_t priv,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_context context = priv->context;\n    krb5_kdc_configuration *config = priv->config;\n    KDC_REQ *req = &priv->req;\n    KDC_REQ_BODY *b = &priv->req.req_body;\n    const char *from = priv->from;\n    krb5_error_code ret, ret2;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *tgt_realm = /* Realm of TGT issuer */\n        krb5_principal_get_realm(context, krbtgt->entry.principal);\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /*\n     * The canonicalize KDC option is passed as a hint to the backend, but\n     * can typically be ignored. Per RFC 6806, names are not canonicalized\n     * in response to a TGS request (although we make an exception, see\n     * force-canonicalize below).\n     */\n    if (b->kdc_options.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 4,\n\t\t    \"No second ticket present in user-to-user request\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"No second ticket present in user-to-user request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 4,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tret = krb5_unparse_name(context, p, &tpn);\n\tif (ret)\n\t\tgoto out;\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user service principal (TGS) unknown\");\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user enctype not supported\");\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT decrypt failure\");\n\t    goto out;\n        }\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT expired or invalid\");\n\t    goto out;\n        }\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &priv->sname);\n    if (ret)\n\tgoto out;\n    spn = priv->sname;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &priv->cname);\n    if (ret)\n\tgoto out;\n    cpn = priv->cname;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp,\n                        HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags,\n\t\t\tNULL, NULL, &server);\n    priv->server = server;\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", spn);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Target not found here\");\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(priv->sname);\n        priv->sname = NULL;\n\tret = krb5_unparse_name(context, sp, &priv->sname);\n\tif (ret)\n\t    goto out;\n\tspn = priv->sname;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret2 = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                         req_rlm, TRUE, &capath, &num_capath);\n                if (ret2) {\n                    ret = ret2;\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"No trusted path from client realm to ours\");\n                    goto out;\n                }\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(priv->sname);\n                priv->sname = NULL;\n                ret = krb5_unparse_name(context, sp, &priv->sname);\n                if (ret)\n                    goto out;\n                spn = priv->sname;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(priv->sname);\n                priv->sname = NULL;\n\t\tret = krb5_unparse_name(context, sp, &priv->sname);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\t\tspn = priv->sname;\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 3,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Service principal unknown\");\n\tgoto out;\n    }\n\n    /*\n     * RFC 6806 notes that names MUST NOT be changed in the response to\n     * a TGS request. Hence we ignore the setting of the canonicalize\n     * KDC option. However, for legacy interoperability we do allow the\n     * backend to override this by setting the force-canonicalize HDB\n     * flag in the server entry.\n     */\n    if (server->entry.flags.force_canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"No matching enctypes for 2nd ticket\");\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(priv, krb5_principal_is_krbtgt(context, sp)\n\t\t\t\t\t\t\t     ? KFE_IS_TGS : 0,\n\t\t\t\t  b->etype.val, b->etype.len, &etype, NULL,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authorization data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"No key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n        _kdc_audit_addreason((kdc_request_t)priv, \"Request with wrong TGT\");\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    {\n        krb5_data verified_cas;\n\n        /*\n         * If the client doesn't exist in the HDB but has a TGT and it's\n         * obtained with PKINIT then we assume it's a synthetic client -- that\n         * is, a client whose name was vouched for by a CA using a PKINIT SAN,\n         * but which doesn't exist in the HDB proper.  We'll allow such a\n         * client to do TGT requests even though normally we'd reject all\n         * clients that don't exist in the HDB.\n         */\n        ret = krb5_ticket_get_authorization_data_type(context, ticket,\n                                                      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n                                                      &verified_cas);\n        if (ret == 0) {\n            krb5_data_free(&verified_cas);\n            flags |= HDB_F_SYNTHETIC_OK;\n        }\n    }\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    flags &= ~HDB_F_SYNTHETIC_OK;\n    priv->client = client;\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 4, \"Client no longer in database: %s\",\n\t\t    cpn);\n            _kdc_audit_addreason((kdc_request_t)priv, \"Client no longer in HDB\");\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Client not found in database: %s\", msg);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client does not exist\");\n\tkrb5_free_error_message(context, msg);\n    } else if (ret == 0 &&\n               (client->entry.flags.invalid || !client->entry.flags.client)) {\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client has invalid bit set\");\n        kdc_log(context, config, 4, \"Client has invalid bit set\");\n        ret = KRB5KDC_ERR_POLICY;\n        goto out;\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"PAC check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    struct astgs_request_desc imp_req;\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Failed to decode PA-S4U2Self\");\n\t\tkdc_log(context, config, 4, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    if (!krb5_checksum_is_keyed(context, self.cksum.cksumtype)) {\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"PA-S4U2Self with unkeyed checksum\");\n\t\tkdc_log(context, config, 4, \"Reject PA-S4U2Self with unkeyed checksum\");\n\t\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Allow HMAC_MD5 checksum with any key type */\n\t    if (self.cksum.cksumtype == CKSUMTYPE_HMAC_MD5) {\n\t\tstruct krb5_crypto_iov iov;\n\t\tunsigned char csdata[16];\n\t\tChecksum cs;\n\n\t\tcs.checksum.length = sizeof(csdata);\n\t\tcs.checksum.data = &csdata;\n\n\t\tiov.data.data = datack.data;\n\t\tiov.data.length = datack.length;\n\t\tiov.flags = KRB5_CRYPTO_TYPE_DATA;\n\n\t\tret = _krb5_HMAC_MD5_checksum(context, NULL, &crypto->key,\n\t\t\t\t\t      KRB5_KU_OTHER_CKSUM, &iov, 1,\n\t\t\t\t\t      &cs);\n\t\tif (ret == 0 &&\n\t\t    krb5_data_ct_cmp(&cs.checksum, &self.cksum.checksum) != 0)\n\t\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t    }\n\t    else {\n\t\tret = krb5_verify_checksum(context,\n\t\t\t\t\t   crypto,\n\t\t\t\t\t   KRB5_KU_OTHER_CKSUM,\n\t\t\t\t\t   datack.data,\n\t\t\t\t\t   datack.length,\n\t\t\t\t\t   &self.cksum);\n\t    }\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self checksum failed\");\n\t\tkdc_log(context, config, 4,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n            /*\n             * Note no HDB_F_SYNTHETIC_OK -- impersonating non-existent clients\n             * is probably not desirable!\n             */\n\t    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\tNULL, &s4u2self_impersonated_clientdb,\n\t\t\t\t&s4u2self_impersonated_client);\n\t    if (ret) {\n\t\tconst char *msg;\n\n\t\t/*\n\t\t * If the client belongs to the same realm as our krbtgt, it\n\t\t * should exist in the local database.\n\t\t *\n\t\t */\n\n\t\tif (ret == HDB_ERR_NOENTRY)\n\t\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\tmsg = krb5_get_error_message(context, ret);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self principal to impersonate not found\");\n\t\tkdc_log(context, config, 2,\n\t\t\t\"S4U2Self principal to impersonate %s not found in database: %s\",\n\t\t\ttpn, msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Ignore require_pwchange and pw_end attributes (as Windows does),\n\t     * since S4U2Self is not password authentication. */\n\t    s4u2self_impersonated_client->entry.flags.require_pwchange = FALSE;\n\t    free(s4u2self_impersonated_client->entry.pw_end);\n\t    s4u2self_impersonated_client->entry.pw_end = NULL;\n\n\t    imp_req = *priv;\n\t    imp_req.client = s4u2self_impersonated_client;\n\t    imp_req.client_princ = tp;\n\n\t    ret = kdc_check_flags(&imp_req, FALSE);\n\t    if (ret)\n\t\tgoto out; /* kdc_check_flags() calls _kdc_audit_addreason() */\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"KRB5SignedPath missing\");\n\t\t    kdc_log(context, config, 4, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 4, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 4, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation or if the impersonate client is disallowed\n\t     * forwardable, remove the forwardable flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation &&\n\t\ts4u2self_impersonated_client->entry.flags.forwardable) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 4, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.cname_in_addl_tkt\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n            _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath missing\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Failed to decrypt constrained delegation ticket\");\n\t    kdc_log(context, config, 4,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n        _kdc_audit_addkv((kdc_request_t)priv, 0, \"impersonatee\", \"%s\", tpn);\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Missing forwardable flag on ticket for constrained delegation\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation not allowed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket expired or invalid\");\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket PAC check failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 4,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"KRB5SignedPath check failed\");\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 4,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket not signed\");\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(priv, FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n        _kdc_audit_addreason((kdc_request_t)priv, \"Inconsistent request\");\n\tkdc_log(context, config, 4, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if (!_kdc_check_addresses(priv, tgt->caddr, from_addr)) {\n        if (config->check_ticket_addresses) {\n            ret = KRB5KRB_AP_ERR_BADADDR;\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n            kdc_log(context, config, 4, \"Request from wrong address\");\n            _kdc_audit_addreason((kdc_request_t)priv, \"Request from wrong address\");\n            goto out;\n        } else if (config->warn_ticket_addresses) {\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n        }\n    }\n\n    /* check local and per-principal anonymous ticket issuance policy */\n    if (is_anon_tgs_request_p(b, tgt)) {\n\tret = _kdc_check_anon_policy(priv);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 3,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv, \"Referral build failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 4,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(priv,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t client,\n\t\t\t cp,\n                         tgt_realm,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}", "target": 1, "cwe": ["CWE-476"], "project": "heimdal", "commit_id": "04171147948d0a3636bc6374181926f0fb2ec83a", "hash": 172674879650950329667725116403393224452, "size": 1038, "message": "kdc: validate sname in TGS-REQ\n\nIn tgs_build_reply(), validate the server name in the TGS-REQ is present before\ndereferencing.", "idx": 88}
{"func": "xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)\n{\n    int ret;\n\n    if ((ctxt == NULL) || (doc == NULL))\n        return (-1);\n\n    ctxt->doc = doc;\n\n    ret = xmlRelaxNGValidateDocument(ctxt, doc);\n    /*\n     * Remove all left PSVI\n     */\n    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);\n\n    /*\n     * TODO: build error codes\n     */\n    if (ret == -1)\n        return (1);\n    return (ret);\n}", "target": 0, "cwe": ["CWE-134"], "project": "libxml2", "commit_id": "502f6a6d08b08c04b3ddfb1cd21b2f699c1b7f5b", "hash": 313310822743424215518657086057880060554, "size": 22, "message": "More format string warnings with possible format string vulnerability\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=761029\n\nadds a new xmlEscapeFormatString() function to escape composed format\nstrings", "idx": 89}
{"func": "clump_splay_walk_fwd(clump_splay_walker *sw)\n{\n    clump_t *cp = sw->cp;\n    int from = sw->from;\n\n    if (cp == NULL)\n        return NULL;\n\n    /* We step through the tree, and stop when we arrive\n     * at sw->end in an in order manner (i.e. by moving from\n     * the left). */\n    while (1)\n    {\n        if (from == SPLAY_FROM_ABOVE)\n        {\n            /* We have arrived from above. Step left. */\n            if (cp->left)\n            {\n                cp = cp->left;\n                from = SPLAY_FROM_ABOVE;\n                continue;\n            }\n            /* No left to step to, so imagine we have just arrived from there */\n            from = SPLAY_FROM_LEFT;\n            /* Have we reached the stopping point? */\n            if (cp == sw->end)\n                cp = NULL;\n            /* We want to stop here, for inorder operation. So break out of the loop. */\n            break;\n        }\n        if (from == SPLAY_FROM_LEFT)\n        {\n            /* We have arrived from the left. Step right. */\n            if (cp->right)\n            {\n                cp = cp->right;\n                from = SPLAY_FROM_ABOVE;\n                continue;\n            }\n            /* No right to step to, so imagine we have just arrived from there. */\n            from = SPLAY_FROM_RIGHT;\n        }\n        if (from == SPLAY_FROM_RIGHT)\n        {\n            /* We have arrived from the right. Step up. */\n            clump_t *old = cp;\n            cp = cp->parent;\n            if (cp == NULL)\n            {\n                /* We've reached the root of the tree. Is this our stopping point? */\n                if (sw->end == NULL)\n                    break;\n                /* If not, step on. */\n                cp = old;\n                from = SPLAY_FROM_ABOVE;\n            }\n            else\n            {\n                from = (cp->left == old ? SPLAY_FROM_LEFT : SPLAY_FROM_RIGHT);\n                if (from == SPLAY_FROM_LEFT)\n                {\n                    /* Have we reached the stopping point? */\n                    if (cp == sw->end)\n                        cp = NULL;\n                    break;\n                }\n            }\n        }\n    }\n    sw->cp = cp;\n    sw->from = from;\n    return cp;\n}", "target": 0, "cwe": ["CWE-190"], "project": "ghostpdl", "commit_id": "cfde94be1d4286bc47633c6e6eaf4e659bd78066", "hash": 18327292960482533490885551602060954692, "size": 73, "message": "Bug 697985: bounds check the array allocations methods\n\nThe clump allocator has four allocation functions that use 'number of elements'\nand 'size of elements' parameters (rather than a simple 'number of bytes').\n\nThose need specific bounds checking.", "idx": 90}
{"func": "_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    char *message = NULL;\n    char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n                       (int) msg, (int) datalen);\n\n        if((macstate == LIBSSH2_MAC_INVALID) &&\n            (!session->macerror ||\n             LIBSSH2_MACERROR(session, (char *) data, datalen))) {\n            /* Bad MAC input, but no callback set or non-zero return from the\n               callback */\n\n            LIBSSH2_FREE(session, data);\n            return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,\n                                  \"Invalid MAC received\");\n        }\n        session->packAdd_state = libssh2_NB_state_allocated;\n        break;\n    case libssh2_NB_state_jump1:\n        goto libssh2_packet_add_jump_point1;\n    case libssh2_NB_state_jump2:\n        goto libssh2_packet_add_jump_point2;\n    case libssh2_NB_state_jump3:\n        goto libssh2_packet_add_jump_point3;\n    case libssh2_NB_state_jump4:\n        goto libssh2_packet_add_jump_point4;\n    case libssh2_NB_state_jump5:\n        goto libssh2_packet_add_jump_point5;\n    default: /* nothing to do */\n        break;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_allocated) {\n        /* A couple exceptions to the packet adding rule: */\n        switch(msg) {\n\n            /*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                size_t reason = _libssh2_ntohu32(data + 1);\n\n                if(datalen >= 9) {\n                    message_len = _libssh2_ntohu32(data + 5);\n\n                    if(message_len < datalen-13) {\n                        /* 9 = packet_type(1) + reason(4) + message_len(4) */\n                        message = (char *) data + 9;\n\n                        language_len =\n                            _libssh2_ntohu32(data + 9 + message_len);\n                        language = (char *) data + 9 + message_len + 4;\n\n                        if(language_len > (datalen-13-message_len)) {\n                            /* bad input, clear info */\n                            language = message = NULL;\n                            language_len = message_len = 0;\n                        }\n                    }\n                    else\n                        /* bad size, clear it */\n                        message_len = 0;\n                }\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, message,\n                                       message_len, language, language_len);\n                }\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n            /*\n              byte      SSH_MSG_IGNORE\n              string    data\n            */\n\n        case SSH_MSG_IGNORE:\n            if(datalen >= 2) {\n                if(session->ssh_msg_ignore) {\n                    LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);\n                }\n            }\n            else if(session->ssh_msg_ignore) {\n                LIBSSH2_IGNORE(session, \"\", 0);\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_DEBUG\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    message_len = _libssh2_ntohu32(data + 2);\n\n                    if(message_len <= (datalen - 10)) {\n                        /* 6 = packet_type(1) + display(1) + message_len(4) */\n                        message = (char *) data + 6;\n                        language_len = _libssh2_ntohu32(data + 6 +\n                                                        message_len);\n\n                        if(language_len <= (datalen - 10 - message_len))\n                            language = (char *) data + 10 + message_len;\n                    }\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display, message,\n                                  message_len, language, language_len);\n                }\n            }\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_GLOBAL_REQUEST\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            */\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if(datalen >= (6 + len)) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =\n                        SSH_MSG_REQUEST_FAILURE;\n                  libssh2_packet_add_jump_point5:\n                    session->packAdd_state = libssh2_NB_state_jump5;\n                    rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n              uint32    recipient channel\n              uint32    data_type_code\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_EXTENDED_DATA:\n            /* streamid(4) */\n            data_head += 4;\n\n            /* fall-through */\n\n            /*\n              byte      SSH_MSG_CHANNEL_DATA\n              uint32    recipient channel\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_DATA:\n            /* packet_type(1) + channelno(4) + datalen(4) */\n            data_head += 9;\n\n            if(datalen >= data_head)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n\n            if(!channelp) {\n                _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,\n                               \"Packet received for unknown channel\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n#ifdef LIBSSH2DEBUG\n            {\n                uint32_t stream_id = 0;\n                if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                    stream_id = _libssh2_ntohu32(data + 5);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"%d bytes packet_add() for %lu/%lu/%lu\",\n                               (int) (datalen - data_head),\n                               channelp->local.id,\n                               channelp->remote.id,\n                               stream_id);\n            }\n#endif\n            if((channelp->remote.extended_data_ignore_mode ==\n                 LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&\n                (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {\n                /* Pretend we didn't receive this */\n                LIBSSH2_FREE(session, data);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"Ignoring extended data and refunding %d bytes\",\n                               (int) (datalen - 13));\n                if(channelp->read_avail + datalen - data_head >=\n                    channelp->remote.window_size)\n                    datalen = channelp->remote.window_size -\n                        channelp->read_avail + data_head;\n\n                channelp->remote.window_size -= datalen - data_head;\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"shrinking window size by %lu bytes to %lu, \"\n                               \"read_avail %lu\",\n                               datalen - data_head,\n                               channelp->remote.window_size,\n                               channelp->read_avail);\n\n                session->packAdd_channelp = channelp;\n\n                /* Adjust the window based on the block we just freed */\n              libssh2_packet_add_jump_point1:\n                session->packAdd_state = libssh2_NB_state_jump1;\n                rc = _libssh2_channel_receive_window_adjust(session->\n                                                            packAdd_channelp,\n                                                            datalen - 13,\n                                                            1, NULL);\n                if(rc == LIBSSH2_ERROR_EAGAIN)\n                    return rc;\n\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n\n            /*\n             * REMEMBER! remote means remote as source of data,\n             * NOT remote window!\n             */\n            if(channelp->remote.packet_size < (datalen - data_head)) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * packet_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,\n                               \"Packet contains more data than we offered\"\n                               \" to receive, truncating\");\n                datalen = channelp->remote.packet_size + data_head;\n            }\n            if(channelp->remote.window_size <= channelp->read_avail) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * window_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"The current receive window is full,\"\n                               \" data ignored\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            /* Reset EOF status */\n            channelp->remote.eof = 0;\n\n            if(channelp->read_avail + datalen - data_head >\n                channelp->remote.window_size) {\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"Remote sent more data than current \"\n                               \"window allows, truncating\");\n                datalen = channelp->remote.window_size -\n                    channelp->read_avail + data_head;\n            }\n\n            /* Update the read_avail counter. The window size will be\n             * updated once the data is actually read from the queue\n             * from an upper layer */\n            channelp->read_avail += datalen - data_head;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"increasing read_avail by %lu bytes to %lu/%lu\",\n                           (long)(datalen - data_head),\n                           (long)channelp->read_avail,\n                           (long)channelp->remote.window_size);\n\n            break;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EOF\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_EOF:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp)\n                /* We may have freed already, just quietly ignore this... */\n                ;\n            else {\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"EOF received for channel %lu/%lu\",\n                               channelp->local.id,\n                               channelp->remote.id);\n                channelp->remote.eof = 1;\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_REQUEST\n              uint32    recipient channel\n              string    request type in US-ASCII characters only\n              boolean   want reply\n              ....      type-specific data follows\n            */\n\n        case SSH_MSG_CHANNEL_REQUEST:\n            if(datalen >= 9) {\n                uint32_t channel = _libssh2_ntohu32(data + 1);\n                uint32_t len = _libssh2_ntohu32(data + 5);\n                unsigned char want_reply = 1;\n\n                if((len + 9) < datalen)\n                    want_reply = data[len + 9];\n\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"Channel %d received request type %.*s (wr %X)\",\n                               channel, len, data + 9, want_reply);\n\n                if(len == sizeof(\"exit-status\") - 1\n                    && (sizeof(\"exit-status\") - 1 + 9) <= datalen\n                    && !memcmp(\"exit-status\", data + 9,\n                               sizeof(\"exit-status\") - 1)) {\n\n                    /* we've got \"exit-status\" packet. Set the session value */\n                    if(datalen >= 20)\n                        channelp =\n                            _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {\n                        channelp->exit_status =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));\n                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                       \"Exit status %lu received for \"\n                                       \"channel %lu/%lu\",\n                                       channelp->exit_status,\n                                       channelp->local.id,\n                                       channelp->remote.id);\n                    }\n\n                }\n                else if(len == sizeof(\"exit-signal\") - 1\n                         && (sizeof(\"exit-signal\") - 1 + 9) <= datalen\n                         && !memcmp(\"exit-signal\", data + 9,\n                                    sizeof(\"exit-signal\") - 1)) {\n                    /* command terminated due to signal */\n                    if(datalen >= 20)\n                        channelp = _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {\n                        /* set signal name (without SIG prefix) */\n                        uint32_t namelen =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));\n\n                        if(namelen <= UINT_MAX - 1) {\n                            channelp->exit_signal =\n                                LIBSSH2_ALLOC(session, namelen + 1);\n                        }\n                        else {\n                            channelp->exit_signal = NULL;\n                        }\n\n                        if(!channelp->exit_signal)\n                            rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                                \"memory for signal name\");\n                        else if((sizeof(\"exit-signal\") + 13 + namelen <=\n                                 datalen)) {\n                            memcpy(channelp->exit_signal,\n                                   data + 13 + sizeof(\"exit-signal\"), namelen);\n                            channelp->exit_signal[namelen] = '\\0';\n                            /* TODO: save error message and language tag */\n                            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                           \"Exit signal %s received for \"\n                                           \"channel %lu/%lu\",\n                                           channelp->exit_signal,\n                                           channelp->local.id,\n                                           channelp->remote.id);\n                        }\n                    }\n                }\n\n\n                if(want_reply) {\n                    unsigned char packet[5];\n                  libssh2_packet_add_jump_point4:\n                    session->packAdd_state = libssh2_NB_state_jump4;\n                    packet[0] = SSH_MSG_CHANNEL_FAILURE;\n                    memcpy(&packet[1], data + 1, 4);\n                    rc = _libssh2_transport_send(session, packet, 5, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_CLOSE\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_CLOSE:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp) {\n                /* We may have freed already, just quietly ignore this... */\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"Close received for channel %lu/%lu\",\n                           channelp->local.id,\n                           channelp->remote.id);\n\n            channelp->remote.close = 1;\n            channelp->remote.eof = 1;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_OPEN\n              string    \"session\"\n              uint32    sender channel\n              uint32    initial window size\n              uint32    maximum packet size\n            */\n\n        case SSH_MSG_CHANNEL_OPEN:\n            if(datalen < 17)\n                ;\n            else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                     ((sizeof(\"forwarded-tcpip\") - 1) ==\n                      _libssh2_ntohu32(data + 1))\n                     &&\n                     (memcmp(data + 5, \"forwarded-tcpip\",\n                             sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_Qlstn_state, 0,\n                       sizeof(session->packAdd_Qlstn_state));\n\n              libssh2_packet_add_jump_point2:\n                session->packAdd_state = libssh2_NB_state_jump2;\n                rc = packet_queue_listener(session, data, datalen,\n                                           &session->packAdd_Qlstn_state);\n            }\n            else if((datalen >= (sizeof(\"x11\") + 4)) &&\n                     ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&\n                     (memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_x11open_state, 0,\n                       sizeof(session->packAdd_x11open_state));\n\n              libssh2_packet_add_jump_point3:\n                session->packAdd_state = libssh2_NB_state_jump3;\n                rc = packet_x11_open(session, data, datalen,\n                                     &session->packAdd_x11open_state);\n            }\n            if(rc == LIBSSH2_ERROR_EAGAIN)\n                return rc;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n              uint32    recipient channel\n              uint32    bytes to add\n            */\n        case SSH_MSG_CHANNEL_WINDOW_ADJUST:\n            if(datalen < 9)\n                ;\n            else {\n                uint32_t bytestoadd = _libssh2_ntohu32(data + 5);\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n                if(channelp) {\n                    channelp->local.window_size += bytestoadd;\n\n                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                   \"Window adjust for channel %lu/%lu, \"\n                                   \"adding %lu bytes, new window_size=%lu\",\n                                   channelp->local.id,\n                                   channelp->remote.id,\n                                   bytestoadd,\n                                   channelp->local.window_size);\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n        default:\n            break;\n        }\n\n        session->packAdd_state = libssh2_NB_state_sent;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_sent) {\n        LIBSSH2_PACKET *packetp =\n            LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));\n        if(!packetp) {\n            _libssh2_debug(session, LIBSSH2_ERROR_ALLOC,\n                           \"memory for packet\");\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return LIBSSH2_ERROR_ALLOC;\n        }\n        packetp->data = data;\n        packetp->data_len = datalen;\n        packetp->data_head = data_head;\n\n        _libssh2_list_add(&session->packets, &packetp->node);\n\n        session->packAdd_state = libssh2_NB_state_sent1;\n    }\n\n    if((msg == SSH_MSG_KEXINIT &&\n         !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||\n        (session->packAdd_state == libssh2_NB_state_sent2)) {\n        if(session->packAdd_state == libssh2_NB_state_sent1) {\n            /*\n             * Remote wants new keys\n             * Well, it's already in the brigade,\n             * let's just call back into ourselves\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");\n\n            session->packAdd_state = libssh2_NB_state_sent2;\n        }\n\n        /*\n         * The KEXINIT message has been added to the queue.  The packAdd and\n         * readPack states need to be reset because _libssh2_kex_exchange\n         * (eventually) calls upon _libssh2_transport_read to read the rest of\n         * the key exchange conversation.\n         */\n        session->readPack_state = libssh2_NB_state_idle;\n        session->packet.total_num = 0;\n        session->packAdd_state = libssh2_NB_state_idle;\n        session->fullpacket_state = libssh2_NB_state_idle;\n\n        memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));\n\n        /*\n         * If there was a key reexchange failure, let's just hope we didn't\n         * send NEWKEYS yet, otherwise remote will drop us like a rock\n         */\n        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n        if(rc == LIBSSH2_ERROR_EAGAIN)\n            return rc;\n    }\n\n    session->packAdd_state = libssh2_NB_state_idle;\n    return 0;\n}", "target": 1, "cwe": ["CWE-190", "CWE-703"], "project": "libssh2", "commit_id": "dedcbd106f8e52d5586b0205bc7677e4c9868f9c", "hash": 1170263160591633863198263904436599036, "size": 621, "message": "packet.c: improve message parsing (#402)\n\n* packet.c: improve parsing of packets\r\n\r\nfile: packet.c\r\n\r\nnotes:\r\nUse _libssh2_get_string API in SSH_MSG_DEBUG/SSH_MSG_DISCONNECT. Additional uint32 bounds check in SSH_MSG_GLOBAL_REQUEST.", "idx": 91}
{"func": "static size_t EncodeImage(Image *image,const unsigned char *scanline,\n  const size_t bytes_per_line,unsigned char *pixels)\n{\n#define MaxCount  128\n#define MaxPackbitsRunlength  128\n\n  register const unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    repeat_count,\n    runlength;\n\n  unsigned char\n    index;\n\n  /*\n    Pack scanline.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(scanline != (unsigned char *) NULL);\n  assert(pixels != (unsigned char *) NULL);\n  count=0;\n  runlength=0;\n  p=scanline+(bytes_per_line-1);\n  q=pixels;\n  index=(*p);\n  for (i=(ssize_t) bytes_per_line-1; i >= 0; i--)\n  {\n    if (index == *p)\n      runlength++;\n    else\n      {\n        if (runlength < 3)\n          while (runlength > 0)\n          {\n            *q++=(unsigned char) index;\n            runlength--;\n            count++;\n            if (count == MaxCount)\n              {\n                *q++=(unsigned char) (MaxCount-1);\n                count-=MaxCount;\n              }\n          }\n        else\n          {\n            if (count > 0)\n              *q++=(unsigned char) (count-1);\n            count=0;\n            while (runlength > 0)\n            {\n              repeat_count=runlength;\n              if (repeat_count > MaxPackbitsRunlength)\n                repeat_count=MaxPackbitsRunlength;\n              *q++=(unsigned char) index;\n              *q++=(unsigned char) (257-repeat_count);\n              runlength-=repeat_count;\n            }\n          }\n        runlength=1;\n      }\n    index=(*p);\n    p--;\n  }\n  if (runlength < 3)\n    while (runlength > 0)\n    {\n      *q++=(unsigned char) index;\n      runlength--;\n      count++;\n      if (count == MaxCount)\n        {\n          *q++=(unsigned char) (MaxCount-1);\n          count-=MaxCount;\n        }\n    }\n  else\n    {\n      if (count > 0)\n        *q++=(unsigned char) (count-1);\n      count=0;\n      while (runlength > 0)\n      {\n        repeat_count=runlength;\n        if (repeat_count > MaxPackbitsRunlength)\n          repeat_count=MaxPackbitsRunlength;\n        *q++=(unsigned char) index;\n        *q++=(unsigned char) (257-repeat_count);\n        runlength-=repeat_count;\n      }\n    }\n  if (count > 0)\n    *q++=(unsigned char) (count-1);\n  /*\n    Write the number of and the packed length.\n  */\n  length=(size_t) (q-pixels);\n  if (bytes_per_line > 200)\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) length);\n      length+=2;\n    }\n  else\n    {\n      (void) WriteBlobByte(image,(unsigned char) length);\n      length++;\n    }\n  while (q != pixels)\n  {\n    q--;\n    (void) WriteBlobByte(image,*q);\n  }\n  return(length);\n}", "target": 0, "cwe": ["CWE-190", "CWE-189", "CWE-703"], "project": "ImageMagick", "commit_id": "0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734", "hash": 200549617459652161639454456218368836762, "size": 128, "message": "", "idx": 92}
{"func": "PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n\n    PJ_UNUSED_ARG(ses);\n\n    /* Assume RTP header at the start of packet. We'll verify this later. */\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n\n    /* Check RTP header sanity. */\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n\n    /* Payload is located right after header plus CSRC */\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n\n    /* Decode RTP extension. */\n    if ((*hdr)->x) {\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n\n    /* Check that offset is less than packet size */\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n\n    /* Find and set payload. */\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n \n    /* Remove payload padding if any */\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n\n    return PJ_SUCCESS;\n}", "target": 1, "cwe": ["CWE-125"], "project": "pjproject", "commit_id": "22af44e68a0c7d190ac1e25075e1382f77e9397a", "hash": 282855813413266918798201953973800953865, "size": 54, "message": "Merge pull request from GHSA-m66q-q64c-hv36\n\n* Prevent OOB read during RTP/RTCP parsing\n\n* Add log\n\n* Add more logs", "idx": 93}
{"func": "LJ_NOINLINE void lj_err_run(lua_State *L)\n{\n  ptrdiff_t ef = finderrfunc(L);\n  if (ef) {\n    TValue *errfunc = restorestack(L, ef);\n    TValue *top = L->top;\n    lj_trace_abort(G(L));\n    if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {\n      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));\n      lj_err_throw(L, LUA_ERRERR);\n    }\n    L->status = LUA_ERRERR;\n    copyTV(L, top, top-1);\n    copyTV(L, top-1, errfunc);\n    L->top = top+1;\n    lj_vm_call(L, top, 1+1);  /* Stack: |errfunc|msg| -> |msg| */\n  }\n  lj_err_throw(L, LUA_ERRRUN);\n}", "target": 1, "cwe": ["CWE-125"], "project": "LuaJIT", "commit_id": "e296f56b825c688c3530a981dc6b495d972f3d01", "hash": 295611232396518332386836316299494710511, "size": 19, "message": "Call error function on rethrow after trace exit.", "idx": 94}
{"func": "void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tnsc_encode_argb_to_aycocg(context, bmpdata, rowstride);\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tnsc_encode_subsampling(context);\n\t}\n}", "target": 1, "cwe": ["CWE-200", "CWE-787"], "project": "FreeRDP", "commit_id": "d1112c279bd1a327e8e4d0b5f371458bf2579659", "hash": 81893667448869254340458197404575475172, "size": 9, "message": "Fixed CVE-2018-8788\n\nThanks to Eyal Itkin from Check Point Software Technologies.", "idx": 95}
{"func": "local block_state deflate_fast(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head;       /* head of the hash chain */\n    int bflush;           /* set if current block must be flushed */\n\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            s->match_length = longest_match (s, hash_head);\n            /* longest_match() sets match_start */\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n\n            s->lookahead -= s->match_length;\n\n            /* Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             */\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; /* string at strstart already in table */\n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                     * always MIN_MATCH bytes ahead.\n                     */\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n            {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n                 * matter since it will be recomputed at next deflate call.\n                 */\n            }\n        } else {\n            /* No match, output a literal byte */\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1, "cwe": ["CWE-284", "CWE-787"], "project": "zlib", "commit_id": "5c44459c3b28a9bd3283aaceab7c615f8020c531", "hash": 150185998726684580664681990733976538753, "size": 95, "message": "Fix a bug that can crash deflate on some input when using Z_FIXED.\n\nThis bug was reported by Danilo Ramos of Eideticom, Inc. It has\nlain in wait 13 years before being found! The bug was introduced\nin zlib 1.2.2.2, with the addition of the Z_FIXED option. That\noption forces the use of fixed Huffman codes. For rare inputs with\na large number of distant matches, the pending buffer into which\nthe compressed data is written can overwrite the distance symbol\ntable which it overlays. That results in corrupted output due to\ninvalid distances, and can result in out-of-bound accesses,\ncrashing the application.\n\nThe fix here combines the distance buffer and literal/length\nbuffers into a single symbol buffer. Now three bytes of pending\nbuffer space are opened up for each literal or length/distance\npair consumed, instead of the previous two bytes. This assures\nthat the pending buffer cannot overwrite the symbol table, since\nthe maximum fixed code compressed length/distance is 31 bits, and\nsince there are four bytes of pending space for every three bytes\nof symbol space.", "idx": 96}
{"func": "HandleRegisterDNSMessage(void)\n{\n    DWORD err;\n    HANDLE thread = NULL;\n\n    /* Delegate this job to a sub-thread */\n    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);\n\n    /*\n     * We don't add these thread handles to the undo list -- the thread and\n     * processes it spawns are all supposed to terminate or timeout by themselves.\n     */\n    if (thread)\n    {\n        err = 0;\n        CloseHandle(thread);\n    }\n    else\n    {\n        err = GetLastError();\n    }\n\n    return err;\n}", "target": 0, "cwe": ["CWE-415"], "project": "openvpn", "commit_id": "1394192b210cb3c6624a7419bcf3ff966742e79b", "hash": 320692790282839179416058628970086784228, "size": 24, "message": "Fix potential double-free() in Interactive Service (CVE-2018-9336)\n\nMalformed input data on the service pipe towards the OpenVPN interactive\nservice (normally used by the OpenVPN GUI to request openvpn instances\nfrom the service) can result in a double free() in the error handling code.\n\nThis usually only leads to a process crash (DoS by an unprivileged local\naccount) but since it could possibly lead to memory corruption if\nhappening while multiple other threads are active at the same time,\nCVE-2018-9336 has been assigned to acknowledge this risk.\n\nFix by ensuring that sud->directory is set to NULL in GetStartUpData()\nfor all error cases (thus not being free()ed in FreeStartupData()).\n\nRewrite control flow to use explicit error label for error exit.\n\nDiscovered and reported by Jacob Baines <jbaines@tenable.com>.\n\nCVE: 2018-9336\n\nSigned-off-by: Gert Doering <gert@greenie.muc.de>\nAcked-by: Selva Nair <selva.nair@gmail.com>\nMessage-Id: <20180414072617.25075-1-gert@greenie.muc.de>\nURL: https://www.mail-archive.com/search?l=mid&q=20180414072617.25075-1-gert@greenie.muc.de\n\nSigned-off-by: Gert Doering <gert@greenie.muc.de>", "idx": 97}
{"func": "  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n\n    return schema.detach();\n  }", "target": 1, "cwe": ["CWE-674"], "project": "libsass", "commit_id": "f2db04883e5fff4e03777dcc1eb60d4373c45be1", "hash": 303442168559582241242417189366734894355, "size": 15, "message": "Make `parse_css_variable_value` non-recursive\n\nFixes #2658 stack overflow", "idx": 98}
{"func": "  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }", "target": 0, "cwe": ["CWE-94"], "project": "hhvm", "commit_id": "95f96e7287effe2fcdfb9a5338d1a7e4f55b083b", "hash": 214855787513125002076656095209621085742, "size": 1, "message": "Fix libxml_disable_entity_loader()\n\nThis wasn't calling requestInit and setting the libxml handler no null.\nSo the first time an error came along it would reset the handler from\nno-op to reading again.\n\nThis is a much better fix, we set our custom handler in requestInit and\nwhen libxml_disable_entity_loader we store that state as a member bool\nensuring requestInit is always called to set our own handler.\n\nIf the handler isn't inserted then the behavious is as before. The only\ntime this could go pear shaped is say we wanted to make the default be\noff. In that case we'd need a global requestInit that is always called\nsince there are libxml references everywhere.\n\nReviewed By: @jdelong\n\nDifferential Revision: D1116686", "idx": 99}
{"func": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\n\t/* We don't need a base pointer in the /proc filesystem */\n\tpath_put(&nd->path);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1, "cwe": ["CWE-20", "CWE-362", "CWE-416"], "project": "linux", "commit_id": "86acdca1b63e6890540fa19495cfc708beff3d8b", "hash": 136319961353335967115851107094655129411, "size": 17, "message": "fix autofs/afs/etc. magic mountpoint breakage\n\nWe end up trying to kfree() nd.last.name on open(\"/mnt/tmp\", O_CREAT)\nif /mnt/tmp is an autofs direct mount.  The reason is that nd.last_type\nis bogus here; we want LAST_BIND for everything of that kind and we\nget LAST_NORM left over from finding parent directory.\n\nSo make sure that it *is* set properly; set to LAST_BIND before\ndoing ->follow_link() - for normal symlinks it will be changed\nby __vfs_follow_link() and everything else needs it set that way.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>", "idx": 100}
{"func": "main (\n  int argc,\n  char *argv[]\n)\n{\n  int exit_val;\n  fribidi_boolean file_found;\n  char *s;\n  FILE *IN;\n\n  text_width = default_text_width;\n  do_break = true;\n  do_pad = true;\n  do_mirror = true;\n  do_clean = false;\n  do_reorder_nsm = false;\n  show_input = false;\n  show_visual = true;\n  show_basedir = false;\n  show_ltov = false;\n  show_vtol = false;\n  show_levels = false;\n  char_set = \"UTF-8\";\n  bol_text = NULL;\n  eol_text = NULL;\n  input_base_direction = FRIBIDI_PAR_ON;\n\n  if ((s = (char *) getenv (\"COLUMNS\")))\n    {\n      int i;\n\n      i = atoi (s);\n      if (i > 0)\n\ttext_width = i;\n    }\n\n#define CHARSETDESC 257\n#define CAPRTL 258\n\n  /* Parse the command line with getopt library */\n  /* Must set argv[0], getopt uses it to generate error messages */\n  argv[0] = appname;\n  while (1)\n    {\n      int option_index = 0, c;\n      static struct option long_options[] = {\n\t{\"help\", 0, 0, 'h'},\n\t{\"version\", 0, 0, 'V'},\n\t{\"verbose\", 0, 0, 'v'},\n\t{\"debug\", 0, 0, 'd'},\n\t{\"test\", 0, 0, 't'},\n\t{\"charset\", 1, 0, 'c'},\n\t{\"charsetdesc\", 1, 0, CHARSETDESC},\n\t{\"caprtl\", 0, 0, CAPRTL},\n\t{\"showinput\", 0, (int *) (void *) &show_input, true},\n\t{\"nopad\", 0, (int *) (void *) &do_pad, false},\n\t{\"nobreak\", 0, (int *) (void *) &do_break, false},\n\t{\"width\", 1, 0, 'w'},\n\t{\"bol\", 1, 0, 'B'},\n\t{\"eol\", 1, 0, 'E'},\n\t{\"nomirror\", 0, (int *) (void *) &do_mirror, false},\n\t{\"reordernsm\", 0, (int *) (void *) &do_reorder_nsm, true},\n\t{\"clean\", 0, (int *) (void *) &do_clean, true},\n\t{\"ltr\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_LTR},\n\t{\"rtl\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_RTL},\n\t{\"wltr\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WLTR},\n\t{\"wrtl\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WRTL},\n\t{\"basedir\", 0, (int *) (void *) &show_basedir, true},\n\t{\"ltov\", 0, (int *) (void *) &show_ltov, true},\n\t{\"vtol\", 0, (int *) (void *) &show_vtol, true},\n\t{\"levels\", 0, (int *) (void *) &show_levels, true},\n\t{\"novisual\", 0, (int *) (void *) &show_visual, false},\n\t{0, 0, 0, 0}\n      };\n\n      c =\n\tgetopt_long (argc, argv, \"hVvdtc:w:B:E:\", long_options,\n\t\t     &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  break;\n\tcase 'h':\n\t  help ();\n\t  break;\n\tcase 'V':\n\t  version ();\n\t  break;\n\tcase 'v':\n\t  show_basedir = show_ltov = show_vtol = show_levels = true;\n\t  break;\n\tcase 'w':\n\t  text_width = atoi (optarg);\n\t  if (text_width <= 0)\n\t    die2 (\"invalid screen width `%s'\\n\", optarg);\n\t  break;\n\tcase 'B':\n\t  bol_text = optarg;\n\t  break;\n\tcase 'E':\n\t  eol_text = optarg;\n\t  break;\n\tcase 'd':\n\t  if (!fribidi_set_debug (true))\n\t    die1\n\t      (\"lib\" FRIBIDI\n\t       \" must be compiled with DEBUG option to enable\\nturn debug info on.\\n\");\n\t  break;\n\tcase 't':\n\t  do_clean = show_input = do_reorder_nsm = true;\n\t  do_break = false;\n\t  text_width = default_text_width;\n\t  break;\n\tcase 'c':\n\t  char_set = my_fribidi_strdup (optarg);\n\t  if (!char_set)\n\t    die1 (\"memory allocation failed for char_set!\");\n\t  break;\n\tcase CAPRTL:\n\t  char_set = \"CapRTL\";\n\t  break;\n\tcase CHARSETDESC:\n\t  char_set = optarg;\n\t  char_set_num = fribidi_parse_charset (char_set);\n\t  if (!char_set_num)\n\t    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\t  if (!fribidi_char_set_desc (char_set_num))\n\t    die2 (\"no description available for character set `%s'\\n\",\n\t\t  fribidi_char_set_name (char_set_num));\n\t  else\n\t    printf (\"Descriptions for character set %s:\\n\"\n\t\t    \"\\n\" \"%s\", fribidi_char_set_title (char_set_num),\n\t\t    fribidi_char_set_desc (char_set_num));\n\t  exit (0);\n\t  break;\n\tcase ':':\n\tcase '?':\n\t  die2 (NULL, NULL);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n\n  char_set_num = fribidi_parse_charset (char_set);\n\n  if (!char_set_num)\n    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\nFRIBIDI_BEGIN_IGNORE_DEPRECATIONS\n  fribidi_set_mirroring (do_mirror);\n  fribidi_set_reorder_nsm (do_reorder_nsm);\nFRIBIDI_END_IGNORE_DEPRECATIONS\n  exit_val = 0;\n  file_found = false;\n  while (optind < argc || !file_found)\n    {\n      const char *filename;\n\n      filename = optind < argc ? argv[optind++] : \"-\";\n      file_found = true;\n\n      /* Open the infile for reading */\n      if (filename[0] == '-' && !filename[1])\n\t{\n\t  IN = stdin;\n\t}\n      else\n\t{\n\t  IN = fopen (filename, \"r\");\n\t  if (!IN)\n\t    {\n\t      fprintf (stderr, \"%s: %s: no such file or directory\\n\",\n\t\t       appname, filename);\n\t      exit_val = 1;\n\t      continue;\n\t    }\n\t}\n\n      /* Read and process input one line at a time */\n      {\n\tchar S_[MAX_STR_LEN];\n\tint padding_width, break_width;\n\n\tpadding_width = show_input ? (text_width - 10) / 2 : text_width;\n\tbreak_width = do_break ? padding_width : 3 * MAX_STR_LEN;\n\n\twhile (fgets (S_, sizeof (S_) - 1, IN))\n\t  {\n\t    const char *new_line, *nl_found;\n\t    FriBidiChar logical[MAX_STR_LEN];\n\t    char outstring[MAX_STR_LEN];\n\t    FriBidiParType base;\n\t    FriBidiStrIndex len;\n\n\t    nl_found = \"\";\n\t    S_[sizeof (S_) - 1] = 0;\n\t    len = strlen (S_);\n\t    /* chop */\n\t    if (S_[len - 1] == '\\n')\n\t      {\n\t\tlen--;\n\t\tS_[len] = '\\0';\n\t\tnew_line = \"\\n\";\n\t      }\n\t    else\n\t      new_line = \"\";\n\t    /* TODO: handle \\r */\n\n\t    len = fribidi_charset_to_unicode (char_set_num, S_, len, logical);\n\n\t    {\n\t      FriBidiChar *visual;\n\t      FriBidiStrIndex *ltov, *vtol;\n\t      FriBidiLevel *levels;\n\t      fribidi_boolean log2vis;\n\n\t      visual = show_visual ? ALLOCATE (FriBidiChar,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\t      ltov = show_ltov ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      vtol = show_vtol ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      levels = show_levels ? ALLOCATE (FriBidiLevel,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\n\t      /* Create a bidi string. */\n\t      base = input_base_direction;\n\n\t      log2vis = fribidi_log2vis (logical, len, &base,\n\t\t\t\t\t /* output */\n\t\t\t\t\t visual, ltov, vtol, levels);\n\n\t      if (log2vis)\n\t\t{\n\n\t\t  if (show_input)\n\t\t    printf (\"%-*s => \", padding_width, S_);\n\n\t\t  /* Remove explicit marks, if asked for. */\n\n\t\t  if (do_clean)\n\t\t    len =\n\t\t      fribidi_remove_bidi_marks (visual, len, ltov, vtol,\n\t\t\t\t\t\t levels);\n\n\t\t  if (show_visual)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\n\t\t      if (bol_text)\n\t\t\tprintf (\"%s\", bol_text);\n\n\t\t      /* Convert it to input charset and print. */\n\t\t      {\n\t\t\tFriBidiStrIndex idx, st;\n\t\t\tfor (idx = 0; idx < len;)\n\t\t\t  {\n\t\t\t    FriBidiStrIndex wid, inlen;\n\n\t\t\t    wid = break_width;\n\t\t\t    st = idx;\n\t\t\t    if (char_set_num != FRIBIDI_CHAR_SET_CAP_RTL)\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid -=\n\t\t\t\t    FRIBIDI_IS_EXPLICIT_OR_ISOLATE_OR_BN_OR_NSM\n\t\t\t\t    (fribidi_get_bidi_type (visual[idx])) ? 0\n\t\t\t\t    : 1;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid--;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    if (wid < 0 && idx - st > 1)\n\t\t\t      idx--;\n\t\t\t    inlen = idx - st;\n\n\t\t\t    fribidi_unicode_to_charset (char_set_num,\n\t\t\t\t\t\t\tvisual + st, inlen,\n\t\t\t\t\t\t\toutstring);\n\t\t\t    if (FRIBIDI_IS_RTL (base))\n\t\t\t      printf (\"%*s\",\n\t\t\t\t      (int) (do_pad ? (padding_width +\n\t\t\t\t\t\t       strlen (outstring) -\n\t\t\t\t\t\t       (break_width -\n\t\t\t\t\t\t\twid)) : 0),\n\t\t\t\t      outstring);\n\t\t\t    else\n\t\t\t      printf (\"%s\", outstring);\n\t\t\t    if (idx < len)\n\t\t\t      printf (\"\\n\");\n\t\t\t  }\n\t\t      }\n\t\t      if (eol_text)\n\t\t\tprintf (\"%s\", eol_text);\n\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_basedir)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\t\t      printf (\"Base direction: %s\",\n\t\t\t      (FRIBIDI_DIR_TO_LEVEL (base) ? \"R\" : \"L\"));\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_ltov)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) ltov[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_vtol)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) vtol[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_levels)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%d \", (int) levels[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  exit_val = 2;\n\t\t}\n\n\t      if (show_visual)\n\t\tfree (visual);\n\t      if (show_ltov)\n\t\tfree (ltov);\n\t      if (show_vtol)\n\t\tfree (vtol);\n\t      if (show_levels)\n\t\tfree (levels);\n\t    }\n\n\t    if (*nl_found)\n\t      printf (\"%s\", new_line);\n\t  }\n      }\n    }\n\n  return exit_val;\n}", "target": 1, "cwe": ["CWE-787"], "project": "fribidi", "commit_id": "ad3a19e6372b1e667128ed1ea2f49919884587e1", "hash": 172728079670481210682943367792287225250, "size": 369, "message": "Fix the stack buffer overflow issue\n\nstrlen() could returns 0. Without a conditional check for len,\naccessing S_ pointer with len - 1 may causes a stack buffer overflow.\n\nAddressSanitizer reports this like:\n==1219243==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffdce043c1f at pc 0x000000403547 bp 0x7ffdce0\n43b30 sp 0x7ffdce043b28\nREAD of size 1 at 0x7ffdce043c1f thread T0\n    #0 0x403546 in main ../bin/fribidi-main.c:393\n    #1 0x7f226804e58f in __libc_start_call_main (/lib64/libc.so.6+0x2d58f)\n    #2 0x7f226804e648 in __libc_start_main_impl (/lib64/libc.so.6+0x2d648)\n    #3 0x4036f4 in _start (/tmp/fribidi/build/bin/fribidi+0x4036f4)\n\nAddress 0x7ffdce043c1f is located in stack of thread T0 at offset 63 in frame\n    #0 0x4022bf in main ../bin/fribidi-main.c:193\n\n  This frame has 5 object(s):\n    [32, 36) 'option_index' (line 233)\n    [48, 52) 'base' (line 386)\n    [64, 65064) 'S_' (line 375) <== Memory access at offset 63 underflows this variable\n    [65328, 130328) 'outstring' (line 385)\n    [130592, 390592) 'logical' (line 384)\n\nThis fixes https://github.com/fribidi/fribidi/issues/181", "idx": 101}
{"func": "void Scanner::pop_finished_files()\n{\n    // Pop all files that have been fully processed (file upper bound\n    // in buffer points before the first character of current lexeme),\n    // except for the first (main) file which must always remain at the\n    // bottom of the stack.\n    size_t i = files.size();\n    DASSERT(i > 0);\n    for (;;) {\n        --i;\n        Input *in = files[i];\n        if (i == 0 || in->eo >= tok) break;\n        files.pop_back();\n        delete in;\n    }\n}", "target": 0, "cwe": ["CWE-787"], "project": "re2c", "commit_id": "c4603ba5ce229db83a2a4fb93e6d4b4e3ec3776a", "hash": 206574273435723420963345666485154059235, "size": 16, "message": "Fix crash in lexer refill (reported by Agostino Sarubbo).\n\nThe crash happened in a rare case of a very long lexeme that doen't fit\ninto the buffer, forcing buffer reallocation.\n\nThe crash was caused by an incorrect calculation of the shift offset\n(it was smaller than necessary). As a consequence, the data from buffer\nstart and up to the beginning of the current lexeme was not discarded\n(as it should have been), resulting in less free space for new data than\nexpected.", "idx": 102}
{"func": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}", "target": 1, "cwe": ["CWE-476"], "project": "linux", "commit_id": "4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6", "hash": 209636361444839759360888493321404633048, "size": 47, "message": "f2fs: support swap file w/ DIO\n\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>", "idx": 103}
{"func": "msg_scroll_up(void)\n{\n#ifdef FEAT_GUI\n    // Remove the cursor before scrolling, ScreenLines[] is going\n    // to become invalid.\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n    // scrolling up always works\n    mch_disable_flush();\n    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);\n    mch_enable_flush();\n\n    if (!can_clear((char_u *)\" \"))\n    {\n\t// Scrolling up doesn't result in the right background.  Set the\n\t// background here.  It's not efficient, but avoids that we have to do\n\t// it all over the code.\n\tscreen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\n\t// Also clear the last char of the last but one line if it was not\n\t// cleared before to avoid a scroll-up.\n\tif (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)\n\t    screen_fill((int)Rows - 2, (int)Rows - 1,\n\t\t\t\t (int)Columns - 1, (int)Columns, ' ', ' ', 0);\n    }\n}", "target": 0, "cwe": ["CWE-416"], "project": "vim", "commit_id": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f", "hash": 178696888871123808617603173117812613764, "size": 27, "message": "patch 8.2.4040: keeping track of allocated lines is too complicated\n\nProblem:    Keeping track of allocated lines in user functions is too\n            complicated.\nSolution:   Instead of freeing individual lines keep them all until the end.", "idx": 104}
{"func": "int pmd_huge(pmd_t pmd)\n{\n\treturn !pmd_none(pmd) &&\n\t\t(pmd_val(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;\n}", "target": 0, "cwe": ["CWE-119"], "project": "linux", "commit_id": "1be7107fbe18eed3e319a6c3e83c78254b693acb", "hash": 203033456551788960212335321006838986208, "size": 5, "message": "mm: larger stack guard gap, between vmas\n\nStack guard page is a useful feature to reduce a risk of stack smashing\ninto a different mapping. We have been using a single page gap which\nis sufficient to prevent having stack adjacent to a different mapping.\nBut this seems to be insufficient in the light of the stack usage in\nuserspace. E.g. glibc uses as large as 64kB alloca() in many commonly\nused functions. Others use constructs liks gid_t buffer[NGROUPS_MAX]\nwhich is 256kB or stack strings with MAX_ARG_STRLEN.\n\nThis will become especially dangerous for suid binaries and the default\nno limit for the stack size limit because those applications can be\ntricked to consume a large portion of the stack and a single glibc call\ncould jump over the guard page. These attacks are not theoretical,\nunfortunatelly.\n\nMake those attacks less probable by increasing the stack guard gap\nto 1MB (on systems with 4k pages; but make it depend on the page size\nbecause systems with larger base pages might cap stack allocations in\nthe PAGE_SIZE units) which should cover larger alloca() and VLA stack\nallocations. It is obviously not a full fix because the problem is\nsomehow inherent, but it should reduce attack space a lot.\n\nOne could argue that the gap size should be configurable from userspace,\nbut that can be done later when somebody finds that the new 1MB is wrong\nfor some special case applications.  For now, add a kernel command line\noption (stack_guard_gap) to specify the stack gap size (in page units).\n\nImplementation wise, first delete all the old code for stack guard page:\nbecause although we could get away with accounting one extra page in a\nstack vma, accounting a larger gap can break userspace - case in point,\na program run with \"ulimit -S -v 20000\" failed when the 1MB gap was\ncounted for RLIMIT_AS; similar problems could come with RLIMIT_MLOCK\nand strict non-overcommit mode.\n\nInstead of keeping gap inside the stack vma, maintain the stack guard\ngap as a gap between vmas: using vm_start_gap() in place of vm_start\n(or vm_end_gap() in place of vm_end if VM_GROWSUP) in just those few\nplaces which need to respect the gap - mainly arch_get_unmapped_area(),\nand and the vma tree's subtree_gap support for that.\n\nOriginal-patch-by: Oleg Nesterov <oleg@redhat.com>\nOriginal-patch-by: Michal Hocko <mhocko@suse.com>\nSigned-off-by: Hugh Dickins <hughd@google.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nTested-by: Helge Deller <deller@gmx.de> # parisc\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 105}
{"func": "int ssl23_get_client_hello(SSL *s)\n\t{\n\tchar buf_space[11]; /* Request this many bytes in initial read.\n\t                     * We can detect SSL 3.0/TLS 1.0 Client Hellos\n\t                     * ('type == 3') correctly only when the following\n\t                     * is in a single record, which is not guaranteed by\n\t                     * the protocol specification:\n\t                     * Byte  Content\n\t                     *  0     type            \\\n\t                     *  1/2   version          > record header\n\t                     *  3/4   length          /\n\t                     *  5     msg_type        \\\n\t                     *  6-8   length           > Client Hello message\n\t                     *  9/10  client_version  /\n\t                     */\n\tchar *buf= &(buf_space[0]);\n\tunsigned char *p,*d,*d_len,*dd;\n\tunsigned int i;\n\tunsigned int csl,sil,cl;\n\tint n=0,j;\n\tint type=0;\n\tint v[2];\n\n\tif (s->state ==\tSSL23_ST_SR_CLNT_HELLO_A)\n\t\t{\n\t\t/* read the initial header */\n\t\tv[0]=v[1]=0;\n\n\t\tif (!ssl3_setup_buffers(s)) goto err;\n\n\t\tn=ssl23_read_bytes(s, sizeof buf_space);\n\t\tif (n != sizeof buf_space) return(n); /* n == -1 || n == 0 */\n\n\t\tp=s->packet;\n\n\t\tmemcpy(buf,p,n);\n\n\t\tif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\n\t\t\t{\n\t\t\t/*\n\t\t\t * SSLv2 header\n\t\t\t */\n\t\t\tif ((p[3] == 0x00) && (p[4] == 0x02))\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv2 */\n\t\t\t\tif (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\t\t\t\t}\n\t\t\telse if (p[3] == SSL3_VERSION_MAJOR)\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv3/TLSv1 */\n\t\t\t\tif (p[4] >= TLS1_VERSION_MINOR)\n\t\t\t\t\t{\n\t\t\t\t\tif (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=TLS1_VERSION;\n\t\t\t\t\t\t/* type=2; */ /* done later to survive restarts */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\t\t/* type=2; */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttype=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\t/* type=2; */\n\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\n\t\t\t\t}\n\t\t\t}\n\t\telse if ((p[0] == SSL3_RT_HANDSHAKE) &&\n\t\t\t (p[1] == SSL3_VERSION_MAJOR) &&\n\t\t\t (p[5] == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t ((p[3] == 0 && p[4] < 5 /* silly record length? */)\n\t\t\t\t|| (p[9] == p[1])))\n\t\t\t{\n\t\t\t/*\n\t\t\t * SSLv3 or tls1 header\n\t\t\t */\n\t\t\t\n\t\t\tv[0]=p[1]; /* major version (= SSL3_VERSION_MAJOR) */\n\t\t\t/* We must look at client_version inside the Client Hello message\n\t\t\t * to get the correct minor version.\n\t\t\t * However if we have only a pathologically small fragment of the\n\t\t\t * Client Hello message, this would be difficult, and we'd have\n\t\t\t * to read more records to find out.\n\t\t\t * No known SSL 3.0 client fragments ClientHello like this,\n\t\t\t * so we simply assume TLS 1.0 to avoid protocol version downgrade\n\t\t\t * attacks. */\n\t\t\tif (p[3] == 0 && p[4] < 6)\n\t\t\t\t{\n#if 0\n\t\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);\n\t\t\t\tgoto err;\n#else\n\t\t\t\tv[1] = TLS1_VERSION_MINOR;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tv[1]=p[10]; /* minor version according to client_version */\n\t\t\tif (v[1] >= TLS1_VERSION_MINOR)\n\t\t\t\t{\n\t\t\t\tif (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=TLS1_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* client requests SSL 3.0 */\n\t\t\t\tif (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t{\n\t\t\t\t\t/* we won't be able to use TLS of course,\n\t\t\t\t\t * but this will send an appropriate alert */\n\t\t\t\t\ts->version=TLS1_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telse if ((strncmp(\"GET \", (char *)p,4) == 0) ||\n\t\t\t (strncmp(\"POST \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"HEAD \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"PUT \", (char *)p,4) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\telse if (strncmp(\"CONNECT\",(char *)p,7) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\tif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\n\t\t{\n\t\t/* we have SSLv3/TLSv1 in an SSLv2 header\n\t\t * (other cases skip this state) */\n\n\t\ttype=2;\n\t\tp=s->packet;\n\t\tv[0] = p[3]; /* == SSL3_VERSION_MAJOR */\n\t\tv[1] = p[4];\n\n\t\tn=((p[0]&0x7f)<<8)|p[1];\n\t\tif (n > (1024*4))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tj=ssl23_read_bytes(s,n+2);\n\t\tif (j <= 0) return(j);\n\n\t\tssl3_finish_mac(s, s->packet+2, s->packet_length-2);\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg); /* CLIENT-HELLO */\n\n\t\tp=s->packet;\n\t\tp+=5;\n\t\tn2s(p,csl);\n\t\tn2s(p,sil);\n\t\tn2s(p,cl);\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tif ((csl+sil+cl+11) != s->packet_length) /* We can't have TLS extensions in SSL 2.0 format\n\t\t                                          * Client Hello, can we? Error condition should be\n\t\t                                          * '>' otherweise */\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* record header: msg_type ... */\n\t\t*(d++) = SSL3_MT_CLIENT_HELLO;\n\t\t/* ... and length (actual value will be written later) */\n\t\td_len = d;\n\t\td += 3;\n\n\t\t/* client_version */\n\t\t*(d++) = SSL3_VERSION_MAJOR; /* == v[0] */\n\t\t*(d++) = v[1];\n\n\t\t/* lets populate the random area */\n\t\t/* get the challenge_length */\n\t\ti=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\n\t\tmemset(d,0,SSL3_RANDOM_SIZE);\n\t\tmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\n\t\td+=SSL3_RANDOM_SIZE;\n\n\t\t/* no session-id reuse */\n\t\t*(d++)=0;\n\n\t\t/* ciphers */\n\t\tj=0;\n\t\tdd=d;\n\t\td+=2;\n\t\tfor (i=0; i<csl; i+=3)\n\t\t\t{\n\t\t\tif (p[i] != 0) continue;\n\t\t\t*(d++)=p[i+1];\n\t\t\t*(d++)=p[i+2];\n\t\t\tj+=2;\n\t\t\t}\n\t\ts2n(j,dd);\n\n\t\t/* COMPRESSION */\n\t\t*(d++)=1;\n\t\t*(d++)=0;\n\t\t\n#if 0\n                /* copy any remaining data with may be extensions */\n\t        p = p+csl+sil+cl;\n\t\twhile (p <  s->packet+s->packet_length)\n\t\t\t{\n\t\t\t*(d++)=*(p++);\n\t\t\t}\n#endif\n\n\t\ti = (d-(unsigned char *)s->init_buf->data) - 4;\n\t\tl2n3((long)i, d_len);\n\n\t\t/* get the data reused from the init_buf */\n\t\ts->s3->tmp.reuse_message=1;\n\t\ts->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\n\t\ts->s3->tmp.message_size=i;\n\t\t}\n\n\t/* imaginary new state (for program structure): */\n\t/* s->state = SSL23_SR_CLNT_HELLO_C */\n\n\tif (type == 1)\n\t\t{\n#ifdef OPENSSL_NO_SSL2\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\tgoto err;\n#else\n\t\t/* we are talking sslv2 */\n\t\t/* we need to clean up the SSLv3/TLSv1 setup and put in the\n\t\t * sslv2 stuff. */\n\n\t\tif (s->s2 == NULL)\n\t\t\t{\n\t\t\tif (!ssl2_new(s))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n\t\t\tssl2_clear(s);\n\n\t\tif (s->s3 != NULL) ssl3_free(s);\n\n\t\tif (!BUF_MEM_grow_clean(s->init_buf,\n\t\t\tSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\n\t\t\t{\n\t\t\tgoto err;\n\t\t\t}\n\n\t\ts->state=SSL2_ST_GET_CLIENT_HELLO_A;\n\t\tif (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)\n\t\t\ts->s2->ssl2_rollback=0;\n\t\telse\n\t\t\t/* reject SSL 2.0 session if client supports SSL 3.0 or TLS 1.0\n\t\t\t * (SSL 3.0 draft/RFC 2246, App. E.2) */\n\t\t\ts->s2->ssl2_rollback=1;\n\n\t\t/* setup the n bytes we have read so we get them from\n\t\t * the sslv2 buffer */\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\ts->packet_length=n;\n\t\ts->packet= &(s->s2->rbuf[0]);\n\t\tmemcpy(s->packet,buf,n);\n\t\ts->s2->rbuf_left=n;\n\t\ts->s2->rbuf_offs=0;\n\n\t\ts->method=SSLv2_server_method();\n\t\ts->handshake_func=s->method->ssl_accept;\n#endif\n\t\t}\n\n\tif ((type == 2) || (type == 3))\n\t\t{\n\t\t/* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */\n\n\t\tif (!ssl_init_wbio_buffer(s,1)) goto err;\n\n\t\t/* we are in this state */\n\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\n\t\tif (type == 3)\n\t\t\t{\n\t\t\t/* put the 'n' bytes we have read into the input buffer\n\t\t\t * for SSLv3 */\n\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\ts->packet_length=n;\n\t\t\ts->packet= &(s->s3->rbuf.buf[0]);\n\t\t\tmemcpy(s->packet,buf,n);\n\t\t\ts->s3->rbuf.left=n;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ts->packet_length=0;\n\t\t\ts->s3->rbuf.left=0;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n\n\t\tif (s->version == TLS1_VERSION)\n\t\t\ts->method = TLSv1_server_method();\n\t\telse\n\t\t\ts->method = SSLv3_server_method();\n#if 0 /* ssl3_get_client_hello does this */\n\t\ts->client_version=(v[0]<<8)|v[1];\n#endif\n\t\ts->handshake_func=s->method->ssl_accept;\n\t\t}\n\t\n\tif ((type < 1) || (type > 3))\n\t\t{\n\t\t/* bad, very bad */\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\n\t\tgoto err;\n\t\t}\n\ts->init_num=0;\n\n\tif (buf != buf_space) OPENSSL_free(buf);\n\treturn(SSL_accept(s));\nerr:\n\tif (buf != buf_space) OPENSSL_free(buf);\n\treturn(-1);\n\t}", "target": 1, "cwe": [], "project": "openssl", "commit_id": "8671b898609777c95aedf33743419a523874e6e8", "hash": 242944453836465623625016043102520232018, "size": 353, "message": "Memory saving patch.", "idx": 106}
{"func": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}", "target": 1, "cwe": ["CWE-399", "CWE-119"], "project": "linux", "commit_id": "05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655", "hash": 117636803742517238428371546188563715116, "size": 12, "message": "ieee802154: atusb: do not use the stack for buffers to make them DMA able\n\nFrom 4.9 we should really avoid using the stack here as this will not be DMA\nable on various platforms. This changes the buffers already being present in\ntime of 4.9 being released. This should go into stable as well.\n\nReported-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Stefan Schmidt <stefan@osg.samsung.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>", "idx": 107}
{"func": "static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t refblock_offset)\n{\n\tssize_t ret;\n\n\ttcmu_dbg(\"%s: setting RC[%d] to %llx\\n\", __func__, rc_index, refblock_offset);\n\ts->refcount_table[rc_index] = htobe64(refblock_offset);\n\n\tret = pwrite(s->fd,\n\t\t&s->refcount_table[rc_index],\n\t\tsizeof(uint64_t),\n\t\ts->refcount_table_offset + (rc_index * sizeof(uint64_t)));\n\n\tif (ret != sizeof(uint64_t))\n\t\ttcmu_err(\"%s: error, RC writeback failed (%zd)\\n\", __func__, ret);\n\n\tfdatasync(s->fd);\n\treturn ret;\n}", "target": 0, "cwe": ["CWE-200"], "project": "tcmu-runner", "commit_id": "8cf8208775022301adaa59c240bb7f93742d1329", "hash": 302774047603199970674542151866009806906, "size": 18, "message": "removed all check_config callback implementations to avoid security issues\n\nsee github issue #194\n\nqcow.c contained an information leak, could test for existance of any\nfile in the system\n\nfile_example.c and file_optical.c allow also to test for existance of\nany file, plus to temporarily create empty new files anywhere in the\nfile system. This also involves a race condition, if a file didn't exist\nin the first place, but would be created in-between by some other\nprocess, then the file would be deleted by the check_config\nimplementation.", "idx": 108}
{"func": "static void prune_dead_connections(struct Curl_easy *data)\n{\n  struct curltime now = Curl_now();\n  timediff_t elapsed;\n\n  DEBUGASSERT(!data->conn); /* no connection */\n  CONNCACHE_LOCK(data);\n  elapsed =\n    Curl_timediff(now, data->state.conn_cache->last_cleanup);\n  CONNCACHE_UNLOCK(data);\n\n  if(elapsed >= 1000L) {\n    struct prunedead prune;\n    prune.data = data;\n    prune.extracted = NULL;\n    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,\n                                 call_extract_if_dead)) {\n      /* unlocked */\n\n      /* remove connection from cache */\n      Curl_conncache_remove_conn(data, prune.extracted, TRUE);\n\n      /* disconnect it */\n      Curl_disconnect(data, prune.extracted, TRUE);\n    }\n    CONNCACHE_LOCK(data);\n    data->state.conn_cache->last_cleanup = now;\n    CONNCACHE_UNLOCK(data);\n  }\n}", "target": 0, "cwe": [], "project": "curl", "commit_id": "852aa5ad351ea53e5f01d2f44b5b4370c2bf5425", "hash": 134635035591706689931888345954210781333, "size": 30, "message": "url: check sasl additional parameters for connection reuse.\n\nAlso move static function safecmp() as non-static Curl_safecmp() since\nits purpose is needed at several places.\n\nBug: https://curl.se/docs/CVE-2022-22576.html\n\nCVE-2022-22576\n\nCloses #8746", "idx": 109}
{"func": "TEE_Result syscall_authenc_dec_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, const void *tag, size_t tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_DECRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_dec_final(cs->ctx, cs->algo, src_data, src_len,\n\t\t\t\t       dst_data, &dlen, tag, tag_len);\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}", "target": 1, "cwe": ["CWE-327"], "project": "optee_os", "commit_id": "34a08bec755670ea0490cb53bbc68058cafc69b6", "hash": 330272732493913102813848681834349199044, "size": 72, "message": "cryp: prevent direct calls to update and final functions\n\nWith inconsistent or malformed data it has been possible to call\n\"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1]\nwe have seen that this results in asserts, i.e., a crash that\npotentially could leak sensitive information.\n\nBy setting the state (initialized) in the crypto context (i.e., the\ntee_cryp_state) at the end of all syscall_*_init functions and then add\na check of the state at the beginning of all update and final functions,\n  we prevent direct entrance to the \"update\" and \"final\" functions.\n\n[1] https://github.com/MartijnB/optee_fuzzer\n\nFixes: OP-TEE-2019-0021\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Martijn Bogaard <bogaard@riscure.com>\nAcked-by: Jerome Forissier <jerome.forissier@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>", "idx": 110}
{"func": "ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }", "target": 1, "cwe": ["CWE-400"], "project": "envoy", "commit_id": "0e49a495826ea9e29134c1bd54fdeb31a034f40c", "hash": 178586838059200984289094081668374172712, "size": 1, "message": "http/2: add stats and stream flush timeout (#139)\n\nThis commit adds a new stream flush timeout to guard against a\nremote server that does not open window once an entire stream has\nbeen buffered for flushing. Additional stats have also been added\nto better understand the codecs view of active streams as well as\namount of data buffered.\n\nSigned-off-by: Matt Klein <mklein@lyft.com>", "idx": 111}
{"func": "bool TestRandomPool()\r\n{\r\n\tstd::cout << \"\\nTesting RandomPool generator...\\n\\n\";\r\n\tbool pass=true, fail;\r\n\t{\r\n\t\tRandomPool prng;\r\n\t\tstatic const unsigned int ENTROPY_SIZE = 32;\r\n\r\n\t\tMeterFilter meter(new Redirector(TheBitBucket()));\r\n\t\tRandomNumberSource test(prng, 100000, true, new Deflator(new Redirector(meter)));\r\n\r\n\t\tfail = false;\r\n\t\tif (meter.GetTotalBytes() < 100000)\r\n\t\t\tfail = true;\r\n\r\n\t\tpass &= !fail;\r\n\t\tif (fail)\r\n\t\t\tstd::cout << \"FAILED:\";\r\n\t\telse\r\n\t\t\tstd::cout << \"passed:\";\r\n\t\tstd::cout << \"  100000 generated bytes compressed to \" << meter.GetTotalBytes() << \" bytes by DEFLATE\\n\";\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tfail = false;\r\n\t\t\tprng.DiscardBytes(100000);\r\n\t\t}\r\n\t\tcatch (const Exception&)\r\n\t\t{\r\n\t\t\tfail = true;\r\n\t\t}\r\n\r\n\t\tpass &= !fail;\r\n\t\tif (fail)\r\n\t\t\tstd::cout << \"FAILED:\";\r\n\t\telse\r\n\t\t\tstd::cout << \"passed:\";\r\n\t\tstd::cout << \"  discarded 10000 bytes\" << std::endl;\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tfail = false;\r\n\t\t\tif(prng.CanIncorporateEntropy())\r\n\t\t\t{\r\n\t\t\t\tSecByteBlock entropy(ENTROPY_SIZE);\r\n\t\t\t\tGlobalRNG().GenerateBlock(entropy, entropy.SizeInBytes());\r\n\r\n\t\t\t\tprng.IncorporateEntropy(entropy, entropy.SizeInBytes());\r\n\t\t\t\tprng.IncorporateEntropy(entropy, entropy.SizeInBytes());\r\n\t\t\t\tprng.IncorporateEntropy(entropy, entropy.SizeInBytes());\r\n\t\t\t\tprng.IncorporateEntropy(entropy, entropy.SizeInBytes());\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (const Exception& /*ex*/)\r\n\t\t{\r\n\t\t\tfail = true;\r\n\t\t}\r\n\r\n\t\tpass &= !fail;\r\n\t\tif (fail)\r\n\t\t\tstd::cout << \"FAILED:\";\r\n\t\telse\r\n\t\t\tstd::cout << \"passed:\";\r\n\t\tstd::cout << \"  IncorporateEntropy with \" << 4*ENTROPY_SIZE << \" bytes\\n\";\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// Miscellaneous for code coverage\r\n\t\t\t(void)prng.AlgorithmName();  // \"unknown\"\r\n\t\t\tword32 result = prng.GenerateWord32();\r\n\t\t\tresult = prng.GenerateWord32((result & 0xff), 0xffffffff - (result & 0xff));\r\n\t\t\tprng.GenerateBlock(reinterpret_cast<byte*>(&result), 4);\r\n\t\t\tprng.GenerateBlock(reinterpret_cast<byte*>(&result), 3);\r\n\t\t\tprng.GenerateBlock(reinterpret_cast<byte*>(&result), 2);\r\n\t\t\tprng.GenerateBlock(reinterpret_cast<byte*>(&result), 1);\r\n\t\t}\r\n\t\tcatch (const Exception&)\r\n\t\t{\r\n\t\t\tfail = true;\r\n\t\t}\r\n\r\n\t\tpass &= !fail;\r\n\t\tif (fail)\r\n\t\t\tstd::cout << \"FAILED:\";\r\n\t\telse\r\n\t\t\tstd::cout << \"passed:\";\r\n\t\tstd::cout << \"  GenerateWord32 and Crop\\n\";\t\r\n\t}\r\n\r\n#if !defined(NO_OS_DEPENDENCE)\r\n\tstd::cout << \"\\nTesting AutoSeeded RandomPool generator...\\n\\n\";\r\n\t{\r\n\t\tAutoSeededRandomPool prng;\r\n\t\tstatic const unsigned int ENTROPY_SIZE = 32;\r\n\r\n\t\tMeterFilter meter(new Redirector(TheBitBucket()));\r\n\t\tRandomNumberSource test(prng, 100000, true, new Deflator(new Redirector(meter)));\r\n\r\n\t\tfail = false;\r\n\t\tif (meter.GetTotalBytes() < 100000)\r\n\t\t\tfail = true;\r\n\r\n\t\tpass &= !fail;\r\n\t\tif (fail)\r\n\t\t\tstd::cout << \"FAILED:\";\r\n\t\telse\r\n\t\t\tstd::cout << \"passed:\";\r\n\t\tstd::cout << \"  100000 generated bytes compressed to \" << meter.GetTotalBytes() << \" bytes by DEFLATE\\n\";\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tfail = false;\r\n\t\t\tprng.DiscardBytes(100000);\r\n\t\t}\r\n\t\tcatch (const Exception&)\r\n\t\t{\r\n\t\t\tfail = true;\r\n\t\t}\r\n\r\n\t\tpass &= !fail;\r\n\t\tif (fail)\r\n\t\t\tstd::cout << \"FAILED:\";\r\n\t\telse\r\n\t\t\tstd::cout << \"passed:\";\r\n\t\tstd::cout << \"  discarded 10000 bytes\" << std::endl;\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tfail = false;\r\n\t\t\tif(prng.CanIncorporateEntropy())\r\n\t\t\t{\r\n\t\t\t\tSecByteBlock entropy(ENTROPY_SIZE);\r\n\t\t\t\tGlobalRNG().GenerateBlock(entropy, entropy.SizeInBytes());\r\n\r\n\t\t\t\tprng.IncorporateEntropy(entropy, entropy.SizeInBytes());\r\n\t\t\t\tprng.IncorporateEntropy(entropy, entropy.SizeInBytes());\r\n\t\t\t\tprng.IncorporateEntropy(entropy, entropy.SizeInBytes());\r\n\t\t\t\tprng.IncorporateEntropy(entropy, entropy.SizeInBytes());\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (const Exception& /*ex*/)\r\n\t\t{\r\n\t\t\tfail = true;\r\n\t\t}\r\n\r\n\t\tpass &= !fail;\r\n\t\tif (fail)\r\n\t\t\tstd::cout << \"FAILED:\";\r\n\t\telse\r\n\t\t\tstd::cout << \"passed:\";\r\n\t\tstd::cout << \"  IncorporateEntropy with \" << 4*ENTROPY_SIZE << \" bytes\\n\";\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// Miscellaneous for code coverage\r\n\t\t\tfail = false;\r\n\t\t\t(void)prng.AlgorithmName();  // \"unknown\"\r\n\t\t\tword32 result = prng.GenerateWord32();\r\n\t\t\tresult = prng.GenerateWord32((result & 0xff), 0xffffffff - (result & 0xff));\r\n\t\t\tprng.GenerateBlock(reinterpret_cast<byte*>(&result), 4);\r\n\t\t\tprng.GenerateBlock(reinterpret_cast<byte*>(&result), 3);\r\n\t\t\tprng.GenerateBlock(reinterpret_cast<byte*>(&result), 2);\r\n\t\t\tprng.GenerateBlock(reinterpret_cast<byte*>(&result), 1);\r\n\t\t}\r\n\t\tcatch (const Exception&)\r\n\t\t{\r\n\t\t\tfail = true;\r\n\t\t}\r\n\r\n\t\tpass &= !fail;\r\n\t\tif (fail)\r\n\t\t\tstd::cout << \"FAILED:\";\r\n\t\telse\r\n\t\t\tstd::cout << \"passed:\";\r\n\t\tstd::cout << \"  GenerateWord32 and Crop\\n\";\t\r\n\t}\r\n#endif\r\n\r\n\tstd::cout.flush();\r\n\treturn pass;\r\n}\r", "target": 1, "cwe": ["CWE-190", "CWE-125"], "project": "cryptopp", "commit_id": "07dbcc3d9644b18e05c1776db2a57fe04d780965", "hash": 233257459850675234714384171174434067585, "size": 181, "message": "Add Inflator::BadDistanceErr exception (Issue 414)\nThe improved validation and excpetion clears the Address Sanitizer and Undefined Behavior Sanitizer findings", "idx": 112}
{"func": "xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {\n    int ix;\n    unsigned char c;\n    int codepoint;\n\n    if ((utf == NULL) || (len <= 0))\n        return(0);\n\n    for (ix = 0; ix < len;) {      /* string is 0-terminated */\n        c = utf[ix];\n        if ((c & 0x80) == 0x00) {\t/* 1-byte code, starts with 10 */\n\t    if (c >= 0x20)\n\t\tix++;\n\t    else if ((c == 0xA) || (c == 0xD) || (c == 0x9))\n\t        ix++;\n\t    else\n\t        return(-ix);\n\t} else if ((c & 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */\n\t    if (ix + 2 > len) return(complete ? -ix : ix);\n\t    if ((utf[ix+1] & 0xc0 ) != 0x80)\n\t        return(-ix);\n\t    codepoint = (utf[ix] & 0x1f) << 6;\n\t    codepoint |= utf[ix+1] & 0x3f;\n\t    if (!xmlIsCharQ(codepoint))\n\t        return(-ix);\n\t    ix += 2;\n\t} else if ((c & 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */\n\t    if (ix + 3 > len) return(complete ? -ix : ix);\n\t    if (((utf[ix+1] & 0xc0) != 0x80) ||\n\t        ((utf[ix+2] & 0xc0) != 0x80))\n\t\t    return(-ix);\n\t    codepoint = (utf[ix] & 0xf) << 12;\n\t    codepoint |= (utf[ix+1] & 0x3f) << 6;\n\t    codepoint |= utf[ix+2] & 0x3f;\n\t    if (!xmlIsCharQ(codepoint))\n\t        return(-ix);\n\t    ix += 3;\n\t} else if ((c & 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */\n\t    if (ix + 4 > len) return(complete ? -ix : ix);\n\t    if (((utf[ix+1] & 0xc0) != 0x80) ||\n\t        ((utf[ix+2] & 0xc0) != 0x80) ||\n\t\t((utf[ix+3] & 0xc0) != 0x80))\n\t\t    return(-ix);\n\t    codepoint = (utf[ix] & 0x7) << 18;\n\t    codepoint |= (utf[ix+1] & 0x3f) << 12;\n\t    codepoint |= (utf[ix+2] & 0x3f) << 6;\n\t    codepoint |= utf[ix+3] & 0x3f;\n\t    if (!xmlIsCharQ(codepoint))\n\t        return(-ix);\n\t    ix += 4;\n\t} else\t\t\t\t/* unknown encoding */\n\t    return(-ix);\n      }\n      return(ix);\n}", "target": 0, "cwe": ["CWE-20"], "project": "libxml2", "commit_id": "bdd66182ef53fe1f7209ab6535fda56366bd7ac9", "hash": 241651439678394075386915360308383014616, "size": 55, "message": "Avoid building recursive entities\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=762100\n\nWhen we detect a recusive entity we should really not\nbuild the associated data, moreover if someone bypass\nlibxml2 fatal errors and still tries to serialize a broken\nentity make sure we don't risk to get ito a recursion\n\n* parser.c: xmlParserEntityCheck() don't build if entity loop\n  were found and remove the associated text content\n* tree.c: xmlStringGetNodeList() avoid a potential recursion", "idx": 113}
{"func": "static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tzend_op *opline = EX(opline);\n\tzval *str = &EX_T(opline->result.u.var).tmp_var;\n\n\tif (IS_TMP_VAR == IS_UNUSED) {\n\t\t/* Initialize for erealloc in add_string_to_string */\n\t\tZ_STRVAL_P(str) = NULL;\n\t\tZ_STRLEN_P(str) = 0;\n\t\tZ_TYPE_P(str) = IS_STRING;\n\n\t\tINIT_PZVAL(str);\n\t}\n\n\tadd_string_to_string(str, str, &opline->op2.u.constant);\n\n\t/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */\n\tZEND_VM_NEXT_OPCODE();\n}", "target": 0, "cwe": [], "project": "php-src", "commit_id": "ce96fd6b0761d98353761bf78d5bfb55291179fd", "hash": 157333281248077585362013780859480679406, "size": 19, "message": "- fix #39863, do not accept paths with NULL in them. See http://news.php.net/php.internals/50191, trunk will have the patch later (adding a macro and/or changing (some) APIs. Patch by Rasmus", "idx": 114}
{"func": "MagickExport Image *CloneImage(const Image *image,const size_t columns,\n  const size_t rows,const MagickBooleanType detach,ExceptionInfo *exception)\n{\n  Image\n    *clone_image;\n\n  double\n    scale;\n\n  size_t\n    length;\n\n  /*\n    Clone the image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"NegativeOrZeroImageSize\",\"`%s'\",image->filename);\n      return((Image *) NULL);\n    }\n  clone_image=(Image *) AcquireMagickMemory(sizeof(*clone_image));\n  if (clone_image == (Image *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(clone_image,0,sizeof(*clone_image));\n  clone_image->signature=MagickCoreSignature;\n  clone_image->storage_class=image->storage_class;\n  clone_image->number_channels=image->number_channels;\n  clone_image->number_meta_channels=image->number_meta_channels;\n  clone_image->metacontent_extent=image->metacontent_extent;\n  clone_image->colorspace=image->colorspace;\n  clone_image->read_mask=image->read_mask;\n  clone_image->write_mask=image->write_mask;\n  clone_image->alpha_trait=image->alpha_trait;\n  clone_image->columns=image->columns;\n  clone_image->rows=image->rows;\n  clone_image->dither=image->dither;\n  if (image->colormap != (PixelInfo *) NULL)\n    {\n      /*\n        Allocate and copy the image colormap.\n      */\n      clone_image->colors=image->colors;\n      length=(size_t) image->colors;\n      clone_image->colormap=(PixelInfo *) AcquireQuantumMemory(length,\n        sizeof(*clone_image->colormap));\n      if (clone_image->colormap == (PixelInfo *) NULL)\n        ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) CopyMagickMemory(clone_image->colormap,image->colormap,length*\n        sizeof(*clone_image->colormap));\n    }\n  clone_image->image_info=CloneImageInfo(image->image_info);\n  (void) CloneImageProfiles(clone_image,image);\n  (void) CloneImageProperties(clone_image,image);\n  (void) CloneImageArtifacts(clone_image,image);\n  GetTimerInfo(&clone_image->timer);\n  if (image->ascii85 != (void *) NULL)\n    Ascii85Initialize(clone_image);\n  clone_image->magick_columns=image->magick_columns;\n  clone_image->magick_rows=image->magick_rows;\n  clone_image->type=image->type;\n  clone_image->channel_mask=image->channel_mask;\n  clone_image->channel_map=ClonePixelChannelMap(image->channel_map);\n  (void) CopyMagickString(clone_image->magick_filename,image->magick_filename,\n    MagickPathExtent);\n  (void) CopyMagickString(clone_image->magick,image->magick,MagickPathExtent);\n  (void) CopyMagickString(clone_image->filename,image->filename,\n    MagickPathExtent);\n  clone_image->progress_monitor=image->progress_monitor;\n  clone_image->client_data=image->client_data;\n  clone_image->reference_count=1;\n  clone_image->next=image->next;\n  clone_image->previous=image->previous;\n  clone_image->list=NewImageList();\n  if (detach == MagickFalse)\n    clone_image->blob=ReferenceBlob(image->blob);\n  else\n    {\n      clone_image->next=NewImageList();\n      clone_image->previous=NewImageList();\n      clone_image->blob=CloneBlobInfo((BlobInfo *) NULL);\n    }\n  clone_image->ping=image->ping;\n  clone_image->debug=IsEventLogging();\n  clone_image->semaphore=AcquireSemaphoreInfo();\n  if ((columns == 0) || (rows == 0))\n    {\n      if (image->montage != (char *) NULL)\n        (void) CloneString(&clone_image->montage,image->montage);\n      if (image->directory != (char *) NULL)\n        (void) CloneString(&clone_image->directory,image->directory);\n      clone_image->cache=ReferencePixelCache(image->cache);\n      return(clone_image);\n    }\n  scale=1.0;\n  if (image->columns != 0)\n    scale=(double) columns/(double) image->columns;\n  clone_image->page.width=(size_t) floor(scale*image->page.width+0.5);\n  clone_image->page.x=(ssize_t) ceil(scale*image->page.x-0.5);\n  clone_image->tile_offset.x=(ssize_t) ceil(scale*image->tile_offset.x-0.5);\n  scale=1.0;\n  if (image->rows != 0)\n    scale=(double) rows/(double) image->rows;\n  clone_image->page.height=(size_t) floor(scale*image->page.height+0.5);\n  clone_image->page.y=(ssize_t) ceil(scale*image->page.y-0.5);\n  clone_image->tile_offset.y=(ssize_t) ceil(scale*image->tile_offset.y-0.5);\n  clone_image->columns=columns;\n  clone_image->rows=rows;\n  clone_image->cache=ClonePixelCache(image->cache);\n  return(clone_image);\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "ImageMagick", "commit_id": "aecd0ada163a4d6c769cec178955d5f3e9316f2f", "hash": 95947567649993432918972172756178503575, "size": 117, "message": "Set pixel cache to undefined if any resource limit is exceeded", "idx": 115}
{"func": "struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,\n\t\t\t  ext4_iget_flags flags, const char *function,\n\t\t\t  unsigned int line)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\tlong ret;\n\tloff_t size;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\tprojid_t i_projid;\n\n\tif ((!(flags & EXT4_IGET_SPECIAL) &&\n\t     (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)) ||\n\t    (ino < EXT4_ROOT_INO) ||\n\t    (ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))) {\n\t\tif (flags & EXT4_IGET_HANDLE)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t__ext4_error(sb, function, line, EFSCORRUPTED, 0,\n\t\t\t     \"inode #%lu: comm %s: iget: illegal inode #\",\n\t\t\t     ino, current->comm);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT4_I(inode);\n\tiloc.bh = NULL;\n\n\tret = __ext4_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\traw_inode = ext4_raw_inode(&iloc);\n\n\tif ((ino == EXT4_ROOT_INO) && (raw_inode->i_links_count == 0)) {\n\t\text4_error_inode(inode, function, line, 0,\n\t\t\t\t \"iget: root inode unallocated\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto bad_inode;\n\t}\n\n\tif ((flags & EXT4_IGET_HANDLE) &&\n\t    (raw_inode->i_links_count == 0) && (raw_inode->i_mode == 0)) {\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t\tEXT4_INODE_SIZE(inode->i_sb) ||\n\t\t    (ei->i_extra_isize & 3)) {\n\t\t\text4_error_inode(inode, function, line, 0,\n\t\t\t\t\t \"iget: bad extra_isize %u \"\n\t\t\t\t\t \"(inode size %u)\",\n\t\t\t\t\t ei->i_extra_isize,\n\t\t\t\t\t EXT4_INODE_SIZE(inode->i_sb));\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto bad_inode;\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\t/* Precompute checksum seed for inode metadata */\n\tif (ext4_has_metadata_csum(sb)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = raw_inode->i_generation;\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\tif (!ext4_inode_csum_verify(inode, raw_inode, ei) ||\n\t    ext4_simulate_fail(sb, EXT4_SIM_INODE_CRC)) {\n\t\text4_error_inode_err(inode, function, line, 0, EFSBADCRC,\n\t\t\t\t     \"iget: checksum invalid\");\n\t\tret = -EFSBADCRC;\n\t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (ext4_has_feature_project(sb) &&\n\t    EXT4_INODE_SIZE(sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw_inode, ei, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(raw_inode->i_projid);\n\telse\n\t\ti_projid = EXT4_DEF_PROJID;\n\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tei->i_projid = make_kprojid(&init_user_ns, i_projid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\n\text4_clear_state_flags(ei);\t/* Only relevant on 32-bit archs */\n\tei->i_inline_off = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif ((inode->i_mode == 0 ||\n\t\t     !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) &&\n\t\t    ino != EXT4_BOOT_LOADER_INO) {\n\t\t\t/* this inode is deleted */\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those.\n\t\t * OR it is the EXT4_BOOT_LOADER_INO which is\n\t\t * not initialized on a new filesystem. */\n\t}\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\text4_set_inode_flags(inode, true);\n\tinode->i_blocks = ext4_inode_blocks(raw_inode, ei);\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo);\n\tif (ext4_has_feature_64bit(sb))\n\t\tei->i_file_acl |=\n\t\t\t((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32;\n\tinode->i_size = ext4_isize(sb, raw_inode);\n\tif ((size = i_size_read(inode)) < 0) {\n\t\text4_error_inode(inode, function, line, 0,\n\t\t\t\t \"iget: bad i_size value: %lld\", size);\n\t\tret = -EFSCORRUPTED;\n\t\tgoto bad_inode;\n\t}\n\t/*\n\t * If dir_index is not enabled but there's dir with INDEX flag set,\n\t * we'd normally treat htree data as empty space. But with metadata\n\t * checksumming that corrupts checksums so forbid that.\n\t */\n\tif (!ext4_has_feature_dir_index(sb) && ext4_has_metadata_csum(sb) &&\n\t    ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) {\n\t\text4_error_inode(inode, function, line, 0,\n\t\t\t \"iget: Dir with htree data on filesystem without dir_index feature.\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto bad_inode;\n\t}\n\tei->i_disksize = inode->i_size;\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n#endif\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\tei->i_last_alloc_group = ~0;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tei->i_sync_tid = tid;\n\t\tei->i_datasync_tid = tid;\n\t}\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tBUILD_BUG_ON(sizeof(struct ext4_inode) & 3);\n\t\t\tei->i_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t    EXT4_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\tret = ext4_iget_extra_inode(inode, raw_inode, ei);\n\t\t\tif (ret)\n\t\t\t\tgoto bad_inode;\n\t\t}\n\t}\n\n\tEXT4_INODE_GET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_GET_XTIME(i_crtime, ei, raw_inode);\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\tu64 ivers = le32_to_cpu(raw_inode->i_disk_version);\n\n\t\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\tivers |=\n\t\t    (__u64)(le32_to_cpu(raw_inode->i_version_hi)) << 32;\n\t\t}\n\t\text4_inode_set_iversion_queried(inode, ivers);\n\t}\n\n\tret = 0;\n\tif (ei->i_file_acl &&\n\t    !ext4_data_block_valid(EXT4_SB(sb), ei->i_file_acl, 1)) {\n\t\text4_error_inode(inode, function, line, 0,\n\t\t\t\t \"iget: bad extended attribute block %llu\",\n\t\t\t\t ei->i_file_acl);\n\t\tret = -EFSCORRUPTED;\n\t\tgoto bad_inode;\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\t/* validate the block references in the inode */\n\t\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t   (S_ISLNK(inode->i_mode) &&\n\t\t    !ext4_inode_is_fast_symlink(inode))) {\n\t\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\t\t\tret = ext4_ext_check_inode(inode);\n\t\t\telse\n\t\t\t\tret = ext4_ind_check_inode(inode);\n\t\t}\n\t}\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext4_dir_inode_operations;\n\t\tinode->i_fop = &ext4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t/* VFS does not allow setting these so must be corruption */\n\t\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode)) {\n\t\t\text4_error_inode(inode, function, line, 0,\n\t\t\t\t\t \"iget: immutable or append flags \"\n\t\t\t\t\t \"not allowed on symlinks\");\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (IS_ENCRYPTED(inode)) {\n\t\t\tinode->i_op = &ext4_encrypted_symlink_inode_operations;\n\t\t\text4_set_aops(inode);\n\t\t} else if (ext4_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_link = (char *)ei->i_data;\n\t\t\tinode->i_op = &ext4_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext4_symlink_inode_operations;\n\t\t\text4_set_aops(inode);\n\t\t}\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t      S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &ext4_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t} else if (ino == EXT4_BOOT_LOADER_INO) {\n\t\tmake_bad_inode(inode);\n\t} else {\n\t\tret = -EFSCORRUPTED;\n\t\text4_error_inode(inode, function, line, 0,\n\t\t\t\t \"iget: bogus i_mode (%o)\", inode->i_mode);\n\t\tgoto bad_inode;\n\t}\n\tif (IS_CASEFOLDED(inode) && !ext4_has_feature_casefold(inode->i_sb))\n\t\text4_error_inode(inode, function, line, 0,\n\t\t\t\t \"casefold flag without casefold feature\");\n\tbrelse(iloc.bh);\n\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tbrelse(iloc.bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}", "target": 1, "cwe": ["CWE-703"], "project": "linux", "commit_id": "ce9f24cccdc019229b70a5c15e2b09ad9c0ab5d1", "hash": 13181212694435538987998578361204089009, "size": 310, "message": "ext4: check journal inode extents more carefully\n\nCurrently, system zones just track ranges of block, that are \"important\"\nfs metadata (bitmaps, group descriptors, journal blocks, etc.). This\nhowever complicates how extent tree (or indirect blocks) can be checked\nfor inodes that actually track such metadata - currently the journal\ninode but arguably we should be treating quota files or resize inode\nsimilarly. We cannot run __ext4_ext_check() on such metadata inodes when\nloading their extents as that would immediately trigger the validity\nchecks and so we just hack around that and special-case the journal\ninode. This however leads to a situation that a journal inode which has\nextent tree of depth at least one can have invalid extent tree that gets\nunnoticed until ext4_cache_extents() crashes.\n\nTo overcome this limitation, track inode number each system zone belongs\nto (0 is used for zones not belonging to any inode). We can then verify\ninode number matches the expected one when verifying extent tree and\nthus avoid the false errors. With this there's no need to to\nspecial-case journal inode during extent tree checking anymore so remove\nit.\n\nFixes: 0a944e8a6c66 (\"ext4: don't perform block validity checks on the journal inode\")\nReported-by: Wolfgang Frisch <wolfgang.frisch@suse.com>\nReviewed-by: Lukas Czerner <lczerner@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nLink: https://lore.kernel.org/r/20200728130437.7804-4-jack@suse.cz\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>", "idx": 116}
{"func": "dataiterator_skip_attribute(Dataiterator *di)\n{\n  if (di->state == di_nextsolvableattr)\n    di->state = di_nextsolvablekey;\n  else\n    di->state = di_nextkey;\n}", "target": 0, "cwe": ["CWE-125"], "project": "libsolv", "commit_id": "fdb9c9c03508990e4583046b590c30d958f272da", "hash": 99655414484461184654014227460340703376, "size": 7, "message": "repodata_schema2id: fix heap-buffer-overflow in memcmp\n\nWhen the length of last schema in data->schemadata is\nless than length of input schema, we got a read overflow\nin asan test.\n\nSigned-off-by: Zhipeng Xie <xiezhipeng1@huawei.com>", "idx": 117}
{"func": "spell_load_cb(char_u *fname, void *cookie)\n{\n    spelload_T\t*slp = (spelload_T *)cookie;\n    slang_T\t*slang;\n\n    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);\n    if (slang != NULL)\n    {\n\t// When a previously loaded file has NOBREAK also use it for the\n\t// \".add\" files.\n\tif (slp->sl_nobreak && slang->sl_add)\n\t    slang->sl_nobreak = TRUE;\n\telse if (slang->sl_nobreak)\n\t    slp->sl_nobreak = TRUE;\n\n\tslp->sl_slang = slang;\n    }\n}", "target": 0, "cwe": ["CWE-416"], "project": "vim", "commit_id": "2813f38e021c6e6581c0c88fcf107e41788bc835", "hash": 309134877870114567473944593891486874044, "size": 18, "message": "patch 8.2.5072: using uninitialized value and freed memory in spell command\n\nProblem:    Using uninitialized value and freed memory in spell command.\nSolution:   Initialize \"attr\".  Check for empty line early.", "idx": 118}
{"func": "CtPtr ProtocolV1::handle_connect_message_2() {\n  ldout(cct, 20) << __func__ << dendl;\n\n  ldout(cct, 20) << __func__ << \" accept got peer connect_seq \"\n                 << connect_msg.connect_seq << \" global_seq \"\n                 << connect_msg.global_seq << dendl;\n\n  connection->set_peer_type(connect_msg.host_type);\n  connection->policy = messenger->get_policy(connect_msg.host_type);\n\n  ldout(cct, 10) << __func__ << \" accept of host_type \" << connect_msg.host_type\n                 << \", policy.lossy=\" << connection->policy.lossy\n                 << \" policy.server=\" << connection->policy.server\n                 << \" policy.standby=\" << connection->policy.standby\n                 << \" policy.resetcheck=\" << connection->policy.resetcheck\n\t\t << \" features 0x\" << std::hex << (uint64_t)connect_msg.features\n\t\t << std::dec\n                 << dendl;\n\n  ceph_msg_connect_reply reply;\n  bufferlist authorizer_reply;\n\n  // FIPS zeroization audit 20191115: this memset is not security related.\n  memset(&reply, 0, sizeof(reply));\n  reply.protocol_version =\n      messenger->get_proto_version(connection->peer_type, false);\n\n  // mismatch?\n  ldout(cct, 10) << __func__ << \" accept my proto \" << reply.protocol_version\n                 << \", their proto \" << connect_msg.protocol_version << dendl;\n\n  if (connect_msg.protocol_version != reply.protocol_version) {\n    return send_connect_message_reply(CEPH_MSGR_TAG_BADPROTOVER, reply,\n                                      authorizer_reply);\n  }\n\n  // require signatures for cephx?\n  if (connect_msg.authorizer_protocol == CEPH_AUTH_CEPHX) {\n    if (connection->peer_type == CEPH_ENTITY_TYPE_OSD ||\n        connection->peer_type == CEPH_ENTITY_TYPE_MDS) {\n      if (cct->_conf->cephx_require_signatures ||\n          cct->_conf->cephx_cluster_require_signatures) {\n        ldout(cct, 10)\n            << __func__\n            << \" using cephx, requiring MSG_AUTH feature bit for cluster\"\n            << dendl;\n        connection->policy.features_required |= CEPH_FEATURE_MSG_AUTH;\n      }\n    } else {\n      if (cct->_conf->cephx_require_signatures ||\n          cct->_conf->cephx_service_require_signatures) {\n        ldout(cct, 10)\n            << __func__\n            << \" using cephx, requiring MSG_AUTH feature bit for service\"\n            << dendl;\n        connection->policy.features_required |= CEPH_FEATURE_MSG_AUTH;\n      }\n    }\n    if (cct->_conf->cephx_service_require_version >= 2) {\n      connection->policy.features_required |= CEPH_FEATURE_CEPHX_V2;\n    }\n  }\n\n  uint64_t feat_missing =\n      connection->policy.features_required & ~(uint64_t)connect_msg.features;\n  if (feat_missing) {\n    ldout(cct, 1) << __func__ << \" peer missing required features \" << std::hex\n                  << feat_missing << std::dec << dendl;\n    return send_connect_message_reply(CEPH_MSGR_TAG_FEATURES, reply,\n                                      authorizer_reply);\n  }\n\n  bufferlist auth_bl_copy = authorizer_buf;\n  connection->lock.unlock();\n  ldout(cct,10) << __func__ << \" authorizor_protocol \"\n\t\t<< connect_msg.authorizer_protocol\n\t\t<< \" len \" << auth_bl_copy.length()\n\t\t<< dendl;\n  bool authorizer_valid;\n  bool need_challenge = HAVE_FEATURE(connect_msg.features, CEPHX_V2);\n  bool had_challenge = (bool)authorizer_challenge;\n  if (!messenger->ms_deliver_verify_authorizer(\n          connection, connection->peer_type, connect_msg.authorizer_protocol,\n          auth_bl_copy, authorizer_reply, authorizer_valid, session_key,\n\t  nullptr /* connection_secret */,\n          need_challenge ? &authorizer_challenge : nullptr) ||\n      !authorizer_valid) {\n    connection->lock.lock();\n    if (state != ACCEPTING_WAIT_CONNECT_MSG_AUTH) {\n      ldout(cct, 1) << __func__\n\t\t    << \" state changed while accept, it must be mark_down\"\n\t\t    << dendl;\n      ceph_assert(state == CLOSED);\n      return _fault();\n    }\n\n    if (need_challenge && !had_challenge && authorizer_challenge) {\n      ldout(cct, 10) << __func__ << \": challenging authorizer\" << dendl;\n      ceph_assert(authorizer_reply.length());\n      return send_connect_message_reply(CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER,\n                                        reply, authorizer_reply);\n    } else {\n      ldout(cct, 0) << __func__ << \": got bad authorizer, auth_reply_len=\"\n                    << authorizer_reply.length() << dendl;\n      session_security.reset();\n      return send_connect_message_reply(CEPH_MSGR_TAG_BADAUTHORIZER, reply,\n                                        authorizer_reply);\n    }\n  }\n\n  // We've verified the authorizer for this AsyncConnection, so set up the\n  // session security structure.  PLR\n  ldout(cct, 10) << __func__ << \" accept setting up session_security.\" << dendl;\n\n  // existing?\n  AsyncConnectionRef existing = messenger->lookup_conn(*connection->peer_addrs);\n\n  connection->inject_delay();\n\n  connection->lock.lock();\n  if (state != ACCEPTING_WAIT_CONNECT_MSG_AUTH) {\n    ldout(cct, 1) << __func__\n                  << \" state changed while accept, it must be mark_down\"\n                  << dendl;\n    ceph_assert(state == CLOSED);\n    return _fault();\n  }\n\n  if (existing == connection) {\n    existing = nullptr;\n  }\n  if (existing && existing->protocol->proto_type != 1) {\n    ldout(cct,1) << __func__ << \" existing \" << existing << \" proto \"\n\t\t << existing->protocol.get() << \" version is \"\n\t\t << existing->protocol->proto_type << \", marking down\" << dendl;\n    existing->mark_down();\n    existing = nullptr;\n  }\n\n  if (existing) {\n    // There is no possible that existing connection will acquire this\n    // connection's lock\n    existing->lock.lock();  // skip lockdep check (we are locking a second\n                            // AsyncConnection here)\n\n    ldout(cct,10) << __func__ << \" existing=\" << existing << \" exproto=\"\n\t\t  << existing->protocol.get() << dendl;\n    ProtocolV1 *exproto = dynamic_cast<ProtocolV1 *>(existing->protocol.get());\n    ceph_assert(exproto);\n    ceph_assert(exproto->proto_type == 1);\n\n    if (exproto->state == CLOSED) {\n      ldout(cct, 1) << __func__ << \" existing \" << existing\n\t\t    << \" already closed.\" << dendl;\n      existing->lock.unlock();\n      existing = nullptr;\n\n      return open(reply, authorizer_reply);\n    }\n\n    if (exproto->replacing) {\n      ldout(cct, 1) << __func__\n                    << \" existing racing replace happened while replacing.\"\n                    << \" existing_state=\"\n                    << connection->get_state_name(existing->state) << dendl;\n      reply.global_seq = exproto->peer_global_seq;\n      existing->lock.unlock();\n      return send_connect_message_reply(CEPH_MSGR_TAG_RETRY_GLOBAL, reply,\n                                        authorizer_reply);\n    }\n\n    if (connect_msg.global_seq < exproto->peer_global_seq) {\n      ldout(cct, 10) << __func__ << \" accept existing \" << existing << \".gseq \"\n                     << exproto->peer_global_seq << \" > \"\n                     << connect_msg.global_seq << \", RETRY_GLOBAL\" << dendl;\n      reply.global_seq = exproto->peer_global_seq;  // so we can send it below..\n      existing->lock.unlock();\n      return send_connect_message_reply(CEPH_MSGR_TAG_RETRY_GLOBAL, reply,\n                                        authorizer_reply);\n    } else {\n      ldout(cct, 10) << __func__ << \" accept existing \" << existing << \".gseq \"\n                     << exproto->peer_global_seq\n                     << \" <= \" << connect_msg.global_seq << \", looks ok\"\n                     << dendl;\n    }\n\n    if (existing->policy.lossy) {\n      ldout(cct, 0)\n          << __func__\n          << \" accept replacing existing (lossy) channel (new one lossy=\"\n          << connection->policy.lossy << \")\" << dendl;\n      exproto->session_reset();\n      return replace(existing, reply, authorizer_reply);\n    }\n\n    ldout(cct, 1) << __func__ << \" accept connect_seq \"\n                  << connect_msg.connect_seq\n                  << \" vs existing csq=\" << exproto->connect_seq\n                  << \" existing_state=\"\n                  << connection->get_state_name(existing->state) << dendl;\n\n    if (connect_msg.connect_seq == 0 && exproto->connect_seq > 0) {\n      ldout(cct, 0)\n          << __func__\n          << \" accept peer reset, then tried to connect to us, replacing\"\n          << dendl;\n      // this is a hard reset from peer\n      is_reset_from_peer = true;\n      if (connection->policy.resetcheck) {\n        exproto->session_reset();  // this resets out_queue, msg_ and\n                                   // connect_seq #'s\n      }\n      return replace(existing, reply, authorizer_reply);\n    }\n\n    if (connect_msg.connect_seq < exproto->connect_seq) {\n      // old attempt, or we sent READY but they didn't get it.\n      ldout(cct, 10) << __func__ << \" accept existing \" << existing << \".cseq \"\n                     << exproto->connect_seq << \" > \" << connect_msg.connect_seq\n                     << \", RETRY_SESSION\" << dendl;\n      reply.connect_seq = exproto->connect_seq + 1;\n      existing->lock.unlock();\n      return send_connect_message_reply(CEPH_MSGR_TAG_RETRY_SESSION, reply,\n                                        authorizer_reply);\n    }\n\n    if (connect_msg.connect_seq == exproto->connect_seq) {\n      // if the existing connection successfully opened, and/or\n      // subsequently went to standby, then the peer should bump\n      // their connect_seq and retry: this is not a connection race\n      // we need to resolve here.\n      if (exproto->state == OPENED || exproto->state == STANDBY) {\n        ldout(cct, 10) << __func__ << \" accept connection race, existing \"\n                       << existing << \".cseq \" << exproto->connect_seq\n                       << \" == \" << connect_msg.connect_seq\n                       << \", OPEN|STANDBY, RETRY_SESSION \" << dendl;\n        // if connect_seq both zero, dont stuck into dead lock. it's ok to\n        // replace\n        if (connection->policy.resetcheck && exproto->connect_seq == 0) {\n          return replace(existing, reply, authorizer_reply);\n        }\n\n        reply.connect_seq = exproto->connect_seq + 1;\n        existing->lock.unlock();\n        return send_connect_message_reply(CEPH_MSGR_TAG_RETRY_SESSION, reply,\n                                          authorizer_reply);\n      }\n\n      // connection race?\n      if (connection->peer_addrs->legacy_addr() < messenger->get_myaddr_legacy() ||\n          existing->policy.server) {\n        // incoming wins\n        ldout(cct, 10) << __func__ << \" accept connection race, existing \"\n                       << existing << \".cseq \" << exproto->connect_seq\n                       << \" == \" << connect_msg.connect_seq\n                       << \", or we are server, replacing my attempt\" << dendl;\n        return replace(existing, reply, authorizer_reply);\n      } else {\n        // our existing outgoing wins\n        ldout(messenger->cct, 10)\n            << __func__ << \" accept connection race, existing \" << existing\n            << \".cseq \" << exproto->connect_seq\n            << \" == \" << connect_msg.connect_seq << \", sending WAIT\" << dendl;\n        ceph_assert(connection->peer_addrs->legacy_addr() >\n                    messenger->get_myaddr_legacy());\n        existing->lock.unlock();\n\t// make sure we follow through with opening the existing\n\t// connection (if it isn't yet open) since we know the peer\n\t// has something to send to us.\n\texisting->send_keepalive();\n        return send_connect_message_reply(CEPH_MSGR_TAG_WAIT, reply,\n                                          authorizer_reply);\n      }\n    }\n\n    ceph_assert(connect_msg.connect_seq > exproto->connect_seq);\n    ceph_assert(connect_msg.global_seq >= exproto->peer_global_seq);\n    if (connection->policy.resetcheck &&  // RESETSESSION only used by servers;\n                                          // peers do not reset each other\n        exproto->connect_seq == 0) {\n      ldout(cct, 0) << __func__ << \" accept we reset (peer sent cseq \"\n                    << connect_msg.connect_seq << \", \" << existing\n                    << \".cseq = \" << exproto->connect_seq\n                    << \"), sending RESETSESSION \" << dendl;\n      existing->lock.unlock();\n      return send_connect_message_reply(CEPH_MSGR_TAG_RESETSESSION, reply,\n                                        authorizer_reply);\n    }\n\n    // reconnect\n    ldout(cct, 10) << __func__ << \" accept peer sent cseq \"\n                   << connect_msg.connect_seq << \" > \" << exproto->connect_seq\n                   << dendl;\n    return replace(existing, reply, authorizer_reply);\n  }  // existing\n  else if (!replacing && connect_msg.connect_seq > 0) {\n    // we reset, and they are opening a new session\n    ldout(cct, 0) << __func__ << \" accept we reset (peer sent cseq \"\n                  << connect_msg.connect_seq << \"), sending RESETSESSION\"\n                  << dendl;\n    return send_connect_message_reply(CEPH_MSGR_TAG_RESETSESSION, reply,\n                                      authorizer_reply);\n  } else {\n    // new session\n    ldout(cct, 10) << __func__ << \" accept new session\" << dendl;\n    existing = nullptr;\n    return open(reply, authorizer_reply);\n  }\n}", "target": 1, "cwe": ["CWE-294"], "project": "ceph", "commit_id": "bb5d3d58bfcae96d2e5f796eaa74fc0987f79e77", "hash": 64592637716607987736812011900234057799, "size": 309, "message": "msg/async/ProtocolV1: resurrect \"include MGR as service when applying cephx settings\"\n\nThis was added in commit 0ec7d6bbc4af (\"msg/async,simple: include MGR\nas service when applying cephx settings\") and inadvertently dropped in\ncommit e6f043f7d2dc (\"msgr/async: huge refactoring of protocol V1\").\nAs a result, mgr daemons are miscategorized as clients when enforcing\ncephx_*require_signatures options.\n\nSigned-off-by: Ilya Dryomov <idryomov@gmail.com>\n(cherry picked from commit 949e2e595eda553aa68f697cee1dcfff3c09cf3f)", "idx": 119}
{"func": "int dhcp6_option_parse_domainname(const uint8_t *optval, uint16_t optlen, char ***str_arr) {\n        size_t pos = 0, idx = 0;\n        _cleanup_strv_free_ char **names = NULL;\n        int r;\n\n        assert_return(optlen > 1, -ENODATA);\n        assert_return(optval[optlen - 1] == '\\0', -EINVAL);\n\n        while (pos < optlen) {\n                _cleanup_free_ char *ret = NULL;\n                size_t n = 0, allocated = 0;\n                bool first = true;\n\n                for (;;) {\n                        const char *label;\n                        uint8_t c;\n\n                        c = optval[pos++];\n\n                        if (c == 0)\n                                /* End of name */\n                                break;\n                        if (c > 63)\n                                return -EBADMSG;\n\n                        /* Literal label */\n                        label = (const char *)&optval[pos];\n                        pos += c;\n                        if (pos >= optlen)\n                                return -EMSGSIZE;\n\n                        if (!GREEDY_REALLOC(ret, allocated, n + !first + DNS_LABEL_ESCAPED_MAX))\n                                return -ENOMEM;\n\n                        if (first)\n                                first = false;\n                        else\n                                ret[n++] = '.';\n\n                        r = dns_label_escape(label, c, ret + n, DNS_LABEL_ESCAPED_MAX);\n                        if (r < 0)\n                                return r;\n\n                        n += r;\n                }\n\n                if (n == 0)\n                        continue;\n\n                if (!GREEDY_REALLOC(ret, allocated, n + 1))\n                        return -ENOMEM;\n\n                ret[n] = 0;\n\n                r = strv_extend(&names, ret);\n                if (r < 0)\n                        return r;\n\n                idx++;\n        }\n\n        *str_arr = TAKE_PTR(names);\n\n        return idx;\n}", "target": 0, "cwe": ["CWE-120"], "project": "systemd", "commit_id": "4dac5eaba4e419b29c97da38a8b1f82336c2c892", "hash": 29984663630218004574808287447436944570, "size": 65, "message": "dhcp6: make sure we have enough space for the DHCP6 option header\n\nFixes a vulnerability originally discovered by Felix Wilhelm from\nGoogle.\n\nCVE-2018-15688\nLP: #1795921\nhttps://bugzilla.redhat.com/show_bug.cgi?id=1639067", "idx": 120}
{"func": "int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  const void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);\n\treturn 1;\n}", "target": 0, "cwe": ["CWE-476"], "project": "linux-2.6", "commit_id": "59839dfff5eabca01cc4e20b45797a60a80af8cb", "hash": 260921565497647764239939459860974612458, "size": 11, "message": "KVM: x86: check for cr3 validity in ioctl_set_sregs\n\nMatt T. Yourst notes that kvm_arch_vcpu_ioctl_set_sregs lacks validity\nchecking for the new cr3 value:\n\n\"Userspace callers of KVM_SET_SREGS can pass a bogus value of cr3 to\nthe kernel. This will trigger a NULL pointer access in gfn_to_rmap()\nwhen userspace next tries to call KVM_RUN on the affected VCPU and kvm\nattempts to activate the new non-existent page table root.\n\nThis happens since kvm only validates that cr3 points to a valid guest\nphysical memory page when code *inside* the guest sets cr3. However, kvm\ncurrently trusts the userspace caller (e.g. QEMU) on the host machine to\nalways supply a valid page table root, rather than properly validating\nit along with the rest of the reloaded guest state.\"\n\nhttp://sourceforge.net/tracker/?func=detail&atid=893831&aid=2687641&group_id=180599\n\nCheck for a valid cr3 address in kvm_arch_vcpu_ioctl_set_sregs, triple\nfault in case of failure.\n\nCc: stable@kernel.org\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>", "idx": 121}
{"func": "char *FLTGetIsLikeComparisonCommonExpression(FilterEncodingNode *psFilterNode)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char szTmp[256];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  int  bCaseInsensitive = 0;\n  FEPropertyIsLike* propIsLike;\n\n  int nLength=0, i=0, iTmp=0;\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode || !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 || !pszSingle || strlen(pszSingle) == 0 || !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Use operand with regular expressions.                           */\n  /* -------------------------------------------------------------------- */\n  szBuffer[0] = '\\0';\n  sprintf(szTmp, \"%s\", \"(\\\"[\");\n  szTmp[4] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  /* #3521 */\n  if (bCaseInsensitive == 1)\n    sprintf(szTmp, \"%s\", \"]\\\" ~* \\\"\");\n  else\n    sprintf(szTmp, \"%s\", \"]\\\" ~ \\\"\");\n  szTmp[7] = '\\0';\n  strlcat(szBuffer, szTmp, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n\n  iTmp =0;\n  if (nLength > 0 && pszValue[0] != pszWild[0] && pszValue[0] != pszSingle[0] && pszValue[0] != pszEscape[0]) {\n    szTmp[iTmp]= '^';\n    iTmp++;\n  }\n  for (i=0; i<nLength; i++) {\n    if (pszValue[i] != pszWild[0] && pszValue[i] != pszSingle[0] && pszValue[i] != pszEscape[0]) {\n      szTmp[iTmp] = pszValue[i];\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszSingle[0]) {\n      szTmp[iTmp] = '.';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszEscape[0]) {\n      szTmp[iTmp] = '\\\\';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszWild[0]) {\n      szTmp[iTmp++] = '.';\n      szTmp[iTmp++] = '*';\n      szTmp[iTmp] = '\\0';\n    }\n  }\n  szTmp[iTmp] = '\"';\n  szTmp[++iTmp] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n  return msStrdup(szBuffer);\n}", "target": 1, "cwe": ["CWE-200", "CWE-119"], "project": "mapserver", "commit_id": "e52a436c0e1c5e9f7ef13428dba83194a800f4df", "hash": 134883724867065190360949092579421068023, "size": 83, "message": "security fix (patch by EvenR)", "idx": 122}
{"func": "ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_mail_core_srv_conf_t *prev = parent;\n    ngx_mail_core_srv_conf_t *conf = child;\n\n    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);\n    ngx_conf_merge_msec_value(conf->resolver_timeout, prev->resolver_timeout,\n                              30000);\n\n\n    ngx_conf_merge_str_value(conf->server_name, prev->server_name, \"\");\n\n    if (conf->server_name.len == 0) {\n        conf->server_name = cf->cycle->hostname;\n    }\n\n    if (conf->protocol == NULL) {\n        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                      \"unknown mail protocol for server in %s:%ui\",\n                      conf->file_name, conf->line);\n        return NGX_CONF_ERROR;\n    }\n\n    if (conf->error_log == NULL) {\n        if (prev->error_log) {\n            conf->error_log = prev->error_log;\n        } else {\n            conf->error_log = &cf->cycle->new_log;\n        }\n    }\n\n    ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);\n\n    return NGX_CONF_OK;\n}", "target": 1, "cwe": ["CWE-284", "CWE-295"], "project": "nginx", "commit_id": "173f16f736c10eae46cd15dd861b04b82d91a37a", "hash": 76251872673176010834867151694023295082, "size": 35, "message": "Mail: max_errors directive.\n\nSimilarly to smtpd_hard_error_limit in Postfix and smtp_max_unknown_commands\nin Exim, specifies the number of errors after which the connection is closed.", "idx": 123}
{"func": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime,\n\t\t\tSEED_COMPAT_LEVEL seedCompatLevel  // IN: compatibility level; libtpms added\n\t\t\t)\n{\n    switch (seedCompatLevel) {\n    case SEED_COMPAT_LEVEL_ORIGINAL:\n        RsaAdjustPrimeCandidate_PreRev155(prime);\n        break;\n    /* case SEED_COMPAT_LEVEL_LAST: */\n    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:\n        RsaAdjustPrimeCandidate_New(prime);\n        break;\n    default:\n        FAIL(FATAL_ERROR_INTERNAL);\n    }\n}", "target": 1, "cwe": ["CWE-331"], "project": "libtpms", "commit_id": "c1f7bf55099fcd427715aa65e130475c6e836a6b", "hash": 137464920479412069441467954600140437673, "size": 17, "message": "tpm2: Activate SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX\n\nSigned-off-by: Stefan Berger <stefanb@linux.ibm.com>", "idx": 124}
{"func": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}", "target": 1, "cwe": ["CWE-476"], "project": "miniupnp", "commit_id": "cb8a02af7a5677cf608e86d57ab04241cf34e24f", "hash": 312187754280246049224099514253681897886, "size": 6, "message": "pcpserver.c: copyIPv6IfDifferent() check for NULL src argument", "idx": 125}
{"func": "static int on_osc(const char *command, size_t cmdlen, void *user)\n{\n  VTermState *state = user;\n\n  if(cmdlen < 2)\n    return 0;\n\n  if(strneq(command, \"0;\", 2)) {\n    settermprop_string(state, VTERM_PROP_ICONNAME, command + 2, cmdlen - 2);\n    settermprop_string(state, VTERM_PROP_TITLE, command + 2, cmdlen - 2);\n    return 1;\n  }\n  else if(strneq(command, \"1;\", 2)) {\n    settermprop_string(state, VTERM_PROP_ICONNAME, command + 2, cmdlen - 2);\n    return 1;\n  }\n  else if(strneq(command, \"2;\", 2)) {\n    settermprop_string(state, VTERM_PROP_TITLE, command + 2, cmdlen - 2);\n    return 1;\n  }\n  else if(strneq(command, \"10;\", 3)) {\n    /* request foreground color: <Esc>]10;?<0x07> */\n    int red = state->default_fg.red;\n    int blue = state->default_fg.blue;\n    int green = state->default_fg.green;\n    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, \"10;rgb:%02x%02x/%02x%02x/%02x%02x\\x07\", red, red, green, green, blue, blue);\n    return 1;\n  }\n  else if(strneq(command, \"11;\", 3)) {\n    /* request background color: <Esc>]11;?<0x07> */\n    int red = state->default_bg.red;\n    int blue = state->default_bg.blue;\n    int green = state->default_bg.green;\n    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, \"11;rgb:%02x%02x/%02x%02x/%02x%02x\\x07\", red, red, green, green, blue, blue);\n    return 1;\n  }\n  else if(strneq(command, \"12;\", 3)) {\n    settermprop_string(state, VTERM_PROP_CURSORCOLOR, command + 3, cmdlen - 3);\n    return 1;\n  }\n  else if(state->fallbacks && state->fallbacks->osc)\n    if((*state->fallbacks->osc)(command, cmdlen, state->fbdata))\n      return 1;\n\n  return 0;\n}", "target": 0, "cwe": ["CWE-476"], "project": "vim", "commit_id": "cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8", "hash": 15594523588752989448933823218808835879, "size": 46, "message": "patch 8.1.0633: crash when out of memory while opening a terminal window\n\nProblem:    Crash when out of memory while opening a terminal window.\nSolution:   Handle out-of-memory more gracefully.", "idx": 126}
{"func": "static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}", "target": 0, "cwe": ["CWE-476"], "project": "jasper", "commit_id": "69a1439a5381e42b06ec6a06ed2675eb793babee", "hash": 88610995342852336453230189204742201733, "size": 27, "message": "The member (pi) in tiles was not properly initialized.\nThis is now corrected.\nAlso, each tile is now only cleaned up once.", "idx": 127}
{"func": "apply_autocmds_group(\n    event_T\tevent,\n    char_u\t*fname,\t     // NULL or empty means use actual file name\n    char_u\t*fname_io,   // fname to use for <afile> on cmdline, NULL means\n\t\t\t     // use fname\n    int\t\tforce,\t     // when TRUE, ignore autocmd_busy\n    int\t\tgroup,\t     // group ID, or AUGROUP_ALL\n    buf_T\t*buf,\t     // buffer for <abuf>\n    exarg_T\t*eap UNUSED) // command arguments\n{\n    char_u\t*sfname = NULL;\t// short file name\n    char_u\t*tail;\n    int\t\tsave_changed;\n    buf_T\t*old_curbuf;\n    int\t\tretval = FALSE;\n    char_u\t*save_autocmd_fname;\n    int\t\tsave_autocmd_fname_full;\n    int\t\tsave_autocmd_bufnr;\n    char_u\t*save_autocmd_match;\n    int\t\tsave_autocmd_busy;\n    int\t\tsave_autocmd_nested;\n    static int\tnesting = 0;\n    AutoPatCmd_T patcmd;\n    AutoPat\t*ap;\n    sctx_T\tsave_current_sctx;\n#ifdef FEAT_EVAL\n    funccal_entry_T funccal_entry;\n    char_u\t*save_cmdarg;\n    long\tsave_cmdbang;\n#endif\n    static int\tfilechangeshell_busy = FALSE;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n    int\t\tdid_save_redobuff = FALSE;\n    save_redo_T\tsave_redo;\n    int\t\tsave_KeyTyped = KeyTyped;\n    int\t\tsave_did_emsg;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * Quickly return if there are no autocommands for this event or\n     * autocommands are blocked.\n     */\n    if (event == NUM_EVENTS || first_autopat[(int)event] == NULL\n\t    || autocmd_blocked > 0)\n\tgoto BYPASS_AU;\n\n    /*\n     * When autocommands are busy, new autocommands are only executed when\n     * explicitly enabled with the \"nested\" flag.\n     */\n    if (autocmd_busy && !(force || autocmd_nested))\n\tgoto BYPASS_AU;\n\n#ifdef FEAT_EVAL\n    /*\n     * Quickly return when immediately aborting on error, or when an interrupt\n     * occurred or an exception was thrown but not caught.\n     */\n    if (aborting())\n\tgoto BYPASS_AU;\n#endif\n\n    /*\n     * FileChangedShell never nests, because it can create an endless loop.\n     */\n    if (filechangeshell_busy && (event == EVENT_FILECHANGEDSHELL\n\t\t\t\t      || event == EVENT_FILECHANGEDSHELLPOST))\n\tgoto BYPASS_AU;\n\n    /*\n     * Ignore events in 'eventignore'.\n     */\n    if (event_ignored(event))\n\tgoto BYPASS_AU;\n\n    /*\n     * Allow nesting of autocommands, but restrict the depth, because it's\n     * possible to create an endless loop.\n     */\n    if (nesting == 10)\n    {\n\temsg(_(e_autocommand_nesting_too_deep));\n\tgoto BYPASS_AU;\n    }\n\n    /*\n     * Check if these autocommands are disabled.  Used when doing \":all\" or\n     * \":ball\".\n     */\n    if (       (autocmd_no_enter\n\t\t&& (event == EVENT_WINENTER || event == EVENT_BUFENTER))\n\t    || (autocmd_no_leave\n\t\t&& (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))\n\tgoto BYPASS_AU;\n\n    /*\n     * Save the autocmd_* variables and info about the current buffer.\n     */\n    save_autocmd_fname = autocmd_fname;\n    save_autocmd_fname_full = autocmd_fname_full;\n    save_autocmd_bufnr = autocmd_bufnr;\n    save_autocmd_match = autocmd_match;\n    save_autocmd_busy = autocmd_busy;\n    save_autocmd_nested = autocmd_nested;\n    save_changed = curbuf->b_changed;\n    old_curbuf = curbuf;\n\n    /*\n     * Set the file name to be used for <afile>.\n     * Make a copy to avoid that changing a buffer name or directory makes it\n     * invalid.\n     */\n    if (fname_io == NULL)\n    {\n\tif (event == EVENT_COLORSCHEME || event == EVENT_COLORSCHEMEPRE\n\t\t\t\t\t\t   || event == EVENT_OPTIONSET\n\t\t\t\t\t\t   || event == EVENT_MODECHANGED)\n\t    autocmd_fname = NULL;\n\telse if (fname != NULL && !ends_excmd(*fname))\n\t    autocmd_fname = fname;\n\telse if (buf != NULL)\n\t    autocmd_fname = buf->b_ffname;\n\telse\n\t    autocmd_fname = NULL;\n    }\n    else\n\tautocmd_fname = fname_io;\n    if (autocmd_fname != NULL)\n\tautocmd_fname = vim_strsave(autocmd_fname);\n    autocmd_fname_full = FALSE; // call FullName_save() later\n\n    /*\n     * Set the buffer number to be used for <abuf>.\n     */\n    if (buf == NULL)\n\tautocmd_bufnr = 0;\n    else\n\tautocmd_bufnr = buf->b_fnum;\n\n    /*\n     * When the file name is NULL or empty, use the file name of buffer \"buf\".\n     * Always use the full path of the file name to match with, in case\n     * \"allow_dirs\" is set.\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tif (buf == NULL)\n\t    fname = NULL;\n\telse\n\t{\n#ifdef FEAT_SYN_HL\n\t    if (event == EVENT_SYNTAX)\n\t\tfname = buf->b_p_syn;\n\t    else\n#endif\n\t\tif (event == EVENT_FILETYPE)\n\t\t    fname = buf->b_p_ft;\n\t\telse\n\t\t{\n\t\t    if (buf->b_sfname != NULL)\n\t\t\tsfname = vim_strsave(buf->b_sfname);\n\t\t    fname = buf->b_ffname;\n\t\t}\n\t}\n\tif (fname == NULL)\n\t    fname = (char_u *)\"\";\n\tfname = vim_strsave(fname);\t// make a copy, so we can change it\n    }\n    else\n    {\n\tsfname = vim_strsave(fname);\n\t// Don't try expanding FileType, Syntax, FuncUndefined, WindowID,\n\t// ColorScheme, QuickFixCmd*, DirChanged and similar.\n\tif (event == EVENT_FILETYPE\n\t\t|| event == EVENT_SYNTAX\n\t\t|| event == EVENT_CMDLINECHANGED\n\t\t|| event == EVENT_CMDLINEENTER\n\t\t|| event == EVENT_CMDLINELEAVE\n\t\t|| event == EVENT_CMDWINENTER\n\t\t|| event == EVENT_CMDWINLEAVE\n\t\t|| event == EVENT_CMDUNDEFINED\n\t\t|| event == EVENT_FUNCUNDEFINED\n\t\t|| event == EVENT_REMOTEREPLY\n\t\t|| event == EVENT_SPELLFILEMISSING\n\t\t|| event == EVENT_QUICKFIXCMDPRE\n\t\t|| event == EVENT_COLORSCHEME\n\t\t|| event == EVENT_COLORSCHEMEPRE\n\t\t|| event == EVENT_OPTIONSET\n\t\t|| event == EVENT_QUICKFIXCMDPOST\n\t\t|| event == EVENT_DIRCHANGED\n\t\t|| event == EVENT_DIRCHANGEDPRE\n\t\t|| event == EVENT_MODECHANGED\n\t\t|| event == EVENT_USER\n\t\t|| event == EVENT_WINCLOSED\n\t\t|| event == EVENT_WINSCROLLED)\n\t{\n\t    fname = vim_strsave(fname);\n\t    autocmd_fname_full = TRUE; // don't expand it later\n\t}\n\telse\n\t    fname = FullName_save(fname, FALSE);\n    }\n    if (fname == NULL)\t    // out of memory\n    {\n\tvim_free(sfname);\n\tretval = FALSE;\n\tgoto BYPASS_AU;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n#ifdef VMS\n    // remove version for correct match\n    if (sfname != NULL)\n\tvms_remove_version(sfname);\n    vms_remove_version(fname);\n#endif\n\n    /*\n     * Set the name to be used for <amatch>.\n     */\n    autocmd_match = fname;\n\n\n    // Don't redraw while doing autocommands.\n    ++RedrawingDisabled;\n\n    // name and lnum are filled in later\n    estack_push(ETYPE_AUCMD, NULL, 0);\n    ESTACK_CHECK_SETUP\n\n    save_current_sctx = current_sctx;\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time); // doesn't count for the caller itself\n# endif\n\n    // Don't use local function variables, if called from a function.\n    save_funccal(&funccal_entry);\n#endif\n\n    /*\n     * When starting to execute autocommands, save the search patterns.\n     */\n    if (!autocmd_busy)\n    {\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redobuff = TRUE;\n\t}\n\tdid_filetype = keep_filetype;\n    }\n\n    /*\n     * Note that we are applying autocmds.  Some commands need to know.\n     */\n    autocmd_busy = TRUE;\n    filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);\n    ++nesting;\t\t// see matching decrement below\n\n    // Remember that FileType was triggered.  Used for did_filetype().\n    if (event == EVENT_FILETYPE)\n\tdid_filetype = TRUE;\n\n    tail = gettail(fname);\n\n    // Find first autocommand that matches\n    CLEAR_FIELD(patcmd);\n    patcmd.curpat = first_autopat[(int)event];\n    patcmd.group = group;\n    patcmd.fname = fname;\n    patcmd.sfname = sfname;\n    patcmd.tail = tail;\n    patcmd.event = event;\n    patcmd.arg_bufnr = autocmd_bufnr;\n    auto_next_pat(&patcmd, FALSE);\n\n    // found one, start executing the autocommands\n    if (patcmd.curpat != NULL)\n    {\n\t// add to active_apc_list\n\tpatcmd.next = active_apc_list;\n\tactive_apc_list = &patcmd;\n\n#ifdef FEAT_EVAL\n\t// set v:cmdarg (only when there is a matching pattern)\n\tsave_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);\n\tif (eap != NULL)\n\t{\n\t    save_cmdarg = set_cmdarg(eap, NULL);\n\t    set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);\n\t}\n\telse\n\t    save_cmdarg = NULL;\t// avoid gcc warning\n#endif\n\tretval = TRUE;\n\t// mark the last pattern, to avoid an endless loop when more patterns\n\t// are added when executing autocommands\n\tfor (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)\n\t    ap->last = FALSE;\n\tap->last = TRUE;\n\n\tif (nesting == 1)\n\t    // make sure cursor and topline are valid\n\t    check_lnums(TRUE);\n\n\tsave_did_emsg = did_emsg;\n\n\tdo_cmdline(NULL, getnextac, (void *)&patcmd,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n\tdid_emsg += save_did_emsg;\n\n\tif (nesting == 1)\n\t    // restore cursor and topline, unless they were changed\n\t    reset_lnums();\n\n#ifdef FEAT_EVAL\n\tif (eap != NULL)\n\t{\n\t    (void)set_cmdarg(NULL, save_cmdarg);\n\t    set_vim_var_nr(VV_CMDBANG, save_cmdbang);\n\t}\n#endif\n\t// delete from active_apc_list\n\tif (active_apc_list == &patcmd)\t    // just in case\n\t    active_apc_list = patcmd.next;\n    }\n\n    --RedrawingDisabled;\n    autocmd_busy = save_autocmd_busy;\n    filechangeshell_busy = FALSE;\n    autocmd_nested = save_autocmd_nested;\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n    vim_free(autocmd_fname);\n    autocmd_fname = save_autocmd_fname;\n    autocmd_fname_full = save_autocmd_fname_full;\n    autocmd_bufnr = save_autocmd_bufnr;\n    autocmd_match = save_autocmd_match;\n    current_sctx = save_current_sctx;\n#ifdef FEAT_EVAL\n    restore_funccal();\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n    KeyTyped = save_KeyTyped;\n    vim_free(fname);\n    vim_free(sfname);\n    --nesting;\t\t// see matching increment above\n\n    /*\n     * When stopping to execute autocommands, restore the search patterns and\n     * the redo buffer.  Free any buffers in the au_pending_free_buf list and\n     * free any windows in the au_pending_free_win list.\n     */\n    if (!autocmd_busy)\n    {\n\trestore_search_patterns();\n\tif (did_save_redobuff)\n\t    restoreRedobuff(&save_redo);\n\tdid_filetype = FALSE;\n\twhile (au_pending_free_buf != NULL)\n\t{\n\t    buf_T *b = au_pending_free_buf->b_next;\n\n\t    vim_free(au_pending_free_buf);\n\t    au_pending_free_buf = b;\n\t}\n\twhile (au_pending_free_win != NULL)\n\t{\n\t    win_T *w = au_pending_free_win->w_next;\n\n\t    vim_free(au_pending_free_win);\n\t    au_pending_free_win = w;\n\t}\n    }\n\n    /*\n     * Some events don't set or reset the Changed flag.\n     * Check if still in the same buffer!\n     */\n    if (curbuf == old_curbuf\n\t    && (event == EVENT_BUFREADPOST\n\t\t|| event == EVENT_BUFWRITEPOST\n\t\t|| event == EVENT_FILEAPPENDPOST\n\t\t|| event == EVENT_VIMLEAVE\n\t\t|| event == EVENT_VIMLEAVEPRE))\n    {\n\tif (curbuf->b_changed != save_changed)\n\t    need_maketitle = TRUE;\n\tcurbuf->b_changed = save_changed;\n    }\n\n    au_cleanup();\t// may really delete removed patterns/commands now\n\nBYPASS_AU:\n    // When wiping out a buffer make sure all its buffer-local autocommands\n    // are deleted.\n    if (event == EVENT_BUFWIPEOUT && buf != NULL)\n\taubuflocal_remove(buf);\n\n    if (retval == OK && event == EVENT_FILETYPE)\n\tau_did_filetype = TRUE;\n\n    return retval;\n}", "target": 1, "cwe": ["CWE-122", "CWE-787"], "project": "vim", "commit_id": "5fa9f23a63651a8abdb074b4fc2ec9b1adc6b089", "hash": 57459239772723396176587531462765607219, "size": 424, "message": "patch 9.0.0061: ml_get error with nested autocommand\n\nProblem:    ml_get error with nested autocommand.\nSolution:   Also check line numbers for a nested autocommand. (closes #10761)", "idx": 128}
{"func": "juniper_ppp_heuristic_guess(netdissect_options *ndo,\n                            register const u_char *p, u_int length)\n{\n    switch(EXTRACT_16BITS(p)) {\n    case PPP_IP :\n    case PPP_OSI :\n    case PPP_MPLS_UCAST :\n    case PPP_MPLS_MCAST :\n    case PPP_IPCP :\n    case PPP_OSICP :\n    case PPP_MPLSCP :\n    case PPP_LCP :\n    case PPP_PAP :\n    case PPP_CHAP :\n    case PPP_ML :\n    case PPP_IPV6 :\n    case PPP_IPV6CP :\n        ppp_print(ndo, p, length);\n        break;\n\n    default:\n        return 0; /* did not find a ppp header */\n        break;\n    }\n    return 1; /* we printed a ppp packet */\n}", "target": 0, "cwe": ["CWE-125", "CWE-787"], "project": "tcpdump", "commit_id": "1dcd10aceabbc03bf571ea32b892c522cbe923de", "hash": 71106964577118863779945223159688212050, "size": 26, "message": "CVE-2017-12897/ISO CLNS: Use ND_TTEST() for the bounds checks in isoclns_print().\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nDon't pass the remaining caplen - that's too hard to get right, and we\nwere getting it wrong in at least one case; just use ND_TTEST().\n\nAdd a test using the capture file supplied by the reporter(s).", "idx": 129}
{"func": "static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint32_t str_j = 0;\n    uint32_t index1;\n\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_ARRAY;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_j = j * bplist->ref_size;\n        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index1);\n        if (!val) {\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, val);\n    }\n\n    return node;\n}", "target": 1, "cwe": ["CWE-125"], "project": "libplist", "commit_id": "4765d9a60ca4248a8f89289271ac69cbffcc29bc", "hash": 151812168941986988627969160216598193418, "size": 34, "message": "bplist: Fix possible out-of-bounds read in parse_array_node() with proper bounds checking", "idx": 130}
{"func": "IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n    int content_len)\n{\n    Packet *p = NULL;\n    uint8_t *pcontent;\n    IPV6Hdr ip6h;\n\n    p = SCCalloc(1, sizeof(*p) + default_packet_size);\n    if (unlikely(p == NULL))\n        return NULL;\n\n    PACKET_INITIALIZE(p);\n\n    gettimeofday(&p->ts, NULL);\n\n    ip6h.s_ip6_nxt = 44;\n    ip6h.s_ip6_hlim = 2;\n\n    /* Source and dest address - very bogus addresses. */\n    ip6h.s_ip6_src[0] = 0x01010101;\n    ip6h.s_ip6_src[1] = 0x01010101;\n    ip6h.s_ip6_src[2] = 0x01010101;\n    ip6h.s_ip6_src[3] = 0x01010101;\n    ip6h.s_ip6_dst[0] = 0x02020202;\n    ip6h.s_ip6_dst[1] = 0x02020202;\n    ip6h.s_ip6_dst[2] = 0x02020202;\n    ip6h.s_ip6_dst[3] = 0x02020202;\n\n    /* copy content_len crap, we need full length */\n    PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));\n\n    p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);\n    IPV6_SET_RAW_VER(p->ip6h, 6);\n    /* Fragmentation header. */\n    IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n    fh->ip6fh_nxt = IPPROTO_ICMP;\n    fh->ip6fh_ident = htonl(id);\n    fh->ip6fh_offlg = htons((off << 3) | mf);\n\n    DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);\n\n    pcontent = SCCalloc(1, content_len);\n    if (unlikely(pcontent == NULL))\n        return NULL;\n    memset(pcontent, content, content_len);\n    PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), pcontent, content_len);\n    SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);\n    SCFree(pcontent);\n\n    p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);\n\n    SET_IPV6_SRC_ADDR(p, &p->src);\n    SET_IPV6_DST_ADDR(p, &p->dst);\n\n    /* Self test. */\n    if (IPV6_GET_VER(p) != 6)\n        goto error;\n    if (IPV6_GET_NH(p) != 44)\n        goto error;\n    if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)\n        goto error;\n\n    return p;\nerror:\n    fprintf(stderr, \"Error building test packet.\\n\");\n    if (p != NULL)\n        SCFree(p);\n    return NULL;\n}", "target": 1, "cwe": ["CWE-358"], "project": "suricata", "commit_id": "4a04f814b15762eb446a5ead4d69d021512df6f8", "hash": 255539900191482040439125334991879643275, "size": 69, "message": "defrag - take protocol into account during re-assembly\n\nThe IP protocol was not being used to match fragments with\ntheir packets allowing a carefully constructed packet\nwith a different protocol to be matched, allowing re-assembly\nto complete, creating a packet that would not be re-assembled\nby the destination host.", "idx": 131}
{"func": "sraSpanCheck(const sraSpan *span, const char *text) {\n  /* Check the span is valid! */\n  if (span->start == span->end) {\n    printf(text); \n    printf(\":%d-%d\\n\", span->start, span->end);\n  }\n}", "target": 0, "cwe": ["CWE-476"], "project": "libvncserver", "commit_id": "38e98ee61d74f5f5ab4aa4c77146faad1962d6d0", "hash": 53126994408038513651440141285308680688, "size": 7, "message": "libvncserver: add missing NULL pointer checks", "idx": 132}
{"func": "changed_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}", "target": 0, "cwe": ["CWE-122"], "project": "vim", "commit_id": "777e7c21b7627be80961848ac560cb0a9978ff43", "hash": 155142240556001174295434484413305718654, "size": 5, "message": "patch 8.2.3564: invalid memory access when scrolling without valid screen\n\nProblem:    Invalid memory access when scrolling without a valid screen.\nSolution:   Do not set VALID_BOTLINE in w_valid.", "idx": 133}
{"func": "com_quit(String *buffer __attribute__((unused)),\n\t char *line __attribute__((unused)))\n{\n  status.exit_status=0;\n  return 1;\n}", "target": 0, "cwe": ["CWE-284", "CWE-295"], "project": "mysql-server", "commit_id": "3bd5589e1a5a93f9c224badf983cd65c45215390", "hash": 226600518840823057180058383016045315249, "size": 6, "message": "WL#6791 : Redefine client --ssl option to imply enforced encryption\n\n# Changed the meaning of the --ssl=1 option of all client binaries\nto mean force ssl, not try ssl and fail over to eunecrypted\n# Added a new MYSQL_OPT_SSL_ENFORCE mysql_options()\noption to specify that an ssl connection is required.\n# Added a new macro SSL_SET_OPTIONS() to the client\nSSL handling headers that sets all the relevant SSL options at \nonce.\n# Revamped all of the current native clients to use the new macro\n# Removed some Windows line endings.\n# Added proper handling of the new option into the ssl helper\nheaders.\n# If SSL is mandatory assume that the media is secure enough \nfor the sha256 plugin to do unencrypted password exchange even\nbefore establishing a connection.\n# Set the default ssl cipher to DHE-RSA-AES256-SHA if none is \nspecified.\n# updated test cases that require a non-default cipher to spawn \na mysql command line tool binary since mysqltest has no support\nfor specifying ciphers.\n# updated the replication slave connection code to always enforce\nSSL if any of the SSL config options is present.\n# test cases added and updated.\n# added a mysql_get_option() API to return mysql_options() \nvalues. Used the new API inside the sha256 plugin.\n# Fixed compilation warnings because of unused variables.\n# Fixed test failures (mysql_ssl and bug13115401)\n# Fixed whitespace issues.\n# Fully implemented the mysql_get_option() function.\n# Added a test case for mysql_get_option()\n# fixed some trailing whitespace issues\n# fixed some uint/int warnings in mysql_client_test.c\n# removed shared memory option from non-windows get_options\n tests\n# moved MYSQL_OPT_LOCAL_INFILE to the uint options", "idx": 134}
{"func": "bool Webm2Pes::WritePesPacket(const VideoFrame& frame,\n                              PacketDataBuffer* packet_data) {\n  if (frame.buffer().data.get() == nullptr || frame.buffer().length < 1)\n    return false;\n\n  Ranges frame_ranges;\n  if (frame.codec() == VideoFrame::kVP9) {\n    const bool has_superframe_index = ParseVP9SuperFrameIndex(\n        frame.buffer().data.get(), frame.buffer().length, &frame_ranges);\n    if (has_superframe_index == false) {\n      frame_ranges.push_back(Range(0, frame.buffer().length));\n    }\n  } else {\n    frame_ranges.push_back(Range(0, frame.buffer().length));\n  }\n\n  const std::int64_t khz90_pts =\n      NanosecondsTo90KhzTicks(frame.nanosecond_pts());\n  PesHeader header;\n  header.optional_header.SetPtsBits(khz90_pts);\n\n  packet_data->clear();\n\n  for (const Range& packet_payload_range : frame_ranges) {\n    std::size_t extra_bytes = 0;\n    if (packet_payload_range.length > kMaxPayloadSize) {\n      extra_bytes = packet_payload_range.length - kMaxPayloadSize;\n    }\n\n    // First packet of new frame. Always include PTS and BCMV header.\n    header.packet_length =\n        packet_payload_range.length - extra_bytes + BCMVHeader::size();\n    if (header.Write(true, packet_data) != true) {\n      std::fprintf(stderr, \"Webm2Pes: packet header write failed.\\n\");\n      return false;\n    }\n\n    BCMVHeader bcmv_header(static_cast<uint32_t>(packet_payload_range.length));\n    if (bcmv_header.Write(packet_data) != true) {\n      std::fprintf(stderr, \"Webm2Pes: BCMV write failed.\\n\");\n      return false;\n    }\n\n    // Insert the payload at the end of |packet_data|.\n    const std::uint8_t* const payload_start =\n        frame.buffer().data.get() + packet_payload_range.offset;\n\n    const std::size_t bytes_to_copy = packet_payload_range.length - extra_bytes;\n    if (CopyAndEscapeStartCodes(payload_start, bytes_to_copy, packet_data) ==\n        false) {\n      fprintf(stderr, \"Webm2Pes: Payload write failed.\\n\");\n      return false;\n    }\n\n    std::size_t bytes_copied = bytes_to_copy;\n    while (extra_bytes) {\n      // Write PES packets for the remaining data, but omit the PTS and BCMV\n      // header.\n      const std::size_t extra_bytes_to_copy =\n          std::min(kMaxPayloadSize, extra_bytes);\n      extra_bytes -= extra_bytes_to_copy;\n      header.packet_length = extra_bytes_to_copy;\n      if (header.Write(false, packet_data) != true) {\n        fprintf(stderr, \"Webm2pes: fragment write failed.\\n\");\n        return false;\n      }\n\n      const std::uint8_t* fragment_start = payload_start + bytes_copied;\n      if (CopyAndEscapeStartCodes(fragment_start, extra_bytes_to_copy,\n                                  packet_data) == false) {\n        fprintf(stderr, \"Webm2Pes: Payload write failed.\\n\");\n        return false;\n      }\n\n      bytes_copied += extra_bytes_to_copy;\n    }\n  }\n\n  return true;\n}", "target": 1, "cwe": ["CWE-125"], "project": "libwebm", "commit_id": "8e88e04b07352f2ca449278b44a2d8ec7631bdcf", "hash": 145677327602930502659293931052029773001, "size": 80, "message": "webm2pes: Avoid OOB reads caused by invalid superframe index.\n\nBUG=webm:1492\n\nChange-Id: Ibd5781731fe8f6fcdf5f1cc6e5807d17b3b92d4d", "idx": 135}
{"func": "static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,\n                                              BrotliBitReader* br) {\n  uint32_t code;\n  uint32_t nbits;\n  code = ReadSymbol(table, br);\n  nbits = kBlockLengthPrefixCode[code].nbits;  /* nbits == 2..24 */\n  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(br, nbits);\n}", "target": 1, "cwe": ["CWE-120"], "project": "brotli", "commit_id": "223d80cfbec8fd346e32906c732c8ede21f0cea6", "hash": 265599258566133364937572527182271106904, "size": 8, "message": "Update (#826)\n\n * IMPORTANT: decoder: fix potential overflow when input chunk is >2GiB\r\n * simplify max Huffman table size calculation\r\n * eliminate symbol duplicates (static arrays in .h files)\r\n * minor combing in research/ code", "idx": 136}
{"func": "static int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}", "target": 1, "cwe": ["CWE-755"], "project": "sqlite", "commit_id": "8654186b0236d556aa85528c2573ee0b6ab71be3", "hash": 208208245522129666857516610065395604656, "size": 25, "message": "When an error occurs while rewriting the parser tree for window functions\nin the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set,\nand make sure that this shuts down any subsequent code generation that might\ndepend on the transformations that were implemented.  This fixes a problem\ndiscovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f", "idx": 137}
{"func": "TIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* module)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n    if (!_TIFFFillStriles( tif ))\n        return ((tmsize_t)(-1));\n\n\tassert((tif->tif_flags&TIFF_NOREADRAW)==0);\n\tif (!isMapped(tif)) {\n\t\ttmsize_t cc;\n\n\t\tif (!SeekOK(tif, td->td_stripoffset[tile])) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Seek error at row %lu, col %lu, tile %lu\",\n\t\t\t    (unsigned long) tif->tif_row,\n\t\t\t    (unsigned long) tif->tif_col,\n\t\t\t    (unsigned long) tile);\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\tcc = TIFFReadFile(tif, buf, size);\n\t\tif (cc != size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at row %lu, col %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned __int64) cc,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at row %lu, col %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned long long) cc,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t} else {\n\t\ttmsize_t ma,mb;\n\t\ttmsize_t n;\n\t\tma=(tmsize_t)td->td_stripoffset[tile];\n\t\tmb=ma+size;\n\t\tif (((uint64)ma!=td->td_stripoffset[tile])||(ma>tif->tif_size))\n\t\t\tn=0;\n\t\telse if ((mb<ma)||(mb<size)||(mb>tif->tif_size))\n\t\t\tn=tif->tif_size-ma;\n\t\telse\n\t\t\tn=size;\n\t\tif (n!=size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Read error at row %lu, col %lu, tile %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned long) tile,\n\t\t\t\t     (unsigned __int64) n,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Read error at row %lu, col %lu, tile %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned long) tile,\n\t\t\t\t     (unsigned long long) n,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\t_TIFFmemcpy(buf, tif->tif_base + ma, size);\n\t}\n\treturn (size);\n}", "target": 1, "cwe": ["CWE-189"], "project": "libtiff", "commit_id": "0ba5d8814a17a64bdb8d9035f4c533f3f3f4b496", "hash": 23509755624112448635737496074109613634, "size": 73, "message": "* libtiff/tif_read.c: Fix out-of-bounds read on\nmemory-mapped files in TIFFReadRawStrip1() and TIFFReadRawTile1()\nwhen stripoffset is beyond tmsize_t max value (reported by\nMathias Svensson)", "idx": 138}
{"func": "network_init ()\n{\n#ifdef HAVE_GNUTLS\n    char *ca_path, *ca_path2;\n\n    gnutls_global_init ();\n    gnutls_certificate_allocate_credentials (&gnutls_xcred);\n    \n    ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));\n    if (ca_path)\n    {\n        ca_path2 = string_replace (ca_path, \"%h\", weechat_home);\n        if (ca_path2)\n        {\n            gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,\n                                                    GNUTLS_X509_FMT_PEM);\n            free (ca_path2);\n        }\n        free (ca_path);\n    }\n    gnutls_certificate_client_set_retrieve_function (gnutls_xcred,\n                                                     &hook_connect_gnutls_set_certificates);\n    network_init_ok = 1;\n#endif\n#ifdef HAVE_GCRYPT\n    gcry_check_version (GCRYPT_VERSION);\n    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);\n    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n}", "target": 1, "cwe": ["CWE-20"], "project": "weechat", "commit_id": "c265cad1c95b84abfd4e8d861f25926ef13b5d91", "hash": 85114822597843435632107142359915480095, "size": 30, "message": "Fix verification of SSL certificates by calling gnutls verify callback (patch #7459)", "idx": 139}
{"func": "static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)\n{\n\tconst struct auth_passdb *passdb;\n\n\tfor (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {\n\t\tif (passdb->passdb->iface.lookup_credentials != NULL)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 0, "cwe": ["CWE-284"], "project": "core", "commit_id": "7bad6a24160e34bce8f10e73dbbf9e5fbbcd1904", "hash": 331126452256284827593792842040040736368, "size": 10, "message": "auth: Fix handling passdbs with identical driver/args but different mechanisms/username_filter\n\nThe passdb was wrongly deduplicated in this situation, causing wrong\nmechanisms or username_filter setting to be used. This would be a rather\nunlikely configuration though.\n\nFixed by moving mechanisms and username_filter from struct passdb_module\nto struct auth_passdb, which is where they should have been in the first\nplace.", "idx": 140}
{"func": "static int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands)\n{\n\tsctp_datahdr_t *data_hdr;\n\tstruct sctp_chunk *err;\n\tsize_t datalen;\n\tsctp_verb_t deliver;\n\tint tmp;\n\t__u32 tsn;\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tu16 ssn;\n\tu16 sid;\n\tu8 ordered = 0;\n\n\tdata_hdr = chunk->subh.data_hdr = (sctp_datahdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_datahdr_t));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tSCTP_DEBUG_PRINTK(\"eat_data: TSN 0x%x.\\n\", tsn);\n\n\t/* ASSERT:  Now skb->data is really the user data.  */\n\n\t/* Process ECN based congestion.\n\t *\n\t * Since the chunk structure is reused for all chunks within\n\t * a packet, we use ecn_ce_done to track if we've already\n\t * done CE processing for this packet.\n\t *\n\t * We need to do ECN processing even if we plan to discard the\n\t * chunk later.\n\t */\n\n\tif (!chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\taf = sctp_get_af_specific(\n\t\t\tipver2af(ip_hdr(chunk->skb)->version));\n\n\t\tif (af && af->is_ce(chunk->skb) && asoc->peer.ecn_capable) {\n\t\t\t/* Do real work as sideffect. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t/* The TSN is too high--silently discard the chunk and\n\t\t * count on it getting retransmitted later.\n\t\t */\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t/* This is a duplicate.  Record it.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t/* This is a new TSN.  */\n\n\t/* Discard if there is no room in the receive window.\n\t * Actually, allow a little bit of overflow (up to a MTU).\n\t */\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sizeof(sctp_data_chunk_t);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t/* Think about partial delivery. */\n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t/* Even if we don't accept this chunk there is\n\t\t * memory pressure.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t/* Spill over rwnd a little bit.  Note: While allowed, this spill over\n\t * seems a bit troublesome in that frag_point varies based on\n\t * PMTU.  In cases, such as loopback, this might be a rather\n\t * large spill over.\n\t */\n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t/* If this is the next TSN, consider reneging to make\n\t\t * room.   Note: Playing nice with a confused sender.  A\n\t\t * malicious sender can still eat up all our buffer\n\t\t * space and in the future we may want to detect and\n\t\t * do more drastic reneging.\n\t\t */\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tSCTP_DEBUG_PRINTK(\"Reneging for tsn:%u\\n\", tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tSCTP_DEBUG_PRINTK(\"Discard tsn: %u len: %Zd, \"\n\t\t\t\t\t  \"rwnd: %d\\n\", tsn, datalen,\n\t\t\t\t\t  asoc->rwnd);\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t/*\n\t * Also try to renege to limit our memory usage in the event that\n\t * we are under memory pressure\n\t * If we can't renege, don't worry about it, the sk_rmem_schedule\n\t * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our\n\t * memory usage too much\n\t */\n\tif (*sk->sk_prot_creator->memory_pressure) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t           (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tSCTP_DEBUG_PRINTK(\"Under Pressure! Reneging for tsn:%u\\n\", tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t }\n\t}\n\n\t/*\n\t * Section 3.3.10.9 No User Data (9)\n\t *\n\t * Cause of error\n\t * ---------------\n\t * No User Data:  This error cause is returned to the originator of a\n\t * DATA chunk if a received DATA chunk has no user data.\n\t */\n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t/* Note: Some chunks may get overcounted (if we drop) or overcounted\n\t * if we renege and the chunk arrives again.\n\t */\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\telse {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tordered = 1;\n\t}\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * If an endpoint receive a DATA chunk with an invalid stream\n\t * identifier, it shall acknowledge the reception of the DATA chunk\n\t * following the normal procedure, immediately send an ERROR chunk\n\t * with cause set to \"Invalid Stream Identifier\" (See Section 3.3.10)\n\t * and discard the DATA chunk.\n\t */\n\tsid = ntohs(data_hdr->stream);\n\tif (sid >= asoc->c.sinit_max_instreams) {\n\t\t/* Mark tsn as received even though we drop it */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t/* Check to see if the SSN is possible for this TSN.\n\t * The biggest gap we can record is 4K wide.  Since SSNs wrap\n\t * at an unsigned short, there is no way that an SSN can\n\t * wrap and for a valid TSN.  We can simply check if the current\n\t * SSN is smaller then the next expected one.  If it is, it wrapped\n\t * and is invalid.\n\t */\n\tssn = ntohs(data_hdr->ssn);\n\tif (ordered && SSN_lt(ssn, sctp_ssn_peek(&asoc->ssnmap->in, sid))) {\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\t}\n\n\t/* Send the data up to the user.  Note:  Schedule  the\n\t * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK\n\t * chunk needs the updated rwnd.\n\t */\n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}", "target": 1, "cwe": [], "project": "linux", "commit_id": "196d67593439b03088913227093e374235596e33", "hash": 9593846739098686435067930716502433422, "size": 203, "message": "sctp: Add support to per-association statistics via a new SCTP_GET_ASSOC_STATS call\n\nThe current SCTP stack is lacking a mechanism to have per association\nstatistics. This is an implementation modeled after OpenSolaris'\nSCTP_GET_ASSOC_STATS.\n\nUserspace part will follow on lksctp if/when there is a general ACK on\nthis.\nV4:\n- Move ipackets++ before q->immediate.func() for consistency reasons\n- Move sctp_max_rto() at the end of sctp_transport_update_rto() to avoid\n  returning bogus RTO values\n- return asoc->rto_min when max_obs_rto value has not changed\n\nV3:\n- Increase ictrlchunks in sctp_assoc_bh_rcv() as well\n- Move ipackets++ to sctp_inq_push()\n- return 0 when no rto updates took place since the last call\n\nV2:\n- Implement partial retrieval of stat struct to cope for future expansion\n- Kill the rtxpackets counter as it cannot be precise anyway\n- Rename outseqtsns to outofseqtsns to make it clearer that these are out\n  of sequence unexpected TSNs\n- Move asoc->ipackets++ under a lock to avoid potential miscounts\n- Fold asoc->opackets++ into the already existing asoc check\n- Kill unneeded (q->asoc) test when increasing rtxchunks\n- Do not count octrlchunks if sending failed (SCTP_XMIT_OK != 0)\n- Don't count SHUTDOWNs as SACKs\n- Move SCTP_GET_ASSOC_STATS to the private space API\n- Adjust the len check in sctp_getsockopt_assoc_stats() to allow for\n  future struct growth\n- Move association statistics in their own struct\n- Update idupchunks when we send a SACK with dup TSNs\n- return min_rto in max_rto when RTO has not changed. Also return the\n  transport when max_rto last changed.\n\nSigned-off: Michele Baldessari <michele@acksyn.org>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\n\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 141}
{"func": "peek_for_as4_capability (struct peer *peer, u_char length)\n{\n  struct stream *s = BGP_INPUT (peer);\n  size_t orig_getp = stream_get_getp (s);\n  size_t end = orig_getp + length;\n  as_t as4 = 0;\n  \n  /* The full capability parser will better flag the error.. */\n  if (STREAM_READABLE(s) < length)\n    return 0;\n\n  if (BGP_DEBUG (as4, AS4))\n    zlog_info (\"%s [AS4] rcv OPEN w/ OPTION parameter len: %u,\"\n                \" peeking for as4\",\n\t        peer->host, length);\n  /* the error cases we DONT handle, we ONLY try to read as4 out of\n   * correctly formatted options.\n   */\n  while (stream_get_getp(s) < end) \n    {\n      u_char opt_type;\n      u_char opt_length;\n      \n      /* Check the length. */\n      if (stream_get_getp (s) + 2 > end)\n        goto end;\n      \n      /* Fetch option type and length. */\n      opt_type = stream_getc (s);\n      opt_length = stream_getc (s);\n      \n      /* Option length check. */\n      if (stream_get_getp (s) + opt_length > end)\n        goto end;\n      \n      if (opt_type == BGP_OPEN_OPT_CAP)\n        {\n          unsigned long capd_start = stream_get_getp (s);\n          unsigned long capd_end = capd_start + opt_length;\n          \n          assert (capd_end <= end);\n          \n\t  while (stream_get_getp (s) < capd_end)\n\t    {\n\t      struct capability_header hdr;\n\t      \n\t      if (stream_get_getp (s) + 2 > capd_end)\n                goto end;\n              \n              hdr.code = stream_getc (s);\n              hdr.length = stream_getc (s);\n              \n\t      if ((stream_get_getp(s) +  hdr.length) > capd_end)\n\t\tgoto end;\n\n\t      if (hdr.code == CAPABILITY_CODE_AS4)\n\t        {\n\t          if (hdr.length != CAPABILITY_CODE_AS4_LEN)\n\t            goto end;\n                  \n\t          if (BGP_DEBUG (as4, AS4))\n\t            zlog_info (\"[AS4] found AS4 capability, about to parse\");\n\t          as4 = bgp_capability_as4 (peer, &hdr);\n\t          \n\t          goto end;\n                }\n              stream_forward_getp (s, hdr.length);\n\t    }\n\t}\n    }\n\nend:\n  stream_set_getp (s, orig_getp);\n  return as4;\n}", "target": 1, "cwe": ["CWE-119"], "project": "quagga", "commit_id": "5861739f8c38bc36ea9955e5cb2be2bf2f482d70", "hash": 161224952016418663125384257493773646052, "size": 75, "message": "bgpd: Open option parse errors don't NOTIFY, resulting in abort & DoS\n\n* bgp_packet.c: (bgp_open_receive) Errors from bgp_open_option_parse are\n  detected, and the code will stop processing the OPEN and return.  However\n  it does so without calling bgp_notify_send to send a NOTIFY - which means\n  the peer FSM doesn't get stopped, and bgp_read will be called again later.\n  Because it returns, it doesn't go through the code near the end of the\n  function that removes the current message from the peer input streaam.\n  Thus the next call to bgp_read will try to parse a half-parsed stream as\n  if it were a new BGP message, leading to an assert later in the code when\n  it tries to read stuff that isn't there. Add the required call to\n  bgp_notify_send before returning.\n* bgp_open.c: (bgp_capability_as4) Be a bit stricter, check the length field\n  corresponds to the only value it can be, which is the amount we're going to\n  read off the stream. And make sure the capability flag gets set, so\n  callers can know this capability was read, regardless.\n  (peek_for_as4_capability) Let bgp_capability_as4 do the length check.", "idx": 142}
{"func": "tcp_dst_prompt(packet_info *pinfo, gchar *result)\n{\n    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));\n\n    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, \"destination (%s%u)\", UTF8_RIGHTWARDS_ARROW, port);\n}", "target": 0, "cwe": ["CWE-354"], "project": "wireshark", "commit_id": "7f3fe6164a68b76d9988c4253b24d43f498f1753", "hash": 229594618645422847498588340128012053786, "size": 6, "message": "TCP: do not use an unknown status when the checksum is 0xffff\n\nOtherwise it triggers an assert when adding the column as the field is\ndefined as BASE_NONE and not BASE_DEC or BASE_HEX. Thus an unknown value\n(not in proto_checksum_vals[)array) cannot be represented.\nMark the checksum as bad even if we process the packet.\nCloses #16816\n\nConflicts:\n\tepan/dissectors/packet-tcp.c", "idx": 143}
{"func": "bool setup_imginfo_jpg(bool only_allocate_two_image_rows)\n{\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   hpos = 0; // position in header\n\n    int cmp;\n\n    // header parser loop\n    while ( hpos < hdrs ) {\n        type = hpos + 1 < hdrs ? hdrdata[ hpos + 1 ] : 0;\n        len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ] : 0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] : 0);\n        // do not parse DHT & DRI\n        if ( ( type != 0xDA ) && ( type != 0xC4 ) && ( type != 0xDD ) ) {\n            if ( !parse_jfif_jpg( type, len, hdrs-hpos, &( hdrdata[ hpos ] ) ) )\n                return false;\n        }\n        hpos += len;\n    }\n\n    // check if information is complete\n    if ( cmpc == 0 ) {\n        fprintf( stderr, \"header contains incomplete information\" );\n        errorlevel.store(2);\n        return false;\n    }\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        if ( ( cmpnfo[cmp].sfv == 0 ) ||\n             ( cmpnfo[cmp].sfh == 0 ) ||\n             ( cmpnfo[cmp].qtable == NULL ) ||\n             ( cmpnfo[cmp].qtable[0] == 0 ) ||\n             ( jpegtype == 0 ) ) {\n            fprintf( stderr, \"header information is incomplete\" );\n            errorlevel.store(2);\n            return false;\n        }\n    }\n        \n    // do all remaining component info calculations\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        if ( cmpnfo[ cmp ].sfh > sfhm ) sfhm = cmpnfo[ cmp ].sfh;\n        if ( cmpnfo[ cmp ].sfv > sfvm ) sfvm = cmpnfo[ cmp ].sfv;\n    }\n    mcuv = ( int ) ceil( (float) imgheight / (float) ( 8 * sfhm ) );\n    mcuh = ( int ) ceil( (float) imgwidth  / (float) ( 8 * sfvm ) );\n    mcuc  = mcuv * mcuh;\n    int maxChromaWidth = 0;\n    int maxChromaHeight = 0;\n    int maxLumaWidth = 0;\n    int maxLumaHeight = 0;\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        cmpnfo[ cmp ].mbs = cmpnfo[ cmp ].sfv * cmpnfo[ cmp ].sfh;\n        cmpnfo[ cmp ].bcv = mcuv * cmpnfo[ cmp ].sfh;\n        cmpnfo[ cmp ].bch = mcuh * cmpnfo[ cmp ].sfv;\n        cmpnfo[ cmp ].bc  = cmpnfo[ cmp ].bcv * cmpnfo[ cmp ].bch;\n        cmpnfo[ cmp ].ncv = ( int ) ceil( (float) imgheight *\n                            ( (float) cmpnfo[ cmp ].sfh / ( 8.0 * sfhm ) ) );\n        cmpnfo[ cmp ].nch = ( int ) ceil( (float) imgwidth *\n                            ( (float) cmpnfo[ cmp ].sfv / ( 8.0 * sfvm ) ) );\n        cmpnfo[ cmp ].nc  = cmpnfo[ cmp ].ncv * cmpnfo[ cmp ].nch;\n        cmpnfo[cmp].check_valid_value_range();\n        if (cmp == 0) {\n            maxLumaWidth = cmpnfo[ cmp ].bch * 8;\n            maxLumaHeight = cmpnfo[ cmp ].bcv * 8;\n        } else {\n            if (maxChromaWidth < cmpnfo[ cmp ].bch * 8) {\n                maxChromaWidth = cmpnfo[ cmp ].bch * 8;\n            }\n            if (maxChromaHeight < cmpnfo[ cmp ].bcv * 8) {\n                maxChromaHeight = cmpnfo[ cmp ].bcv * 8;\n            }\n        }\n    }\n    LeptonDebug::setupDebugData(maxLumaWidth, maxLumaHeight,\n                                maxChromaWidth, maxChromaHeight);\n\n    // decide components' statistical ids\n    if ( cmpc <= 3 ) {\n        for ( cmp = 0; cmp < cmpc; cmp++ ) cmpnfo[ cmp ].sid = cmp;\n    }\n    else {\n        for ( cmp = 0; cmp < cmpc; cmp++ ) cmpnfo[ cmp ].sid = 0;\n    }\n    size_t start_allocated = Sirikata::memmgr_size_allocated();\n    // alloc memory for further operations\n    colldata.init(cmpnfo, cmpc, mcuh, mcuv, jpegtype == 1 && only_allocate_two_image_rows);\n    size_t end_allocated = Sirikata::memmgr_size_allocated();\n    total_framebuffer_allocated = end_allocated - start_allocated;\n    return true;\n}", "target": 0, "cwe": ["CWE-399", "CWE-190"], "project": "lepton", "commit_id": "6a5ceefac1162783fffd9506a3de39c85c725761", "hash": 284406052495795682862827836856120442671, "size": 90, "message": "fix #111", "idx": 144}
{"func": "ldns_pkt_algorithm2str(ldns_algorithm algorithm)\n{\n\tchar *str;\n\tldns_buffer *buf;\n\n\tbuf = ldns_buffer_new(10);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tstr = NULL;\n\tif (ldns_algorithm2buffer_str(buf, algorithm)\n\t    == LDNS_STATUS_OK) {\n\t\tstr = ldns_buffer_export2str(buf);\n\t}\n\n\tldns_buffer_free(buf);\n\treturn str;\n}", "target": 0, "cwe": ["CWE-415"], "project": "ldns", "commit_id": "070b4595981f48a21cc6b4f5047fdc2d09d3da91", "hash": 313265322035430986599553144900072291564, "size": 19, "message": "CAA and URI", "idx": 145}
{"func": "skip_double_quoted (string, slen, sind, flags)\n     char *string;\n     size_t slen;\n     int sind;\n     int flags;\n{\n  int c, i;\n  char *ret;\n  int pass_next, backquote, si;\n  DECLARE_MBSTATE;\n\n  pass_next = backquote = 0;\n  i = sind;\n  while (c = string[i])\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '\\\\')\n\t{\n\t  pass_next++;\n\t  i++;\n\t  continue;\n\t}\n      else if (backquote)\n\t{\n\t  if (c == '`')\n\t    backquote = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '`')\n\t{\n\t  backquote++;\n\t  i++;\n\t  continue;\n\t}\n      else if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))\n\t{\n\t  si = i + 2;\n\t  if (string[i + 1] == LPAREN)\n\t    ret = extract_command_subst (string, &si, SX_NOALLOC|(flags&SX_COMPLETE));\n\t  else\n\t    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, SX_NOALLOC);\n\n\t  i = si + 1;\n\t  continue;\n\t}\n      else if (c != '\"')\n\t{\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else\n\tbreak;\n    }\n\n  if (c)\n    i++;\n\n  return (i);\n}", "target": 0, "cwe": [], "project": "bash", "commit_id": "955543877583837c85470f7fb8a97b7aa8d45e6c", "hash": 256082874193727192521281046968234342929, "size": 65, "message": "bash-4.4-rc2 release", "idx": 146}
{"func": "TfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,\n                         const TfLiteTensor* rhs) {\n  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);\n  if (rhs->type == kTfLiteInt8) {\n    // Get the quantization params from the RHS tensor.\n    transposed_rhs->params.scale = rhs->params.scale;\n    transposed_rhs->params.zero_point = rhs->params.zero_point;\n  }\n  return transposed_rhs;\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tensorflow", "commit_id": "1970c2158b1ffa416d159d03c3370b9a462aee35", "hash": 89734395118794125422859009831833704201, "size": 10, "message": "[tflite]: Insert `nullptr` checks when obtaining tensors.\n\nAs part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.\n\nWe also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).\n\nPiperOrigin-RevId: 332521299\nChange-Id: I29af455bcb48d0b92e58132d951a3badbd772d56", "idx": 147}
{"func": "void Downstream::inspect_http1_request() {\n  if (req_.method == HTTP_CONNECT) {\n    req_.upgrade_request = true;\n  } else if (req_.http_minor > 0) {\n    auto upgrade = req_.fs.header(http2::HD_UPGRADE);\n    if (upgrade) {\n      const auto &val = upgrade->value;\n      // TODO Perform more strict checking for upgrade headers\n      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),\n                        val.size())) {\n        req_.http2_upgrade_seen = true;\n      } else {\n        req_.upgrade_request = true;\n\n        // TODO Should we check Sec-WebSocket-Key, and\n        // Sec-WebSocket-Version as well?\n        if (util::strieq_l(\"websocket\", val)) {\n          req_.connect_proto = ConnectProto::WEBSOCKET;\n        }\n      }\n    }\n  }\n  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);\n  if (transfer_encoding) {\n    req_.fs.content_length = -1;\n    if (util::iends_with_l(transfer_encoding->value, \"chunked\")) {\n      chunked_request_ = true;\n    }\n  }\n}", "target": 1, "cwe": [], "project": "nghttp2", "commit_id": "319d5ab1c6d916b6b8a0d85b2ae3f01b3ad04f2c", "hash": 58365931505958026046137358639810841667, "size": 30, "message": "nghttpx: Fix request stall\n\nFix request stall if backend connection is reused and buffer is full.", "idx": 148}
{"func": "static void spl_array_unset_dimension_ex(int check_inherited, zval *object, zval *offset TSRMLS_DC) /* {{{ */\n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tlong index;\n\tHashTable *ht;\n\n\tif (check_inherited && intern->fptr_offset_del) {\n\t\tSEPARATE_ARG_IF_REF(offset);\n\t\tzend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_del, \"offsetUnset\", NULL, offset);\n\t\tzval_ptr_dtor(&offset);\n\t\treturn;\n\t}\n\n\tswitch(Z_TYPE_P(offset)) {\n\tcase IS_STRING:\n\t\tht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\tif (ht->nApplyCount > 0) {\n\t\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\t\treturn;\n\t\t}\n\t\tif (ht == &EG(symbol_table)) {\n\t\t\tif (zend_delete_global_variable(Z_STRVAL_P(offset), Z_STRLEN_P(offset) TSRMLS_CC)) {\n\t\t\t\tzend_error(E_NOTICE,\"Undefined index: %s\", Z_STRVAL_P(offset));\n\t\t\t}\n\t\t} else {\n\t\t\tif (zend_symtable_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1) == FAILURE) {\n\t\t\t\tzend_error(E_NOTICE,\"Undefined index: %s\", Z_STRVAL_P(offset));\n\t\t\t} else {\n\t\t\t\tspl_array_object *obj = intern;\n\n\t\t\t\twhile (1) {\n\t\t\t\t\tif ((obj->ar_flags & SPL_ARRAY_IS_SELF) != 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (Z_TYPE_P(obj->array) == IS_OBJECT) {\n\t\t\t\t\t    if ((obj->ar_flags & SPL_ARRAY_USE_OTHER) == 0) {\n\t\t\t\t\t\t\tobj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC);\n\t\t\t\t\t    \tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tobj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC);\n\t\t\t\t\t    }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobj = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (obj) {\n\t\t\t\t\tzend_property_info *property_info = zend_get_property_info(obj->std.ce, offset, 1 TSRMLS_CC);\n\n\t\t\t\t\tif (property_info &&\n\t\t\t\t\t    (property_info->flags & ZEND_ACC_STATIC) == 0 &&\n\t\t\t\t\t    property_info->offset >= 0) {\n\t\t\t\t\t    obj->std.properties_table[property_info->offset] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\tbreak;\n\tcase IS_DOUBLE:\n\tcase IS_RESOURCE:\n\tcase IS_BOOL: \n\tcase IS_LONG: \n\t\tif (offset->type == IS_DOUBLE) {\n\t\t\tindex = (long)Z_DVAL_P(offset);\n\t\t} else {\n\t\t\tindex = Z_LVAL_P(offset);\n\t\t}\n\t\tht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\tif (ht->nApplyCount > 0) {\n\t\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\t\treturn;\n\t\t}\n\t\tif (zend_hash_index_del(ht, index) == FAILURE) {\n\t\t\tzend_error(E_NOTICE,\"Undefined offset: %ld\", Z_LVAL_P(offset));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tzend_error(E_WARNING, \"Illegal offset type\");\n\t\treturn;\n\t}\n\tspl_hash_verify_pos(intern TSRMLS_CC); /* call rewind on FAILURE */\n} /* }}} */", "target": 1, "cwe": [], "project": "php-src", "commit_id": "b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2", "hash": 267517286754202027041747900302369709334, "size": 81, "message": "Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items)", "idx": 149}
{"func": "crm_trigger_prepare(GSource * source, gint * timeout)\n{\n    crm_trigger_t *trig = (crm_trigger_t *) source;\n\n    /* cluster-glue's FD and IPC related sources make use of\n     * g_source_add_poll() but do not set a timeout in their prepare\n     * functions\n     *\n     * This means mainloop's poll() will block until an event for one\n     * of these sources occurs - any /other/ type of source, such as\n     * this one or g_idle_*, that doesn't use g_source_add_poll() is\n     * S-O-L and wont be processed until there is something fd-based\n     * happens.\n     *\n     * Luckily the timeout we can set here affects all sources and\n     * puts an upper limit on how long poll() can take.\n     *\n     * So unconditionally set a small-ish timeout, not too small that\n     * we're in constant motion, which will act as an upper bound on\n     * how long the signal handling might be delayed for.\n     */\n    *timeout = 500;             /* Timeout in ms */\n\n    return trig->trigger;\n}", "target": 0, "cwe": ["CWE-399"], "project": "pacemaker", "commit_id": "564f7cc2a51dcd2f28ab12a13394f31be5aa3c93", "hash": 206020037803096878569126839101531388118, "size": 25, "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend.", "idx": 150}
{"func": "int input_scancode_to_scalar(const struct input_keymap_entry *ke,\n\t\t\t     unsigned int *scancode)\n{\n\tswitch (ke->len) {\n\tcase 1:\n\t\t*scancode = *((u8 *)ke->scancode);\n\t\tbreak;\n\n\tcase 2:\n\t\t*scancode = *((u16 *)ke->scancode);\n\t\tbreak;\n\n\tcase 4:\n\t\t*scancode = *((u32 *)ke->scancode);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-703", "CWE-787"], "project": "linux", "commit_id": "cb222aed03d798fc074be55e59d9a112338ee784", "hash": 100237593835804217794302045389687655531, "size": 22, "message": "Input: add safety guards to input_set_keycode()\n\nIf we happen to have a garbage in input device's keycode table with values\ntoo big we'll end up doing clear_bit() with offset way outside of our\nbitmaps, damaging other objects within an input device or even outside of\nit. Let's add sanity checks to the returned old keycodes.\n\nReported-by: syzbot+c769968809f9359b07aa@syzkaller.appspotmail.com\nReported-by: syzbot+76f3a30e88d256644c78@syzkaller.appspotmail.com\nLink: https://lore.kernel.org/r/20191207212757.GA245964@dtor-ws\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>", "idx": 151}
{"func": "lexer_compare_identifiers (parser_context_t *context_p, /**< context */\n                           const lexer_lit_location_t *left_p, /**< left literal */\n                           const lexer_lit_location_t *right_p) /**< right literal */\n{\n  prop_length_t length = left_p->length;\n\n  if (length != right_p->length)\n  {\n    return false;\n  }\n\n  if (!left_p->has_escape)\n  {\n    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, length);\n  }\n\n  if (!right_p->has_escape)\n  {\n    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, length);\n  }\n\n  if (length <= 64)\n  {\n    uint8_t buf_p[64];\n    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);\n    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);\n  }\n\n  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);\n\n  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);\n  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);\n  parser_free (dynamic_buf_p, length);\n\n  return result;\n} /* lexer_compare_identifiers */", "target": 1, "cwe": ["CWE-416"], "project": "jerryscript", "commit_id": "3bcd48f72d4af01d1304b754ef19fe1a02c96049", "hash": 39595768625269699251372504963445475665, "size": 36, "message": "Improve parse_identifier (#4691)\n\nAscii string length is no longer computed during string allocation.\r\n\r\nJerryScript-DCO-1.0-Signed-off-by: Daniel Batiz batizjob@gmail.com", "idx": 152}
{"func": "connect_to_server_process (CamelIMAPXServer *is,\n                           const gchar *cmd,\n                           GError **error)\n{\n\tGSubprocessLauncher *launcher;\n\tGSubprocess *subprocess = NULL;\n\tCamelNetworkSettings *network_settings;\n\tCamelProvider *provider;\n\tCamelSettings *settings;\n\tCamelIMAPXStore *store;\n\tCamelURL url;\n\tgchar **argv = NULL;\n\tgchar *buf;\n\tgchar *cmd_copy;\n\tgchar *full_cmd;\n\tconst gchar *password;\n\tgchar *host;\n\tgchar *user;\n\tguint16 port;\n\n\tmemset (&url, 0, sizeof (CamelURL));\n\n\tlauncher = g_subprocess_launcher_new (\n\t\tG_SUBPROCESS_FLAGS_STDIN_PIPE |\n\t\tG_SUBPROCESS_FLAGS_STDOUT_PIPE |\n\t\tG_SUBPROCESS_FLAGS_STDERR_SILENCE);\n\n#ifdef G_OS_UNIX\n\tg_subprocess_launcher_set_child_setup (\n\t\tlauncher, imapx_server_child_process_setup,\n\t\tNULL, (GDestroyNotify) NULL);\n#endif\n\n\tstore = camel_imapx_server_ref_store (is);\n\n\tpassword = camel_service_get_password (CAMEL_SERVICE (store));\n\tprovider = camel_service_get_provider (CAMEL_SERVICE (store));\n\tsettings = camel_service_ref_settings (CAMEL_SERVICE (store));\n\n\tnetwork_settings = CAMEL_NETWORK_SETTINGS (settings);\n\thost = camel_network_settings_dup_host (network_settings);\n\tport = camel_network_settings_get_port (network_settings);\n\tuser = camel_network_settings_dup_user (network_settings);\n\n\t/* Put full details in the environment, in case the connection\n\t * program needs them */\n\tcamel_url_set_protocol (&url, provider->protocol);\n\tcamel_url_set_host (&url, host);\n\tcamel_url_set_port (&url, port);\n\tcamel_url_set_user (&url, user);\n\tbuf = camel_url_to_string (&url, 0);\n\n\tg_subprocess_launcher_setenv (launcher, \"URL\", buf, TRUE);\n\tg_subprocess_launcher_setenv (launcher, \"URLHOST\", host, TRUE);\n\n\tif (port > 0) {\n\t\tgchar *port_string;\n\n\t\tport_string = g_strdup_printf (\"%u\", port);\n\t\tg_subprocess_launcher_setenv (\n\t\t\tlauncher, \"URLPORT\", port_string, TRUE);\n\t\tg_free (port_string);\n\t}\n\n\tif (user != NULL) {\n\t\tg_subprocess_launcher_setenv (\n\t\t\tlauncher, \"URLPORT\", user, TRUE);\n\t}\n\n\tif (password != NULL) {\n\t\tg_subprocess_launcher_setenv (\n\t\t\tlauncher, \"URLPASSWD\", password, TRUE);\n\t}\n\n\tg_free (buf);\n\n\tg_object_unref (settings);\n\tg_object_unref (store);\n\n\t/* Now do %h, %u, etc. substitution in cmd */\n\tbuf = cmd_copy = g_strdup (cmd);\n\n\tfull_cmd = g_strdup (\"\");\n\n\tfor (;;) {\n\t\tgchar *pc;\n\t\tgchar *tmp;\n\t\tconst gchar *var;\n\t\tgint len;\n\n\t\tpc = strchr (buf, '%');\n\tignore:\n\t\tif (!pc) {\n\t\t\ttmp = g_strdup_printf (\"%s%s\", full_cmd, buf);\n\t\t\tg_free (full_cmd);\n\t\t\tfull_cmd = tmp;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = pc - buf;\n\n\t\tvar = NULL;\n\n\t\tswitch (pc[1]) {\n\t\tcase 'h':\n\t\t\tvar = host;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tvar = user;\n\t\t\tbreak;\n\t\t}\n\t\tif (!var) {\n\t\t\t/* If there wasn't a valid %-code, with an actual\n\t\t\t * variable to insert, pretend we didn't see the % */\n\t\t\tpc = strchr (pc + 1, '%');\n\t\t\tgoto ignore;\n\t\t}\n\t\ttmp = g_strdup_printf (\"%s%.*s%s\", full_cmd, len, buf, var);\n\t\tg_free (full_cmd);\n\t\tfull_cmd = tmp;\n\t\tbuf = pc + 2;\n\t}\n\n\tg_free (cmd_copy);\n\n\tg_free (host);\n\tg_free (user);\n\n\tif (g_shell_parse_argv (full_cmd, NULL, &argv, error)) {\n\t\tsubprocess = g_subprocess_launcher_spawnv (\n\t\t\tlauncher, (const gchar * const *) argv, error);\n\t\tg_strfreev (argv);\n\t}\n\n\tg_free (full_cmd);\n\tg_object_unref (launcher);\n\n\tif (subprocess != NULL) {\n\t\tGInputStream *input_stream;\n\t\tGOutputStream *output_stream;\n\n\t\tg_mutex_lock (&is->priv->stream_lock);\n\t\tg_warn_if_fail (is->priv->subprocess == NULL);\n\t\tis->priv->subprocess = g_object_ref (subprocess);\n\t\tg_mutex_unlock (&is->priv->stream_lock);\n\n\t\tinput_stream = g_subprocess_get_stdout_pipe (subprocess);\n\t\toutput_stream = g_subprocess_get_stdin_pipe (subprocess);\n\n\t\timapx_server_set_streams (is, input_stream, output_stream);\n\n\t\tg_object_unref (subprocess);\n\t}\n\n\treturn TRUE;\n}", "target": 0, "cwe": [], "project": "evolution-data-server", "commit_id": "f26a6f672096790d0bbd76903db4c9a2e44f116b", "hash": 69323131382849284680697773684588477559, "size": 156, "message": "[IMAPx] 'STARTTLS not supported' error ignored\n\nWhen a user has setup the STARTTLS encryption method, but the server doesn't\nsupport it, then an error should be shown to the user, instead of using\nunsecure connection. There had been two bugs in the existing code which\nprevented this error from being used and the failure properly reported.\n\nThis had been filled at:\nhttps://bugzilla.redhat.com/show_bug.cgi?id=1334842", "idx": 153}
{"func": "rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)\n{\n    gchar *uri;\n\n    g_return_if_fail (handle != NULL);\n\n    if (base_uri == NULL)\n\treturn;\n\n    if (rsvg_path_is_uri (base_uri)) \n        uri = g_strdup (base_uri);\n    else\n        uri = rsvg_get_base_uri_from_filename (base_uri);\n\n    if (uri) {\n        if (handle->priv->base_uri)\n            g_free (handle->priv->base_uri);\n        handle->priv->base_uri = uri;\n        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);\n    }\n}", "target": 0, "cwe": [], "project": "librsvg", "commit_id": "34c95743ca692ea0e44778e41a7c0a129363de84", "hash": 154854794031262788121293916855161073085, "size": 21, "message": "Store node type separately in RsvgNode\n\nThe node name (formerly RsvgNode:type) cannot be used to infer\nthe sub-type of RsvgNode that we're dealing with, since for unknown\nelements we put type = node-name. This lead to a (potentially exploitable)\ncrash e.g. when the element name started with \"fe\" which tricked\nthe old code into considering it as a RsvgFilterPrimitive.\n\nCVE-2011-3146\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=658014", "idx": 154}
{"func": "fm_mgr_config_init\r\n(\r\n\t\t\t\t\tOUT\tp_fm_config_conx_hdlt\t\t*p_hdl,\r\n\t\t\t\tIN\t\tint\t\t\t\t\t\t\tinstance,\r\n\tOPTIONAL\tIN\t\tchar\t\t\t\t\t\t*rem_address,\r\n\tOPTIONAL\tIN\t\tchar\t\t\t\t\t\t*community\r\n)\r\n{\r\n\tfm_config_conx_hdl      *hdl;\r\n\tfm_mgr_config_errno_t   res = FM_CONF_OK;\r\n\r\n\r\n\tif ( (hdl = calloc(1,sizeof(fm_config_conx_hdl))) == NULL )\r\n\t{\r\n\t\tres = FM_CONF_NO_MEM;\r\n\t\tgoto cleanup;\r\n\t}\r\n\r\n\thdl->instance = instance;\r\n\r\n\t*p_hdl = hdl;\r\n\r\n\t\t// connect to the snmp agent via localhost?\r\n\tif(!rem_address || (strcmp(rem_address,\"localhost\") == 0))\r\n\t{\r\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_SM) == FM_CONF_INIT_ERR )\r\n\t\t{\r\n\t\t\tres = FM_CONF_INIT_ERR;\r\n\t\t\tgoto cleanup;\r\n\t\t}\r\n\r\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_PM) == FM_CONF_INIT_ERR )\r\n\t\t{\r\n\t\t\tres = FM_CONF_INIT_ERR;\r\n\t\t\tgoto cleanup;\r\n\t\t}\r\n\r\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_FE) == FM_CONF_INIT_ERR )\r\n\t\t{\r\n\t\t\tres = FM_CONF_INIT_ERR;\r\n\t\t\tgoto cleanup;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\treturn res;\r\n\r\n\r\n\tcleanup:\r\n\r\n\tif ( hdl ) {\r\n\t\tfree(hdl);\r\n\t\thdl = NULL;\r\n\t}\r\n\r\n\treturn res;\r\n}\r", "target": 1, "cwe": ["CWE-362"], "project": "opa-fm", "commit_id": "c5759e7b76f5bf844be6c6641cc1b356bbc83869", "hash": 271488843839979966273874492148148901599, "size": 57, "message": "Fix scripts and code that use well-known tmp files.", "idx": 155}
{"func": "do_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t    name = tagstack[tagstackidx].tagname;\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}", "target": 1, "cwe": ["CWE-416"], "project": "vim", "commit_id": "adce965162dd89bf29ee0e5baf53652e7515762c", "hash": 126478621754533124439278167196869287849, "size": 679, "message": "patch 9.0.0246: using freed memory when 'tagfunc' deletes the buffer\n\nProblem:    Using freed memory when 'tagfunc' deletes the buffer.\nSolution:   Make a copy of the tag name.", "idx": 156}
{"func": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\t(void)a; /* UNUSED */\n\t(void)fd; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)mode; /* UNUSED */\n\t(void)set; /* UNUSED */\n\t(void)clear; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}", "target": 1, "cwe": ["CWE-59"], "project": "libarchive", "commit_id": "e2ad1a2c3064fa9eba6274b3641c4c1beed25c0b", "hash": 73175865392357514292679963403383848346, "size": 11, "message": "Never follow symlinks when setting file flags on Linux\n\nWhen opening a file descriptor to set file flags on linux, ensure\nno symbolic links are followed. This fixes the case when an archive\ncontains a directory entry followed by a symlink entry with the same\npath. The fixup code would modify file flags of the symlink target.", "idx": 157}
{"func": "static void io_req_drop_files(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->inflight_lock, flags);\n\tlist_del(&req->inflight_entry);\n\tif (waitqueue_active(&ctx->inflight_wait))\n\t\twake_up(&ctx->inflight_wait);\n\tspin_unlock_irqrestore(&ctx->inflight_lock, flags);\n\treq->flags &= ~REQ_F_INFLIGHT;\n\treq->work.files = NULL;\n}", "target": 1, "cwe": [], "project": "linux", "commit_id": "0f2122045b946241a9e549c2a76cea54fa58a7ff", "hash": 78815404057282036547500393817457480118, "size": 13, "message": "io_uring: don't rely on weak ->files references\n\nGrab actual references to the files_struct. To avoid circular references\nissues due to this, we add a per-task note that keeps track of what\nio_uring contexts a task has used. When the tasks execs or exits its\nassigned files, we cancel requests based on this tracking.\n\nWith that, we can grab proper references to the files table, and no\nlonger need to rely on stashing away ring_fd and ring_file to check\nif the ring_fd may have been closed.\n\nCc: stable@vger.kernel.org # v5.5+\nReviewed-by: Pavel Begunkov <asml.silence@gmail.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>", "idx": 158}
{"func": "_public_ int sd_bus_default(sd_bus **ret) {\n        int (*bus_open)(sd_bus **) = NULL;\n        sd_bus **busp;\n\n        busp = bus_choose_default(&bus_open);\n        return bus_default(bus_open, busp, ret);\n}", "target": 0, "cwe": ["CWE-416"], "project": "systemd", "commit_id": "1068447e6954dc6ce52f099ed174c442cb89ed54", "hash": 141503872681491969708934210608573629919, "size": 7, "message": "sd-bus: introduce API for re-enqueuing incoming messages\n\nWhen authorizing via PolicyKit we want to process incoming method calls\ntwice: once to process and figure out that we need PK authentication,\nand a second time after we aquired PK authentication to actually execute\nthe operation. With this new call sd_bus_enqueue_for_read() we have a\nway to put an incoming message back into the read queue for this\npurpose.\n\nThis might have other uses too, for example debugging.", "idx": 159}
{"func": "Controller::constructHeaderForSessionProtocol(Request *req, char * restrict buffer,\n\tunsigned int &size, const SessionProtocolWorkingState &state, string delta_monotonic)\n{\n\tchar *pos = buffer;\n\tconst char *end = buffer + size;\n\n\tpos += sizeof(boost::uint32_t);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_URI\"));\n\tpos = appendData(pos, end, req->path.start->data, req->path.size);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PATH_INFO\"));\n\tpos = appendData(pos, end, state.path.data(), state.path.size());\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SCRIPT_NAME\"));\n\tif (state.hasBaseURI) {\n\t\tpos = appendData(pos, end, req->options.baseURI);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t} else {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"\"));\n\t}\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"QUERY_STRING\"));\n\tpos = appendData(pos, end, state.queryString.data(), state.queryString.size());\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_METHOD\"));\n\tpos = appendData(pos, end, state.methodStr);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_NAME\"));\n\tpos = appendData(pos, end, state.serverName);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PORT\"));\n\tpos = appendData(pos, end, state.serverPort);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_SOFTWARE\"));\n\tpos = appendData(pos, end, serverSoftware);\n\tpos = appendData(pos, end, \"\", 1);\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PROTOCOL\"));\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP/1.1\"));\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_ADDR\"));\n\tif (state.remoteAddr != NULL) {\n\t\tpos = appendData(pos, end, state.remoteAddr);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t} else {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"127.0.0.1\"));\n\t}\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_PORT\"));\n\tif (state.remotePort != NULL) {\n\t\tpos = appendData(pos, end, state.remotePort);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t} else {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"0\"));\n\t}\n\n\tif (state.remoteUser != NULL) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_USER\"));\n\t\tpos = appendData(pos, end, state.remoteUser);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tif (state.contentType != NULL) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_TYPE\"));\n\t\tpos = appendData(pos, end, state.contentType);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tif (state.contentLength != NULL) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_LENGTH\"));\n\t\tpos = appendData(pos, end, state.contentLength);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_CONNECT_PASSWORD\"));\n\tpos = appendData(pos, end, req->session->getApiKey().toStaticString());\n\tpos = appendData(pos, end, \"\", 1);\n\n\tif (req->https) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTPS\"));\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"on\"));\n\t}\n\n\tif (req->options.analytics) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_TXN_ID\"));\n\t\tpos = appendData(pos, end, req->options.transaction->getTxnId());\n\t\tpos = appendData(pos, end, \"\", 1);\n\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_DELTA_MONOTONIC\"));\n\t\tpos = appendData(pos, end, delta_monotonic);\n\t\tpos = appendData(pos, end, \"\", 1);\n\t}\n\n\tif (req->upgraded()) {\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP_CONNECTION\"));\n\t\tpos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"upgrade\"));\n\t}\n\n\tServerKit::HeaderTable::Iterator it(req->headers);\n\twhile (*it != NULL) {\n\t\tif ((it->header->hash == HTTP_CONTENT_LENGTH.hash()\n\t\t\t|| it->header->hash == HTTP_CONTENT_TYPE.hash()\n\t\t\t|| it->header->hash == HTTP_CONNECTION.hash())\n\t\t && (psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-type\"))\n\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-length\"))\n\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"connection\"))))\n\t\t{\n\t\t\tit.next();\n\t\t\tcontinue;\n\t\t}\n\n\t\tpos = appendData(pos, end, P_STATIC_STRING(\"HTTP_\"));\n\t\tconst LString::Part *part = it->header->key.start;\n\t\twhile (part != NULL) {\n\t\t\tchar *start = pos;\n\t\t\tpos = appendData(pos, end, part->data, part->size);\n\t\t\thttpHeaderToScgiUpperCase((unsigned char *) start, pos - start);\n\t\t\tpart = part->next;\n\t\t}\n\t\tpos = appendData(pos, end, \"\", 1);\n\n\t\tpart = it->header->val.start;\n\t\twhile (part != NULL) {\n\t\t\tpos = appendData(pos, end, part->data, part->size);\n\t\t\tpart = part->next;\n\t\t}\n\t\tpos = appendData(pos, end, \"\", 1);\n\n\t\tit.next();\n\t}\n\n\tif (state.environmentVariablesData != NULL) {\n\t\tpos = appendData(pos, end, state.environmentVariablesData, state.environmentVariablesSize);\n\t}\n\n\tUint32Message::generate(buffer, pos - buffer - sizeof(boost::uint32_t));\n\n\tsize = pos - buffer;\n\treturn pos < end;\n}", "target": 1, "cwe": ["CWE-20", "CWE-476"], "project": "passenger", "commit_id": "ddb8ecc4ebf260e4967f57f271d4f5761abeac3e", "hash": 268675128554542724588552945220693308724, "size": 147, "message": "Fix CVE-2015-7519 header collision vulnerability", "idx": 160}
{"func": "ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\n\ncleanup:\n\tbrelse(bh);\n\n\treturn error;\n}", "target": 1, "cwe": ["CWE-241", "CWE-19"], "project": "linux", "commit_id": "82939d7999dfc1f1998c4b1c12e2f19edbdff272", "hash": 312645836590111437976393192682352150453, "size": 35, "message": "ext4: convert to mbcache2\n\nThe conversion is generally straightforward. The only tricky part is\nthat xattr block corresponding to found mbcache entry can get freed\nbefore we get buffer lock for that block. So we have to check whether\nthe entry is still valid after getting buffer lock.\n\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>", "idx": 161}
{"func": "main(int argc,\n     char *argv[])\n{\n    int ch;\n    double r;\n    double c;\n    int my_colors;\n    int f_option = 0;\n    int m_option = 2;\n    int r_option = 0;\n    int s_option = 1;\n    size_t need;\n    char *my_env;\n\n    while ((ch = getopt(argc, argv, \"T:efm:r:s:\")) != -1) {\n\tswitch (ch) {\n\tcase 'T':\n\t    need = 6 + strlen(optarg);\n\t    my_env = malloc(need);\n\t    _nc_SPRINTF(my_env, _nc_SLIMIT(need) \"TERM=%s\", optarg);\n\t    putenv(my_env);\n\t    break;\n#if HAVE_USE_ENV\n\tcase 'e':\n\t    use_env(TRUE);\n\t    break;\n#endif\n\tcase 'f':\n\t    f_option = 1;\n\t    break;\n\tcase 'm':\n\t    m_option = atoi(optarg);\n\t    break;\n\tcase 'r':\n\t    r_option = atoi(optarg);\n\t    break;\n\tcase 's':\n\t    s_option = atoi(optarg);\n\t    break;\n\tdefault:\n\t    usage();\n\t    break;\n\t}\n    }\n\n    SetupAlarm(r_option);\n    InitAndCatch(setupterm((char *) 0, 1, (int *) 0), onsig);\n\n    srand((unsigned) time(0));\n\n    outs(clear_screen);\n    outs(cursor_invisible);\n\n#define GetNumber(ln,sn) get_number(f_option ? #sn : 0, ln)\n    my_colors = GetNumber(max_colors, colors);\n    if (my_colors > 1) {\n\tif (!VALID_STRING(set_a_foreground)\n\t    || !VALID_STRING(set_a_background)\n\t    || (!VALID_STRING(orig_colors) && !VALID_STRING(orig_pair)))\n\t    my_colors = -1;\n    }\n\n    r = (double) (GetNumber(lines, lines) - (m_option * 2));\n    c = (double) (GetNumber(columns, cols) - (m_option * 2));\n    started = time((time_t *) 0);\n\n    while (!interrupted) {\n\tint x = (int) (c * ranf()) + m_option;\n\tint y = (int) (r * ranf()) + m_option;\n\tint p = (ranf() > 0.9) ? '*' : ' ';\n\n\ttputs(tparm3(cursor_address, y, x), 1, outc);\n\tif (my_colors > 0) {\n\t    int z = (int) (ranf() * my_colors);\n\t    if (ranf() > 0.01) {\n\t\ttputs(tparm2(set_a_foreground, z), 1, outc);\n\t    } else {\n\t\ttputs(tparm2(set_a_background, z), 1, outc);\n\t\tnapms(s_option);\n\t    }\n\t} else if (VALID_STRING(exit_attribute_mode)\n\t\t   && VALID_STRING(enter_reverse_mode)) {\n\t    if (ranf() <= 0.01) {\n\t\touts((ranf() > 0.6)\n\t\t     ? enter_reverse_mode\n\t\t     : exit_attribute_mode);\n\t\tnapms(s_option);\n\t    }\n\t}\n\toutc(p);\n\tfflush(stdout);\n\t++total_chars;\n    }\n    cleanup();\n    ExitProgram(EXIT_SUCCESS);\n}", "target": 1, "cwe": [], "project": "ncurses", "commit_id": "790a85dbd4a81d5f5d8dd02a44d84f01512ef443", "hash": 127382103677209287154823263947449729528, "size": 96, "message": "ncurses 6.2 - patch 20200531\n\n+ correct configure version-check/warnng for g++ to allow for 10.x\n+ re-enable \"bel\" in konsole-base (report by Nia Huang)\n+ add linux-s entry (patch by Alexandre Montaron).\n+ drop long-obsolete convert_configure.pl\n+ add test/test_parm.c, for checking tparm changes.\n+ improve parameter-checking for tparm, adding function _nc_tiparm() to\n  handle the most-used case, which accepts only numeric parameters\n  (report/testcase by \"puppet-meteor\").\n+ use a more conservative estimate of the buffer-size in lib_tparm.c's\n  save_text() and save_number(), in case the sprintf() function\n  passes-through unexpected characters from a format specifier\n  (report/testcase by \"puppet-meteor\").\n+ add a check for end-of-string in cvtchar to handle a malformed\n  string in infotocap (report/testcase by \"puppet-meteor\").", "idx": 162}
{"func": "void Magick::Image::solarize(const double factor_)\n{\n  modifyImage();\n  GetPPException;\n  SolarizeImage(image(),factor_,exceptionInfo);\n  ThrowImageException;\n}", "target": 0, "cwe": ["CWE-416"], "project": "ImageMagick", "commit_id": "8c35502217c1879cb8257c617007282eee3fe1cc", "hash": 239247537538639514922772816514898944074, "size": 7, "message": "Added missing return to avoid use after free.", "idx": 163}
{"func": "static SplineFont *SFD_GetFont( FILE *sfd,SplineFont *cidmaster,char *tok,\n\t\t\t\tint fromdir, char *dirname, float sfdversion )\n{\n    SplineFont *sf;\n    int realcnt, i, eof, mappos=-1, ch;\n    struct table_ordering *lastord = NULL;\n    struct axismap *lastaxismap = NULL;\n    struct named_instance *lastnamedinstance = NULL;\n    int pushedbacktok = false;\n    Encoding *enc = &custom;\n    struct remap *remap = NULL;\n    int haddupenc;\n    int old_style_order2 = false;\n    int had_layer_cnt=false;\n\n    orig_pos = 0;\t\t/* Only used for compatibility with extremely old sfd files */\n\n    sf = SplineFontEmpty();\n    if ( sfdversion>0 && sfdversion<2 ) {\n\t/* If it's an old style sfd file with old style features we need some */\n\t/*  extra data space to do the conversion from old to new */\n\tsf = realloc(sf,sizeof(SplineFont1));\n\tmemset(((uint8 *) sf) + sizeof(SplineFont),0,sizeof(SplineFont1)-sizeof(SplineFont));\n    }\n    sf->sfd_version = sfdversion;\n    sf->cidmaster = cidmaster;\n    sf->uni_interp = ui_unset;\n\tSFD_GetFontMetaDataData d;\n\tSFD_GetFontMetaDataData_Init( &d );\n    while ( 1 ) {\n\tif ( pushedbacktok )\n\t    pushedbacktok = false;\n\telse if ( (eof = getname(sfd,tok))!=1 ) {\n\t    if ( eof==-1 )\n    break;\n\t    geteol(sfd,tok);\n    continue;\n\t}\n\n\n\tbool wasMetadata = SFD_GetFontMetaData( sfd, tok, sf, &d );\n\thad_layer_cnt = d.had_layer_cnt;\n        if( wasMetadata )\n        {\n            // we have handled the token entirely\n            // inside SFD_GetFontMetaData() move to next token.\n            continue;\n        }\n        \n        \n\tif ( strmatch(tok,\"DisplaySize:\")==0 )\n\t{\n\t    getint(sfd,&sf->display_size);\n\t}\n\telse if ( strmatch(tok,\"DisplayLayer:\")==0 )\n\t{\n\t    getint(sfd,&sf->display_layer);\n\t}\n\telse if ( strmatch(tok,\"ExtremaBound:\")==0 )\n\t{\n\t    getint(sfd,&sf->extrema_bound);\n\t}\n\telse if ( strmatch(tok,\"WidthSeparation:\")==0 )\n\t{\n\t    getint(sfd,&sf->width_separation);\n\t}\n\telse if ( strmatch(tok,\"WinInfo:\")==0 )\n\t{\n\t    int temp1, temp2;\n\t    getint(sfd,&sf->top_enc);\n\t    getint(sfd,&temp1);\n\t    getint(sfd,&temp2);\n\t    if ( sf->top_enc<=0 ) sf->top_enc=-1;\n\t    if ( temp1<=0 ) temp1 = 16;\n\t    if ( temp2<=0 ) temp2 = 4;\n\t    sf->desired_col_cnt = temp1;\n\t    sf->desired_row_cnt = temp2;\n\t}\n\telse if ( strmatch(tok,\"AntiAlias:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->display_antialias = temp;\n\t}\n\telse if ( strmatch(tok,\"FitToEm:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->display_bbsized = temp;\n\t}\n\telse if ( strmatch(tok,\"OnlyBitmaps:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->onlybitmaps = temp;\n\t}\n\telse if ( strmatch(tok,\"Order2:\")==0 )\n\t{\n\t    getint(sfd,&old_style_order2);\n\t    sf->grid.order2 = old_style_order2;\n\t    sf->layers[ly_back].order2 = old_style_order2;\n\t    sf->layers[ly_fore].order2 = old_style_order2;\n\t}\n\telse if ( strmatch(tok,\"GridOrder2:\")==0 )\n\t{\n\t    int o2;\n\t    getint(sfd,&o2);\n\t    sf->grid.order2 = o2;\n\t}\n\telse if ( strmatch(tok,\"Encoding:\")==0 )\n\t{\n\t    enc = SFDGetEncoding(sfd,tok);\n\t    if ( sf->map!=NULL ) sf->map->enc = enc;\n\t}\n\telse if ( strmatch(tok,\"OldEncoding:\")==0 )\n\t{\n\t    /* old_encname =*/ (void) SFDGetEncoding(sfd,tok);\n\t}\n\telse if ( strmatch(tok,\"UnicodeInterp:\")==0 )\n\t{\n\t    sf->uni_interp = SFDGetUniInterp(sfd,tok,sf);\n\t}\n\telse if ( strmatch(tok,\"NameList:\")==0 )\n\t{\n\t    SFDGetNameList(sfd,tok,sf);\n\t}\n\telse if ( strmatch(tok,\"Compacted:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->compacted = temp;\n\t}\n\telse if ( strmatch(tok,\"Registry:\")==0 )\n\t{\n\t    geteol(sfd,tok);\n\t    sf->cidregistry = copy(tok);\n\t}\n\n\n\t//////////\n\n\n\telse if ( strmatch(tok,\"Ordering:\")==0 ) {\n\t    geteol(sfd,tok);\n\t    sf->ordering = copy(tok);\n\t} else if ( strmatch(tok,\"Supplement:\")==0 ) {\n\t    getint(sfd,&sf->supplement);\n\t} else if ( strmatch(tok,\"RemapN:\")==0 ) {\n\t    int n;\n\t    getint(sfd,&n);\n\t    remap = calloc(n+1,sizeof(struct remap));\n\t    remap[n].infont = -1;\n\t    mappos = 0;\n\t    if ( sf->map!=NULL ) sf->map->remap = remap;\n\t} else if ( strmatch(tok,\"Remap:\")==0 ) {\n\t    uint32 f, l; int p;\n\t    gethex(sfd,&f);\n\t    gethex(sfd,&l);\n\t    getint(sfd,&p);\n\t    if ( remap!=NULL && remap[mappos].infont!=-1 ) {\n\t\tremap[mappos].firstenc = f;\n\t\tremap[mappos].lastenc = l;\n\t\tremap[mappos].infont = p;\n\t\tmappos++;\n\t    }\n\t} else if ( strmatch(tok,\"CIDVersion:\")==0 ) {\n\t    real temp;\n\t    getreal(sfd,&temp);\n\t    sf->cidversion = temp;\n\t} else if ( strmatch(tok,\"Grid\")==0 ) {\n\t    sf->grid.splines = SFDGetSplineSet(sfd,sf->grid.order2);\n\t} else if ( strmatch(tok,\"ScriptLang:\")==0 ) {\n\t    int i,j,k;\n\t    int imax, jmax, kmax;\n\t    if ( sf->sfd_version==0 || sf->sfd_version>=2 ) {\n\t\tIError( \"Script lang lists should not happen in version 2 sfd files.\" );\n                SplineFontFree(sf);\n                return NULL;\n\t    }\n\t    getint(sfd,&imax);\n\t    ((SplineFont1 *) sf)->sli_cnt = imax;\n\t    ((SplineFont1 *) sf)->script_lang = malloc((imax+1)*sizeof(struct script_record *));\n\t    ((SplineFont1 *) sf)->script_lang[imax] = NULL;\n\t    for ( i=0; i<imax; ++i ) {\n\t\tgetint(sfd,&jmax);\n\t\t((SplineFont1 *) sf)->script_lang[i] = malloc((jmax+1)*sizeof(struct script_record));\n\t\t((SplineFont1 *) sf)->script_lang[i][jmax].script = 0;\n\t\tfor ( j=0; j<jmax; ++j ) {\n\t\t    ((SplineFont1 *) sf)->script_lang[i][j].script = gettag(sfd);\n\t\t    getint(sfd,&kmax);\n\t\t    ((SplineFont1 *) sf)->script_lang[i][j].langs = malloc((kmax+1)*sizeof(uint32));\n\t\t    ((SplineFont1 *) sf)->script_lang[i][j].langs[kmax] = 0;\n\t\t    for ( k=0; k<kmax; ++k ) {\n\t\t\t((SplineFont1 *) sf)->script_lang[i][j].langs[k] = gettag(sfd);\n\t\t    }\n\t\t}\n\t    }\n\t} else if ( strmatch(tok,\"TeXData:\")==0 ) {\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->texdata.type = temp;\n\t    getint(sfd, &temp);\n\t    if ( sf->design_size==0 ) {\n\t    \tsf->design_size = (5*temp+(1<<18))>>19;\n\t    }\n\t    for ( i=0; i<22; ++i ) {\n\t\tint foo;\n\t\tgetint(sfd,&foo);\n\t\tsf->texdata.params[i]=foo;\n\t    }\n\t} else if ( strnmatch(tok,\"AnchorClass\",11)==0 ) {\n\t    char *name;\n\t    AnchorClass *lastan = NULL, *an;\n\t    int old = strchr(tok,'2')==NULL;\n\t    while ( (name=SFDReadUTF7Str(sfd))!=NULL ) {\n\t\tan = chunkalloc(old ? sizeof(AnchorClass1) : sizeof(AnchorClass));\n\t\tan->name = name;\n\t\tif ( old ) {\n\t\t    getname(sfd,tok);\n\t\t    if ( tok[0]=='0' && tok[1]=='\\0' )\n\t\t\t((AnchorClass1 *) an)->feature_tag = 0;\n\t\t    else {\n\t\t\tif ( tok[1]=='\\0' ) { tok[1]=' '; tok[2] = 0; }\n\t\t\tif ( tok[2]=='\\0' ) { tok[2]=' '; tok[3] = 0; }\n\t\t\tif ( tok[3]=='\\0' ) { tok[3]=' '; tok[4] = 0; }\n\t\t\t((AnchorClass1 *) an)->feature_tag = (tok[0]<<24) | (tok[1]<<16) | (tok[2]<<8) | tok[3];\n\t\t    }\n\t\t    while ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\t    ungetc(ch,sfd);\n\t\t    if ( isdigit(ch)) {\n\t\t\tint temp;\n\t\t\tgetint(sfd,&temp);\n\t\t\t((AnchorClass1 *) an)->flags = temp;\n\t\t    }\n\t\t    while ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\t    ungetc(ch,sfd);\n\t\t    if ( isdigit(ch)) {\n\t\t\tint temp;\n\t\t\tgetint(sfd,&temp);\n\t\t\t((AnchorClass1 *) an)->script_lang_index = temp;\n\t\t    } else\n\t\t\t((AnchorClass1 *) an)->script_lang_index = 0xffff;\t\t/* Will be fixed up later */\n\t\t    while ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\t    ungetc(ch,sfd);\n\t\t    if ( isdigit(ch)) {\n\t\t\tint temp;\n\t\t\tgetint(sfd,&temp);\n\t\t\t((AnchorClass1 *) an)->merge_with = temp;\n\t\t    } else\n\t\t\t((AnchorClass1 *) an)->merge_with = 0xffff;\t\t\t/* Will be fixed up later */\n\t\t} else {\n                    char *subtable_name = SFDReadUTF7Str(sfd);\n                    if ( subtable_name!=NULL)                                           /* subtable is optional */\n\t\t        an->subtable = SFFindLookupSubtableAndFreeName(sf,subtable_name);\n                }\n\t\twhile ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\tungetc(ch,sfd);\n\t\tif ( isdigit(ch) ) {\n\t\t    /* Early versions of SfdFormat 2 had a number here */\n\t\t    int temp;\n\t\t    getint(sfd,&temp);\n\t\t    an->type = temp;\n\t\t} else if ( old ) {\n\t\t    if ( ((AnchorClass1 *) an)->feature_tag==CHR('c','u','r','s'))\n\t\t\tan->type = act_curs;\n\t\t    else if ( ((AnchorClass1 *) an)->feature_tag==CHR('m','k','m','k'))\n\t\t\tan->type = act_mkmk;\n\t\t    else\n\t\t\tan->type = act_mark;\n\t\t} else {\n\t\t    an->type = act_mark;\n\t\t    if( an->subtable && an->subtable->lookup )\n\t\t    {\n\t\t\tswitch ( an->subtable->lookup->lookup_type )\n\t\t\t{\n\t\t\tcase gpos_cursive:\n\t\t\t    an->type = act_curs;\n\t\t\t    break;\n\t\t\tcase gpos_mark2base:\n\t\t\t    an->type = act_mark;\n\t\t\t    break;\n\t\t\tcase gpos_mark2ligature:\n\t\t\t    an->type = act_mklg;\n\t\t\t    break;\n\t\t\tcase gpos_mark2mark:\n\t\t\t    an->type = act_mkmk;\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    an->type = act_mark;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif ( lastan==NULL )\n\t\t    sf->anchor = an;\n\t\telse\n\t\t    lastan->next = an;\n\t\tlastan = an;\n\t    }\n\t} else if ( strncmp(tok,\"MATH:\",5)==0 ) {\n\t    SFDParseMathItem(sfd,sf,tok);\n\t} else if ( strmatch(tok,\"TableOrder:\")==0 ) {\n\t    int temp;\n\t    struct table_ordering *ord;\n\t    if ( sfdversion==0 || sfdversion>=2 ) {\n\t\tIError(\"Table ordering specified in version 2 sfd file.\\n\" );\n                SplineFontFree(sf);\n                return NULL;\n\t    }\n\t    ord = chunkalloc(sizeof(struct table_ordering));\n\t    ord->table_tag = gettag(sfd);\n\t    getint(sfd,&temp);\n\t    ord->ordered_features = malloc((temp+1)*sizeof(uint32));\n\t    ord->ordered_features[temp] = 0;\n\t    for ( i=0; i<temp; ++i ) {\n\t\twhile ( isspace((ch=nlgetc(sfd))) );\n\t\tif ( ch=='\\'' ) {\n\t\t    ungetc(ch,sfd);\n\t\t    ord->ordered_features[i] = gettag(sfd);\n\t\t} else if ( ch=='<' ) {\n\t\t    int f,s;\n\t\t    fscanf(sfd,\"%d,%d>\", &f, &s );\n\t\t    ord->ordered_features[i] = (f<<16)|s;\n\t\t}\n\t    }\n\t    if ( lastord==NULL )\n\t\t((SplineFont1 *) sf)->orders = ord;\n\t    else\n\t\tlastord->next = ord;\n\t    lastord = ord;\n\t} else if ( strmatch(tok,\"BeginPrivate:\")==0 ) {\n\t    SFDGetPrivate(sfd,sf);\n\t} else if ( strmatch(tok,\"BeginSubrs:\")==0 ) {\t/* leave in so we don't croak on old sfd files */\n\t    SFDGetSubrs(sfd);\n\t} else if ( strmatch(tok,\"PickledData:\")==0 ) {\n\t    if (sf->python_persistent != NULL) {\n#if defined(_NO_PYTHON)\n\t      free( sf->python_persistent );\t/* It's a string of pickled data which we leave as a string */\n#else\n\t      PyFF_FreePythonPersistent(sf->python_persistent);\n#endif\n\t      sf->python_persistent = NULL;\n\t    }\n\t    sf->python_persistent = SFDUnPickle(sfd, 0);\n\t    sf->python_persistent_has_lists = 0;\n\t} else if ( strmatch(tok,\"PickledDataWithLists:\")==0 ) {\n\t    if (sf->python_persistent != NULL) {\n#if defined(_NO_PYTHON)\n\t      free( sf->python_persistent );\t/* It's a string of pickled data which we leave as a string */\n#else\n\t      PyFF_FreePythonPersistent(sf->python_persistent);\n#endif\n\t      sf->python_persistent = NULL;\n\t    }\n\t    sf->python_persistent = SFDUnPickle(sfd, 1);\n\t    sf->python_persistent_has_lists = 1;\n\t} else if ( strmatch(tok,\"MMCounts:\")==0 ) {\n\t    MMSet *mm = sf->mm = chunkalloc(sizeof(MMSet));\n\t    getint(sfd,&mm->instance_count);\n\t    getint(sfd,&mm->axis_count);\n\t    ch = nlgetc(sfd);\n\t    if ( ch!=' ' )\n\t\tungetc(ch,sfd);\n\t    else { int temp;\n\t\tgetint(sfd,&temp);\n\t\tmm->apple = temp;\n\t\tgetint(sfd,&mm->named_instance_count);\n\t    }\n\t    mm->instances = calloc(mm->instance_count,sizeof(SplineFont *));\n\t    mm->positions = malloc(mm->instance_count*mm->axis_count*sizeof(real));\n\t    mm->defweights = malloc(mm->instance_count*sizeof(real));\n\t    mm->axismaps = calloc(mm->axis_count,sizeof(struct axismap));\n\t    if ( mm->named_instance_count!=0 )\n\t\tmm->named_instances = calloc(mm->named_instance_count,sizeof(struct named_instance));\n\t} else if ( strmatch(tok,\"MMAxis:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tfor ( i=0; i<mm->axis_count; ++i ) {\n\t\t    getname(sfd,tok);\n\t\t    mm->axes[i] = copy(tok);\n\t\t}\n\t    }\n\t} else if ( strmatch(tok,\"MMPositions:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tfor ( i=0; i<mm->axis_count*mm->instance_count; ++i )\n\t\t    getreal(sfd,&mm->positions[i]);\n\t    }\n\t} else if ( strmatch(tok,\"MMWeights:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tfor ( i=0; i<mm->instance_count; ++i )\n\t\t    getreal(sfd,&mm->defweights[i]);\n\t    }\n\t} else if ( strmatch(tok,\"MMAxisMap:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tint index, points;\n\t\tgetint(sfd,&index); getint(sfd,&points);\n\t\tmm->axismaps[index].points = points;\n\t\tmm->axismaps[index].blends = malloc(points*sizeof(real));\n\t\tmm->axismaps[index].designs = malloc(points*sizeof(real));\n\t\tfor ( i=0; i<points; ++i ) {\n\t\t    getreal(sfd,&mm->axismaps[index].blends[i]);\n\t\t    while ( (ch=nlgetc(sfd))!=EOF && isspace(ch));\n\t\t    ungetc(ch,sfd);\n\t\t    if ( (ch=nlgetc(sfd))!='=' )\n\t\t\tungetc(ch,sfd);\n\t\t    else if ( (ch=nlgetc(sfd))!='>' )\n\t\t\tungetc(ch,sfd);\n\t\t    getreal(sfd,&mm->axismaps[index].designs[i]);\n\t\t}\n\t\tlastaxismap = &mm->axismaps[index];\n\t\tlastnamedinstance = NULL;\n\t    }\n\t} else if ( strmatch(tok,\"MMNamedInstance:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tint index;\n\t\tgetint(sfd,&index);\n\t\tmm->named_instances[index].coords = malloc(mm->axis_count*sizeof(real));\n\t\tfor ( i=0; i<mm->axis_count; ++i )\n\t\t    getreal(sfd,&mm->named_instances[index].coords[i]);\n\t\tlastnamedinstance = &mm->named_instances[index];\n\t\tlastaxismap = NULL;\n\t    }\n\t} else if ( strmatch(tok,\"MacName:\")==0 ) {\n\t    struct macname *names = SFDParseMacNames(sfd,tok);\n\t    if ( lastaxismap!=NULL )\n\t\tlastaxismap->axisnames = names;\n\t    else if ( lastnamedinstance !=NULL )\n\t\tlastnamedinstance->names = names;\n\t    pushedbacktok = true;\n\t} else if ( strmatch(tok,\"MMCDV:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL )\n\t\tmm->cdv = SFDParseMMSubroutine(sfd);\n\t} else if ( strmatch(tok,\"MMNDV:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL )\n\t\tmm->ndv = SFDParseMMSubroutine(sfd);\n\t} else if ( strmatch(tok,\"BeginMMFonts:\")==0 ) {\n\t    int cnt;\n\t    getint(sfd,&cnt);\n\t    getint(sfd,&realcnt);\n\t    ff_progress_change_stages(cnt);\n\t    ff_progress_change_total(realcnt);\n\t    MMInferStuff(sf->mm);\n    break;\n\t} else if ( strmatch(tok,\"BeginSubFonts:\")==0 ) {\n\t    getint(sfd,&sf->subfontcnt);\n\t    sf->subfonts = calloc(sf->subfontcnt,sizeof(SplineFont *));\n\t    getint(sfd,&realcnt);\n\t    sf->map = EncMap1to1(realcnt);\n\t    ff_progress_change_stages(2);\n\t    ff_progress_change_total(realcnt);\n    break;\n\t} else if ( strmatch(tok,\"BeginChars:\")==0 ) {\n\t    int charcnt;\n\t    getint(sfd,&charcnt);\n\t    if (charcnt<enc->char_cnt) {\n\t\tIError(\"SFD file specifies too few slots for its encoding.\\n\" );\nexit( 1 );\n\t    }\n\t    if ( getint(sfd,&realcnt)!=1 || realcnt==-1 )\n\t\trealcnt = charcnt;\n\t    else\n\t\t++realcnt;\t\t/* value saved is max glyph, not glyph cnt */\n\t    ff_progress_change_total(realcnt);\n\t    sf->glyphcnt = sf->glyphmax = realcnt;\n\t    sf->glyphs = calloc(realcnt,sizeof(SplineChar *));\n\t    if ( cidmaster!=NULL ) {\n\t\tsf->map = cidmaster->map;\n\t    } else {\n\t\tsf->map = EncMapNew(charcnt,realcnt,enc);\n\t\tsf->map->remap = remap;\n\t    }\n\t    SFDSizeMap(sf->map,sf->glyphcnt,charcnt);\n    break;\n#if HANYANG\n\t} else if ( strmatch(tok,\"BeginCompositionRules\")==0 ) {\n\t    sf->rules = SFDReadCompositionRules(sfd);\n#endif\n\t} else {\n\t    /* If we don't understand it, skip it */\n\t    geteol(sfd,tok);\n\t}\n    }\n\n    if ( fromdir )\n\tsf = SFD_FigureDirType(sf,tok,dirname,enc,remap,had_layer_cnt);\n    else if ( sf->subfontcnt!=0 ) {\n\tff_progress_change_stages(2*sf->subfontcnt);\n\tfor ( i=0; i<sf->subfontcnt; ++i ) {\n\t    if ( i!=0 )\n\t\tff_progress_next_stage();\n\t    sf->subfonts[i] = SFD_GetFont(sfd,sf,tok,fromdir,dirname,sfdversion);\n\t}\n    } else if ( sf->mm!=NULL ) {\n\tMMSet *mm = sf->mm;\n\tff_progress_change_stages(2*(mm->instance_count+1));\n\tfor ( i=0; i<mm->instance_count; ++i ) {\n\t    if ( i!=0 )\n\t\tff_progress_next_stage();\n\t    mm->instances[i] = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);\n\t    EncMapFree(mm->instances[i]->map); mm->instances[i]->map=NULL;\n\t    mm->instances[i]->mm = mm;\n\t}\n\tff_progress_next_stage();\n\tmm->normal = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);\n\tmm->normal->mm = mm;\n\tsf->mm = NULL;\n\tSplineFontFree(sf);\n\tsf = mm->normal;\n\tif ( sf->map->enc!=&custom ) {\n\t    EncMap *map;\n\t    MMMatchGlyphs(mm);\t\t/* sfd files from before the encoding change can have mismatched orig pos */\n\t    map = EncMapFromEncoding(sf,sf->map->enc);\n\t    EncMapFree(sf->map);\n\t    sf->map = map;\n\t}\n    } else {\n\twhile ( SFDGetChar(sfd,sf,had_layer_cnt)!=NULL ) {\n\t    ff_progress_next();\n\t}\n\tff_progress_next_stage();\n    }\n    haddupenc = false;\n    while ( getname(sfd,tok)==1 ) {\n\tif ( strcmp(tok,\"EndSplineFont\")==0 || strcmp(tok,\"EndSubSplineFont\")==0 )\n    break;\n\telse if ( strcmp(tok,\"BitmapFont:\")==0 )\n\t    SFDGetBitmapFont(sfd,sf,false,NULL);\n\telse if ( strmatch(tok,\"DupEnc:\")==0 ) {\n\t    int enc, orig;\n\t    haddupenc = true;\n\t    if ( getint(sfd,&enc) && getint(sfd,&orig) && sf->map!=NULL ) {\n\t\tSFDSetEncMap(sf,orig,enc);\n\t    }\n\t}\n    }\n    if ( sf->cidmaster==NULL )\n\tSFDFixupRefs(sf);\n\n    if ( !haddupenc )\n\tSFD_DoAltUnis(sf);\n    else\n\tAltUniFigure(sf,sf->map,true);\n    if ( sf->sfd_version<2 )\n\tSFD_AssignLookups((SplineFont1 *) sf);\n    if ( !d.hadtimes )\n\tSFTimesFromFile(sf,sfd);\n    // Make a blank encoding if there are no characters so as to avoid crashes later.\n    if (sf->map == NULL) sf->map = EncMapNew(sf->glyphcnt,sf->glyphcnt,&custom);\n\n    SFDFixupUndoRefs(sf);\nreturn( sf );\n}", "target": 1, "cwe": ["CWE-416"], "project": "fontforge", "commit_id": "048a91e2682c1a8936ae34dbc7bd70291ec05410", "hash": 108140177552726643560174545630365351595, "size": 558, "message": "Fix for #4084 Use-after-free (heap) in the SFD_GetFontMetaData() function\nFix for #4086 NULL pointer dereference in the SFDGetSpiros() function\nFix for #4088 NULL pointer dereference in the SFD_AssignLookups() function\nAdd empty sf->fontname string if it isn't set, fixing #4089 #4090 and many\n  other potential issues (many downstream calls to strlen() on the value).", "idx": 164}
{"func": "static struct dst_entry *rxe_find_route6(struct net_device *ndev,\n\t\t\t\t\t struct in6_addr *saddr,\n\t\t\t\t\t struct in6_addr *daddr)\n{\n\treturn NULL;\n}", "target": 1, "cwe": [], "project": "net", "commit_id": "6c8991f41546c3c472503dff1ea9daaddf9331c2", "hash": 284778951407466133230452763426709859685, "size": 6, "message": "net: ipv6_stub: use ip6_dst_lookup_flow instead of ip6_dst_lookup\n\nipv6_stub uses the ip6_dst_lookup function to allow other modules to\nperform IPv6 lookups. However, this function skips the XFRM layer\nentirely.\n\nAll users of ipv6_stub->ip6_dst_lookup use ip_route_output_flow (via the\nip_route_output_key and ip_route_output helpers) for their IPv4 lookups,\nwhich calls xfrm_lookup_route(). This patch fixes this inconsistent\nbehavior by switching the stub to ip6_dst_lookup_flow, which also calls\nxfrm_lookup_route().\n\nThis requires some changes in all the callers, as these two functions\ntake different arguments and have different return types.\n\nFixes: 5f81bd2e5d80 (\"ipv6: export a stub for IPv6 symbols used by vxlan\")\nReported-by: Xiumei Mu <xmu@redhat.com>\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 165}
{"func": "static enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't realloc input buffer\\n\");\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = read(c->sfd, c->rbuf + c->rbytes, avail);\n        if (res > 0) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.bytes_read += res;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}", "target": 1, "cwe": ["CWE-20"], "project": "memcached", "commit_id": "75cc83685e103bc8ba380a57468c8f04413033f9", "hash": 117264606103154996111933518755446823126, "size": 53, "message": "Issue 102: Piping null to the server will crash it", "idx": 166}
{"func": "read_header_block (PSDimage  *img_a,\n                   FILE      *f,\n                   GError   **error)\n{\n  guint16  version;\n  gchar    sig[4];\n  gchar    buf[6];\n\n  if (fread (sig, 4, 1, f) < 1\n      || fread (&version, 2, 1, f) < 1\n      || fread (buf, 6, 1, f) < 1\n      || fread (&img_a->channels, 2, 1, f) < 1\n      || fread (&img_a->rows, 4, 1, f) < 1\n      || fread (&img_a->columns, 4, 1, f) < 1\n      || fread (&img_a->bps, 2, 1, f) < 1\n      || fread (&img_a->color_mode, 2, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n  version = GUINT16_FROM_BE (version);\n  img_a->channels = GUINT16_FROM_BE (img_a->channels);\n  img_a->rows = GUINT32_FROM_BE (img_a->rows);\n  img_a->columns = GUINT32_FROM_BE (img_a->columns);\n  img_a->bps = GUINT16_FROM_BE (img_a->bps);\n  img_a->color_mode = GUINT16_FROM_BE (img_a->color_mode);\n\n  IFDBG(1) g_debug (\"\\n\\n\\tSig: %.4s\\n\\tVer: %d\\n\\tChannels: \"\n                    \"%d\\n\\tSize: %dx%d\\n\\tBPS: %d\\n\\tMode: %d\\n\",\n                    sig, version, img_a->channels,\n                    img_a->columns, img_a->rows,\n                    img_a->bps, img_a->color_mode);\n\n  if (memcmp (sig, \"8BPS\", 4) != 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Not a valid photoshop document file\"));\n      return -1;\n    }\n\n  if (version != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported file format version: %d\"), version);\n      return -1;\n    }\n\n  if (img_a->channels > MAX_CHANNELS)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Too many channels in file: %d\"), img_a->channels);\n      return -1;\n    }\n\n    /* Photoshop CS (version 8) supports 300000 x 300000, but this\n       is currently larger than GIMP_MAX_IMAGE_SIZE */\n\n  if (img_a->rows < 1 || img_a->rows > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image height: %d\"),\n                  img_a->rows);\n      return -1;\n    }\n\n  if (img_a->columns < 1 || img_a->columns > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image width: %d\"),\n                  img_a->columns);\n      return -1;\n    }\n\n  /* img_a->rows is sanitized above, so a division by zero is avoided here */\n  if (img_a->columns > G_MAXINT32 / img_a->rows)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported or invalid image size: %dx%d\"),\n                   img_a->columns, img_a->rows);\n      return -1;\n    }\n\n  if (img_a->color_mode != PSD_BITMAP\n      && img_a->color_mode != PSD_GRAYSCALE\n      && img_a->color_mode != PSD_INDEXED\n      && img_a->color_mode != PSD_RGB\n      && img_a->color_mode != PSD_DUOTONE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported color mode: %s\"),\n                   get_psd_color_mode_name (img_a->color_mode));\n      return -1;\n    }\n\n  /* Warnings for format conversions */\n  switch (img_a->bps)\n    {\n      case 16:\n        IFDBG(3) g_debug (\"16 Bit Data\");\n        if (CONVERSION_WARNINGS)\n          g_message (_(\"Warning:\\n\"\n                       \"The image you are loading has 16 bits per channel. GIMP \"\n                       \"can only handle 8 bit, so it will be converted for you. \"\n                       \"Information will be lost because of this conversion.\"));\n        break;\n\n      case 8:\n        IFDBG(3) g_debug (\"8 Bit Data\");\n        break;\n\n      case 1:\n        IFDBG(3) g_debug (\"1 Bit Data\");\n        break;\n\n      default:\n        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                    _(\"Unsupported bit depth: %d\"), img_a->bps);\n        return -1;\n        break;\n    }\n\n  return 0;\n}", "target": 0, "cwe": ["CWE-190"], "project": "gimp", "commit_id": "88eccea84aa375197cc04a2a0e2e29debb56bfa5", "hash": 96991920556253812898989426542915567092, "size": 123, "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)", "idx": 167}
{"func": "dissect_80211n_mac(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, int data_len, gboolean add_subtree, guint32 *n_mac_flags, guint32 *ampdu_id, struct ieee_802_11_phdr *phdr)\n{\n    proto_tree  *ftree       = tree;\n    ptvcursor_t *csr;\n    int          subtree_off = add_subtree ? 4 : 0;\n    guint32      flags;\n\n    phdr->phy = PHDR_802_11_PHY_11N;\n\n    *n_mac_flags = tvb_get_letohl(tvb, offset + subtree_off);\n    *ampdu_id = tvb_get_letohl(tvb, offset + 4 + subtree_off);\n\n    if (add_subtree) {\n        ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11n_mac, NULL, \"802.11n MAC\");\n        add_ppi_field_header(tvb, ftree, &offset);\n        data_len -= 4; /* Subtract field header length */\n    }\n\n    if (data_len != PPI_80211N_MAC_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        THROW(ReportedBoundsError);\n    }\n\n    csr = ptvcursor_new(ftree, tvb, offset);\n\n    flags = tvb_get_letohl(tvb, ptvcursor_current_offset(csr));\n    phdr->phy_info.info_11n.presence_flags = PHDR_802_11N_HAS_SHORT_GI|PHDR_802_11N_HAS_GREENFIELD;\n    phdr->phy_info.info_11n.short_gi = ((flags & DOT11N_FLAG_SHORT_GI) != 0);\n    phdr->phy_info.info_11n.greenfield = ((flags & DOT11N_FLAG_GREENFIELD) != 0);\n    ptvcursor_add_with_subtree(csr, hf_80211n_mac_flags, 4, ENC_LITTLE_ENDIAN,\n                               ett_dot11n_mac_flags);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_greenfield, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_ht20_40, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_rx_guard_interval, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_duplicate_rx, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_aggregate, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_more_aggregates, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211n_mac_flags_delimiter_crc_after, 4, ENC_LITTLE_ENDIAN); /* Last */\n    ptvcursor_pop_subtree(csr);\n\n    ptvcursor_add(csr, hf_80211n_mac_ampdu_id, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211n_mac_num_delimiters, 1, ENC_LITTLE_ENDIAN);\n\n    if (add_subtree) {\n        ptvcursor_add(csr, hf_80211n_mac_reserved, 3, ENC_LITTLE_ENDIAN);\n    }\n\n    ptvcursor_free(csr);\n}", "target": 0, "cwe": ["CWE-20"], "project": "wireshark", "commit_id": "2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7", "hash": 65281139466616001207774224424284460910, "size": 49, "message": "The WTAP_ENCAP_ETHERNET dissector needs to be passed a struct eth_phdr.\n\nWe now require that.  Make it so.\n\nBug: 12440\nChange-Id: Iffee520976b013800699bde3c6092a3e86be0d76\nReviewed-on: https://code.wireshark.org/review/15424\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "idx": 168}
{"func": "static void cil_reset_netifcon(struct cil_netifcon *netifcon)\n{\n\tif (netifcon->if_context_str == NULL) {\n\t\tcil_reset_context(netifcon->if_context);\n\t}\n\n\tif (netifcon->packet_context_str == NULL) {\n\t\tcil_reset_context(netifcon->packet_context);\n\t}\n}", "target": 0, "cwe": ["CWE-416"], "project": "selinux", "commit_id": "f34d3d30c8325e4847a6b696fe7a3936a8a361f3", "hash": 266989301306506351876653892961154046816, "size": 10, "message": "libsepol/cil: Destroy classperms list when resetting classpermission\n\nNicolas Iooss reports:\n  A few months ago, OSS-Fuzz found a crash in the CIL compiler, which\n  got reported as\n  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28648 (the title\n  is misleading, or is caused by another issue that conflicts with the\n  one I report in this message). Here is a minimized CIL policy which\n  reproduces the issue:\n\n  (class CLASS (PERM))\n  (classorder (CLASS))\n  (sid SID)\n  (sidorder (SID))\n  (user USER)\n  (role ROLE)\n  (type TYPE)\n  (category CAT)\n  (categoryorder (CAT))\n  (sensitivity SENS)\n  (sensitivityorder (SENS))\n  (sensitivitycategory SENS (CAT))\n  (allow TYPE self (CLASS (PERM)))\n  (roletype ROLE TYPE)\n  (userrole USER ROLE)\n  (userlevel USER (SENS))\n  (userrange USER ((SENS)(SENS (CAT))))\n  (sidcontext SID (USER ROLE TYPE ((SENS)(SENS))))\n\n  (classpermission CLAPERM)\n\n  (optional OPT\n      (roletype nonexistingrole nonexistingtype)\n      (classpermissionset CLAPERM (CLASS (PERM)))\n  )\n\n  The CIL policy fuzzer (which mimics secilc built with clang Address\n  Sanitizer) reports:\n\n  ==36541==ERROR: AddressSanitizer: heap-use-after-free on address\n  0x603000004f98 at pc 0x56445134c842 bp 0x7ffe2a256590 sp\n  0x7ffe2a256588\n  READ of size 8 at 0x603000004f98 thread T0\n      #0 0x56445134c841 in __cil_verify_classperms\n  /selinux/libsepol/src/../cil/src/cil_verify.c:1620:8\n      #1 0x56445134a43e in __cil_verify_classpermission\n  /selinux/libsepol/src/../cil/src/cil_verify.c:1650:9\n      #2 0x56445134a43e in __cil_pre_verify_helper\n  /selinux/libsepol/src/../cil/src/cil_verify.c:1715:8\n      #3 0x5644513225ac in cil_tree_walk_core\n  /selinux/libsepol/src/../cil/src/cil_tree.c:272:9\n      #4 0x564451322ab1 in cil_tree_walk\n  /selinux/libsepol/src/../cil/src/cil_tree.c:316:7\n      #5 0x5644513226af in cil_tree_walk_core\n  /selinux/libsepol/src/../cil/src/cil_tree.c:284:9\n      #6 0x564451322ab1 in cil_tree_walk\n  /selinux/libsepol/src/../cil/src/cil_tree.c:316:7\n      #7 0x5644512b88fd in cil_pre_verify\n  /selinux/libsepol/src/../cil/src/cil_post.c:2510:7\n      #8 0x5644512b88fd in cil_post_process\n  /selinux/libsepol/src/../cil/src/cil_post.c:2524:7\n      #9 0x5644511856ff in cil_compile\n  /selinux/libsepol/src/../cil/src/cil.c:564:7\n\nThe classperms list of a classpermission rule is created and filled\nin when classpermissionset rules are processed, so it doesn't own any\npart of the list and shouldn't retain any of it when it is reset.\n\nDestroy the classperms list (without destroying the data in it)  when\nresetting a classpermission rule.\n\nReported-by: Nicolas Iooss <nicolas.iooss@m4x.org>\nSigned-off-by: James Carter <jwcart2@gmail.com>", "idx": 169}
{"func": "bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,\n\t\t\t      files_struct *fsp)\n{\n\tif (!check_fsp_open(conn, req, fsp)) {\n\t\treturn false;\n\t}\n\n\tif (fsp->fsp_flags.is_directory) {\n\t\treturn false;\n\t}\n\n\tif (fsp->fake_file_handle == NULL) {\n\t\treturn false;\n\t}\n\n\tif (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {\n\t\treturn false;\n\t}\n\n\tif (fsp->fake_file_handle->private_data == NULL) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "target": 0, "cwe": ["CWE-200"], "project": "samba", "commit_id": "3ddc9344c2fa7461336899fbddb0bb80995e9170", "hash": 210078218551108177164154094812085243881, "size": 25, "message": "CVE-2022-32742: s3: smbd: Harden the smbreq_bufrem() macro.\n\nFixes the raw.write.bad-write test.\n\nNB. We need the two (==0) changes in source3/smbd/smb2_reply.c\nas the gcc optimizer now knows that the return from\nsmbreq_bufrem() can never be less than zero.\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=15085\n\nRemove knownfail.\n\nSigned-off-by: Jeremy Allison <jra@samba.org>\nReviewed-by: David Disseldorp <ddiss@samba.org>\n\nAutobuild-User(master): Jule Anger <janger@samba.org>\nAutobuild-Date(master): Wed Jul 27 11:46:46 UTC 2022 on sn-devel-184", "idx": 170}
{"func": "exec_instructions(ectx_T *ectx)\n{\n    int\t\tret = FAIL;\n    int\t\tsave_trylevel_at_start = ectx->ec_trylevel_at_start;\n    int\t\tdict_stack_len_at_start = dict_stack.ga_len;\n\n    // Start execution at the first instruction.\n    ectx->ec_iidx = 0;\n\n    // Only catch exceptions in this instruction list.\n    ectx->ec_trylevel_at_start = trylevel;\n\n    for (;;)\n    {\n\tstatic int  breakcheck_count = 0;  // using \"static\" makes it faster\n\tisn_T\t    *iptr;\n\ttypval_T    *tv;\n\n\tif (unlikely(++breakcheck_count >= 100))\n\t{\n\t    line_breakcheck();\n\t    breakcheck_count = 0;\n\t}\n\tif (unlikely(got_int))\n\t{\n\t    // Turn CTRL-C into an exception.\n\t    got_int = FALSE;\n\t    if (throw_exception(\"Vim:Interrupt\", ET_INTERRUPT, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t}\n\n\tif (unlikely(did_emsg && msg_list != NULL && *msg_list != NULL))\n\t{\n\t    // Turn an error message into an exception.\n\t    did_emsg = FALSE;\n\t    if (throw_exception(*msg_list, ET_ERROR, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t    *msg_list = NULL;\n\t}\n\n\tif (unlikely(did_throw))\n\t{\n\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t    trycmd_T    *trycmd = NULL;\n\t    int\t\tindex = trystack->ga_len;\n\n\t    // An exception jumps to the first catch, finally, or returns from\n\t    // the current function.\n\t    while (index > 0)\n\t    {\n\t\ttrycmd = ((trycmd_T *)trystack->ga_data) + index - 1;\n\t\tif (!trycmd->tcd_in_catch || trycmd->tcd_finally_idx != 0)\n\t\t    break;\n\t\t// In the catch and finally block of this try we have to go up\n\t\t// one level.\n\t\t--index;\n\t\ttrycmd = NULL;\n\t    }\n\t    if (trycmd != NULL && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t    {\n\t\tif (trycmd->tcd_in_catch)\n\t\t{\n\t\t    // exception inside \":catch\", jump to \":finally\" once\n\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t}\n\t\telse\n\t\t    // jump to first \":catch\"\n\t\t    ectx->ec_iidx = trycmd->tcd_catch_idx;\n\t\ttrycmd->tcd_in_catch = TRUE;\n\t\tdid_throw = FALSE;  // don't come back here until :endtry\n\t\ttrycmd->tcd_did_throw = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// Not inside try or need to return from current functions.\n\t\t// Push a dummy return value.\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t\t{\n\t\t    // At the toplevel we are done.\n\t\t    need_rethrow = TRUE;\n\t\t    if (handle_closure_in_use(ectx, FALSE) == FAIL)\n\t\t\tgoto theend;\n\t\t    goto done;\n\t\t}\n\n\t\tif (func_return(ectx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    continue;\n\t}\n\n\tiptr = &ectx->ec_instr[ectx->ec_iidx++];\n\tswitch (iptr->isn_type)\n\t{\n\t    // execute Ex command line\n\t    case ISN_EXEC:\n\t\tif (exec_command(iptr) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // execute Ex command line split at NL characters.\n\t    case ISN_EXEC_SPLIT:\n\t\t{\n\t\t    source_cookie_T cookie;\n\t\t    char_u\t    *line;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    cookie.nextline = iptr->isn_arg.string;\n\t\t    line = get_split_sourceline(0, &cookie, 0, 0);\n\t\t    if (do_cmdline(line,\n\t\t\t\tget_split_sourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED)\n\t\t\t\t\t\t\t\t\t== FAIL\n\t\t\t\t|| did_emsg)\n\t\t    {\n\t\t\tvim_free(line);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    vim_free(line);\n\t\t}\n\t\tbreak;\n\n\t    // execute Ex command line that is only a range\n\t    case ISN_EXECRANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*error = NULL;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = CMD_SIZE;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    parse_cmd_address(&ea, &error, FALSE);\n\t\t    if (ea.cmd == NULL)\n\t\t\tgoto on_error;\n\t\t    if (error == NULL)\n\t\t\terror = ex_range_without_command(&ea);\n\t\t    if (error != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(error);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Evaluate an expression with legacy syntax, push it onto the\n\t    // stack.\n\t    case ISN_LEGACY_EVAL:\n\t\t{\n\t\t    char_u  *arg = iptr->isn_arg.string;\n\t\t    int\t    res;\n\t\t    int\t    save_flags = cmdmod.cmod_flags;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    init_tv(tv);\n\t\t    cmdmod.cmod_flags |= CMOD_LEGACY;\n\t\t    res = eval0(arg, tv, NULL, &EVALARG_EVALUATE);\n\t\t    cmdmod.cmod_flags = save_flags;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // push typeval VAR_INSTR with instructions to be executed\n\t    case ISN_INSTR:\n\t\t{\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->vval.v_instr = ALLOC_ONE(instr_T);\n\t\t    if (tv->vval.v_instr == NULL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\n\t\t    tv->v_type = VAR_INSTR;\n\t\t    tv->vval.v_instr->instr_ectx = ectx;\n\t\t    tv->vval.v_instr->instr_instr = iptr->isn_arg.instr;\n\t\t}\n\t\tbreak;\n\n\t    // execute :substitute with an expression\n\t    case ISN_SUBSTITUTE:\n\t\t{\n\t\t    subs_T\t\t*subs = &iptr->isn_arg.subs;\n\t\t    source_cookie_T\tcookie;\n\t\t    struct subs_expr_S\t*save_instr = substitute_instr;\n\t\t    struct subs_expr_S\tsubs_instr;\n\t\t    int\t\t\tres;\n\n\t\t    subs_instr.subs_ectx = ectx;\n\t\t    subs_instr.subs_instr = subs->subs_instr;\n\t\t    subs_instr.subs_status = OK;\n\t\t    substitute_instr = &subs_instr;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    // This is very much like ISN_EXEC\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    res = do_cmdline(subs->subs_cmd,\n\t\t\t\tgetsourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n\t\t    substitute_instr = save_instr;\n\n\t\t    if (res == FAIL || did_emsg\n\t\t\t\t\t     || subs_instr.subs_status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINISH:\n\t\tgoto done;\n\n\t    case ISN_REDIRSTART:\n\t\t// create a dummy entry for var_redir_str()\n\t\tif (alloc_redir_lval() == FAIL)\n\t\t    goto on_error;\n\n\t\t// The output is stored in growarray \"redir_ga\" until\n\t\t// redirection ends.\n\t\tinit_redir_ga();\n\t\tredir_vname = 1;\n\t\tbreak;\n\n\t    case ISN_REDIREND:\n\t\t{\n\t\t    char_u *res = get_clear_redir_ga();\n\n\t\t    // End redirection, put redirected text on the stack.\n\t\t    clear_redir_lval();\n\t\t    redir_vname = 0;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(res);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_STRING;\n\t\t    tv->vval.v_string = res;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CEXPR_AUCMD:\n#ifdef FEAT_QUICKFIX\n\t\tif (trigger_cexpr_autocmd(iptr->isn_arg.number) == FAIL)\n\t\t    goto on_error;\n#endif\n\t\tbreak;\n\n\t    case ISN_CEXPR_CORE:\n#ifdef FEAT_QUICKFIX\n\t\t{\n\t\t    exarg_T ea;\n\t\t    int\t    res;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = iptr->isn_arg.cexpr.cexpr_ref->cer_cmdidx;\n\t\t    ea.forceit = iptr->isn_arg.cexpr.cexpr_ref->cer_forceit;\n\t\t    ea.cmdlinep = &iptr->isn_arg.cexpr.cexpr_ref->cer_cmdline;\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    res = cexpr_core(&ea, tv);\n\t\t    clear_tv(tv);\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    // execute Ex command from pieces on the stack\n\t    case ISN_EXECCONCAT:\n\t\t{\n\t\t    int\t    count = iptr->isn_arg.number;\n\t\t    size_t  len = 0;\n\t\t    int\t    pass;\n\t\t    int\t    i;\n\t\t    char_u  *cmd = NULL;\n\t\t    char_u  *str;\n\n\t\t    for (pass = 1; pass <= 2; ++pass)\n\t\t    {\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t{\n\t\t\t    tv = STACK_TV_BOT(i - count);\n\t\t\t    str = tv->vval.v_string;\n\t\t\t    if (str != NULL && *str != NUL)\n\t\t\t    {\n\t\t\t\tif (pass == 2)\n\t\t\t\t    STRCPY(cmd + len, str);\n\t\t\t\tlen += STRLEN(str);\n\t\t\t    }\n\t\t\t    if (pass == 2)\n\t\t\t\tclear_tv(tv);\n\t\t\t}\n\t\t\tif (pass == 1)\n\t\t\t{\n\t\t\t    cmd = alloc(len + 1);\n\t\t\t    if (unlikely(cmd == NULL))\n\t\t\t\tgoto theend;\n\t\t\t    len = 0;\n\t\t\t}\n\t\t    }\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    do_cmdline_cmd(cmd);\n\t\t    vim_free(cmd);\n\t\t}\n\t\tbreak;\n\n\t    // execute :echo {string} ...\n\t    case ISN_ECHO:\n\t\t{\n\t\t    int count = iptr->isn_arg.echo.echo_count;\n\t\t    int\tatstart = TRUE;\n\t\t    int needclr = TRUE;\n\t\t    int\tidx;\n\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\techo_one(tv, iptr->isn_arg.echo.echo_with_white,\n\t\t\t\t\t\t\t   &atstart, &needclr);\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    if (needclr)\n\t\t\tmsg_clr_eos();\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t}\n\t\tbreak;\n\n\t    // :execute {string} ...\n\t    // :echomsg {string} ...\n\t    // :echoconsole {string} ...\n\t    // :echoerr {string} ...\n\t    case ISN_EXECUTE:\n\t    case ISN_ECHOMSG:\n\t    case ISN_ECHOCONSOLE:\n\t    case ISN_ECHOERR:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    garray_T\tga;\n\t\t    char_u\tbuf[NUMBUFLEN];\n\t\t    char_u\t*p;\n\t\t    int\t\tlen;\n\t\t    int\t\tfailed = FALSE;\n\t\t    int\t\tidx;\n\n\t\t    ga_init2(&ga, 1, 80);\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    if (tv->v_type == VAR_CHANNEL\n\t\t\t\t\t\t      || tv->v_type == VAR_JOB)\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tsemsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t    vartype_name(tv->v_type));\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tp = tv_get_string_buf(tv, buf);\n\t\t\t}\n\t\t\telse\n\t\t\t    p = tv_stringify(tv, buf);\n\n\t\t\tlen = (int)STRLEN(p);\n\t\t\tif (GA_GROW_FAILS(&ga, len + 2))\n\t\t\t    failed = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (ga.ga_len > 0)\n\t\t\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t\t\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t\t\t    ga.ga_len += len;\n\t\t\t}\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t    if (failed)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    if (ga.ga_data != NULL)\n\t\t    {\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    do_cmdline_cmd((char_u *)ga.ga_data);\n\t\t\t    if (did_emsg)\n\t\t\t    {\n\t\t\t\tga_clear(&ga);\n\t\t\t\tgoto on_error;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    msg_sb_eol();\n\t\t\t    if (iptr->isn_type == ISN_ECHOMSG)\n\t\t\t    {\n\t\t\t\tmsg_attr(ga.ga_data, echo_attr);\n\t\t\t\tout_flush();\n\t\t\t    }\n\t\t\t    else if (iptr->isn_type == ISN_ECHOCONSOLE)\n\t\t\t    {\n\t\t\t\tui_write(ga.ga_data, (int)STRLEN(ga.ga_data),\n\t\t\t\t\t\t\t\t\t TRUE);\n\t\t\t\tui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\temsg(ga.ga_data);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    ga_clear(&ga);\n\t\t}\n\t\tbreak;\n\n\t    // load local variable or argument\n\t    case ISN_LOAD:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(STACK_TV_VAR(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load v: variable\n\t    case ISN_LOADV:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(get_vim_var_tv(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load s: variable in Vim9 script\n\t    case ISN_LOADSCRIPT:\n\t\t{\n\t\t    scriptref_T\t*sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    allocate_if_null(sv->sv_tv);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    copy_tv(sv->sv_tv, STACK_TV_BOT(0));\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load s: variable in old script\n\t    case ISN_LOADS:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_str), name);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: variable\n\t    case ISN_LOADG:\n\t    case ISN_LOADB:\n\t    case ISN_LOADW:\n\t    case ISN_LOADT:\n\t\t{\n\t\t    dictitem_T *di = NULL;\n\t\t    hashtab_T *ht = NULL;\n\t\t    char namespace;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    namespace = 'g';\n\t\t\t    break;\n\t\t\tcase ISN_LOADB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    namespace = 'b';\n\t\t\t    break;\n\t\t\tcase ISN_LOADW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    namespace = 'w';\n\t\t\t    break;\n\t\t\tcase ISN_LOADT:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    namespace = 't';\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    di = find_var_in_ht(ht, 0, iptr->isn_arg.string, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_char_str),\n\t\t\t\t\t     namespace, iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load autoload variable\n\t    case ISN_LOADAUTO:\n\t\t{\n\t\t    char_u *name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (eval_variable(name, (int)STRLEN(name), 0,\n\t\t\t      STACK_TV_BOT(0), NULL, EVAL_VAR_VERBOSE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: namespace\n\t    case ISN_LOADGDICT:\n\t    case ISN_LOADBDICT:\n\t    case ISN_LOADWDICT:\n\t    case ISN_LOADTDICT:\n\t\t{\n\t\t    dict_T *d = NULL;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADGDICT: d = get_globvar_dict(); break;\n\t\t\tcase ISN_LOADBDICT: d = curbuf->b_vars; break;\n\t\t\tcase ISN_LOADWDICT: d = curwin->w_vars; break;\n\t\t\tcase ISN_LOADTDICT: d = curtab->tp_vars; break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = d;\n\t\t    ++d->dv_refcount;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load &option\n\t    case ISN_LOADOPT:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    // This is not expected to fail, name is checked during\n\t\t    // compilation: don't set SOURCING_LNUM.\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (eval_option(&name, &optval, TRUE) == FAIL)\n\t\t\tgoto theend;\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load $ENV\n\t    case ISN_LOADENV:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    // name is always valid, checked when compiling\n\t\t    (void)eval_env_var(&name, &optval, TRUE);\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load @register\n\t    case ISN_LOADREG:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\t// This may result in NULL, which should be equivalent to an\n\t\t// empty string.\n\t\ttv->vval.v_string = get_reg_contents(\n\t\t\t\t\t  iptr->isn_arg.number, GREG_EXPR_SRC);\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store local variable\n\t    case ISN_STORE:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.number);\n\t\tclear_tv(tv);\n\t\t*tv = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // store s: variable in old script\n\t    case ISN_STORES:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name + 2, TRUE);\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (di == NULL)\n\t\t\tstore_var(name, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store script-local variable in Vim9 script\n\t    case ISN_STORESCRIPT:\n\t\t{\n\t\t    scriptref_T\t    *sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t    *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    --ectx->ec_stack.ga_len;\n\n\t\t    // \"const\" and \"final\" are checked at compile time, locking\n\t\t    // the value needs to be checked here.\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (value_check_lock(sv->sv_tv->v_lock, sv->sv_name, FALSE))\n\t\t    {\n\t\t\tclear_tv(STACK_TV_BOT(0));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    clear_tv(sv->sv_tv);\n\t\t    *sv->sv_tv = *STACK_TV_BOT(0);\n\t\t}\n\t\tbreak;\n\n\t    // store option\n\t    case ISN_STOREOPT:\n\t    case ISN_STOREFUNCOPT:\n\t\t{\n\t\t    char_u\t*opt_name = iptr->isn_arg.storeopt.so_name;\n\t\t    int\t\topt_flags = iptr->isn_arg.storeopt.so_flags;\n\t\t    long\tn = 0;\n\t\t    char_u\t*s = NULL;\n\t\t    char\t*msg;\n\t\t    char_u\tnumbuf[NUMBUFLEN];\n\t\t    char_u\t*tofree = NULL;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->v_type == VAR_STRING)\n\t\t    {\n\t\t\ts = tv->vval.v_string;\n\t\t\tif (s == NULL)\n\t\t\t    s = (char_u *)\"\";\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_STOREFUNCOPT)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t// If the option can be set to a function reference or\n\t\t\t// a lambda and the passed value is a function\n\t\t\t// reference, then convert it to the name (string) of\n\t\t\t// the function reference.\n\t\t\ts = tv2string(tv, &tofree, numbuf, 0);\n\t\t\tif (s == NULL || *s == NUL)\n\t\t\t{\n\t\t\t    clear_tv(tv);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\t// must be VAR_NUMBER, CHECKTYPE makes sure\n\t\t\tn = tv->vval.v_number;\n\t\t    msg = set_option_value(opt_name, n, s, opt_flags);\n\t\t    clear_tv(tv);\n\t\t    vim_free(tofree);\n\t\t    if (msg != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(msg));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store $ENV\n\t    case ISN_STOREENV:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_BOT(0);\n\t\tvim_setenv_ext(iptr->isn_arg.string, tv_get_string(tv));\n\t\tclear_tv(tv);\n\t\tbreak;\n\n\t    // store @r\n\t    case ISN_STOREREG:\n\t\t{\n\t\t    int\treg = iptr->isn_arg.number;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    write_reg_contents(reg, tv_get_string(tv), -1, FALSE);\n\t\t    clear_tv(tv);\n\t\t}\n\t\tbreak;\n\n\t    // store v: variable\n\t    case ISN_STOREV:\n\t\t--ectx->ec_stack.ga_len;\n\t\tif (set_vim_var_tv(iptr->isn_arg.number, STACK_TV_BOT(0))\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    // should not happen, type is checked when compiling\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // store g:/b:/w:/t: variable\n\t    case ISN_STOREG:\n\t    case ISN_STOREB:\n\t    case ISN_STOREW:\n\t    case ISN_STORET:\n\t\t{\n\t\t    dictitem_T\t*di;\n\t\t    hashtab_T\t*ht;\n\t\t    char_u\t*name = iptr->isn_arg.string + 2;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_STOREG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    break;\n\t\t\tcase ISN_STOREB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STOREW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STORET:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    di = find_var_in_ht(ht, 0, name, TRUE);\n\t\t    if (di == NULL)\n\t\t\tstore_var(iptr->isn_arg.string, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t    goto on_error;\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store an autoload variable\n\t    case ISN_STOREAUTO:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tset_var(iptr->isn_arg.string, STACK_TV_BOT(-1), TRUE);\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t--ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store number in local variable\n\t    case ISN_STORENR:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.storenr.stnr_idx);\n\t\tclear_tv(tv);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = iptr->isn_arg.storenr.stnr_val;\n\t\tbreak;\n\n\t    // store value in list or dict variable\n\t    case ISN_STOREINDEX:\n\t\t{\n\t\t    vartype_T\tdest_type = iptr->isn_arg.vartype;\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -3 value to be stored\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    tv = STACK_TV_BOT(-3);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (dest_type == VAR_ANY)\n\t\t    {\n\t\t\tdest_type = tv_dest->v_type;\n\t\t\tif (dest_type == VAR_DICT)\n\t\t\t    status = do_2string(tv_idx, TRUE, FALSE);\n\t\t\telse if (dest_type == VAR_LIST\n\t\t\t\t\t       && tv_idx->v_type != VAR_NUMBER)\n\t\t\t{\n\t\t\t    emsg(_(e_number_expected));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t    }\n\t\t    else if (dest_type != tv_dest->v_type)\n\t\t    {\n\t\t\t// just in case, should be OK\n\t\t\tsemsg(_(e_expected_str_but_got_str),\n\t\t\t\t    vartype_name(dest_type),\n\t\t\t\t    vartype_name(tv_dest->v_type));\n\t\t\tstatus = FAIL;\n\t\t    }\n\n\t\t    if (status == OK && dest_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tlist_T\t    *list = tv_dest->vval.v_list;\n\n\t\t\tif (list == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_list_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < 0 && list->lv_len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = list->lv_len + lidx;\n\t\t\tif (lidx < 0 || lidx > list->lv_len)\n\t\t\t{\n\t\t\t    semsg(_(e_list_index_out_of_range_nr), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < list->lv_len)\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list, lidx);\n\n\t\t\t    if (error_if_locked(li->li_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_list_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing list item\n\t\t\t    clear_tv(&li->li_tv);\n\t\t\t    li->li_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(list->lv_lock,\n\t\t\t\t\t\t\t e_cannot_change_list))\n\t\t\t\tgoto on_error;\n\t\t\t    // append to list, only fails when out of memory\n\t\t\t    if (list_append_tv(list, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_DICT)\n\t\t    {\n\t\t\tchar_u\t\t*key = tv_idx->vval.v_string;\n\t\t\tdict_T\t\t*dict = tv_dest->vval.v_dict;\n\t\t\tdictitem_T\t*di;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (dict == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_dictionary_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (key == NULL)\n\t\t\t    key = (char_u *)\"\";\n\t\t\tdi = dict_find(dict, key, -1);\n\t\t\tif (di != NULL)\n\t\t\t{\n\t\t\t    if (error_if_locked(di->di_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_dict_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing value\n\t\t\t    clear_tv(&di->di_tv);\n\t\t\t    di->di_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(dict->dv_lock,\n\t\t\t\t\t\t\t e_cannot_change_dict))\n\t\t\t\tgoto on_error;\n\t\t\t    // add to dict, only fails when out of memory\n\t\t\t    if (dict_add_tv(dict, (char *)key, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_BLOB)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tblob_T\t    *blob = tv_dest->vval.v_blob;\n\t\t\tvarnumber_T nr;\n\t\t\tint\t    error = FALSE;\n\t\t\tint\t    len;\n\n\t\t\tif (blob == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_blob_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tlen = blob_len(blob);\n\t\t\tif (lidx < 0 && len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = len + lidx;\n\n\t\t\t// Can add one byte at the end.\n\t\t\tif (lidx < 0 || lidx > len)\n\t\t\t{\n\t\t\t    semsg(_(e_blob_index_out_of_range_nr), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (value_check_lock(blob->bv_lock,\n\t\t\t\t\t\t      (char_u *)\"blob\", FALSE))\n\t\t\t    goto on_error;\n\t\t\tnr = tv_get_number_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t\tblob_set_append(blob, lidx, nr);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str), vartype_name(dest_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t    {\n\t\t\tclear_tv(tv);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store value in blob range\n\t    case ISN_STORERANGE:\n\t\t{\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -4 value to be stored\n\t\t    // -3 first index or \"none\"\n\t\t    // -2 second index or \"none\"\n\t\t    // -1 destination list or blob\n\t\t    tv = STACK_TV_BOT(-4);\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\tn1;\n\t\t\tlong\tn2;\n\t\t\tint\terror = FALSE;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = (long)tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = list_len(tv_dest->vval.v_list) - 1;\n\t\t\t    else\n\t\t\t\tn2 = (long)tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T *li1 = check_range_index_one(\n\t\t\t\t\ttv_dest->vval.v_list, &n1, FALSE);\n\n\t\t\t\tif (li1 == NULL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    status = check_range_index_two(\n\t\t\t\t\t    tv_dest->vval.v_list,\n\t\t\t\t\t    &n1, li1, &n2, FALSE);\n\t\t\t\t    if (status != FAIL)\n\t\t\t\t\tstatus = list_assign_range(\n\t\t\t\t\t\ttv_dest->vval.v_list,\n\t\t\t\t\t\ttv->vval.v_list,\n\t\t\t\t\t\tn1,\n\t\t\t\t\t\tn2,\n\t\t\t\t\t\ttv_idx2->v_type == VAR_SPECIAL,\n\t\t\t\t\t\t(char_u *)\"=\",\n\t\t\t\t\t\t(char_u *)\"[unknown]\");\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tvarnumber_T n1;\n\t\t\tvarnumber_T n2;\n\t\t\tint\t    error = FALSE;\n\n\t\t\tn1 = tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = blob_len(tv_dest->vval.v_blob) - 1;\n\t\t\t    else\n\t\t\t\tn2 = tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlong  bloblen = blob_len(tv_dest->vval.v_blob);\n\n\t\t\t\tif (check_blob_index(bloblen,\n\t\t\t\t\t\t\t     n1, FALSE) == FAIL\n\t\t\t\t\t|| check_blob_range(bloblen,\n\t\t\t\t\t\t\tn1, n2, FALSE) == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    status = blob_set_range(\n\t\t\t\t\t     tv_dest->vval.v_blob, n1, n2, tv);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\temsg(_(e_blob_required));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 4;\n\t\t    clear_tv(tv);\n\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // load or store variable or argument from outer scope\n\t    case ISN_LOADOUTER:\n\t    case ISN_STOREOUTER:\n\t\t{\n\t\t    int\t\tdepth = iptr->isn_arg.outer.outer_depth;\n\t\t    outer_T\t*outer = ectx->ec_outer_ref == NULL ? NULL\n\t\t\t\t\t\t: ectx->ec_outer_ref->or_outer;\n\n\t\t    while (depth > 1 && outer != NULL)\n\t\t    {\n\t\t\touter = outer->out_up;\n\t\t\t--depth;\n\t\t    }\n\t\t    if (outer == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx\n\t\t\t\t\t\t || ectx->ec_outer_ref == NULL)\n\t\t\t    // Possibly :def function called from legacy\n\t\t\t    // context.\n\t\t\t    emsg(_(e_closure_called_from_invalid_context));\n\t\t\telse\n\t\t\t    iemsg(\"LOADOUTER depth more than scope levels\");\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = ((typval_T *)outer->out_stack->ga_data)\n\t\t\t\t    + outer->out_frame_idx + STACK_FRAME_SIZE\n\t\t\t\t    + iptr->isn_arg.outer.outer_idx;\n\t\t    if (iptr->isn_type == ISN_LOADOUTER)\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tclear_tv(tv);\n\t\t\t*tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // unlet item in list or dict variable\n\t    case ISN_UNLETINDEX:\n\t\t{\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    if (tv_dest->v_type == VAR_DICT)\n\t\t    {\n\t\t\t// unlet a dict item, index must be a string\n\t\t\tif (tv_idx->v_type != VAR_STRING)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_expected_str_but_got_str),\n\t\t\t\t\tvartype_name(VAR_STRING),\n\t\t\t\t\tvartype_name(tv_idx->v_type));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    dict_T\t*d = tv_dest->vval.v_dict;\n\t\t\t    char_u\t*key = tv_idx->vval.v_string;\n\t\t\t    dictitem_T  *di = NULL;\n\n\t\t\t    if (d != NULL && value_check_lock(\n\t\t\t\t\t\t      d->dv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tif (key == NULL)\n\t\t\t\t    key = (char_u *)\"\";\n\t\t\t\tif (d != NULL)\n\t\t\t\t    di = dict_find(d, key, (int)STRLEN(key));\n\t\t\t\tif (di == NULL)\n\t\t\t\t{\n\t\t\t\t    // NULL dict is equivalent to empty dict\n\t\t\t\t    semsg(_(e_key_not_present_in_dictionary), key);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (var_check_fixed(di->di_flags,\n\t\t\t\t\t\t\t\t   NULL, FALSE)\n\t\t\t\t\t|| var_check_ro(di->di_flags,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    dictitem_remove(d, di);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// unlet a List item, index must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx) == FAIL)\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn = (long)tv_idx->vval.v_number;\n\n\t\t\t    if (l != NULL && value_check_lock(\n\t\t\t\t\t\t      l->lv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T\t*li = list_find(l, n);\n\n\t\t\t\tif (li == NULL)\n\t\t\t\t{\n\t\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t    semsg(_(e_list_index_out_of_range_nr), n);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (value_check_lock(li->li_tv.v_lock,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    listitem_remove(l, li);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 2;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // unlet range of items in list variable\n\t    case ISN_UNLETRANGE:\n\t\t{\n\t\t    // Stack contains:\n\t\t    // -3 index1\n\t\t    // -2 index2\n\t\t    // -1 dict or list\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// indexes must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx1) == FAIL\n\t\t\t\t|| (tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t && check_for_number(tv_idx2) == FAIL))\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn1 = (long)tv_idx1->vval.v_number;\n\t\t\t    long\tn2 = tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t    ? 0 : (long)tv_idx2->vval.v_number;\n\t\t\t    listitem_T\t*li;\n\n\t\t\t    li = list_find_index(l, &n1);\n\t\t\t    if (li == NULL)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (n1 < 0)\n\t\t\t\t    n1 = list_idx_of_item(l, li);\n\t\t\t\tif (n2 < 0)\n\t\t\t\t{\n\t\t\t\t    listitem_T *li2 = list_find(l, n2);\n\n\t\t\t\t    if (li2 == NULL)\n\t\t\t\t\tstatus = FAIL;\n\t\t\t\t    else\n\t\t\t\t\tn2 = list_idx_of_item(l, li2);\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t&& n2 < n1)\n\t\t\t\t{\n\t\t\t\t    semsg(_(e_list_index_out_of_range_nr), n2);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& list_unlet_range(l, li, NULL, n1,\n\t\t\t\t\t    tv_idx2->v_type != VAR_SPECIAL, n2)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // push constant\n\t    case ISN_PUSHNR:\n\t    case ISN_PUSHBOOL:\n\t    case ISN_PUSHSPEC:\n\t    case ISN_PUSHF:\n\t    case ISN_PUSHS:\n\t    case ISN_PUSHBLOB:\n\t    case ISN_PUSHFUNC:\n\t    case ISN_PUSHCHANNEL:\n\t    case ISN_PUSHJOB:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_lock = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tswitch (iptr->isn_type)\n\t\t{\n\t\t    case ISN_PUSHNR:\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHBOOL:\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHSPEC:\n\t\t\ttv->v_type = VAR_SPECIAL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n#ifdef FEAT_FLOAT\n\t\t    case ISN_PUSHF:\n\t\t\ttv->v_type = VAR_FLOAT;\n\t\t\ttv->vval.v_float = iptr->isn_arg.fnumber;\n\t\t\tbreak;\n#endif\n\t\t    case ISN_PUSHBLOB:\n\t\t\tblob_copy(iptr->isn_arg.blob, tv);\n\t\t\tbreak;\n\t\t    case ISN_PUSHFUNC:\n\t\t\ttv->v_type = VAR_FUNC;\n\t\t\tif (iptr->isn_arg.string == NULL)\n\t\t\t    tv->vval.v_string = NULL;\n\t\t\telse\n\t\t\t    tv->vval.v_string =\n\t\t\t\t\t     vim_strsave(iptr->isn_arg.string);\n\t\t\tbreak;\n\t\t    case ISN_PUSHCHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_CHANNEL;\n\t\t\ttv->vval.v_channel = iptr->isn_arg.channel;\n\t\t\tif (tv->vval.v_channel != NULL)\n\t\t\t    ++tv->vval.v_channel->ch_refcount;\n#endif\n\t\t\tbreak;\n\t\t    case ISN_PUSHJOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_JOB;\n\t\t\ttv->vval.v_job = iptr->isn_arg.job;\n\t\t\tif (tv->vval.v_job != NULL)\n\t\t\t    ++tv->vval.v_job->jv_refcount;\n#endif\n\t\t\tbreak;\n\t\t    default:\n\t\t\ttv->v_type = VAR_STRING;\n\t\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\tiptr->isn_arg.string == NULL\n\t\t\t\t\t? (char_u *)\"\" : iptr->isn_arg.string);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_UNLET:\n\t\tif (do_unlet(iptr->isn_arg.unlet.ul_name,\n\t\t\t\t       iptr->isn_arg.unlet.ul_forceit) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\t    case ISN_UNLETENV:\n\t\tvim_unsetenv(iptr->isn_arg.unlet.ul_name);\n\t\tbreak;\n\n\t    case ISN_LOCKUNLOCK:\n\t\t{\n\t\t    typval_T\t*lval_root_save = lval_root;\n\t\t    int\t\tres;\n\n\t\t    // Stack has the local variable, argument the whole :lock\n\t\t    // or :unlock command, like ISN_EXEC.\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    lval_root = STACK_TV_BOT(0);\n\t\t    res = exec_command(iptr);\n\t\t    clear_tv(lval_root);\n\t\t    lval_root = lval_root_save;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LOCKCONST:\n\t\titem_lock(STACK_TV_BOT(-1), 100, TRUE, TRUE);\n\t\tbreak;\n\n\t    // create a list from items on the stack; uses a single allocation\n\t    // for the list header and the items\n\t    case ISN_NEWLIST:\n\t\tif (exe_newlist(iptr->isn_arg.number, ectx) == FAIL)\n\t\t    goto theend;\n\t\tbreak;\n\n\t    // create a dict from items on the stack\n\t    case ISN_NEWDICT:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    dict_T\t*dict = dict_alloc();\n\t\t    dictitem_T\t*item;\n\t\t    char_u\t*key;\n\t\t    int\t\tidx;\n\n\t\t    if (unlikely(dict == NULL))\n\t\t\tgoto theend;\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\t// have already checked key type is VAR_STRING\n\t\t\ttv = STACK_TV_BOT(2 * (idx - count));\n\t\t\t// check key is unique\n\t\t\tkey = tv->vval.v_string == NULL\n\t\t\t\t\t    ? (char_u *)\"\" : tv->vval.v_string;\n\t\t\titem = dict_find(dict, key, -1);\n\t\t\tif (item != NULL)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_duplicate_key_in_dicitonary), key);\n\t\t\t    dict_unref(dict);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\titem = dictitem_alloc(key);\n\t\t\tclear_tv(tv);\n\t\t\tif (unlikely(item == NULL))\n\t\t\t{\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\titem->di_tv = *STACK_TV_BOT(2 * (idx - count) + 1);\n\t\t\titem->di_tv.v_lock = 0;\n\t\t\tif (dict_add(dict, item) == FAIL)\n\t\t\t{\n\t\t\t    // can this ever happen?\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t    }\n\n\t\t    if (count > 0)\n\t\t\tectx->ec_stack.ga_len -= 2 * count - 1;\n\t\t    else if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    else\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = dict;\n\t\t    ++dict->dv_refcount;\n\t\t}\n\t\tbreak;\n\n\t    // call a :def function\n\t    case ISN_DCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_dfunc(iptr->isn_arg.dfunc.cdf_idx,\n\t\t\t\tNULL,\n\t\t\t\tiptr->isn_arg.dfunc.cdf_argcount,\n\t\t\t\tectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a builtin function\n\t    case ISN_BCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_bfunc(iptr->isn_arg.bfunc.cbf_idx,\n\t\t\t      iptr->isn_arg.bfunc.cbf_argcount,\n\t\t\t      ectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a funcref or partial\n\t    case ISN_PCALL:\n\t\t{\n\t\t    cpfunc_T\t*pfunc = &iptr->isn_arg.pfunc;\n\t\t    int\t\tr;\n\t\t    typval_T\tpartial_tv;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (pfunc->cpf_top)\n\t\t    {\n\t\t\t// funcref is above the arguments\n\t\t\ttv = STACK_TV_BOT(-pfunc->cpf_argcount - 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Get the funcref from the stack.\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tpartial_tv = *STACK_TV_BOT(0);\n\t\t\ttv = &partial_tv;\n\t\t    }\n\t\t    r = call_partial(tv, pfunc->cpf_argcount, ectx);\n\t\t    if (tv == &partial_tv)\n\t\t\tclear_tv(&partial_tv);\n\t\t    if (r == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PCALL_END:\n\t\t// PCALL finished, arguments have been consumed and replaced by\n\t\t// the return value.  Now clear the funcref from the stack,\n\t\t// and move the return value in its place.\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t*STACK_TV_BOT(-1) = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // call a user defined function or funcref/partial\n\t    case ISN_UCALL:\n\t\t{\n\t\t    cufunc_T\t*cufunc = &iptr->isn_arg.ufunc;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (call_eval_func(cufunc->cuf_name, cufunc->cuf_argcount,\n\t\t\t\t\t\t\t   ectx, iptr) == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // return from a :def function call without a value\n\t    case ISN_RETURN_VOID:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_VOID;\n\t\ttv->vval.v_number = 0;\n\t\ttv->v_lock = 0;\n\t\t// FALLTHROUGH\n\n\t    // return from a :def function call with what is on the stack\n\t    case ISN_RETURN:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t    if (trycmd != NULL\n\t\t\t\t && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t\t    {\n\t\t\t// jump to \":finally\" or \":endtry\"\n\t\t\tif (trycmd->tcd_finally_idx != 0)\n\t\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t\telse\n\t\t\t    ectx->ec_iidx = trycmd->tcd_endtry_idx;\n\t\t\ttrycmd->tcd_return = TRUE;\n\t\t    }\n\t\t    else\n\t\t\tgoto func_return;\n\t\t}\n\t\tbreak;\n\n\t    // push a partial, a reference to a compiled function\n\t    case ISN_FUNCREF:\n\t\t{\n\t\t    partial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\t\t    ufunc_T\t*ufunc;\n\t\t    funcref_T\t*funcref = &iptr->isn_arg.funcref;\n\n\t\t    if (pt == NULL)\n\t\t\tgoto theend;\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(pt);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (funcref->fr_func_name == NULL)\n\t\t    {\n\t\t\tdfunc_T\t*pt_dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t       + funcref->fr_dfunc_idx;\n\n\t\t\tufunc = pt_dfunc->df_ufunc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tufunc = find_func(funcref->fr_func_name, FALSE, NULL);\n\t\t    }\n\t\t    if (ufunc == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_function_reference_invalid));\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv->vval.v_partial = pt;\n\t\t    tv->v_type = VAR_PARTIAL;\n\t\t    tv->v_lock = 0;\n\t\t}\n\t\tbreak;\n\n\t    // Create a global function from a lambda.\n\t    case ISN_NEWFUNC:\n\t\t{\n\t\t    newfunc_T\t*newfunc = &iptr->isn_arg.newfunc;\n\n\t\t    if (copy_func(newfunc->nf_lambda, newfunc->nf_global,\n\t\t\t\t\t\t\t\t ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    // List functions\n\t    case ISN_DEF:\n\t\tif (iptr->isn_arg.string == NULL)\n\t\t    list_functions(NULL);\n\t\telse\n\t\t{\n\t\t    exarg_T ea;\n\t\t    char_u  *line_to_free = NULL;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmd = ea.arg = iptr->isn_arg.string;\n\t\t    define_function(&ea, NULL, &line_to_free);\n\t\t    vim_free(line_to_free);\n\t\t}\n\t\tbreak;\n\n\t    // jump if a condition is met\n\t    case ISN_JUMP:\n\t\t{\n\t\t    jumpwhen_T\twhen = iptr->isn_arg.jump.jump_when;\n\t\t    int\t\terror = FALSE;\n\t\t    int\t\tjump = TRUE;\n\n\t\t    if (when != JUMP_ALWAYS)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (when == JUMP_IF_COND_FALSE\n\t\t\t\t|| when == JUMP_IF_FALSE\n\t\t\t\t|| when == JUMP_IF_COND_TRUE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    jump = tv_get_bool_chk(tv, &error);\n\t\t\t    if (error)\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\telse\n\t\t\t    jump = tv2bool(tv);\n\t\t\tif (when == JUMP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_AND_KEEP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_IF_COND_FALSE)\n\t\t\t    jump = !jump;\n\t\t\tif (when == JUMP_IF_FALSE || !jump)\n\t\t\t{\n\t\t\t    // drop the value from the stack\n\t\t\t    clear_tv(tv);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    if (jump)\n\t\t\tectx->ec_iidx = iptr->isn_arg.jump.jump_where;\n\t\t}\n\t\tbreak;\n\n\t    // Jump if an argument with a default value was already set and not\n\t    // v:none.\n\t    case ISN_JUMP_IF_ARG_SET:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.jumparg.jump_arg_off);\n\t\tif (tv->v_type != VAR_UNKNOWN\n\t\t\t&& !(tv->v_type == VAR_SPECIAL\n\t\t\t\t\t    && tv->vval.v_number == VVAL_NONE))\n\t\t    ectx->ec_iidx = iptr->isn_arg.jumparg.jump_where;\n\t\tbreak;\n\n\t    // top of a for loop\n\t    case ISN_FOR:\n\t\t{\n\t\t    typval_T\t*ltv = STACK_TV_BOT(-1);\n\t\t    typval_T\t*idxtv =\n\t\t\t\t   STACK_TV_VAR(iptr->isn_arg.forloop.for_idx);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (ltv->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlist_T *list = ltv->vval.v_list;\n\n\t\t\t// push the next item from the list\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (list == NULL\n\t\t\t\t       || idxtv->vval.v_number >= list->lv_len)\n\t\t\t{\n\t\t\t    // past the end of the list, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse if (list->lv_first == &range_list_item)\n\t\t\t{\n\t\t\t    // non-materialized range() list\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->v_lock = 0;\n\t\t\t    tv->vval.v_number = list_find_nr(\n\t\t\t\t\t     list, idxtv->vval.v_number, NULL);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\n\t\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(0));\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_STRING)\n\t\t    {\n\t\t\tchar_u\t*str = ltv->vval.v_string;\n\n\t\t\t// The index is for the last byte of the previous\n\t\t\t// character.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (str == NULL || str[idxtv->vval.v_number] == NUL)\n\t\t\t{\n\t\t\t    // past the end of the string, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int\tclen = mb_ptr2len(str + idxtv->vval.v_number);\n\n\t\t\t    // Push the next character from the string.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_STRING;\n\t\t\t    tv->vval.v_string = vim_strnsave(\n\t\t\t\t\t     str + idxtv->vval.v_number, clen);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t    idxtv->vval.v_number += clen - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tblob_T\t*blob = ltv->vval.v_blob;\n\n\t\t\t// When we get here the first time make a copy of the\n\t\t\t// blob, so that the iteration still works when it is\n\t\t\t// changed.\n\t\t\tif (idxtv->vval.v_number == -1 && blob != NULL)\n\t\t\t{\n\t\t\t    blob_copy(blob, ltv);\n\t\t\t    blob_unref(blob);\n\t\t\t    blob = ltv->vval.v_blob;\n\t\t\t}\n\n\t\t\t// The index is for the previous byte.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (blob == NULL\n\t\t\t\t     || idxtv->vval.v_number >= blob_len(blob))\n\t\t\t{\n\t\t\t    // past the end of the blob, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Push the next byte from the blob.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->vval.v_number = blob_get(blob,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tsemsg(_(e_for_loop_on_str_not_supported),\n\t\t\t\t\t\t    vartype_name(ltv->v_type));\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // start of \":try\" block\n\t    case ISN_TRY:\n\t\t{\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_trystack, 1))\n\t\t\tgoto theend;\n\t\t    trycmd = ((trycmd_T *)ectx->ec_trystack.ga_data)\n\t\t\t\t\t\t     + ectx->ec_trystack.ga_len;\n\t\t    ++ectx->ec_trystack.ga_len;\n\t\t    ++trylevel;\n\t\t    CLEAR_POINTER(trycmd);\n\t\t    trycmd->tcd_frame_idx = ectx->ec_frame_idx;\n\t\t    trycmd->tcd_stack_len = ectx->ec_stack.ga_len;\n\t\t    trycmd->tcd_catch_idx =\n\t\t\t\t       iptr->isn_arg.tryref.try_ref->try_catch;\n\t\t    trycmd->tcd_finally_idx =\n\t\t\t\t     iptr->isn_arg.tryref.try_ref->try_finally;\n\t\t    trycmd->tcd_endtry_idx =\n\t\t\t\t      iptr->isn_arg.tryref.try_ref->try_endtry;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUSHEXC:\n\t\tif (current_exception == NULL)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    iemsg(\"Evaluating catch while current_exception is NULL\");\n\t\t    goto theend;\n\t\t}\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\t\t   (char_u *)current_exception->value);\n\t\tbreak;\n\n\t    case ISN_CATCH:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\ttrycmd->tcd_caught = TRUE;\n\t\t\ttrycmd->tcd_did_throw = FALSE;\n\t\t    }\n\t\t    did_emsg = got_int = did_throw = FALSE;\n\t\t    force_abort = need_rethrow = FALSE;\n\t\t    catch_exception(current_exception);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_TRYCONT:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycont_T\t*trycont = &iptr->isn_arg.trycont;\n\t\t    int\t\ti;\n\t\t    trycmd_T    *trycmd;\n\t\t    int\t\tiidx = trycont->tct_where;\n\n\t\t    if (trystack->ga_len < trycont->tct_levels)\n\t\t    {\n\t\t\tsiemsg(\"TRYCONT: expected %d levels, found %d\",\n\t\t\t\t\ttrycont->tct_levels, trystack->ga_len);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    // Make :endtry jump to any outer try block and the last\n\t\t    // :endtry inside the loop to the loop start.\n\t\t    for (i = trycont->tct_levels; i > 0; --i)\n\t\t    {\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - i;\n\t\t\t// Add one to tcd_cont to be able to jump to\n\t\t\t// instruction with index zero.\n\t\t\ttrycmd->tcd_cont = iidx + 1;\n\t\t\tiidx = trycmd->tcd_finally_idx == 0\n\t\t\t    ? trycmd->tcd_endtry_idx : trycmd->tcd_finally_idx;\n\t\t    }\n\t\t    // jump to :finally or :endtry of current try statement\n\t\t    ectx->ec_iidx = iidx;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINALLY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\n\t\t    // Reset the index to avoid a return statement jumps here\n\t\t    // again.\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t    break;\n\t\t}\n\n\t    // end of \":try\" block\n\t    case ISN_ENDTRY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd;\n\n\t\t\t--trystack->ga_len;\n\t\t\t--trylevel;\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t    + trystack->ga_len;\n\t\t\tif (trycmd->tcd_did_throw)\n\t\t\t    did_throw = TRUE;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t}\n\n\t\t\tif (trycmd->tcd_return)\n\t\t\t    goto func_return;\n\n\t\t\twhile (ectx->ec_stack.ga_len > trycmd->tcd_stack_len)\n\t\t\t{\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t}\n\t\t\tif (trycmd->tcd_cont != 0)\n\t\t\t    // handling :continue: jump to outer try block or\n\t\t\t    // start of the loop\n\t\t\t    ectx->ec_iidx = trycmd->tcd_cont - 1;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_THROW:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len == 0 && trylevel == 0 && emsg_silent)\n\t\t    {\n\t\t\t// throwing an exception while using \"silent!\" causes\n\t\t\t// the function to abort but not display an error.\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tclear_tv(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto done;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->vval.v_string == NULL\n\t\t\t\t       || *skipwhite(tv->vval.v_string) == NUL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_throw_with_empty_string));\n\t\t\tgoto theend;\n\t\t    }\n\n\t\t    // Inside a \"catch\" we need to first discard the caught\n\t\t    // exception.\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t    trycmd->tcd_caught = FALSE;\n\t\t\t}\n\t\t    }\n\n\t\t    if (throw_exception(tv->vval.v_string, ET_USER, NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    did_throw = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    // compare with special values\n\t    case ISN_COMPAREBOOL:\n\t    case ISN_COMPARESPECIAL:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    int\t\tres;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tdefault: res = 0; break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    // Operation with two number arguments\n\t    case ISN_OPNR:\n\t    case ISN_COMPARENR:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    varnumber_T res = 0;\n\t\t    int\t\tdiv_zero = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 / arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_REM:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 % arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: res = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: res = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: res = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: res = arg1 <= arg2; break;\n\t\t\tdefault: break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPARENR)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_number = res;\n\t\t    if (div_zero)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_divide_by_zero));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two float arguments\n\t    case ISN_OPFLOAT:\n\t    case ISN_COMPAREFLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    float_T\targ1 = tv1->vval.v_float;\n\t\t    float_T\targ2 = tv2->vval.v_float;\n\t\t    float_T\tres = 0;\n\t\t    int\t\tcmp = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV: res = arg1 / arg2; break;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: cmp = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: cmp = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: cmp = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: cmp = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: cmp = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: cmp = arg1 <= arg2; break;\n\t\t\tdefault: cmp = 0; break;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPAREFLOAT)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = cmp ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_float = res;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    case ISN_COMPARELIST:\n\t    case ISN_COMPAREDICT:\n\t    case ISN_COMPAREFUNC:\n\t    case ISN_COMPARESTRING:\n\t    case ISN_COMPAREBLOB:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tres = FALSE;\n\t\t    int\t\tstatus = OK;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (iptr->isn_type == ISN_COMPARELIST)\n\t\t    {\n\t\t\tstatus = typval_compare_list(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREDICT)\n\t\t    {\n\t\t\tstatus = typval_compare_dict(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREFUNC)\n\t\t    {\n\t\t\tstatus = typval_compare_func(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPARESTRING)\n\t\t    {\n\t\t\tstatus = typval_compare_string(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = typval_compare_blob(tv1, tv2, exprtype, &res);\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(tv1);\n\t\t    clear_tv(tv2);\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_COMPAREANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tstatus;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    status = typval_compare(tv1, tv2, exprtype, ic);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ADDLIST:\n\t    case ISN_ADDBLOB:\n\t\t{\n\t\t    typval_T *tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T *tv2 = STACK_TV_BOT(-1);\n\n\t\t    // add two lists or blobs\n\t\t    if (iptr->isn_type == ISN_ADDLIST)\n\t\t    {\n\t\t\tif (iptr->isn_arg.op.op_type == EXPR_APPEND\n\t\t\t\t\t\t   && tv1->vval.v_list != NULL)\n\t\t\t    list_extend(tv1->vval.v_list, tv2->vval.v_list,\n\t\t\t\t\t\t\t\t\t NULL);\n\t\t\telse\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t    }\n\t\t    else\n\t\t\teval_addblob(tv1, tv2);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    list_T\t*l = tv1->vval.v_list;\n\n\t\t    // add an item to a list\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (l == NULL)\n\t\t    {\n\t\t\temsg(_(e_cannot_add_to_null_list));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    if (value_check_lock(l->lv_lock, NULL, FALSE))\n\t\t\tgoto on_error;\n\t\t    if (list_append_tv(l, tv2) == FAIL)\n\t\t\tgoto theend;\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_BLOBAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    blob_T\t*b = tv1->vval.v_blob;\n\t\t    int\t\terror = FALSE;\n\t\t    varnumber_T n;\n\n\t\t    // add a number to a blob\n\t\t    if (b == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_cannot_add_to_null_blob));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    n = tv_get_number_chk(tv2, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t    ga_append(&b->bv_ga, (int)n);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two arguments of unknown type\n\t    case ISN_OPANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\t    float_T\tf1 = 0, f2 = 0;\n#endif\n\t\t    int\t\terror = FALSE;\n\n\t\t    if (iptr->isn_arg.op.op_type == EXPR_ADD)\n\t\t    {\n\t\t\tif (tv1->v_type == VAR_LIST && tv2->v_type == VAR_LIST)\n\t\t\t{\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (tv1->v_type == VAR_BLOB\n\t\t\t\t\t\t    && tv2->v_type == VAR_BLOB)\n\t\t\t{\n\t\t\t    eval_addblob(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv1->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf1 = tv1->vval.v_float;\n\t\t\tn1 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = tv_get_number_chk(tv1, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv2->v_type == VAR_FLOAT)\n\t\t\t    f1 = n1;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf2 = tv2->vval.v_float;\n\t\t\tn2 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tn2 = tv_get_number_chk(tv2, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv1->v_type == VAR_FLOAT)\n\t\t\t    f2 = n2;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    // if there is a float on either side the result is a float\n\t\t    if (tv1->v_type == VAR_FLOAT || tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: f1 = f1 * f2; break;\n\t\t\t    case EXPR_DIV:  f1 = f1 / f2; break;\n\t\t\t    case EXPR_SUB:  f1 = f1 - f2; break;\n\t\t\t    case EXPR_ADD:  f1 = f1 + f2; break;\n\t\t\t    default: SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t     emsg(_(e_cannot_use_percent_with_float));\n\t\t\t\t     goto on_error;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tint failed = FALSE;\n\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: n1 = n1 * n2; break;\n\t\t\t    case EXPR_DIV:  n1 = num_divide(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t    case EXPR_SUB:  n1 = n1 - n2; break;\n\t\t\t    case EXPR_ADD:  n1 = n1 + n2; break;\n\t\t\t    default:\t    n1 = num_modulus(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CONCAT:\n\t\t{\n\t\t    char_u *str1 = STACK_TV_BOT(-2)->vval.v_string;\n\t\t    char_u *str2 = STACK_TV_BOT(-1)->vval.v_string;\n\t\t    char_u *res;\n\n\t\t    res = concat_str(str1, str2);\n\t\t    clear_tv(STACK_TV_BOT(-2));\n\t\t    clear_tv(STACK_TV_BOT(-1));\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    STACK_TV_BOT(-1)->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_STRINDEX:\n\t    case ISN_STRSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_STRSLICE;\n\t\t    varnumber_T\tn1 = 0, n2;\n\t\t    char_u\t*res;\n\n\t\t    // string index: string is at stack-2, index at stack-1\n\t\t    // string slice: string is at stack-3, first index at\n\t\t    // stack-2, second index at stack-1\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t    }\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n2 = tv->vval.v_number;\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (is_slice)\n\t\t\t// Slice: Select the characters from the string\n\t\t\tres = string_slice(tv->vval.v_string, n1, n2, FALSE);\n\t\t    else\n\t\t\t// Index: The resulting variable is a string of a\n\t\t\t// single character (including composing characters).\n\t\t\t// If the index is too big or negative the result is\n\t\t\t// empty.\n\t\t\tres = char_from_string(tv->vval.v_string, n2);\n\t\t    vim_free(tv->vval.v_string);\n\t\t    tv->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTINDEX:\n\t    case ISN_LISTSLICE:\n\t    case ISN_BLOBINDEX:\n\t    case ISN_BLOBSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_LISTSLICE\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    int\t\tis_blob = iptr->isn_type == ISN_BLOBINDEX\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    varnumber_T\tn1, n2;\n\t\t    typval_T\t*val_tv;\n\n\t\t    // list index: list is at stack-2, index at stack-1\n\t\t    // list slice: list is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    // Same for blob.\n\t\t    val_tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n1 = n2 = tv->vval.v_number;\n\t\t    clear_tv(tv);\n\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t\tclear_tv(tv);\n\t\t    }\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (is_blob)\n\t\t    {\n\t\t\tif (blob_slice_or_index(val_tv->vval.v_blob, is_slice,\n\t\t\t\t\t\t    n1, n2, FALSE, tv) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (list_slice_or_index(val_tv->vval.v_list, is_slice,\n\t\t\t\t\t      n1, n2, FALSE, tv, TRUE) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ANYINDEX:\n\t    case ISN_ANYSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_ANYSLICE;\n\t\t    typval_T\t*var1, *var2;\n\t\t    int\t\tres;\n\n\t\t    // index: composite is at stack-2, index at stack-1\n\t\t    // slice: composite is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_can_index(tv, TRUE, TRUE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    var1 = is_slice ? STACK_TV_BOT(-2) : STACK_TV_BOT(-1);\n\t\t    var2 = is_slice ? STACK_TV_BOT(-1) : NULL;\n\t\t    res = eval_index_inner(tv, is_slice, var1, var2,\n\t\t\t\t\t\t\tFALSE, NULL, -1, TRUE);\n\t\t    clear_tv(var1);\n\t\t    if (is_slice)\n\t\t\tclear_tv(var2);\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SLICE:\n\t\t{\n\t\t    list_T\t*list;\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\n\t\t    // type will have been checked to be a list\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    list = tv->vval.v_list;\n\n\t\t    // no error for short list, expect it to be checked earlier\n\t\t    if (list != NULL && list->lv_len >= count)\n\t\t    {\n\t\t\tlist_T\t*newlist = list_slice(list,\n\t\t\t\t\t\t      count, list->lv_len - 1);\n\n\t\t\tif (newlist != NULL)\n\t\t\t{\n\t\t\t    list_unref(list);\n\t\t\t    tv->vval.v_list = newlist;\n\t\t\t    ++newlist->lv_refcount;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_GETITEM:\n\t\t{\n\t\t    listitem_T\t*li;\n\t\t    getitem_T\t*gi = &iptr->isn_arg.getitem;\n\n\t\t    // Get list item: list is at stack-1, push item.\n\t\t    // List type and length is checked for when compiling.\n\t\t    tv = STACK_TV_BOT(-1 - gi->gi_with_op);\n\t\t    li = list_find(tv->vval.v_list, gi->gi_index);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(-1));\n\n\t\t    // Useful when used in unpack assignment.  Reset at\n\t\t    // ISN_DROP.\n\t\t    ectx->ec_where.wt_index = gi->gi_index + 1;\n\t\t    ectx->ec_where.wt_variable = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_MEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    char_u\t*key;\n\t\t    dictitem_T\t*di;\n\n\t\t    // dict member: dict is at stack-2, key at stack-1\n\t\t    tv = STACK_TV_BOT(-2);\n\t\t    // no need to check for VAR_DICT, CHECKTYPE will check.\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    // no need to check for VAR_STRING, 2STRING will check.\n\t\t    key = tv->vval.v_string;\n\t\t    if (key == NULL)\n\t\t\tkey = (char_u *)\"\";\n\n\t\t    if ((di = dict_find(dict, key, -1)) == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\n\t\t\t// If :silent! is used we will continue, make sure the\n\t\t\t// stack contents makes sense and the dict stack is\n\t\t\t// updated.\n\t\t\tclear_tv(tv);\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\t(void) dict_stack_save(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto on_fatal_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    // dict member with string key\n\t    case ISN_STRINGMEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    dictitem_T\t*di;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_DICT || tv->vval.v_dict == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_dictionary_required));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    if ((di = dict_find(dict, iptr->isn_arg.string, -1))\n\t\t\t\t\t\t\t\t       == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CLEARDICT:\n\t\tdict_stack_drop();\n\t\tbreak;\n\n\t    case ISN_USEDICT:\n\t\t{\n\t\t    typval_T *dict_tv = dict_stack_get_tv();\n\n\t\t    // Turn \"dict.Func\" into a partial for \"Func\" bound to\n\t\t    // \"dict\".  Don't do this when \"Func\" is already a partial\n\t\t    // that was bound explicitly (pt_auto is FALSE).\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_tv != NULL\n\t\t\t    && dict_tv->v_type == VAR_DICT\n\t\t\t    && dict_tv->vval.v_dict != NULL\n\t\t\t    && (tv->v_type == VAR_FUNC\n\t\t\t\t|| (tv->v_type == VAR_PARTIAL\n\t\t\t\t    && (tv->vval.v_partial->pt_auto\n\t\t\t\t     || tv->vval.v_partial->pt_dict == NULL))))\n\t\t    dict_tv->vval.v_dict =\n\t\t\t\t\tmake_partial(dict_tv->vval.v_dict, tv);\n\t\t    dict_stack_drop();\n\t\t}\n\t\tbreak;\n\n\t    case ISN_NEGATENR:\n\t\ttv = STACK_TV_BOT(-1);\n\t\tif (tv->v_type != VAR_NUMBER\n#ifdef FEAT_FLOAT\n\t\t\t&& tv->v_type != VAR_FLOAT\n#endif\n\t\t\t)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    emsg(_(e_number_expected));\n\t\t    goto on_error;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (tv->v_type == VAR_FLOAT)\n\t\t    tv->vval.v_float = -tv->vval.v_float;\n\t\telse\n#endif\n\t\t    tv->vval.v_number = -tv->vval.v_number;\n\t\tbreak;\n\n\t    case ISN_CHECKNR:\n\t\t{\n\t\t    int\t\terror = FALSE;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_not_string(tv) == FAIL)\n\t\t\tgoto on_error;\n\t\t    (void)tv_get_number_chk(tv, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT((int)ct->ct_off);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = ct->ct_arg_idx;\n\t\t    if (check_typval_type(ct->ct_type, tv, ectx->ec_where)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\tgoto on_error;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = 0;\n\n\t\t    // number 0 is FALSE, number 1 is TRUE\n\t\t    if (tv->v_type == VAR_NUMBER\n\t\t\t    && ct->ct_type->tt_type == VAR_BOOL\n\t\t\t    && (tv->vval.v_number == 0\n\t\t\t\t\t\t|| tv->vval.v_number == 1))\n\t\t    {\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = tv->vval.v_number\n\t\t\t\t\t\t      ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKLEN:\n\t\t{\n\t\t    int\t    min_len = iptr->isn_arg.checklen.cl_min_len;\n\t\t    list_T  *list = NULL;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_LIST)\n\t\t\t    list = tv->vval.v_list;\n\t\t    if (list == NULL || list->lv_len < min_len\n\t\t\t    || (list->lv_len > min_len\n\t\t\t\t\t&& !iptr->isn_arg.checklen.cl_more_OK))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t     min_len, list == NULL ? 0 : list->lv_len);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SETTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_dict->dv_type);\n\t\t\ttv->vval.v_dict->dv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t    else if (tv->v_type == VAR_LIST && tv->vval.v_list != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_list->lv_type);\n\t\t\ttv->vval.v_list->lv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2BOOL:\n\t    case ISN_COND2BOOL:\n\t\t{\n\t\t    int n;\n\t\t    int error = FALSE;\n\n\t\t    if (iptr->isn_type == ISN_2BOOL)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(iptr->isn_arg.tobool.offset);\n\t\t\tn = tv2bool(tv);\n\t\t\tif (iptr->isn_arg.tobool.invert)\n\t\t\t    n = !n;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn = tv_get_bool_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    tv->v_type = VAR_BOOL;\n\t\t    tv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2STRING:\n\t    case ISN_2STRING_ANY:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (do_2string(STACK_TV_BOT(iptr->isn_arg.tostring.offset),\n\t\t\t\tiptr->isn_type == ISN_2STRING_ANY,\n\t\t\t\t      iptr->isn_arg.tostring.tolerant) == FAIL)\n\t\t\t    goto on_error;\n\t\tbreak;\n\n\t    case ISN_RANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*errormsg;\n\n\t\t    ea.line2 = 0;\n\t\t    ea.addr_count = 0;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    ea.skip = FALSE;\n\t\t    if (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\t\t\tgoto on_error;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_NUMBER;\n\t\t    tv->v_lock = 0;\n\t\t    if (ea.addr_count == 0)\n\t\t\ttv->vval.v_number = curwin->w_cursor.lnum;\n\t\t    else\n\t\t\ttv->vval.v_number = ea.line2;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUT:\n\t\t{\n\t\t    int\t\tregname = iptr->isn_arg.put.put_regname;\n\t\t    linenr_T\tlnum = iptr->isn_arg.put.put_lnum;\n\t\t    char_u\t*expr = NULL;\n\t\t    int\t\tdir = FORWARD;\n\n\t\t    if (lnum < -2)\n\t\t    {\n\t\t\t// line number was put on the stack by ISN_RANGE\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tcurwin->w_cursor.lnum = tv->vval.v_number;\n\t\t\tif (lnum == LNUM_VARIABLE_RANGE_ABOVE)\n\t\t\t    dir = BACKWARD;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else if (lnum == -2)\n\t\t\t// :put! above cursor\n\t\t\tdir = BACKWARD;\n\t\t    else if (lnum >= 0)\n\t\t\tcurwin->w_cursor.lnum = iptr->isn_arg.put.put_lnum;\n\n\t\t    if (regname == '=')\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (tv->v_type == VAR_STRING)\n\t\t\t    expr = tv->vval.v_string;\n\t\t\telse\n\t\t\t{\n\t\t\t    expr = typval2string(tv, TRUE); // allocates value\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    check_cursor();\n\t\t    do_put(regname, expr, dir, 1L, PUT_LINE|PUT_CURSLINE);\n\t\t    vim_free(expr);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CMDMOD:\n\t\tectx->ec_funclocal.floc_save_cmdmod = cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = TRUE;\n\t\tectx->ec_funclocal.floc_restore_cmdmod_stacklen =\n\t\t\t\t\t\t\t ectx->ec_stack.ga_len;\n\t\tcmdmod = *iptr->isn_arg.cmdmod.cf_cmdmod;\n\t\tapply_cmdmod(&cmdmod);\n\t\tbreak;\n\n\t    case ISN_CMDMOD_REV:\n\t\t// filter regprog is owned by the instruction, don't free it\n\t\tcmdmod.cmod_filter_regmatch.regprog = NULL;\n\t\tundo_cmdmod(&cmdmod);\n\t\tcmdmod = ectx->ec_funclocal.floc_save_cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = FALSE;\n\t\tbreak;\n\n\t    case ISN_UNPACK:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.unpack.unp_count;\n\t\t    int\t\tsemicolon = iptr->isn_arg.unpack.unp_semicolon;\n\t\t    list_T\t*l;\n\t\t    listitem_T\t*li;\n\t\t    int\t\ti;\n\n\t\t    // Check there is a valid list to unpack.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_LIST)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_for_argument_must_be_sequence_of_lists));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    l = tv->vval.v_list;\n\t\t    if (l == NULL\n\t\t\t\t|| l->lv_len < (semicolon ? count - 1 : count))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_does_not_have_enough_items));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else if (!semicolon && l->lv_len > count)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_has_more_items_than_targets));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, count - 1))\n\t\t\tgoto theend;\n\t\t    ectx->ec_stack.ga_len += count - 1;\n\n\t\t    // Variable after semicolon gets a list with the remaining\n\t\t    // items.\n\t\t    if (semicolon)\n\t\t    {\n\t\t\tlist_T\t*rem_list =\n\t\t\t\t  list_alloc_with_items(l->lv_len - count + 1);\n\n\t\t\tif (rem_list == NULL)\n\t\t\t    goto theend;\n\t\t\ttv = STACK_TV_BOT(-count);\n\t\t\ttv->vval.v_list = rem_list;\n\t\t\t++rem_list->lv_refcount;\n\t\t\ttv->v_lock = 0;\n\t\t\tli = l->lv_first;\n\t\t\tfor (i = 0; i < count - 1; ++i)\n\t\t\t    li = li->li_next;\n\t\t\tfor (i = 0; li != NULL; ++i)\n\t\t\t{\n\t\t\t    list_set_item(rem_list, i, &li->li_tv);\n\t\t\t    li = li->li_next;\n\t\t\t}\n\t\t\t--count;\n\t\t    }\n\n\t\t    // Produce the values in reverse order, first item last.\n\t\t    li = l->lv_first;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-i - 1);\n\t\t\tcopy_tv(&li->li_tv, tv);\n\t\t\tli = li->li_next;\n\t\t    }\n\n\t\t    list_unref(l);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PROF_START:\n\t    case ISN_PROF_END:\n\t\t{\n#ifdef FEAT_PROFILE\n\t\t    funccall_T cookie;\n\t\t    ufunc_T\t    *cur_ufunc =\n\t\t\t\t    (((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t       + ectx->ec_dfunc_idx)->df_ufunc;\n\n\t\t    cookie.func = cur_ufunc;\n\t\t    if (iptr->isn_type == ISN_PROF_START)\n\t\t    {\n\t\t\tfunc_line_start(&cookie, iptr->isn_lnum);\n\t\t\t// if we get here the instruction is executed\n\t\t\tfunc_line_exec(&cookie);\n\t\t    }\n\t\t    else\n\t\t\tfunc_line_end(&cookie);\n#endif\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DEBUG:\n\t\thandle_debug(iptr, ectx);\n\t\tbreak;\n\n\t    case ISN_SHUFFLE:\n\t\t{\n\t\t    typval_T\ttmp_tv;\n\t\t    int\t\titem = iptr->isn_arg.shuffle.shfl_item;\n\t\t    int\t\tup = iptr->isn_arg.shuffle.shfl_up;\n\n\t\t    tmp_tv = *STACK_TV_BOT(-item);\n\t\t    for ( ; up > 0 && item > 1; --up)\n\t\t    {\n\t\t\t*STACK_TV_BOT(-item) = *STACK_TV_BOT(-item + 1);\n\t\t\t--item;\n\t\t    }\n\t\t    *STACK_TV_BOT(-item) = tmp_tv;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DROP:\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(0));\n\t\tectx->ec_where.wt_index = 0;\n\t\tectx->ec_where.wt_variable = FALSE;\n\t\tbreak;\n\t}\n\tcontinue;\n\nfunc_return:\n\t// Restore previous function. If the frame pointer is where we started\n\t// then there is none and we are done.\n\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t    goto done;\n\n\tif (func_return(ectx) == FAIL)\n\t    // only fails when out of memory\n\t    goto theend;\n\tcontinue;\n\non_error:\n\t// Jump here for an error that does not require aborting execution.\n\t// If \"emsg_silent\" is set then ignore the error, unless it was set\n\t// when calling the function.\n\tif (did_emsg_cumul + did_emsg == ectx->ec_did_emsg_before\n\t\t\t\t\t   && emsg_silent && did_emsg_def == 0)\n\t{\n\t    // If a sequence of instructions causes an error while \":silent!\"\n\t    // was used, restore the stack length and jump ahead to restoring\n\t    // the cmdmod.\n\t    if (ectx->ec_funclocal.floc_restore_cmdmod)\n\t    {\n\t\twhile (ectx->ec_stack.ga_len\n\t\t\t     > ectx->ec_funclocal.floc_restore_cmdmod_stacklen)\n\t\t{\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t}\n\t\twhile (ectx->ec_instr[ectx->ec_iidx].isn_type != ISN_CMDMOD_REV)\n\t\t    ++ectx->ec_iidx;\n\t    }\n\t    continue;\n\t}\non_fatal_error:\n\t// Jump here for an error that messes up the stack.\n\t// If we are not inside a try-catch started here, abort execution.\n\tif (trylevel <= ectx->ec_trylevel_at_start)\n\t    goto theend;\n    }\n\ndone:\n    ret = OK;\ntheend:\n    dict_stack_clear(dict_stack_len_at_start);\n    ectx->ec_trylevel_at_start = save_trylevel_at_start;\n    return ret;\n}", "target": 1, "cwe": ["CWE-416"], "project": "vim", "commit_id": "143367256836b0f69881dc0c65ff165ae091dbc5", "hash": 18696636658191801693525238012366875384, "size": 3023, "message": "patch 8.2.4042: Vim9: build error\n\nProblem:    Vim9: build error.\nSolution:   Use grow array instead of character pointer.", "idx": 171}
{"func": "static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,\n\t\t\t\t\t    unsigned int reqsize)\n{\n\ttfm->reqsize = reqsize;\n}", "target": 0, "cwe": ["CWE-835"], "project": "linux", "commit_id": "ef0579b64e93188710d48667cb5e014926af9f1b", "hash": 271734517271786043327914584674102232009, "size": 5, "message": "crypto: ahash - Fix EINPROGRESS notification callback\n\nThe ahash API modifies the request's callback function in order\nto clean up after itself in some corner cases (unaligned final\nand missing finup).\n\nWhen the request is complete ahash will restore the original\ncallback and everything is fine.  However, when the request gets\nan EBUSY on a full queue, an EINPROGRESS callback is made while\nthe request is still ongoing.\n\nIn this case the ahash API will incorrectly call its own callback.\n\nThis patch fixes the problem by creating a temporary request\nobject on the stack which is used to relay EINPROGRESS back to\nthe original completion function.\n\nThis patch also adds code to preserve the original flags value.\n\nFixes: ab6bf4e5e5e4 (\"crypto: hash - Fix the pointer voodoo in...\")\nCc: <stable@vger.kernel.org>\nReported-by: Sabrina Dubroca <sd@queasysnail.net>\nTested-by: Sabrina Dubroca <sd@queasysnail.net>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>", "idx": 172}
{"func": "gs_grab_get_keyboard (GSGrab    *grab,\n                      GdkWindow *window,\n                      GdkScreen *screen)\n{\n        GdkGrabStatus status;\n\n        g_return_val_if_fail (window != NULL, FALSE);\n        g_return_val_if_fail (screen != NULL, FALSE);\n\n        gs_debug (\"Grabbing keyboard widget=%X\", (guint32) GDK_WINDOW_XID (window));\n        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);\n\n        if (status == GDK_GRAB_SUCCESS) {\n                grab->priv->keyboard_grab_window = window;\n                grab->priv->keyboard_grab_screen = screen;\n        } else {\n                gs_debug (\"Couldn't grab keyboard!  (%s)\", grab_string (status));\n        }\n\n        return status;\n}", "target": 1, "cwe": [], "project": "gnome-screensaver", "commit_id": "f93a22c175090cf02e80bc3ee676b53f1251f685", "hash": 326224807181770496359740362229919543344, "size": 21, "message": "Nullify grab window variables when windows are destroyed\n\nIf we don't do this then there is a time period where the\ngrab window variables contain dangling pointers which can\ncause crashes.\n\nPart of fix for\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609789", "idx": 173}
{"func": "s64 ntfs_get_attribute_value(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *a, u8 *b)\n{\n\trunlist *rl;\n\ts64 total, r;\n\tint i;\n\n\t/* Sanity checks. */\n\tif (!vol || !a || !b) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/* Complex attribute? */\n\t/*\n\t * Ignore the flags in case they are not zero for an attribute list\n\t * attribute.  Windows does not complain about invalid flags and chkdsk\n\t * does not detect or fix them so we need to cope with it, too.\n\t */\n\tif (a->type != AT_ATTRIBUTE_LIST && a->flags) {\n\t\tntfs_log_error(\"Non-zero (%04x) attribute flags. Cannot handle \"\n\t\t\t       \"this yet.\\n\", le16_to_cpu(a->flags));\n\t\terrno = EOPNOTSUPP;\n\t\treturn 0;\n\t}\n\tif (!a->non_resident) {\n\t\t/* Attribute is resident. */\n\n\t\t/* Sanity check. */\n\t\tif (le32_to_cpu(a->value_length) + le16_to_cpu(a->value_offset)\n\t\t\t\t> le32_to_cpu(a->length)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemcpy(b, (const char*)a + le16_to_cpu(a->value_offset),\n\t\t\t\tle32_to_cpu(a->value_length));\n\t\terrno = 0;\n\t\treturn (s64)le32_to_cpu(a->value_length);\n\t}\n\n\t/* Attribute is not resident. */\n\n\t/* If no data, return 0. */\n\tif (!(a->data_size)) {\n\t\terrno = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * FIXME: What about attribute lists?!? (AIA)\n\t */\n\t/* Decompress the mapping pairs array into a runlist. */\n\trl = ntfs_mapping_pairs_decompress(vol, a, NULL);\n\tif (!rl) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/*\n\t * FIXED: We were overflowing here in a nasty fashion when we\n\t * reach the last cluster in the runlist as the buffer will\n\t * only be big enough to hold data_size bytes while we are\n\t * reading in allocated_size bytes which is usually larger\n\t * than data_size, since the actual data is unlikely to have a\n\t * size equal to a multiple of the cluster size!\n\t * FIXED2:  We were also overflowing here in the same fashion\n\t * when the data_size was more than one run smaller than the\n\t * allocated size which happens with Windows XP sometimes.\n\t */\n\t/* Now load all clusters in the runlist into b. */\n\tfor (i = 0, total = 0; rl[i].length; i++) {\n\t\tif (total + (rl[i].length << vol->cluster_size_bits) >=\n\t\t\t\tsle64_to_cpu(a->data_size)) {\n\t\t\tunsigned char *intbuf = NULL;\n\t\t\t/*\n\t\t\t * We have reached the last run so we were going to\n\t\t\t * overflow when executing the ntfs_pread() which is\n\t\t\t * BAAAAAAAD!\n\t\t\t * Temporary fix:\n\t\t\t *\tAllocate a new buffer with size:\n\t\t\t *\trl[i].length << vol->cluster_size_bits, do the\n\t\t\t *\tread into our buffer, then memcpy the correct\n\t\t\t *\tamount of data into the caller supplied buffer,\n\t\t\t *\tfree our buffer, and continue.\n\t\t\t * We have reached the end of data size so we were\n\t\t\t * going to overflow in the same fashion.\n\t\t\t * Temporary fix:  same as above.\n\t\t\t */\n\t\t\tintbuf = ntfs_malloc(rl[i].length << vol->cluster_size_bits);\n\t\t\tif (!intbuf) {\n\t\t\t\tfree(rl);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FIXME: If compressed file: Only read if lcn != -1.\n\t\t\t * Otherwise, we are dealing with a sparse run and we\n\t\t\t * just memset the user buffer to 0 for the length of\n\t\t\t * the run, which should be 16 (= compression unit\n\t\t\t * size).\n\t\t\t * FIXME: Really only when file is compressed, or can\n\t\t\t * we have sparse runs in uncompressed files as well?\n\t\t\t * - Yes we can, in sparse files! But not necessarily\n\t\t\t * size of 16, just run length.\n\t\t\t */\n\t\t\tr = ntfs_pread(vol->dev, rl[i].lcn <<\n\t\t\t\t\tvol->cluster_size_bits, rl[i].length <<\n\t\t\t\t\tvol->cluster_size_bits, intbuf);\n\t\t\tif (r != rl[i].length << vol->cluster_size_bits) {\n#define ESTR \"Error reading attribute value\"\n\t\t\t\tif (r == -1)\n\t\t\t\t\tntfs_log_perror(ESTR);\n\t\t\t\telse if (r < rl[i].length <<\n\t\t\t\t\t\tvol->cluster_size_bits) {\n\t\t\t\t\tntfs_log_debug(ESTR \": Ran out of input data.\\n\");\n\t\t\t\t\terrno = EIO;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_log_debug(ESTR \": unknown error\\n\");\n\t\t\t\t\terrno = EIO;\n\t\t\t\t}\n#undef ESTR\n\t\t\t\tfree(rl);\n\t\t\t\tfree(intbuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(b + total, intbuf, sle64_to_cpu(a->data_size) -\n\t\t\t\t\ttotal);\n\t\t\tfree(intbuf);\n\t\t\ttotal = sle64_to_cpu(a->data_size);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * FIXME: If compressed file: Only read if lcn != -1.\n\t\t * Otherwise, we are dealing with a sparse run and we just\n\t\t * memset the user buffer to 0 for the length of the run, which\n\t\t * should be 16 (= compression unit size).\n\t\t * FIXME: Really only when file is compressed, or can\n\t\t * we have sparse runs in uncompressed files as well?\n\t\t * - Yes we can, in sparse files! But not necessarily size of\n\t\t * 16, just run length.\n\t\t */\n\t\tr = ntfs_pread(vol->dev, rl[i].lcn << vol->cluster_size_bits,\n\t\t\t\trl[i].length << vol->cluster_size_bits,\n\t\t\t\tb + total);\n\t\tif (r != rl[i].length << vol->cluster_size_bits) {\n#define ESTR \"Error reading attribute value\"\n\t\t\tif (r == -1)\n\t\t\t\tntfs_log_perror(ESTR);\n\t\t\telse if (r < rl[i].length << vol->cluster_size_bits) {\n\t\t\t\tntfs_log_debug(ESTR \": Ran out of input data.\\n\");\n\t\t\t\terrno = EIO;\n\t\t\t} else {\n\t\t\t\tntfs_log_debug(ESTR \": unknown error\\n\");\n\t\t\t\terrno = EIO;\n\t\t\t}\n#undef ESTR\n\t\t\tfree(rl);\n\t\t\treturn 0;\n\t\t}\n\t\ttotal += r;\n\t}\n\tfree(rl);\n\treturn total;\n}", "target": 1, "cwe": ["CWE-703"], "project": "ntfs-3g", "commit_id": "60717a846deaaea47e50ce58872869f7bd1103b5", "hash": 207327288367432466091072935525550388492, "size": 160, "message": "Avoided allocating and reading an attribute beyond its full size\n\nBefore reading a full attribute value for internal use, its expected\nlength has been checked to be < 0x40000. However the allocated size\nin the runlist may be much bigger as a consequence of a bug or malice.\nTo prevent malloc'ing excessive size, restrict the size of the last\nrun to read to the needed length.", "idx": 174}
{"func": "void __idr_remove_all(struct idr *idp)\n{\n\tint n, id, max;\n\tint bt_mask;\n\tstruct idr_layer *p;\n\tstruct idr_layer *pa[MAX_IDR_LEVEL];\n\tstruct idr_layer **paa = &pa[0];\n\n\tn = idp->layers * IDR_BITS;\n\tp = idp->top;\n\trcu_assign_pointer(idp->top, NULL);\n\tmax = 1 << n;\n\n\tid = 0;\n\twhile (id < max) {\n\t\twhile (n > IDR_BITS && p) {\n\t\t\tn -= IDR_BITS;\n\t\t\t*paa++ = p;\n\t\t\tp = p->ary[(id >> n) & IDR_MASK];\n\t\t}\n\n\t\tbt_mask = id;\n\t\tid += 1 << n;\n\t\t/* Get the highest bit that the above add changed from 0->1. */\n\t\twhile (n < fls(id ^ bt_mask)) {\n\t\t\tif (p)\n\t\t\t\tfree_layer(p);\n\t\t\tn += IDR_BITS;\n\t\t\tp = *--paa;\n\t\t}\n\t}\n\tidp->layers = 0;\n}", "target": 1, "cwe": [], "project": "linux", "commit_id": "326cf0f0f308933c10236280a322031f0097205d", "hash": 332821469385154943268798110804965349048, "size": 33, "message": "idr: fix top layer handling\n\nMost functions in idr fail to deal with the high bits when the idr\ntree grows to the maximum height.\n\n* idr_get_empty_slot() stops growing idr tree once the depth reaches\n  MAX_IDR_LEVEL - 1, which is one depth shallower than necessary to\n  cover the whole range.  The function doesn't even notice that it\n  didn't grow the tree enough and ends up allocating the wrong ID\n  given sufficiently high @starting_id.\n\n  For example, on 64 bit, if the starting id is 0x7fffff01,\n  idr_get_empty_slot() will grow the tree 5 layer deep, which only\n  covers the 30 bits and then proceed to allocate as if the bit 30\n  wasn't specified.  It ends up allocating 0x3fffff01 without the bit\n  30 but still returns 0x7fffff01.\n\n* __idr_remove_all() will not remove anything if the tree is fully\n  grown.\n\n* idr_find() can't find anything if the tree is fully grown.\n\n* idr_for_each() and idr_get_next() can't iterate anything if the tree\n  is fully grown.\n\nFix it by introducing idr_max() which returns the maximum possible ID\ngiven the depth of tree and replacing the id limit checks in all\naffected places.\n\nAs the idr_layer pointer array pa[] needs to be 1 larger than the\nmaximum depth, enlarge pa[] arrays by one.\n\nWhile this plugs the discovered issues, the whole code base is\nhorrible and in desparate need of rewrite.  It's fragile like hell,\n\nSigned-off-by: Tejun Heo <tj@kernel.org>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nCc: <stable@vger.kernel.org>\n\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 175}
{"func": "long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)\n\t{\n\tint ret=0;\n\n#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_RSA)\n\tif (\n#ifndef OPENSSL_NO_RSA\n\t    cmd == SSL_CTRL_SET_TMP_RSA ||\n\t    cmd == SSL_CTRL_SET_TMP_RSA_CB ||\n#endif\n#ifndef OPENSSL_NO_DSA\n\t    cmd == SSL_CTRL_SET_TMP_DH ||\n\t    cmd == SSL_CTRL_SET_TMP_DH_CB ||\n#endif\n\t\t0)\n\t\t{\n\t\tif (!ssl_cert_inst(&s->cert))\n\t\t    \t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_MALLOC_FAILURE);\n\t\t\treturn(0);\n\t\t\t}\n\t\t}\n#endif\n\n\tswitch (cmd)\n\t\t{\n\tcase SSL_CTRL_GET_SESSION_REUSED:\n\t\tret=s->hit;\n\t\tbreak;\n\tcase SSL_CTRL_GET_CLIENT_CERT_REQUEST:\n\t\tbreak;\n\tcase SSL_CTRL_GET_NUM_RENEGOTIATIONS:\n\t\tret=s->s3->num_renegotiations;\n\t\tbreak;\n\tcase SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS:\n\t\tret=s->s3->num_renegotiations;\n\t\ts->s3->num_renegotiations=0;\n\t\tbreak;\n\tcase SSL_CTRL_GET_TOTAL_RENEGOTIATIONS:\n\t\tret=s->s3->total_renegotiations;\n\t\tbreak;\n\tcase SSL_CTRL_GET_FLAGS:\n\t\tret=(int)(s->s3->flags);\n\t\tbreak;\n#ifndef OPENSSL_NO_RSA\n\tcase SSL_CTRL_NEED_TMP_RSA:\n\t\tif ((s->cert != NULL) && (s->cert->rsa_tmp == NULL) &&\n\t\t    ((s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\n\t\t     (EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) > (512/8))))\n\t\t\tret = 1;\n\t\tbreak;\n\tcase SSL_CTRL_SET_TMP_RSA:\n\t\t{\n\t\t\tRSA *rsa = (RSA *)parg;\n\t\t\tif (rsa == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\tif ((rsa = RSAPrivateKey_dup(rsa)) == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_RSA_LIB);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\tif (s->cert->rsa_tmp != NULL)\n\t\t\t\tRSA_free(s->cert->rsa_tmp);\n\t\t\ts->cert->rsa_tmp = rsa;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tcase SSL_CTRL_SET_TMP_RSA_CB:\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\treturn(ret);\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DH\n\tcase SSL_CTRL_SET_TMP_DH:\n\t\t{\n\t\t\tDH *dh = (DH *)parg;\n\t\t\tif (dh == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\tif ((dh = DHparams_dup(dh)) == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\tif (!(s->options & SSL_OP_SINGLE_DH_USE))\n\t\t\t\t{\n\t\t\t\tif (!DH_generate_key(dh))\n\t\t\t\t\t{\n\t\t\t\t\tDH_free(dh);\n\t\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\n\t\t\t\t\treturn(ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (s->cert->dh_tmp != NULL)\n\t\t\t\tDH_free(s->cert->dh_tmp);\n\t\t\ts->cert->dh_tmp = dh;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tcase SSL_CTRL_SET_TMP_DH_CB:\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\treturn(ret);\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tcase SSL_CTRL_SET_TMP_ECDH:\n\t\t{\n\t\tEC_KEY *ecdh = NULL;\n \t\t\t\n\t\tif (parg == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n\t\t\treturn(ret);\n\t\t\t}\n\t\tif (!EC_KEY_up_ref((EC_KEY *)parg))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL,ERR_R_ECDH_LIB);\n\t\t\treturn(ret);\n\t\t\t}\n\t\tecdh = (EC_KEY *)parg;\n\t\tif (!(s->options & SSL_OP_SINGLE_ECDH_USE))\n\t\t\t{\n\t\t\tif (!EC_KEY_generate_key(ecdh))\n\t\t\t\t{\n\t\t\t\tEC_KEY_free(ecdh);\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL,ERR_R_ECDH_LIB);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\t}\n\t\tif (s->cert->ecdh_tmp != NULL)\n\t\t\tEC_KEY_free(s->cert->ecdh_tmp);\n\t\ts->cert->ecdh_tmp = ecdh;\n\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tcase SSL_CTRL_SET_TMP_ECDH_CB:\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\treturn(ret);\n\t\t}\n\t\tbreak;\n#endif /* !OPENSSL_NO_ECDH */\n#ifndef OPENSSL_NO_TLSEXT\n\tcase SSL_CTRL_SET_TLSEXT_HOSTNAME:\n \t\tif (larg == TLSEXT_NAMETYPE_host_name)\n\t\t\t{\n\t\t\tif (s->tlsext_hostname != NULL) \n\t\t\t\tOPENSSL_free(s->tlsext_hostname);\n\t\t\ts->tlsext_hostname = NULL;\n\n\t\t\tret = 1;\n\t\t\tif (parg == NULL) \n\t\t\t\tbreak;\n\t\t\tif (strlen((char *)parg) > TLSEXT_MAXLEN_host_name)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME);\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif ((s->tlsext_hostname = BUF_strdup((char *)parg)) == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE);\n\t\t\treturn 0;\n\t\t\t}\n \t\tbreak;\n\tcase SSL_CTRL_SET_TLSEXT_DEBUG_ARG:\n\t\ts->tlsext_debug_arg=parg;\n\t\tret = 1;\n\t\tbreak;\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tcase SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT:\n\t\tif (larg > 12288) /* actual internal limit is 2^16 for the complete hello message\n\t\t                   * (including the cert chain and everything) */\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL, SSL_R_OPAQUE_PRF_INPUT_TOO_LONG);\n\t\t\tbreak;\n\t\t\t}\n\t\tif (s->tlsext_opaque_prf_input != NULL)\n\t\t\tOPENSSL_free(s->tlsext_opaque_prf_input);\n\t\tif ((size_t)larg == 0)\n\t\t\ts->tlsext_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */\n\t\telse\n\t\t\ts->tlsext_opaque_prf_input = BUF_memdup(parg, (size_t)larg);\n\t\tif (s->tlsext_opaque_prf_input != NULL)\n\t\t\t{\n\t\t\ts->tlsext_opaque_prf_input_len = (size_t)larg;\n\t\t\tret = 1;\n\t\t\t}\n\t\telse\n\t\t\ts->tlsext_opaque_prf_input_len = 0;\n\t\tbreak;\n#endif\n\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE:\n\t\ts->tlsext_status_type=larg;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS:\n\t\t*(STACK_OF(X509_EXTENSION) **)parg = s->tlsext_ocsp_exts;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS:\n\t\ts->tlsext_ocsp_exts = parg;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS:\n\t\t*(STACK_OF(OCSP_RESPID) **)parg = s->tlsext_ocsp_ids;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS:\n\t\ts->tlsext_ocsp_ids = parg;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP:\n\t\t*(unsigned char **)parg = s->tlsext_ocsp_resp;\n\t\treturn s->tlsext_ocsp_resplen;\n\t\t\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP:\n\t\tif (s->tlsext_ocsp_resp)\n\t\t\tOPENSSL_free(s->tlsext_ocsp_resp);\n\t\ts->tlsext_ocsp_resp = parg;\n\t\ts->tlsext_ocsp_resplen = larg;\n\t\tret = 1;\n\t\tbreak;\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\tcase SSL_CTRL_TLS_EXT_SEND_HEARTBEAT:\n\t\tif (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)\n\t\t\tret = dtls1_heartbeat(s);\n\t\telse\n\t\t\tret = tls1_heartbeat(s);\n\t\tbreak;\n\n\tcase SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING:\n\t\tret = s->tlsext_hb_pending;\n\t\tbreak;\n\n\tcase SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS:\n\t\tif (larg)\n\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\n\t\telse\n\t\t\ts->tlsext_heartbeat &= ~SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\n\t\tret = 1;\n\t\tbreak;\n#endif\n\n#endif /* !OPENSSL_NO_TLSEXT */\n\tdefault:\n\t\tbreak;\n\t\t}\n\treturn(ret);\n\t}", "target": 1, "cwe": ["CWE-310"], "project": "openssl", "commit_id": "6bfe55380abbf7528e04e59f18921bd6c896af1c", "hash": 209348981415698375945450519958056022751, "size": 272, "message": "Support TLS_FALLBACK_SCSV.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>", "idx": 176}
{"func": "    CImg(const T *const values, const unsigned int size_x, const unsigned int size_y=1,\n         const unsigned int size_z=1, const unsigned int size_c=1, const bool is_shared=false) {\n      const size_t siz = safe_size(size_x,size_y,size_z,size_c);\n      if (values && siz) {\n        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c; _is_shared = is_shared;\n        if (_is_shared) _data = const_cast<T*>(values);\n        else {\n          try { _data = new T[siz]; } catch (...) {\n            _width = _height = _depth = _spectrum = 0; _data = 0;\n            throw CImgInstanceException(_cimg_instance\n                                        \"CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).\",\n                                        cimg_instance,\n                                        cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),\n                                        size_x,size_y,size_z,size_c);\n          }\n          std::memcpy(_data,values,siz*sizeof(T));\n        }\n      } else { _width = _height = _depth = _spectrum = 0; _is_shared = false; _data = 0; }\n    }", "target": 0, "cwe": ["CWE-770"], "project": "cimg", "commit_id": "619cb58dd90b4e03ac68286c70ed98acbefd1c90", "hash": 202450736286082426701488189044660799457, "size": 19, "message": "CImg<>::load_bmp() and CImg<>::load_pandore(): Check that dimensions encoded in file does not exceed file size.", "idx": 177}
{"func": "XML_ResumeParser(XML_Parser parser)\n{\n  enum XML_Status result = XML_STATUS_OK;\n\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  if (ps_parsing != XML_SUSPENDED) {\n    errorCode = XML_ERROR_NOT_SUSPENDED;\n    return XML_STATUS_ERROR;\n  }\n  ps_parsing = XML_PARSING;\n\n  errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);\n\n  if (errorCode != XML_ERROR_NONE) {\n    eventEndPtr = eventPtr;\n    processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  }\n  else {\n    switch (ps_parsing) {\n    case XML_SUSPENDED:\n      result = XML_STATUS_SUSPENDED;\n      break;\n    case XML_INITIALIZED:\n    case XML_PARSING:\n      if (ps_finalBuffer) {\n        ps_parsing = XML_FINISHED;\n        return result;\n      }\n    default: ;\n    }\n  }\n\n  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);\n  positionPtr = bufferPtr;\n  return result;\n}", "target": 0, "cwe": ["CWE-611"], "project": "libexpat", "commit_id": "c4bf96bb51dd2a1b0e185374362ee136fe2c9d7f", "hash": 184895403597468380474722334959558253639, "size": 38, "message": "xmlparse.c: Fix external entity infinite loop bug (CVE-2017-9233)", "idx": 178}
{"func": "TEST_F(RouterTest, MissingRequiredHeaders) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _))\n      .WillOnce(Invoke(\n          [&](Http::ResponseDecoder& decoder,\n              Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.removeMethod();\n\n  EXPECT_CALL(encoder, encodeHeaders(_, _))\n      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {\n        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);\n      }));\n  EXPECT_CALL(\n      callbacks_,\n      sendLocalReply(Http::Code::ServiceUnavailable,\n                     testing::Eq(\"missing required header: :method\"), _, _,\n                     \"filter_removed_required_request_headers{missing required header: :method}\"))\n      .WillOnce(testing::InvokeWithoutArgs([] {}));\n  router_.decodeHeaders(headers, true);\n  router_.onDestroy();\n}", "target": 1, "cwe": ["CWE-703"], "project": "envoy", "commit_id": "f0bb2219112d8cdb4c4e8b346834f962925362ca", "hash": 74443809902179728317176473739757807871, "size": 31, "message": "[1.20] CVE-2022-21655\n\nCrash with direct_response\n\nSigned-off-by: Otto van der Schaaf <ovanders@redhat.com>", "idx": 179}
{"func": "MONGO_COMPILER_NOINLINE void DocumentSourceUnionWith::logStartingSubPipeline(\n    const std::vector<BSONObj>& serializedPipe) {\n    LOGV2_DEBUG(23869,\n                1,\n                \"$unionWith attaching cursor to pipeline {pipeline}\",\n                \"pipeline\"_attr = serializedPipe);\n}", "target": 0, "cwe": [], "project": "mongo", "commit_id": "6518b22420c5bbd92c42caf907671c3a2b140bb6", "hash": 18181629949785970412104525373054085516, "size": 7, "message": "SERVER-58203 factor out logging statements into helper functions", "idx": 180}
{"func": "CURLcode Curl_http_host(struct Curl_easy *data, struct connectdata *conn)\n{\n  const char *ptr;\n  if(!data->state.this_is_a_follow) {\n    /* Free to avoid leaking memory on multiple requests*/\n    free(data->state.first_host);\n\n    data->state.first_host = strdup(conn->host.name);\n    if(!data->state.first_host)\n      return CURLE_OUT_OF_MEMORY;\n\n    data->state.first_remote_port = conn->remote_port;\n  }\n  Curl_safefree(data->state.aptr.host);\n\n  ptr = Curl_checkheaders(data, STRCONST(\"Host\"));\n  if(ptr && (!data->state.this_is_a_follow ||\n             strcasecompare(data->state.first_host, conn->host.name))) {\n#if !defined(CURL_DISABLE_COOKIES)\n    /* If we have a given custom Host: header, we extract the host name in\n       order to possibly use it for cookie reasons later on. We only allow the\n       custom Host: header if this is NOT a redirect, as setting Host: in the\n       redirected request is being out on thin ice. Except if the host name\n       is the same as the first one! */\n    char *cookiehost = Curl_copy_header_value(ptr);\n    if(!cookiehost)\n      return CURLE_OUT_OF_MEMORY;\n    if(!*cookiehost)\n      /* ignore empty data */\n      free(cookiehost);\n    else {\n      /* If the host begins with '[', we start searching for the port after\n         the bracket has been closed */\n      if(*cookiehost == '[') {\n        char *closingbracket;\n        /* since the 'cookiehost' is an allocated memory area that will be\n           freed later we cannot simply increment the pointer */\n        memmove(cookiehost, cookiehost + 1, strlen(cookiehost) - 1);\n        closingbracket = strchr(cookiehost, ']');\n        if(closingbracket)\n          *closingbracket = 0;\n      }\n      else {\n        int startsearch = 0;\n        char *colon = strchr(cookiehost + startsearch, ':');\n        if(colon)\n          *colon = 0; /* The host must not include an embedded port number */\n      }\n      Curl_safefree(data->state.aptr.cookiehost);\n      data->state.aptr.cookiehost = cookiehost;\n    }\n#endif\n\n    if(strcmp(\"Host:\", ptr)) {\n      data->state.aptr.host = aprintf(\"Host:%s\\r\\n\", &ptr[5]);\n      if(!data->state.aptr.host)\n        return CURLE_OUT_OF_MEMORY;\n    }\n    else\n      /* when clearing the header */\n      data->state.aptr.host = NULL;\n  }\n  else {\n    /* When building Host: headers, we must put the host name within\n       [brackets] if the host name is a plain IPv6-address. RFC2732-style. */\n    const char *host = conn->host.name;\n\n    if(((conn->given->protocol&CURLPROTO_HTTPS) &&\n        (conn->remote_port == PORT_HTTPS)) ||\n       ((conn->given->protocol&CURLPROTO_HTTP) &&\n        (conn->remote_port == PORT_HTTP)) )\n      /* if(HTTPS on port 443) OR (HTTP on port 80) then don't include\n         the port number in the host string */\n      data->state.aptr.host = aprintf(\"Host: %s%s%s\\r\\n\",\n                                    conn->bits.ipv6_ip?\"[\":\"\",\n                                    host,\n                                    conn->bits.ipv6_ip?\"]\":\"\");\n    else\n      data->state.aptr.host = aprintf(\"Host: %s%s%s:%d\\r\\n\",\n                                    conn->bits.ipv6_ip?\"[\":\"\",\n                                    host,\n                                    conn->bits.ipv6_ip?\"]\":\"\",\n                                    conn->remote_port);\n\n    if(!data->state.aptr.host)\n      /* without Host: we can't make a nice request */\n      return CURLE_OUT_OF_MEMORY;\n  }\n  return CURLE_OK;\n}", "target": 1, "cwe": [], "project": "curl", "commit_id": "6e659993952aa5f90f48864be84a1bbb047fc258", "hash": 297497962919205821360353427413470445600, "size": 90, "message": "http: avoid auth/cookie on redirects same host diff port\n\nCVE-2022-27776\n\nReported-by: Harry Sintonen\nBug: https://curl.se/docs/CVE-2022-27776.html\nCloses #8749", "idx": 181}
{"func": "do_compose_group(pdf14_buf *tos, pdf14_buf *nos, pdf14_buf *maskbuf,\n              int x0, int x1, int y0, int y1, int n_chan, bool additive,\n              const pdf14_nonseparable_blending_procs_t * pblend_procs,\n              bool has_matte, bool overprint, gx_color_index drawn_comps,\n              gs_memory_t *memory, gx_device *dev)\n{\n    int num_spots = tos->num_spots;\n    byte alpha = tos->alpha>>8;\n    byte shape = tos->shape>>8;\n    gs_blend_mode_t blend_mode = tos->blend_mode;\n    byte *tos_ptr = tos->data + x0 - tos->rect.p.x +\n        (y0 - tos->rect.p.y) * tos->rowstride;\n    byte *nos_ptr = nos->data + x0 - nos->rect.p.x +\n        (y0 - nos->rect.p.y) * nos->rowstride;\n    byte *mask_row_ptr = NULL;\n    int tos_planestride = tos->planestride;\n    int nos_planestride = nos->planestride;\n    byte mask_bg_alpha = 0; /* Quiet compiler. */\n    bool tos_isolated = tos->isolated;\n    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    byte *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    byte *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool is_ident = true;\n    bool has_mask = false;\n    byte *backdrop_ptr = NULL;\n    pdf14_device *pdev = (pdf14_device *)dev;\n\n\n#if RAW_DUMP\n    byte *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n    rect_merge(nos->dirty, tos->dirty);\n    if (nos->has_tags)\n        if_debug7m('v', memory,\n                   \"pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, tag = %d, bm = %d\\n\",\n                   y0, y1, x1 - x0, alpha, shape, dev->graphics_type_tag & ~GS_DEVICE_ENCODES_TAGS, blend_mode);\n    else\n        if_debug6m('v', memory,\n                   \"pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, bm = %d\\n\",\n                   y0, y1, x1 - x0, alpha, shape, blend_mode);\n    if (!nos->has_shape)\n        nos_shape_offset = 0;\n    if (!nos->has_tags)\n        nos_tag_offset = 0;\n    if (nos->has_alpha_g) {\n        nos_alpha_g_ptr = nos_ptr + nos_alpha_g_offset;\n    } else\n        nos_alpha_g_ptr = NULL;\n    if (nos->backdrop != NULL) {\n        backdrop_ptr = nos->backdrop + x0 - nos->rect.p.x +\n                       (y0 - nos->rect.p.y) * nos->rowstride;\n    }\n    if (blend_mode != BLEND_MODE_Compatible && blend_mode != BLEND_MODE_Normal)\n        overprint = false;\n\n    if (maskbuf != NULL) {\n        int tmp;\n\n        mask_tr_fn = maskbuf->transfer_fn;\n\n        is_ident = maskbuf->is_ident;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr = maskbuf->data + x0 - maskbuf->rect.p.x +\n                    (y0 - maskbuf->rect.p.y) * maskbuf->rowstride;\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha>>8;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = mask_tr_fn[mask_bg_alpha];\n        tmp = alpha * mask_bg_alpha + 0x80;\n        mask_bg_alpha = (tmp + (tmp >> 8)) >> 8;\n    }\n    n_chan--; /* Now the true number of colorants (i.e. not including alpha)*/\n#if RAW_DUMP\n    composed_ptr = nos_ptr;\n    dump_raw_buffer(memory, y1-y0, width, tos->n_planes, tos_planestride, tos->rowstride,\n                    \"bImageTOS\", tos_ptr, tos->deep);\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \"cImageNOS\", nos_ptr, tos->deep);\n    if (maskbuf !=NULL && maskbuf->data != NULL) {\n        dump_raw_buffer(memory, maskbuf->rect.q.y - maskbuf->rect.p.y,\n                        maskbuf->rect.q.x - maskbuf->rect.p.x, maskbuf->n_planes,\n                        maskbuf->planestride, maskbuf->rowstride, \"dMask\",\n                        maskbuf->data, maskbuf->deep);\n    }\n#endif\n\n    /* You might hope that has_mask iff maskbuf != NULL, but this is\n     * not the case. Certainly we can see cases where maskbuf != NULL\n     * and has_mask = 0. What's more, treating such cases as being\n     * has_mask = 0 causes diffs. */\n#ifdef TRACK_COMPOSE_GROUPS\n    {\n        int code = 0;\n\n        code += !!nos_knockout;\n        code += (!!nos_isolated)<<1;\n        code += (!!tos_isolated)<<2;\n        code += (!!tos->has_shape)<<3;\n        code += (!!tos_has_tag)<<4;\n        code += (!!additive)<<5;\n        code += (!!overprint)<<6;\n        code += (!!has_mask || maskbuf != NULL)<<7;\n        code += (!!has_matte)<<8;\n        code += (backdrop_ptr != NULL)<<9;\n        code += (num_spots != 0)<<10;\n        code += blend_mode<<11;\n\n        if (track_compose_groups == 0)\n        {\n            atexit(dump_track_compose_groups);\n            track_compose_groups = 1;\n        }\n        compose_groups[code]++;\n    }\n#endif\n\n    /* We have tested the files on the cluster to see what percentage of\n     * files/devices hit the different options. */\n    if (nos_knockout)\n        fn = &compose_group_knockout; /* Small %ages, nothing more than 1.1% */\n    else if (blend_mode != 0)\n        fn = &compose_group_nonknockout_blend; /* Small %ages, nothing more than 2% */\n    else if (tos->has_shape == 0 && tos_has_tag == 0 && nos_isolated == 0 && nos_alpha_g_ptr == NULL &&\n             nos_shape_offset == 0 && nos_tag_offset == 0 && backdrop_ptr == NULL && has_matte == 0 && num_spots == 0 &&\n             overprint == 0) {\n             /* Additive vs Subtractive makes no difference in normal blend mode with no spots */\n        if (tos_isolated) {\n            if (has_mask || maskbuf) {/* 7% */\n                /* AirPrint test case hits this */\n                if (maskbuf && maskbuf->rect.p.x <= x0 && maskbuf->rect.p.y <= y0 &&\n                    maskbuf->rect.q.x >= x1 && maskbuf->rect.q.y >= y1) {\n                    /* AVX and SSE accelerations only valid if maskbuf transfer\n                       function is identity and we have no matte color replacement */\n                    if (is_ident && !has_matte) {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n#ifdef WITH_CAL\n\t\t\tfn = (art_pdf_compose_group_fn)cal_get_compose_group(\n\t\t\t\t\t memory->gs_lib_ctx->core->cal_ctx,\n\t\t\t\t\t (cal_composer_proc_t *)fn,\n\t\t\t\t\t tos->n_chan-1);\n#endif\n                    } else {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n                    }\n                } else\n                    fn = &compose_group_nonknockout_nonblend_isolated_mask_common;\n            } else /* 14% */\n                fn = &compose_group_nonknockout_nonblend_isolated_nomask_common;\n        } else {\n            if (has_mask || maskbuf) /* 4% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_mask_common;\n            else /* 15% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_nomask_common;\n        }\n    } else\n        fn = compose_group_nonknockout_noblend_general;\n\n    fn(tos_ptr, tos_isolated, tos_planestride, tos->rowstride, alpha, shape,\n        blend_mode, tos->has_shape, tos_shape_offset, tos_alpha_g_offset,\n        tos_tag_offset, tos_has_tag, nos_ptr, nos_isolated, nos_planestride,\n        nos->rowstride, nos_alpha_g_ptr, nos_knockout, nos_shape_offset,\n        nos_tag_offset, mask_row_ptr, has_mask, maskbuf, mask_bg_alpha,\n        mask_tr_fn, backdrop_ptr, has_matte, n_chan, additive, num_spots,\n        overprint, drawn_comps, x0, y0, x1, y1, pblend_procs, pdev);\n\n#if RAW_DUMP\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \"eComposed\", composed_ptr, nos->deep);\n    global_index++;\n#endif\n}", "target": 1, "cwe": ["CWE-476"], "project": "ghostpdl", "commit_id": "7870f4951bcc6a153f317e3439e14d0e929fd231", "hash": 338349480252986545311673816338070211685, "size": 191, "message": "Bug 701795: Segv due to image mask issue", "idx": 182}
{"func": "static int rfcomm_tty_write(struct tty_struct *tty, const unsigned char *buf, int count)\n{\n\tstruct rfcomm_dev *dev = (struct rfcomm_dev *) tty->driver_data;\n\tstruct rfcomm_dlc *dlc = dev->dlc;\n\tstruct sk_buff *skb;\n\tint err = 0, sent = 0, size;\n\n\tBT_DBG(\"tty %p count %d\", tty, count);\n\n\twhile (count) {\n\t\tsize = min_t(uint, count, dlc->mtu);\n\n\t\tskb = rfcomm_wmalloc(dev, size + RFCOMM_SKB_RESERVE, GFP_ATOMIC);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tskb_reserve(skb, RFCOMM_SKB_HEAD_RESERVE);\n\n\t\tmemcpy(skb_put(skb, size), buf + sent, size);\n\n\t\terr = rfcomm_dlc_send(dlc, skb);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tsent  += size;\n\t\tcount -= size;\n\t}\n\n\treturn sent ? sent : err;\n}", "target": 0, "cwe": ["CWE-200"], "project": "linux", "commit_id": "f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a", "hash": 249586158420228708173504584774679813507, "size": 33, "message": "Bluetooth: RFCOMM - Fix info leak in ioctl(RFCOMMGETDEVLIST)\n\nThe RFCOMM code fails to initialize the two padding bytes of struct\nrfcomm_dev_list_req inserted for alignment before copying it to\nuserland. Additionally there are two padding bytes in each instance of\nstruct rfcomm_dev_info. The ioctl() that for disclosures two bytes plus\ndev_num times two bytes uninitialized kernel heap memory.\n\nAllocate the memory using kzalloc() to fix this issue.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nCc: Marcel Holtmann <marcel@holtmann.org>\nCc: Gustavo Padovan <gustavo@padovan.org>\nCc: Johan Hedberg <johan.hedberg@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 183}
{"func": "  void Compute(OpKernelContext* context) override {\n    const Tensor& diagonal = context->input(0);\n\n    // MatrixDiag and MatrixDiagV2 both use this OpKernel. MatrixDiag only has\n    // one input, so we have to check the number of inputs before reading\n    // additional parameters in MatrixDiagV2.\n    int32_t lower_diag_index = 0;\n    int32_t upper_diag_index = 0;\n    int32_t num_rows = -1;\n    int32_t num_cols = -1;\n    T padding_value(0);\n\n    // MatrixDiagOpV2-specific.\n    if (context->num_inputs() > kNumV1Inputs) {\n      auto& diag_index = context->input(1);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(diag_index.shape()) ||\n                      TensorShapeUtils::IsVector(diag_index.shape()),\n                  errors::InvalidArgument(\n                      \"diag_index must be a scalar or vector, received shape: \",\n                      diag_index.shape().DebugString()));\n      lower_diag_index = diag_index.flat<int32>()(0);\n      upper_diag_index = lower_diag_index;\n      if (TensorShapeUtils::IsVector(diag_index.shape())) {\n        auto diag_index_size = diag_index.dim_size(0);\n        OP_REQUIRES(\n            context, 0 < diag_index_size && diag_index_size <= 2,\n            errors::InvalidArgument(\n                \"diag_index must have only one or two elements, received \",\n                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n\n      auto& num_rows_tensor = context->input(2);\n      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_rows_tensor.shape()),\n                  errors::InvalidArgument(\"num_rows must be a scalar\"));\n      num_rows = num_rows_tensor.flat<int32>()(0);\n\n      auto& num_cols_tensor = context->input(3);\n      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_cols_tensor.shape()),\n                  errors::InvalidArgument(\"num_cols must be a scalar\"));\n      num_cols = num_cols_tensor.flat<int32>()(0);\n\n      auto& padding_value_tensor = context->input(4);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(padding_value_tensor.shape()),\n                  errors::InvalidArgument(\"padding_value must be a scalar\"));\n      padding_value = padding_value_tensor.flat<T>()(0);\n    }\n\n    // Size validations.\n    const TensorShape& diagonal_shape = diagonal.shape();\n    const int diag_rank = diagonal_shape.dims();\n    const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;\n    OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diagonal_shape),\n                errors::InvalidArgument(\n                    \"diagonal must be at least 1-dim, received shape: \",\n                    diagonal.shape().DebugString()));\n    OP_REQUIRES(\n        context, lower_diag_index <= upper_diag_index,\n        errors::InvalidArgument(\n            \"lower_diag_index must not be larger than upper_diag_index: \",\n            lower_diag_index, \" > \", upper_diag_index));\n    OP_REQUIRES(context,\n                lower_diag_index == upper_diag_index ||\n                    diagonal_shape.dim_size(diag_rank - 2) == num_diags,\n                errors::InvalidArgument(\n                    \"The number of diagonals provided in the input does not \"\n                    \"match the lower_diag_index and upper_diag_index range.\"));\n\n    const Eigen::Index max_diag_len = diagonal_shape.dim_size(diag_rank - 1);\n    const int32_t min_num_rows = max_diag_len - std::min(upper_diag_index, 0);\n    const int32_t min_num_cols = max_diag_len + std::max(lower_diag_index, 0);\n    OP_REQUIRES(context, num_rows == -1 || num_rows >= min_num_rows,\n                errors::InvalidArgument(\"The number of rows is too small.\"));\n    OP_REQUIRES(context, num_cols == -1 || num_cols >= min_num_cols,\n                errors::InvalidArgument(\"The number of columns is too small.\"));\n\n    // If both num_rows and num_cols are unknown, assume that output is square.\n    // Otherwise, use smallest possible values.\n    if (num_rows == -1 && num_cols == -1) {\n      num_rows = std::max(min_num_rows, min_num_cols);\n      num_cols = num_rows;\n    } else if (num_rows == -1) {\n      num_rows = min_num_rows;\n    } else if (num_cols == -1) {\n      num_cols = min_num_cols;\n    }\n    OP_REQUIRES(context, num_rows == min_num_rows || num_cols == min_num_cols,\n                errors::InvalidArgument(\n                    \"The number of rows or columns is not consistent with \"\n                    \"the specified d_lower, d_upper, and diagonal.\"));\n\n    TensorShape output_shape = diagonal_shape;\n    if (num_diags == 1) {  // Output has rank `rank+1`.\n      output_shape.set_dim(diag_rank - 1, num_rows);\n      output_shape.AddDim(num_cols);\n    } else {  // Output has rank `rank`.\n      output_shape.set_dim(diag_rank - 2, num_rows);\n      output_shape.set_dim(diag_rank - 1, num_cols);\n    }\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_reshaped = output->flat_inner_dims<T, 3>();\n    auto diag_reshaped = diagonal.flat<T>();\n    functor::MatrixDiag<Device, T>::Compute(\n        context, context->eigen_device<Device>(), diag_reshaped,\n        output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,\n        padding_value, left_align_superdiagonal_, left_align_subdiagonal_);\n  }", "target": 1, "cwe": ["CWE-703", "CWE-824"], "project": "tensorflow", "commit_id": "f2a673bd34f0d64b8e40a551ac78989d16daad09", "hash": 167243380912468199026734927585452417692, "size": 113, "message": "Add missing validation to `matrix_diag_op.cc`\n\nPiperOrigin-RevId: 387923533\nChange-Id: Idfffeb328d5f9c6748d992d28a56d6e9e45103a0", "idx": 184}
{"func": "plperl_call_perl_func(plperl_proc_desc *desc, FunctionCallInfo fcinfo)\n{\n\tdSP;\n\tSV\t\t   *retval;\n\tint\t\t\ti;\n\tint\t\t\tcount;\n\n\tENTER;\n\tSAVETMPS;\n\n\tPUSHMARK(SP);\n\tEXTEND(sp, desc->nargs);\n\n\tfor (i = 0; i < desc->nargs; i++)\n\t{\n\t\tif (fcinfo->argnull[i])\n\t\t\tPUSHs(&PL_sv_undef);\n\t\telse if (desc->arg_is_rowtype[i])\n\t\t{\n\t\t\tSV\t\t   *sv = plperl_hash_from_datum(fcinfo->arg[i]);\n\n\t\t\tPUSHs(sv_2mortal(sv));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSV\t\t   *sv;\n\n\t\t\tif (OidIsValid(desc->arg_arraytype[i]))\n\t\t\t\tsv = plperl_ref_from_pg_array(fcinfo->arg[i], desc->arg_arraytype[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *tmp;\n\n\t\t\t\ttmp = OutputFunctionCall(&(desc->arg_out_func[i]),\n\t\t\t\t\t\t\t\t\t\t fcinfo->arg[i]);\n\t\t\t\tsv = cstr2sv(tmp);\n\t\t\t\tpfree(tmp);\n\t\t\t}\n\n\t\t\tPUSHs(sv_2mortal(sv));\n\t\t}\n\t}\n\tPUTBACK;\n\n\t/* Do NOT use G_KEEPERR here */\n\tcount = perl_call_sv(desc->reference, G_SCALAR | G_EVAL);\n\n\tSPAGAIN;\n\n\tif (count != 1)\n\t{\n\t\tPUTBACK;\n\t\tFREETMPS;\n\t\tLEAVE;\n\t\telog(ERROR, \"didn't get a return item from function\");\n\t}\n\n\tif (SvTRUE(ERRSV))\n\t{\n\t\t(void) POPs;\n\t\tPUTBACK;\n\t\tFREETMPS;\n\t\tLEAVE;\n\t\t/* XXX need to find a way to assign an errcode here */\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"%s\", strip_trailing_ws(sv2cstr(ERRSV)))));\n\t}\n\n\tretval = newSVsv(POPs);\n\n\tPUTBACK;\n\tFREETMPS;\n\tLEAVE;\n\n\treturn retval;\n}", "target": 0, "cwe": ["CWE-264"], "project": "postgres", "commit_id": "537cbd35c893e67a63c59bc636c3e888bd228bc7", "hash": 74603415615081023950475276833559214633, "size": 76, "message": "Prevent privilege escalation in explicit calls to PL validators.\n\nThe primary role of PL validators is to be called implicitly during\nCREATE FUNCTION, but they are also normal functions that a user can call\nexplicitly.  Add a permissions check to each validator to ensure that a\nuser cannot use explicit validator calls to achieve things he could not\notherwise achieve.  Back-patch to 8.4 (all supported versions).\nNon-core procedural language extensions ought to make the same two-line\nchange to their own validators.\n\nAndres Freund, reviewed by Tom Lane and Noah Misch.\n\nSecurity: CVE-2014-0061", "idx": 185}
{"func": "int __init early_init_dt_scan_rtas(unsigned long node,\n\t\tconst char *uname, int depth, void *data)\n{\n\tconst u32 *basep, *entryp, *sizep;\n\n\tif (depth != 1 || strcmp(uname, \"rtas\") != 0)\n\t\treturn 0;\n\n\tbasep  = of_get_flat_dt_prop(node, \"linux,rtas-base\", NULL);\n\tentryp = of_get_flat_dt_prop(node, \"linux,rtas-entry\", NULL);\n\tsizep  = of_get_flat_dt_prop(node, \"rtas-size\", NULL);\n\n\tif (basep && entryp && sizep) {\n\t\trtas.base = *basep;\n\t\trtas.entry = *entryp;\n\t\trtas.size = *sizep;\n\t}\n\n#ifdef CONFIG_UDBG_RTAS_CONSOLE\n\tbasep = of_get_flat_dt_prop(node, \"put-term-char\", NULL);\n\tif (basep)\n\t\trtas_putchar_token = *basep;\n\n\tbasep = of_get_flat_dt_prop(node, \"get-term-char\", NULL);\n\tif (basep)\n\t\trtas_getchar_token = *basep;\n\n\tif (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&\n\t    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)\n\t\tudbg_init_rtas_console();\n\n#endif\n\n\t/* break now */\n\treturn 1;\n}", "target": 0, "cwe": ["CWE-862"], "project": "linux", "commit_id": "bd59380c5ba4147dcbaad3e582b55ccfd120b764", "hash": 75098512625892994572184637827521610943, "size": 36, "message": "powerpc/rtas: Restrict RTAS requests from userspace\n\nA number of userspace utilities depend on making calls to RTAS to retrieve\ninformation and update various things.\n\nThe existing API through which we expose RTAS to userspace exposes more\nRTAS functionality than we actually need, through the sys_rtas syscall,\nwhich allows root (or anyone with CAP_SYS_ADMIN) to make any RTAS call they\nwant with arbitrary arguments.\n\nMany RTAS calls take the address of a buffer as an argument, and it's up to\nthe caller to specify the physical address of the buffer as an argument. We\nallocate a buffer (the \"RMO buffer\") in the Real Memory Area that RTAS can\naccess, and then expose the physical address and size of this buffer in\n/proc/powerpc/rtas/rmo_buffer. Userspace is expected to read this address,\npoke at the buffer using /dev/mem, and pass an address in the RMO buffer to\nthe RTAS call.\n\nHowever, there's nothing stopping the caller from specifying whatever\naddress they want in the RTAS call, and it's easy to construct a series of\nRTAS calls that can overwrite arbitrary bytes (even without /dev/mem\naccess).\n\nAdditionally, there are some RTAS calls that do potentially dangerous\nthings and for which there are no legitimate userspace use cases.\n\nIn the past, this would not have been a particularly big deal as it was\nassumed that root could modify all system state freely, but with Secure\nBoot and lockdown we need to care about this.\n\nWe can't fundamentally change the ABI at this point, however we can address\nthis by implementing a filter that checks RTAS calls against a list\nof permitted calls and forces the caller to use addresses within the RMO\nbuffer.\n\nThe list is based off the list of calls that are used by the librtas\nuserspace library, and has been tested with a number of existing userspace\nRTAS utilities. For compatibility with any applications we are not aware of\nthat require other calls, the filter can be turned off at build time.\n\nCc: stable@vger.kernel.org\nReported-by: Daniel Axtens <dja@axtens.net>\nSigned-off-by: Andrew Donnellan <ajd@linux.ibm.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20200820044512.7543-1-ajd@linux.ibm.com", "idx": 186}
{"func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    }\n\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader *header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        error_propagate(errp, local_err);\n        return ret;\n    }\n\n    bs = NULL;\n    ret = bdrv_open(&bs, filename, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL,\n                    NULL, &local_err);\n    if (ret < 0) {\n        error_propagate(errp, local_err);\n        return ret;\n    }\n\n    /* Write the header */\n    QEMU_BUILD_BUG_ON((1 << MIN_CLUSTER_BITS) < sizeof(*header));\n    header = g_malloc0(cluster_size);\n    *header = (QCowHeader) {\n        .magic                      = cpu_to_be32(QCOW_MAGIC),\n        .version                    = cpu_to_be32(version),\n        .cluster_bits               = cpu_to_be32(cluster_bits),\n        .size                       = cpu_to_be64(0),\n        .l1_table_offset            = cpu_to_be64(0),\n        .l1_size                    = cpu_to_be32(0),\n        .refcount_table_offset      = cpu_to_be64(cluster_size),\n        .refcount_table_clusters    = cpu_to_be32(1),\n        .refcount_order             = cpu_to_be32(3 + REFCOUNT_SHIFT),\n        .header_length              = cpu_to_be32(sizeof(*header)),\n    };\n\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header->crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header->crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    }\n\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header->compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    }\n\n    ret = bdrv_pwrite(bs, 0, header, cluster_size);\n    g_free(header);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n        goto out;\n    }\n\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n        goto out;\n    }\n\n    bdrv_unref(bs);\n    bs = NULL;\n\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n    ret = bdrv_open(&bs, filename, NULL, NULL,\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n        goto out;\n\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    }\n\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n        goto out;\n    }\n\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n            goto out;\n        }\n    }\n\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n            goto out;\n        }\n    }\n\n    bdrv_unref(bs);\n    bs = NULL;\n\n    /* Reopen the image without BDRV_O_NO_FLUSH to flush it before returning */\n    ret = bdrv_open(&bs, filename, NULL, NULL,\n                    BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_BACKING,\n                    drv, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    ret = 0;\nout:\n    if (bs) {\n        bdrv_unref(bs);\n    }\n    return ret;\n}", "target": 1, "cwe": ["CWE-190"], "project": "qemu", "commit_id": "b106ad9185f35fc4ad669555ad0e79e276083bd7", "hash": 227872669087975385977803120590601618156, "size": 169, "message": "qcow2: Don't rely on free_cluster_index in alloc_refcount_block() (CVE-2014-0147)\n\nfree_cluster_index is only correct if update_refcount() was called from\nan allocation function, and even there it's brittle because it's used to\nprotect unfinished allocations which still have a refcount of 0 - if it\nmoves in the wrong place, the unfinished allocation can be corrupted.\n\nSo not using it any more seems to be a good idea. Instead, use the\nfirst requested cluster to do the calculations. Return -EAGAIN if\nunfinished allocations could become invalid and let the caller restart\nits search for some free clusters.\n\nThe context of creating a snapsnot is one situation where\nupdate_refcount() is called outside of a cluster allocation. For this\ncase, the change fixes a buffer overflow if a cluster is referenced in\nan L2 table that cannot be represented by an existing refcount block.\n(new_table[refcount_table_index] was out of bounds)\n\n[Bump the qemu-iotests 026 refblock_alloc.write leak count from 10 to\n11.\n--Stefan]\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>", "idx": 187}
{"func": "static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  u32 start_seq, u32 end_seq)\n{\n\tint err;\n\tbool in_sack;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Round if necessary so that SACKs cover only full MSSes\n\t\t * and/or the remaining small portion (if present)\n\t\t */\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len >= skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss, GFP_ATOMIC);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn in_sack;\n}", "target": 0, "cwe": ["CWE-703", "CWE-189"], "project": "linux", "commit_id": "8b8a321ff72c785ed5e8b4cf6eda20b35d427390", "hash": 323497569851616196053246005236783097193, "size": 45, "message": "tcp: fix zero cwnd in tcp_cwnd_reduction\n\nPatch 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode\nconditionally\") introduced a bug that cwnd may become 0 when both\ninflight and sndcnt are 0 (cwnd = inflight + sndcnt). This may lead\nto a div-by-zero if the connection starts another cwnd reduction\nphase by setting tp->prior_cwnd to the current cwnd (0) in\ntcp_init_cwnd_reduction().\n\nTo prevent this we skip PRR operation when nothing is acked or\nsacked. Then cwnd must be positive in all cases as long as ssthresh\nis positive:\n\n1) The proportional reduction mode\n   inflight > ssthresh > 0\n\n2) The reduction bound mode\n  a) inflight == ssthresh > 0\n\n  b) inflight < ssthresh\n     sndcnt > 0 since newly_acked_sacked > 0 and inflight < ssthresh\n\nTherefore in all cases inflight and sndcnt can not both be 0.\nWe check invalid tp->prior_cwnd to avoid potential div0 bugs.\n\nIn reality this bug is triggered only with a sequence of less common\nevents.  For example, the connection is terminating an ECN-triggered\ncwnd reduction with an inflight 0, then it receives reordered/old\nACKs or DSACKs from prior transmission (which acks nothing). Or the\nconnection is in fast recovery stage that marks everything lost,\nbut fails to retransmit due to local issues, then receives data\npackets from other end which acks nothing.\n\nFixes: 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode conditionally\")\nReported-by: Oleksandr Natalenko <oleksandr@natalenko.name>\nSigned-off-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: Neal Cardwell <ncardwell@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 188}
{"func": "static int queue_get(struct priv_net *pn, void *buf, int len)\n{\n\tstruct queue *head = &pn->pn_queue;\n\tstruct queue *q = head->q_next;\n\n\tif (q == head)\n\t\treturn 0;\n\n\tassert(q->q_len <= len);\n\tmemcpy(buf, q->q_buf, q->q_len);\n\n\tqueue_del(q);\n\tqueue_add(&pn->pn_queue_free, q);\n\n\treturn q->q_len;\n}", "target": 0, "cwe": ["CWE-20", "CWE-787"], "project": "aircrack-ng", "commit_id": "88702a3ce4c28a973bf69023cd0312f412f6193e", "hash": 19615117437186496715441970182874218820, "size": 16, "message": "OSdep: Fixed segmentation fault that happens with a malicious server sending a negative length (Closes #16 on GitHub).\n\ngit-svn-id: http://svn.aircrack-ng.org/trunk@2419 28c6078b-6c39-48e3-add9-af49d547ecab", "idx": 189}
{"func": "xps_parse_glyphs(xps_document *doc, const fz_matrix *ctm,\n\t\tchar *base_uri, xps_resource *dict, fz_xml *root)\n{\n\tfz_xml *node;\n\n\tchar *fill_uri;\n\tchar *opacity_mask_uri;\n\n\tchar *bidi_level_att;\n\tchar *fill_att;\n\tchar *font_size_att;\n\tchar *font_uri_att;\n\tchar *origin_x_att;\n\tchar *origin_y_att;\n\tchar *is_sideways_att;\n\tchar *indices_att;\n\tchar *unicode_att;\n\tchar *style_att;\n\tchar *transform_att;\n\tchar *clip_att;\n\tchar *opacity_att;\n\tchar *opacity_mask_att;\n\tchar *navigate_uri_att;\n\n\tfz_xml *transform_tag = NULL;\n\tfz_xml *clip_tag = NULL;\n\tfz_xml *fill_tag = NULL;\n\tfz_xml *opacity_mask_tag = NULL;\n\n\tchar *fill_opacity_att = NULL;\n\n\txps_part *part;\n\tfz_font *font;\n\n\tchar partname[1024];\n\tchar fakename[1024];\n\tchar *subfont;\n\n\tfloat font_size = 10;\n\tint subfontid = 0;\n\tint is_sideways = 0;\n\tint bidi_level = 0;\n\n\tfz_text *text;\n\tfz_rect area;\n\n\tfz_matrix local_ctm = *ctm;\n\n\t/*\n\t * Extract attributes and extended attributes.\n\t */\n\n\tbidi_level_att = fz_xml_att(root, \"BidiLevel\");\n\tfill_att = fz_xml_att(root, \"Fill\");\n\tfont_size_att = fz_xml_att(root, \"FontRenderingEmSize\");\n\tfont_uri_att = fz_xml_att(root, \"FontUri\");\n\torigin_x_att = fz_xml_att(root, \"OriginX\");\n\torigin_y_att = fz_xml_att(root, \"OriginY\");\n\tis_sideways_att = fz_xml_att(root, \"IsSideways\");\n\tindices_att = fz_xml_att(root, \"Indices\");\n\tunicode_att = fz_xml_att(root, \"UnicodeString\");\n\tstyle_att = fz_xml_att(root, \"StyleSimulations\");\n\ttransform_att = fz_xml_att(root, \"RenderTransform\");\n\tclip_att = fz_xml_att(root, \"Clip\");\n\topacity_att = fz_xml_att(root, \"Opacity\");\n\topacity_mask_att = fz_xml_att(root, \"OpacityMask\");\n\tnavigate_uri_att = fz_xml_att(root, \"FixedPage.NavigateUri\");\n\n\tfor (node = fz_xml_down(root); node; node = fz_xml_next(node))\n\t{\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.RenderTransform\"))\n\t\t\ttransform_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.OpacityMask\"))\n\t\t\topacity_mask_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.Clip\"))\n\t\t\tclip_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.Fill\"))\n\t\t\tfill_tag = fz_xml_down(node);\n\t}\n\n\tfill_uri = base_uri;\n\topacity_mask_uri = base_uri;\n\n\txps_resolve_resource_reference(doc, dict, &transform_att, &transform_tag, NULL);\n\txps_resolve_resource_reference(doc, dict, &clip_att, &clip_tag, NULL);\n\txps_resolve_resource_reference(doc, dict, &fill_att, &fill_tag, &fill_uri);\n\txps_resolve_resource_reference(doc, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri);\n\n\t/*\n\t * Check that we have all the necessary information.\n\t */\n\n\tif (!font_size_att || !font_uri_att || !origin_x_att || !origin_y_att) {\n\t\tfz_warn(doc->ctx, \"missing attributes in glyphs element\");\n\t\treturn;\n\t}\n\n\tif (!indices_att && !unicode_att)\n\t\treturn; /* nothing to draw */\n\n\tif (is_sideways_att)\n\t\tis_sideways = !strcmp(is_sideways_att, \"true\");\n\n\tif (bidi_level_att)\n\t\tbidi_level = atoi(bidi_level_att);\n\n\t/*\n\t * Find and load the font resource\n\t */\n\n\txps_resolve_url(partname, base_uri, font_uri_att, sizeof partname);\n\tsubfont = strrchr(partname, '#');\n\tif (subfont)\n\t{\n\t\tsubfontid = atoi(subfont + 1);\n\t\t*subfont = 0;\n\t}\n\n\t/* Make a new part name for font with style simulation applied */\n\tfz_strlcpy(fakename, partname, sizeof fakename);\n\tif (style_att)\n\t{\n\t\tif (!strcmp(style_att, \"BoldSimulation\"))\n\t\t\tfz_strlcat(fakename, \"#Bold\", sizeof fakename);\n\t\telse if (!strcmp(style_att, \"ItalicSimulation\"))\n\t\t\tfz_strlcat(fakename, \"#Italic\", sizeof fakename);\n\t\telse if (!strcmp(style_att, \"BoldItalicSimulation\"))\n\t\t\tfz_strlcat(fakename, \"#BoldItalic\", sizeof fakename);\n\t}\n\n\tfont = xps_lookup_font(doc, fakename);\n\tif (!font)\n\t{\n\t\tfz_try(doc->ctx)\n\t\t{\n\t\t\tpart = xps_read_part(doc, partname);\n\t\t}\n\t\tfz_catch(doc->ctx)\n\t\t{\n\t\t\tfz_rethrow_if(doc->ctx, FZ_ERROR_TRYLATER);\n\t\t\tfz_warn(doc->ctx, \"cannot find font resource part '%s'\", partname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* deobfuscate if necessary */\n\t\tif (strstr(part->name, \".odttf\"))\n\t\t\txps_deobfuscate_font_resource(doc, part);\n\t\tif (strstr(part->name, \".ODTTF\"))\n\t\t\txps_deobfuscate_font_resource(doc, part);\n\n\t\tfz_try(doc->ctx)\n\t\t{\n\t\t\tfz_buffer *buf = fz_new_buffer_from_data(doc->ctx, part->data, part->size);\n\t\t\tfont = fz_new_font_from_buffer(doc->ctx, NULL, buf, subfontid, 1);\n\t\t\tfz_drop_buffer(doc->ctx, buf);\n\t\t}\n\t\tfz_catch(doc->ctx)\n\t\t{\n\t\t\tfz_rethrow_if(doc->ctx, FZ_ERROR_TRYLATER);\n\t\t\tfz_warn(doc->ctx, \"cannot load font resource '%s'\", partname);\n\t\t\txps_free_part(doc, part);\n\t\t\treturn;\n\t\t}\n\n\t\tif (style_att)\n\t\t{\n\t\t\tfont->ft_bold = !!strstr(style_att, \"Bold\");\n\t\t\tfont->ft_italic = !!strstr(style_att, \"Italic\");\n\t\t}\n\n\t\txps_select_best_font_encoding(doc, font);\n\n\t\txps_insert_font(doc, fakename, font);\n\n\t\t/* NOTE: we already saved part->data in the buffer in the font */\n\t\tfz_free(doc->ctx, part->name);\n\t\tfz_free(doc->ctx, part);\n\t}\n\n\t/*\n\t * Set up graphics state.\n\t */\n\n\tif (transform_att || transform_tag)\n\t{\n\t\tfz_matrix transform;\n\t\tif (transform_att)\n\t\t\txps_parse_render_transform(doc, transform_att, &transform);\n\t\tif (transform_tag)\n\t\t\txps_parse_matrix_transform(doc, transform_tag, &transform);\n\t\tfz_concat(&local_ctm, &transform, &local_ctm);\n\t}\n\n\tif (clip_att || clip_tag)\n\t\txps_clip(doc, &local_ctm, dict, clip_att, clip_tag);\n\n\tfont_size = fz_atof(font_size_att);\n\n\ttext = xps_parse_glyphs_imp(doc, &local_ctm, font, font_size,\n\t\t\tfz_atof(origin_x_att), fz_atof(origin_y_att),\n\t\t\tis_sideways, bidi_level, indices_att, unicode_att);\n\n\tfz_bound_text(doc->ctx, text, NULL, &local_ctm, &area);\n\n\tif (navigate_uri_att)\n\t\txps_add_link(doc, &area, base_uri, navigate_uri_att);\n\n\txps_begin_opacity(doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n\n\t/* If it's a solid color brush fill/stroke do a simple fill */\n\n\tif (fill_tag && !strcmp(fz_xml_tag(fill_tag), \"SolidColorBrush\"))\n\t{\n\t\tfill_opacity_att = fz_xml_att(fill_tag, \"Opacity\");\n\t\tfill_att = fz_xml_att(fill_tag, \"Color\");\n\t\tfill_tag = NULL;\n\t}\n\n\tif (fill_att)\n\t{\n\t\tfloat samples[32];\n\t\tfz_colorspace *colorspace;\n\n\t\txps_parse_color(doc, base_uri, fill_att, &colorspace, samples);\n\t\tif (fill_opacity_att)\n\t\t\tsamples[0] *= fz_atof(fill_opacity_att);\n\t\txps_set_color(doc, colorspace, samples);\n\n\t\tfz_fill_text(doc->dev, text, &local_ctm,\n\t\t\tdoc->colorspace, doc->color, doc->alpha);\n\t}\n\n\t/* If it's a complex brush, use the charpath as a clip mask */\n\n\tif (fill_tag)\n\t{\n\t\tfz_clip_text(doc->dev, text, &local_ctm, 0);\n\t\txps_parse_brush(doc, &local_ctm, &area, fill_uri, dict, fill_tag);\n\t\tfz_pop_clip(doc->dev);\n\t}\n\n\txps_end_opacity(doc, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n\n\tfz_free_text(doc->ctx, text);\n\n\tif (clip_att || clip_tag)\n\t\tfz_pop_clip(doc->dev);\n\n\tfz_drop_font(doc->ctx, font);\n}", "target": 1, "cwe": ["CWE-119"], "project": "mupdf", "commit_id": "60dabde18d7fe12b19da8b509bdfee9cc886aafc", "hash": 80485607036522961867573653845441049547, "size": 250, "message": "Bug 694957: fix stack buffer overflow in xps_parse_color\n\nxps_parse_color happily reads more than FZ_MAX_COLORS values out of a\nContextColor array which overflows the passed in samples array.\nLimiting the number of allowed samples to FZ_MAX_COLORS and make sure\nto use that constant for all callers fixes the problem.\n\nThanks to Jean-Jamil Khalifé for reporting and investigating the issue\nand providing a sample exploit file.", "idx": 190}
{"func": "\tbool ChanPage(CWebSock& WebSock, CTemplate& Tmpl, CIRCNetwork* pNetwork, CChan* pChan = NULL) {\n\t\tCSmartPtr<CWebSession> spSession = WebSock.GetSession();\n\t\tTmpl.SetFile(\"add_edit_chan.tmpl\");\n\t\tCUser* pUser = pNetwork->GetUser();\n\n\t\tif (!pUser) {\n\t\t\tWebSock.PrintErrorPage(\"That user doesn't exist\");\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!WebSock.GetParam(\"submitted\").ToUInt()) {\n\t\t\tTmpl[\"User\"] = pUser->GetUserName();\n\t\t\tTmpl[\"Network\"] = pNetwork->GetName();\n\n\t\t\tif (pChan) {\n\t\t\t\tTmpl[\"Action\"] = \"editchan\";\n\t\t\t\tTmpl[\"Edit\"] = \"true\";\n\t\t\t\tTmpl[\"Title\"] = \"Edit Channel\" + CString(\" [\" + pChan->GetName() + \"]\") + \" of Network [\" + pNetwork->GetName() + \"] of User [\" + pNetwork->GetUser()->GetUserName() + \"]\";\n\t\t\t\tTmpl[\"ChanName\"] = pChan->GetName();\n\t\t\t\tTmpl[\"BufferCount\"] = CString(pChan->GetBufferCount());\n\t\t\t\tTmpl[\"DefModes\"] = pChan->GetDefaultModes();\n\t\t\t\tTmpl[\"Key\"] = pChan->GetKey();\n\n\t\t\t\tif (pChan->InConfig()) {\n\t\t\t\t\tTmpl[\"InConfig\"] = \"true\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tTmpl[\"Action\"] = \"addchan\";\n\t\t\t\tTmpl[\"Title\"] = \"Add Channel\" + CString(\" for User [\" + pUser->GetUserName() + \"]\");\n\t\t\t\tTmpl[\"BufferCount\"] = CString(pUser->GetBufferCount());\n\t\t\t\tTmpl[\"DefModes\"] = CString(pUser->GetDefaultChanModes());\n\t\t\t\tTmpl[\"InConfig\"] = \"true\";\n\t\t\t}\n\n\t\t\t// o1 used to be AutoCycle which was removed\n\n\t\t\tCTemplate& o2 = Tmpl.AddRow(\"OptionLoop\");\n\t\t\to2[\"Name\"] = \"autoclearchanbuffer\";\n\t\t\to2[\"DisplayName\"] = \"Auto Clear Chan Buffer\";\n\t\t\to2[\"Tooltip\"] = \"Automatically Clear Channel Buffer After Playback\";\n\t\t\tif ((pChan && pChan->AutoClearChanBuffer()) || (!pChan && pUser->AutoClearChanBuffer())) { o2[\"Checked\"] = \"true\"; }\n\n\t\t\tCTemplate& o3 = Tmpl.AddRow(\"OptionLoop\");\n\t\t\to3[\"Name\"] = \"detached\";\n\t\t\to3[\"DisplayName\"] = \"Detached\";\n\t\t\tif (pChan && pChan->IsDetached()) { o3[\"Checked\"] = \"true\"; }\n\n\t\t\tCTemplate& o4 = Tmpl.AddRow(\"OptionLoop\");\n\t\t\to4[\"Name\"] = \"disabled\";\n\t\t\to4[\"DisplayName\"] = \"Disabled\";\n\t\t\tif (pChan && pChan->IsDisabled()) { o4[\"Checked\"] = \"true\"; }\n\n\t\t\tFOR_EACH_MODULE(i, pNetwork) {\n\t\t\t\tCTemplate& mod = Tmpl.AddRow(\"EmbeddedModuleLoop\");\n\t\t\t\tmod.insert(Tmpl.begin(), Tmpl.end());\n\t\t\t\tmod[\"WebadminAction\"] = \"display\";\n\t\t\t\tif ((*i)->OnEmbeddedWebRequest(WebSock, \"webadmin/channel\", mod)) {\n\t\t\t\t\tmod[\"Embed\"] = WebSock.FindTmpl(*i, \"WebadminChan.tmpl\");\n\t\t\t\t\tmod[\"ModName\"] = (*i)->GetModName();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tCString sChanName = WebSock.GetParam(\"name\").Trim_n();\n\n\t\tif (!pChan) {\n\t\t\tif (sChanName.empty()) {\n\t\t\t\tWebSock.PrintErrorPage(\"Channel name is a required argument\");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (pNetwork->FindChan(sChanName.Token(0))) {\n\t\t\t\tWebSock.PrintErrorPage(\"Channel [\" + sChanName.Token(0) + \"] already exists\");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpChan = new CChan(sChanName, pNetwork, true);\n\t\t\tpNetwork->AddChan(pChan);\n\t\t}\n\n\t\tpChan->SetBufferCount(WebSock.GetParam(\"buffercount\").ToUInt(), spSession->IsAdmin());\n\t\tpChan->SetDefaultModes(WebSock.GetParam(\"defmodes\"));\n\t\tpChan->SetInConfig(WebSock.GetParam(\"save\").ToBool());\n\t\tpChan->SetAutoClearChanBuffer(WebSock.GetParam(\"autoclearchanbuffer\").ToBool());\n\t\tpChan->SetKey(WebSock.GetParam(\"key\"));\n\n\t\tbool bDetached = WebSock.GetParam(\"detached\").ToBool();\n\t\tif (pChan->IsDetached() != bDetached) {\n\t\t\tif (bDetached) {\n\t\t\t\tpChan->DetachUser();\n\t\t\t} else {\n\t\t\t\tpChan->AttachUser();\n\t\t\t}\n\t\t}\n\n\t\tbool bDisabled = WebSock.GetParam(\"disabled\").ToBool();\n\t\tif (bDisabled)\n\t\t\tpChan->Disable();\n\t\telse\n\t\t\tpChan->Enable();\n\n\t\tCTemplate TmplMod;\n\t\tTmplMod[\"User\"] = pUser->GetUserName();\n\t\tTmplMod[\"ChanName\"] = sChanName;\n\t\tTmplMod[\"WebadminAction\"] = \"change\";\n\t\tFOR_EACH_MODULE(it, pNetwork) {\n\t\t\t(*it)->OnEmbeddedWebRequest(WebSock, \"webadmin/channel\", TmplMod);\n\t\t}\n\n\t\tif (!CZNC::Get().WriteConfig()) {\n\t\t\tWebSock.PrintErrorPage(\"Channel added/modified, but config was not written\");\n\t\t\treturn true;\n\t\t}\n\n\t\tWebSock.Redirect(GetWebPath() + \"editnetwork?user=\" + pUser->GetUserName().Escape_n(CString::EURL) + \"&network=\" + pNetwork->GetName().Escape_n(CString::EURL));\n\t\treturn true;\n\t}", "target": 1, "cwe": [], "project": "znc", "commit_id": "5e6e3be32acfeadeaf1fb3bb17bada08aec6432f", "hash": 233275427140278529196615591525249520637, "size": 119, "message": "webadmin/add channel: Correctly handle channel names\n\nThe CChan constructor makes sure that the channel name begins with a valid\nchannel prefix. Thus, this could change the name of the resulting channel.\n\nWhen you edited an irc network which already had a channel \"#foo\", were\nconnected to IRC (so ZNC knows which prefixes are valid) and added a channel\n\"foo\", this would lead to a problem:\n\nWebadmin checks and sees that there is no channel \"foo\" yet. Webadmin creates a\nnew CChan instance for \"foo\". The CChan constructor notices that \"f\" is not a\nvalid channel prefix and instead calls itself \"#foo\". Then,\nCIRCNetwork::AddChan() would see that this channel already exists, delete the\ngiven channel and return false.\n\nHowever, webadmin didn't check this result and would continue changing settings\non an already destroyed CChan instance.\n\nFix this by checking if the channel exists after CChan had its chance to mess\nwith the channel name. Also handle failures from CIRCNetwork::AddChan().\n\nFixes #528.\n\nSigned-off-by: Uli Schlachter <psychon@znc.in>", "idx": 191}
{"func": "seamless_process_line(const char *line, void *data)\n{\n\tchar *p, *l;\n\tchar *tok1, *tok2, *tok3, *tok4, *tok5, *tok6, *tok7, *tok8;\n\tunsigned long id, flags;\n\tchar *endptr;\n\n\tl = xstrdup(line);\n\tp = l;\n\n\tDEBUG_SEAMLESS((\"seamlessrdp got:%s\\n\", p));\n\n\ttok1 = seamless_get_token(&p);\n\ttok2 = seamless_get_token(&p);\n\ttok3 = seamless_get_token(&p);\n\ttok4 = seamless_get_token(&p);\n\ttok5 = seamless_get_token(&p);\n\ttok6 = seamless_get_token(&p);\n\ttok7 = seamless_get_token(&p);\n\ttok8 = seamless_get_token(&p);\n\n\tif (!strcmp(\"CREATE\", tok1))\n\t{\n\t\tunsigned long group, parent;\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tgroup = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tparent = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_create_window(id, group, parent, flags);\n\t}\n\telse if (!strcmp(\"DESTROY\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_window(id, flags);\n\n\t}\n\telse if (!strcmp(\"DESTROYGRP\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_group(id, flags);\n\t}\n\telse if (!strcmp(\"SETICON\", tok1))\n\t{\n\t\tint chunk, width, height, len;\n\t\tchar byte[3];\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tchunk = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbyte[2] = '\\0';\n\t\tlen = 0;\n\t\twhile (*tok8 != '\\0')\n\t\t{\n\t\t\tbyte[0] = *tok8;\n\t\t\ttok8++;\n\t\t\tif (*tok8 == '\\0')\n\t\t\t\treturn False;\n\t\t\tbyte[1] = *tok8;\n\t\t\ttok8++;\n\n\t\t\ticon_buf[len] = strtol(byte, NULL, 16);\n\t\t\tlen++;\n\t\t}\n\n\t\tui_seamless_seticon(id, tok5, width, height, chunk, icon_buf, len);\n\t}\n\telse if (!strcmp(\"DELICON\", tok1))\n\t{\n\t\tint width, height;\n\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_delicon(id, tok4, width, height);\n\t}\n\telse if (!strcmp(\"POSITION\", tok1))\n\t{\n\t\tint x, y, width, height;\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tx = strtol(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\ty = strtol(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtol(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\theight = strtol(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok8, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_move_window(id, x, y, width, height, flags);\n\t}\n\telse if (!strcmp(\"ZCHANGE\", tok1))\n\t{\n\t\tunsigned long behind;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbehind = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_restack_window(id, behind, flags);\n\t}\n\telse if (!strcmp(\"TITLE\", tok1))\n\t{\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_settitle(id, tok4, flags);\n\t}\n\telse if (!strcmp(\"STATE\", tok1))\n\t{\n\t\tunsigned int state;\n\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tstate = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_setstate(id, state, flags);\n\t}\n\telse if (!strcmp(\"DEBUG\", tok1))\n\t{\n\t\tDEBUG_SEAMLESS((\"SeamlessRDP:%s\\n\", line));\n\t}\n\telse if (!strcmp(\"SYNCBEGIN\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_syncbegin(flags);\n\t}\n\telse if (!strcmp(\"SYNCEND\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\t/* do nothing, currently */\n\t}\n\telse if (!strcmp(\"HELLO\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_begin(! !(flags & SEAMLESSRDP_HELLO_HIDDEN));\n\t}\n\telse if (!strcmp(\"ACK\", tok1))\n\t{\n\t\tunsigned int serial;\n\n\t\tserial = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_ack(serial);\n\t}\n\telse if (!strcmp(\"HIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_hide_desktop();\n\t}\n\telse if (!strcmp(\"UNHIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_unhide_desktop();\n\t}\n\n\n\txfree(l);\n\treturn True;\n}", "target": 1, "cwe": ["CWE-787"], "project": "rdesktop", "commit_id": "766ebcf6f23ccfe8323ac10242ae6e127d4505d2", "hash": 54426487778495726225195376823421771043, "size": 297, "message": "Malicious RDP server security fixes\n\nThis commit includes fixes for a set of 21 vulnerabilities in\nrdesktop when a malicious RDP server is used.\n\nAll vulnerabilities was identified and reported by Eyal Itkin.\n\n* Add rdp_protocol_error function that is used in several fixes\n* Refactor of process_bitmap_updates\n* Fix possible integer overflow in s_check_rem() on 32bit arch\n* Fix memory corruption in process_bitmap_data - CVE-2018-8794\n* Fix remote code execution in process_bitmap_data - CVE-2018-8795\n* Fix remote code execution in process_plane - CVE-2018-8797\n* Fix Denial of Service in mcs_recv_connect_response - CVE-2018-20175\n* Fix Denial of Service in mcs_parse_domain_params - CVE-2018-20175\n* Fix Denial of Service in sec_parse_crypt_info - CVE-2018-20176\n* Fix Denial of Service in sec_recv - CVE-2018-20176\n* Fix minor information leak in rdpdr_process - CVE-2018-8791\n* Fix Denial of Service in cssp_read_tsrequest - CVE-2018-8792\n* Fix remote code execution in cssp_read_tsrequest - CVE-2018-8793\n* Fix Denial of Service in process_bitmap_data - CVE-2018-8796\n* Fix minor information leak in rdpsnd_process_ping - CVE-2018-8798\n* Fix Denial of Service in process_secondary_order - CVE-2018-8799\n* Fix remote code execution in in ui_clip_handle_data - CVE-2018-8800\n* Fix major information leak in ui_clip_handle_data - CVE-2018-20174\n* Fix memory corruption in rdp_in_unistr - CVE-2018-20177\n* Fix Denial of Service in process_demand_active - CVE-2018-20178\n* Fix remote code execution in lspci_process - CVE-2018-20179\n* Fix remote code execution in rdpsnddbg_process - CVE-2018-20180\n* Fix remote code execution in seamless_process - CVE-2018-20181\n* Fix remote code execution in seamless_process_line - CVE-2018-20182", "idx": 192}
{"func": "init_connection_options(MYSQL *mysql)\n{\n  my_bool handle_expired= (opt_connect_expired_password || !status.batch) ?\n    TRUE : FALSE;\n\n  if (opt_init_command)\n    mysql_options(mysql, MYSQL_INIT_COMMAND, opt_init_command);\n\n  if (opt_connect_timeout)\n  {\n    uint timeout= opt_connect_timeout;\n    mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (char*) &timeout);\n  }\n\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n\n  if (opt_compress)\n    mysql_options(mysql, MYSQL_OPT_COMPRESS, NullS);\n\n  if (!opt_secure_auth)\n    mysql_options(mysql, MYSQL_SECURE_AUTH, (char *) &opt_secure_auth);\n\n  if (using_opt_local_infile)\n    mysql_options(mysql, MYSQL_OPT_LOCAL_INFILE, (char*) &opt_local_infile);\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n\n  if (safe_updates)\n  {\n    char init_command[100];\n    sprintf(init_command,\n\t    \"SET SQL_SAFE_UPDATES=1,SQL_SELECT_LIMIT=%lu,MAX_JOIN_SIZE=%lu\",\n\t    select_limit, max_join_size);\n    mysql_options(mysql, MYSQL_INIT_COMMAND, init_command);\n  }\n\n  mysql_set_character_set(mysql, default_charset);\n\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n\n#if !defined(HAVE_YASSL)\n  if (opt_server_public_key && *opt_server_public_key)\n    mysql_options(mysql, MYSQL_SERVER_PUBLIC_KEY, opt_server_public_key);\n#endif\n\n  if (using_opt_enable_cleartext_plugin)\n    mysql_options(mysql, MYSQL_ENABLE_CLEARTEXT_PLUGIN,\n                  (char*) &opt_enable_cleartext_plugin);\n\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD, \"program_name\", \"mysql\");\n\n  mysql_options(mysql, MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS, &handle_expired);\n}", "target": 1, "cwe": ["CWE-284", "CWE-295"], "project": "mysql-server", "commit_id": "3bd5589e1a5a93f9c224badf983cd65c45215390", "hash": 292268536306148712782929774271670652001, "size": 77, "message": "WL#6791 : Redefine client --ssl option to imply enforced encryption\n\n# Changed the meaning of the --ssl=1 option of all client binaries\nto mean force ssl, not try ssl and fail over to eunecrypted\n# Added a new MYSQL_OPT_SSL_ENFORCE mysql_options()\noption to specify that an ssl connection is required.\n# Added a new macro SSL_SET_OPTIONS() to the client\nSSL handling headers that sets all the relevant SSL options at \nonce.\n# Revamped all of the current native clients to use the new macro\n# Removed some Windows line endings.\n# Added proper handling of the new option into the ssl helper\nheaders.\n# If SSL is mandatory assume that the media is secure enough \nfor the sha256 plugin to do unencrypted password exchange even\nbefore establishing a connection.\n# Set the default ssl cipher to DHE-RSA-AES256-SHA if none is \nspecified.\n# updated test cases that require a non-default cipher to spawn \na mysql command line tool binary since mysqltest has no support\nfor specifying ciphers.\n# updated the replication slave connection code to always enforce\nSSL if any of the SSL config options is present.\n# test cases added and updated.\n# added a mysql_get_option() API to return mysql_options() \nvalues. Used the new API inside the sha256 plugin.\n# Fixed compilation warnings because of unused variables.\n# Fixed test failures (mysql_ssl and bug13115401)\n# Fixed whitespace issues.\n# Fully implemented the mysql_get_option() function.\n# Added a test case for mysql_get_option()\n# fixed some trailing whitespace issues\n# fixed some uint/int warnings in mysql_client_test.c\n# removed shared memory option from non-windows get_options\n tests\n# moved MYSQL_OPT_LOCAL_INFILE to the uint options", "idx": 193}
{"func": "cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,\n    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])\n{\n  return onigenc_get_case_fold_codes_by_str_with_map(\n\t     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,\n\t     flag, p, end, items);\n}", "target": 0, "cwe": ["CWE-125"], "project": "oniguruma", "commit_id": "65a9b1aa03c9bc2dc01b074295b9603232cb3b78", "hash": 293658390481653663832968801669628580606, "size": 7, "message": "onig-5.9.2", "idx": 194}
{"func": "static int sja1105_cold_reset(const struct sja1105_private *priv)\n{\n\tstruct sja1105_reset_cmd reset = {0};\n\n\treset.cold_rst = 1;\n\treturn priv->info->reset_cmd(priv, &reset);\n}", "target": 0, "cwe": ["CWE-401"], "project": "linux", "commit_id": "68501df92d116b760777a2cfda314789f926476f", "hash": 60832414823320723711359933273883732094, "size": 7, "message": "net: dsa: sja1105: Prevent leaking memory\n\nIn sja1105_static_config_upload, in two cases memory is leaked: when\nstatic_config_buf_prepare_for_upload fails and when sja1105_inhibit_tx\nfails. In both cases config_buf should be released.\n\nFixes: 8aa9ebccae87 (\"net: dsa: Introduce driver for NXP SJA1105 5-port L2 switch\")\nFixes: 1a4c69406cc1 (\"net: dsa: sja1105: Prevent PHY jabbering during switch reset\")\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Vladimir Oltean <olteanv@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 195}
{"func": "cmsBool OptimizeByResampling(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)\n{\n    cmsPipeline* Src;\n    cmsPipeline* Dest;\n    cmsStage* mpe;\n    cmsStage* CLUT;\n    cmsStage *KeepPreLin = NULL, *KeepPostLin = NULL;\n    int nGridPoints;\n    cmsColorSpaceSignature ColorSpace, OutputColorSpace;\n    cmsStage *NewPreLin = NULL;\n    cmsStage *NewPostLin = NULL;\n    _cmsStageCLutData* DataCLUT;\n    cmsToneCurve** DataSetIn;\n    cmsToneCurve** DataSetOut;\n    Prelin16Data* p16;\n\n\n    // This is a loosy optimization! does not apply in floating-point cases\n    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) return FALSE;\n\n    ColorSpace       = _cmsICCcolorSpace(T_COLORSPACE(*InputFormat));\n    OutputColorSpace = _cmsICCcolorSpace(T_COLORSPACE(*OutputFormat));\n    nGridPoints      = _cmsReasonableGridpointsByColorspace(ColorSpace, *dwFlags);\n\n    // For empty LUTs, 2 points are enough\n    if (cmsPipelineStageCount(*Lut) == 0)\n        nGridPoints = 2;\n\n    Src = *Lut;\n\n   // Named color pipelines cannot be optimized either\n   for (mpe = cmsPipelineGetPtrToFirstStage(Src);\n         mpe != NULL;\n         mpe = cmsStageNext(mpe)) {\n            if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n    }\n\n    // Allocate an empty LUT\n    Dest =  cmsPipelineAlloc(Src ->ContextID, Src ->InputChannels, Src ->OutputChannels);\n    if (!Dest) return FALSE;\n\n    // Prelinearization tables are kept unless indicated by flags\n    if (*dwFlags & cmsFLAGS_CLUT_PRE_LINEARIZATION) {\n\n        // Get a pointer to the prelinearization element\n        cmsStage* PreLin = cmsPipelineGetPtrToFirstStage(Src);\n\n        // Check if suitable\n        if (PreLin ->Type == cmsSigCurveSetElemType) {\n\n            // Maybe this is a linear tram, so we can avoid the whole stuff\n            if (!AllCurvesAreLinear(PreLin)) {\n\n                // All seems ok, proceed.\n                NewPreLin = cmsStageDup(PreLin);\n                cmsPipelineInsertStage(Dest, cmsAT_BEGIN, NewPreLin);\n\n                // Remove prelinearization. Since we have duplicated the curve\n                // in destination LUT, the sampling shoud be applied after this stage.\n                cmsPipelineUnlinkStage(Src, cmsAT_BEGIN, &KeepPreLin);\n            }\n        }\n    }\n\n    // Allocate the CLUT\n    CLUT = cmsStageAllocCLut16bit(Src ->ContextID, nGridPoints, Src ->InputChannels, Src->OutputChannels, NULL);\n    if (CLUT == NULL) return FALSE;\n\n    // Add the CLUT to the destination LUT\n    cmsPipelineInsertStage(Dest, cmsAT_END, CLUT);\n\n    // Postlinearization tables are kept unless indicated by flags\n    if (*dwFlags & cmsFLAGS_CLUT_POST_LINEARIZATION) {\n\n        // Get a pointer to the postlinearization if present\n        cmsStage* PostLin = cmsPipelineGetPtrToLastStage(Src);\n\n        // Check if suitable\n        if (cmsStageType(PostLin) == cmsSigCurveSetElemType) {\n\n            // Maybe this is a linear tram, so we can avoid the whole stuff\n            if (!AllCurvesAreLinear(PostLin)) {\n\n                // All seems ok, proceed.\n                NewPostLin = cmsStageDup(PostLin);\n                cmsPipelineInsertStage(Dest, cmsAT_END, NewPostLin);\n\n                // In destination LUT, the sampling shoud be applied after this stage.\n                cmsPipelineUnlinkStage(Src, cmsAT_END, &KeepPostLin);\n            }\n        }\n    }\n\n    // Now its time to do the sampling. We have to ignore pre/post linearization\n    // The source LUT whithout pre/post curves is passed as parameter.\n    if (!cmsStageSampleCLut16bit(CLUT, XFormSampler16, (void*) Src, 0)) {\n\n        // Ops, something went wrong, Restore stages\n        if (KeepPreLin != NULL)  cmsPipelineInsertStage(Src, cmsAT_BEGIN, KeepPreLin);\n        if (KeepPostLin != NULL) cmsPipelineInsertStage(Src, cmsAT_END,   KeepPostLin);\n        cmsPipelineFree(Dest);\n        return FALSE;\n    }\n\n    // Done.\n\n    if (KeepPreLin != NULL) cmsStageFree(KeepPreLin);\n    if (KeepPostLin != NULL) cmsStageFree(KeepPostLin);\n    cmsPipelineFree(Src);\n\n    DataCLUT = (_cmsStageCLutData*) CLUT ->Data;\n\n    if (NewPreLin == NULL) DataSetIn = NULL;\n    else DataSetIn = ((_cmsStageToneCurvesData*) NewPreLin ->Data) ->TheCurves;\n\n    if (NewPostLin == NULL) DataSetOut = NULL;\n    else  DataSetOut = ((_cmsStageToneCurvesData*) NewPostLin ->Data) ->TheCurves;\n\n\n    if (DataSetIn == NULL && DataSetOut == NULL) {\n\n        _cmsPipelineSetOptimizationParameters(Dest, (_cmsOPTeval16Fn) DataCLUT->Params->Interpolation.Lerp16, DataCLUT->Params, NULL, NULL);\n    }\n    else {\n\n        p16 = PrelinOpt16alloc(Dest ->ContextID,\n                               DataCLUT ->Params,\n                               Dest ->InputChannels,\n                               DataSetIn,\n                               Dest ->OutputChannels,\n                               DataSetOut);\n\n\n        _cmsPipelineSetOptimizationParameters(Dest, PrelinEval16, (void*) p16, PrelinOpt16free, Prelin16dup);\n    }\n\n\n    // Don't fix white on absolute colorimetric\n    if (Intent == INTENT_ABSOLUTE_COLORIMETRIC)\n        *dwFlags |= cmsFLAGS_NOWHITEONWHITEFIXUP;\n\n    if (!(*dwFlags & cmsFLAGS_NOWHITEONWHITEFIXUP)) {\n\n        FixWhiteMisalignment(Dest, ColorSpace, OutputColorSpace);\n    }\n\n    *Lut = Dest;\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(Intent);\n}", "target": 1, "cwe": [], "project": "Little-CMS", "commit_id": "41d222df1bc6188131a8f46c32eab0a4d4cdf1b6", "hash": 3729763313414801372000253420669283439, "size": 151, "message": "Memory squeezing fix: lcms2 cmsPipeline construction\n\nWhen creating a new pipeline, lcms would often try to allocate a stage\nand pass it to cmsPipelineInsertStage without checking whether the\nallocation succeeded. cmsPipelineInsertStage would then assert (or crash)\nif it had not.\n\nThe fix here is to change cmsPipelineInsertStage to check and return\nan error value. All calling code is then checked to test this return\nvalue and cope.", "idx": 196}
{"func": "bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const\n{\n  /* Assume we don't have rtti */\n  if (this == item)\n    return 1;\t\t\t\t\t// Same item is same.\n  /* Check if other type is also a get_user_var() object */\n  if (item->type() != FUNC_ITEM ||\n      ((Item_func*) item)->functype() != functype())\n    return 0;\n  Item_func_get_user_var *other=(Item_func_get_user_var*) item;\n  return (name.length == other->name.length &&\n\t  !memcmp(name.str, other->name.str, name.length));\n}", "target": 0, "cwe": ["CWE-120"], "project": "server", "commit_id": "eca207c46293bc72dd8d0d5622153fab4d3fccf1", "hash": 16937435205129365722043821928799173837, "size": 13, "message": "MDEV-25317 Assertion `scale <= precision' failed in decimal_bin_size And Assertion `scale >= 0 && precision > 0 && scale <= precision' failed in decimal_bin_size_inline/decimal_bin_size.\n\nPrecision should be kept below DECIMAL_MAX_SCALE for computations.\nIt can be bigger in Item_decimal. I'd fix this too but it changes the\nexisting behaviour so problemmatic to ix.", "idx": 197}
{"func": "int sftp_dir_eof(sftp_dir dir) {\n  return dir->eof;\n}", "target": 0, "cwe": [], "project": "libssh", "commit_id": "4d8420f3282ed07fc99fc5e930c17df27ef1e9b2", "hash": 39999802170626209798041966335249865391, "size": 3, "message": "sftp: Fix bug in sftp_mkdir not returning on error.\n\nresolves: #84\n(cherry picked from commit a92c97b2e17715c1b3cdd693d14af6c3311d8e44)", "idx": 198}
{"func": "unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)\n\t{\n\tint extdatalen=0;\n\tunsigned char *ret = p;\n\n\tret+=2;\n\tif (ret>=limit) return NULL; /* this really never occurs, but ... */\n\n\tif (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)\n\t\t{ \n\t\tif (limit - p - 4 < 0) return NULL; \n\n\t\ts2n(TLSEXT_TYPE_server_name,ret);\n\t\ts2n(0,ret);\n\t\t}\n\t\n\tif ((extdatalen = ret-p-2)== 0) \n\t\treturn p;\n\n\ts2n(extdatalen,p);\n\treturn ret;\n}", "target": 1, "cwe": [], "project": "openssl", "commit_id": "36ca4ba63d083da6f9d4598f18f17a8c32c8eca2", "hash": 280821303405468269266765658707815292857, "size": 22, "message": "Implement the Supported Point Formats Extension for ECC ciphersuites\n\nSubmitted by: Douglas Stebila", "idx": 199}
{"func": "TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n        TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,\n        TPM2B_MAX_BUFFER  *resultKey )\n{\n    TPM2B_DIGEST tmpResult;\n    TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;\n    UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];\n    UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];\n    TPM2B_DIGEST *bufferList[8];\n    UINT32 bitsSwizzled, i_Swizzled;\n    TPM_RC rval;\n    int i, j;\n    UINT16 bytes = bits / 8;\n\n    resultKey->t .size = 0;\n\n    tpm2b_i_2.t.size = 4;\n\n    tpm2bBits.t.size = 4;\n    bitsSwizzled = string_bytes_endian_convert_32( bits );\n    *(UINT32 *)tpm2bBitsPtr = bitsSwizzled;\n\n    for(i = 0; label[i] != 0 ;i++ );\n\n    tpm2bLabel.t.size = i+1;\n    for( i = 0; i < tpm2bLabel.t.size; i++ )\n    {\n        tpm2bLabel.t.buffer[i] = label[i];\n    }\n\n    resultKey->t.size = 0;\n\n    i = 1;\n\n    while( resultKey->t.size < bytes )\n    {\n        // Inner loop\n\n        i_Swizzled = string_bytes_endian_convert_32( i );\n        *(UINT32 *)tpm2b_i_2Ptr = i_Swizzled;\n\n        j = 0;\n        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2b_i_2.b);\n        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bLabel.b);\n        bufferList[j++] = (TPM2B_DIGEST *)contextU;\n        bufferList[j++] = (TPM2B_DIGEST *)contextV;\n        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);\n        bufferList[j++] = (TPM2B_DIGEST *)0;\n        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );\n        if( rval != TPM_RC_SUCCESS )\n        {\n            return( rval );\n        }\n\n        bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));\n        if (!res) {\n            return TSS2_SYS_RC_BAD_VALUE;\n        }\n    }\n\n    // Truncate the result to the desired size.\n    resultKey->t.size = bytes;\n\n    return TPM_RC_SUCCESS;\n}", "target": 1, "cwe": ["CWE-522", "CWE-200"], "project": "tpm2.0-tools", "commit_id": "c5d72beaab1cbbbe68271f4bc4b6670d69985157", "hash": 150243078027001026125960285660972277015, "size": 65, "message": "kdfa: use openssl for hmac not tpm\n\nWhile not reachable in the current code base tools, a potential\nsecurity bug lurked in tpm_kdfa().\n\nIf using that routine for an hmac authorization, the hmac was\ncalculated using the tpm. A user of an object wishing to\nauthenticate via hmac, would expect that the password is never\nsent to the tpm. However, since the hmac calculation relies on\npassword, and is performed by the tpm, the password ends up\nbeing sent in plain text to the tpm.\n\nThe fix is to use openssl to generate the hmac on the host.\n\nFixes: CVE-2017-7524\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>", "idx": 200}
{"func": "static void test_bug12001()\n{\n  MYSQL *mysql_local;\n  MYSQL_RES *result;\n  const char *query= \"DROP TABLE IF EXISTS test_table;\"\n                     \"CREATE TABLE test_table(id INT);\"\n                     \"INSERT INTO test_table VALUES(10);\"\n                     \"UPDATE test_table SET id=20 WHERE id=10;\"\n                     \"SELECT * FROM test_table;\"\n                     \"INSERT INTO non_existent_table VALUES(11);\";\n  int rc, res;\n\n  myheader(\"test_bug12001\");\n\n  if (!(mysql_local= mysql_client_init(NULL)))\n  {\n    fprintf(stdout, \"\\n mysql_client_init() failed\");\n    exit(1);\n  }\n\n  /* Create connection that supports multi statements */\n  if (!mysql_real_connect(mysql_local, opt_host, opt_user,\n                          opt_password, current_db, opt_port,\n                          opt_unix_socket, CLIENT_MULTI_STATEMENTS))\n  {\n    fprintf(stdout, \"\\n mysql_real_connect() failed\");\n    exit(1);\n  }\n\n  rc= mysql_query(mysql_local, query);\n  myquery(rc);\n\n  do\n  {\n    if (mysql_field_count(mysql_local) &&\n        (result= mysql_use_result(mysql_local)))\n    {\n      mysql_free_result(result);\n    }\n  }\n  while (!(res= mysql_next_result(mysql_local)));\n\n  rc= mysql_query(mysql_local, \"DROP TABLE IF EXISTS test_table\");\n  myquery(rc);\n\n  mysql_close(mysql_local);\n  DIE_UNLESS(res==1);\n}", "target": 0, "cwe": ["CWE-284", "CWE-295"], "project": "mysql-server", "commit_id": "3bd5589e1a5a93f9c224badf983cd65c45215390", "hash": 327054991473781602265552906292070266654, "size": 48, "message": "WL#6791 : Redefine client --ssl option to imply enforced encryption\n\n# Changed the meaning of the --ssl=1 option of all client binaries\nto mean force ssl, not try ssl and fail over to eunecrypted\n# Added a new MYSQL_OPT_SSL_ENFORCE mysql_options()\noption to specify that an ssl connection is required.\n# Added a new macro SSL_SET_OPTIONS() to the client\nSSL handling headers that sets all the relevant SSL options at \nonce.\n# Revamped all of the current native clients to use the new macro\n# Removed some Windows line endings.\n# Added proper handling of the new option into the ssl helper\nheaders.\n# If SSL is mandatory assume that the media is secure enough \nfor the sha256 plugin to do unencrypted password exchange even\nbefore establishing a connection.\n# Set the default ssl cipher to DHE-RSA-AES256-SHA if none is \nspecified.\n# updated test cases that require a non-default cipher to spawn \na mysql command line tool binary since mysqltest has no support\nfor specifying ciphers.\n# updated the replication slave connection code to always enforce\nSSL if any of the SSL config options is present.\n# test cases added and updated.\n# added a mysql_get_option() API to return mysql_options() \nvalues. Used the new API inside the sha256 plugin.\n# Fixed compilation warnings because of unused variables.\n# Fixed test failures (mysql_ssl and bug13115401)\n# Fixed whitespace issues.\n# Fully implemented the mysql_get_option() function.\n# Added a test case for mysql_get_option()\n# fixed some trailing whitespace issues\n# fixed some uint/int warnings in mysql_client_test.c\n# removed shared memory option from non-windows get_options\n tests\n# moved MYSQL_OPT_LOCAL_INFILE to the uint options", "idx": 201}
{"func": "PJ_DEF(pj_status_t) pjsip_ua_register_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t   pjsip_dialog *dlg )\n{\n    /* Sanity check. */\n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n\n    /* For all dialogs, local tag (inc hash) must has been initialized. */\n    PJ_ASSERT_RETURN(dlg->local.info && dlg->local.info->tag.slen &&\n\t\t     dlg->local.tag_hval != 0, PJ_EBUG);\n\n    /* For UAS dialog, remote tag (inc hash) must have been initialized. */\n    //PJ_ASSERT_RETURN(dlg->role==PJSIP_ROLE_UAC ||\n    //\t\t     (dlg->role==PJSIP_ROLE_UAS && dlg->remote.info->tag.slen\n    //\t\t      && dlg->remote.tag_hval != 0), PJ_EBUG);\n\n    /* Lock the user agent. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* For UAC, check if there is existing dialog in the same set. */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower( mod_ua.dlg_table,\n                                     dlg->local.info->tag.ptr, \n\t\t\t             (unsigned)dlg->local.info->tag.slen,\n\t\t\t             &dlg->local.tag_hval);\n\n\tif (dlg_set) {\n\t    /* This is NOT the first dialog in the dialog set. \n\t     * Just add this dialog in the list.\n\t     */\n\t    pj_assert(dlg_set->dlg_list.next != (void*)&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t} else {\n\t    /* This is the first dialog in the dialog set. \n\t     * Create the dialog set and add this dialog to it.\n\t     */\n\t    dlg_set = alloc_dlgset_node();\n\t    pj_list_init(&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t    /* Register the dialog set in the hash table. */\n\t    pj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t\t         dlg->local.info->tag.ptr,\n                                 (unsigned)dlg->local.info->tag.slen,\n\t\t\t         dlg->local.tag_hval, dlg_set->ht_entry,\n                                 dlg_set);\n\t}\n\n    } else {\n\t/* For UAS, create the dialog set with a single dialog as member. */\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = alloc_dlgset_node();\n\tpj_list_init(&dlg_set->dlg_list);\n\tpj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\tdlg->dlg_set = dlg_set;\n\n\tpj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t             dlg->local.info->tag.ptr,\n                             (unsigned)dlg->local.info->tag.slen,\n\t\t             dlg->local.tag_hval, dlg_set->ht_entry, dlg_set);\n    }\n\n    /* Unlock user agent. */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Done. */\n    return PJ_SUCCESS;\n}", "target": 1, "cwe": ["CWE-416"], "project": "pjproject", "commit_id": "db3235953baa56d2fb0e276ca510fefca751643f", "hash": 319743340938493305153038722370714539839, "size": 77, "message": "Merge pull request from GHSA-ffff-m5fm-qm62\n\n* Update pjsip_ua_unregister_dlg():\n- update the hash key if the dialog being unregistered is used as hash key.\n- add an assertion check to make sure that the dlg_set to be removed is valid (can be found in the hash table).\n\n* Change hash key string comparison method.", "idx": 202}
{"func": "  void Compute(OpKernelContext* c) override {\n    core::RefCountPtr<Var> v;\n    OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));\n    OP_REQUIRES_OK(c, EnsureSparseVariableAccess<Device, T>(c, v.get()));\n    // NOTE: We hold the lock for the whole gather operation instead\n    // of increasing the reference count of v->tensor() to avoid a\n    // situation where a write to the same variable will see a\n    // reference count greater than one and make a copy of the\n    // (potentially very large) tensor buffer.\n    tf_shared_lock ml(*v->mu());\n    const Tensor& params = *v->tensor();\n    const Tensor& indices = c->input(1);\n    OP_REQUIRES(\n        c, TensorShapeUtils::IsVectorOrHigher(params.shape()),\n        errors::InvalidArgument(\"params must be at least 1 dimensional\"));\n    OP_REQUIRES(\n        c, params.shape().dims() >= batch_dims_,\n        errors::InvalidArgument(\"params must have at least \", batch_dims_,\n                                \" (batch_dims) dimensions but it has shape \",\n                                params.shape().DebugString()));\n\n    // Check that we have enough index space\n    const int64_t N = indices.NumElements();\n    OP_REQUIRES(\n        c, params.dim_size(0) <= std::numeric_limits<Index>::max(),\n        errors::InvalidArgument(\"params.shape[0] too large for \",\n                                DataTypeString(DataTypeToEnum<Index>::v()),\n                                \" indexing: \", params.dim_size(0), \" > \",\n                                std::numeric_limits<Index>::max()));\n\n    // The result shape is params.shape[:batch_dims] +\n    // indices.shape[batch_dims:] + params.shape[batch_dims+1:].\n    TensorShape result_shape;\n    for (int i = 0; i < batch_dims_; ++i) {\n      result_shape.AddDim(params.dim_size(i));\n    }\n    for (int i = batch_dims_; i < indices.dims(); ++i) {\n      result_shape.AddDim(indices.dim_size(i));\n    }\n    for (int i = batch_dims_ + 1; i < params.dims(); ++i) {\n      result_shape.AddDim(params.dim_size(i));\n    }\n\n    Tensor* out = nullptr;\n    Tensor tmp;\n    if (params.dtype() == DT_VARIANT) {\n      tmp = Tensor(DT_VARIANT, result_shape);\n      c->set_output(0, tmp);\n      out = &tmp;\n    } else {\n      OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, &out));\n    }\n\n    if (N > 0) {\n      Tensor tmp_indices;\n\n      // Points to the original or updated (if batch_dims is set) indices.\n      const Tensor* op_indices = &indices;\n      if (batch_dims_ > 0) {\n        OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(),\n                                           &tmp_indices));\n        functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;\n        copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),\n                     indices.flat<Index>());\n\n        AddBatchOffsets(&tmp_indices, params);\n        op_indices = &tmp_indices;\n      }\n\n      int64_t gather_dim_size = 1;\n      for (int idx = 0; idx <= batch_dims_; ++idx) {\n        gather_dim_size *= params.dim_size(idx);\n      }\n      int64_t inner_size = 1;\n      for (int i = batch_dims_ + 1; i < params.dims(); ++i) {\n        inner_size *= params.dim_size(i);\n      }\n      auto params_flat = params.shaped<T, 3>({1, gather_dim_size, inner_size});\n      const auto indices_flat = op_indices->flat<Index>();\n      auto out_flat = out->shaped<T, 3>({1, N, out->NumElements() / N});\n\n      functor::GatherFunctor<Device, T, Index> functor;\n      int64_t bad_i = functor(c, params_flat, indices_flat, out_flat);\n\n      OP_REQUIRES(\n          c, bad_i < 0,\n          errors::InvalidArgument(\n              \"indices\", SliceDebugString(indices.shape(), bad_i), \" = \",\n              indices_flat(bad_i), \" is not in [0, \", params.dim_size(0), \")\"));\n    }\n  }", "target": 1, "cwe": ["CWE-369"], "project": "tensorflow", "commit_id": "ac117ee8a8ea57b73d34665cdf00ef3303bc0b11", "hash": 272929035480010586437538387959089427738, "size": 91, "message": "Prevent division by 0 in `resource_variable_ops.cc`\n\nPiperOrigin-RevId: 387939939\nChange-Id: Ib04902d63756633999959a70613f2eaa30c2c151", "idx": 203}
{"func": "static int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  /* threads are never black */\n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        work++;\n        if (!iswhite(uv))  /* upvalue already visited? */\n          markvalue(g, uv->v);  /* mark its value */\n      }\n    }\n  }\n  return work;\n}", "target": 1, "cwe": ["CWE-763"], "project": "lua", "commit_id": "a6da1472c0c5e05ff249325f979531ad51533110", "hash": 191690362949428734200557897156268054888, "size": 22, "message": "Fixed bug: barriers cannot be active during sweep\n\nBarriers cannot be active during sweep, even in generational mode.\n(Although gen. mode is not incremental, it can hit a barrier when\ndeleting a thread and closing its upvalues.)  The colors of objects are\nbeing changed during sweep and, therefore, cannot be trusted.", "idx": 204}
{"func": "void appendBSONObjToBSONArrayBuilder(BSONArrayBuilder* array, const BSONObj& obj) {\n    array->append(obj);\n}", "target": 0, "cwe": ["CWE-613"], "project": "mongo", "commit_id": "db19e7ce84cfd702a4ba9983ee2ea5019f470f82", "hash": 35103734760693528653865277573189678270, "size": 3, "message": "SERVER-38984 Validate unique User ID on UserCache hit\n\n(cherry picked from commit e55d6e2292e5dbe2f97153251d8193d1cc89f5d7)", "idx": 205}
{"func": "static Image *ReadWEBPImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  int\n    webp_status;\n\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    header[12],\n    *stream;\n\n  WebPDecoderConfig\n    configure;\n\n  WebPDecBuffer\n    *magick_restrict webp_image = &configure.output;\n\n  WebPBitstreamFeatures\n    *magick_restrict features = &configure.input;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (WebPInitDecoderConfig(&configure) == 0)\n    ThrowReaderException(ResourceLimitError,\"UnableToDecodeImageFile\");\n  webp_image->colorspace=MODE_RGBA;\n  count=ReadBlob(image,12,header);\n  if (count != 12)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  status=IsWEBP(header,count);\n  if (status == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  length=(size_t) (ReadWebPLSBWord(header+4)+8);\n  if (length < 12)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  stream=(unsigned char *) AcquireQuantumMemory(length,sizeof(*stream));\n  if (stream == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  memcpy(stream,header,12);\n  count=ReadBlob(image,length-12,stream+12);\n  if (count != (ssize_t) (length-12))\n    {\n      stream=(unsigned char*) RelinquishMagickMemory(stream);\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    }\n  webp_status=WebPGetFeatures(stream,length,features);\n  if (webp_status == VP8_STATUS_OK)\n    {\n      image->columns=(size_t) features->width;\n      image->rows=(size_t) features->height;\n      image->depth=8;\n      image->alpha_trait=features->has_alpha != 0 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n      if (image_info->ping != MagickFalse)\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          (void) CloseBlob(image);\n          return(GetFirstImageInList(image));\n        }\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          (void) CloseBlob(image);\n          return(DestroyImageList(image));\n        }\n      webp_status=WebPDecode(stream,length,&configure);\n    }\n  if (webp_status != VP8_STATUS_OK)\n    {\n      stream=(unsigned char*) RelinquishMagickMemory(stream);\n      switch (webp_status)\n      {\n        case VP8_STATUS_OUT_OF_MEMORY:\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          break;\n        }\n        case VP8_STATUS_INVALID_PARAM:\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          ThrowReaderException(CorruptImageError,\"invalid parameter\");\n          break;\n        }\n        case VP8_STATUS_BITSTREAM_ERROR:\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n          break;\n        }\n        case VP8_STATUS_UNSUPPORTED_FEATURE:\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n          break;\n        }\n        case VP8_STATUS_SUSPENDED:\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          ThrowReaderException(CorruptImageError,\"decoder suspended\");\n          break;\n        }\n        case VP8_STATUS_USER_ABORT:\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          ThrowReaderException(CorruptImageError,\"user abort\");\n          break;\n        }\n        case VP8_STATUS_NOT_ENOUGH_DATA:\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n          break;\n        }\n        default:\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        }\n      }\n    }\n  if (IsWEBPImageLossless(stream,length) != MagickFalse)\n    image->quality=100;\n  p=(unsigned char *) webp_image->u.RGBA.rgba;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *q;\n\n    register ssize_t\n      x;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n      SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n      SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n      SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  WebPFreeDecBuffer(webp_image);\n  stream=(unsigned char*) RelinquishMagickMemory(stream);\n  (void) CloseBlob(image);\n  return(image);\n}", "target": 1, "cwe": ["CWE-400"], "project": "ImageMagick", "commit_id": "cb63560ba25e4a6c51ab282538c24877fff7d471", "hash": 43218061479359242970594654582074780545, "size": 185, "message": "https://github.com/ImageMagick/ImageMagick/issues/641", "idx": 206}
{"func": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}", "target": 0, "cwe": ["CWE-190"], "project": "net", "commit_id": "6399f1fae4ec29fab5ec76070435555e256ca3a6", "hash": 162485270499026782673267263327963830790, "size": 45, "message": "ipv6: avoid overflow of offset in ip6_find_1stfragopt\n\nIn some cases, offset can overflow and can cause an infinite loop in\nip6_find_1stfragopt(). Make it unsigned int to prevent the overflow, and\ncap it at IPV6_MAXPLEN, since packets larger than that should be invalid.\n\nThis problem has been here since before the beginning of git history.\n\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 207}
{"func": "static ssize_t send_change_cipher_spec(gnutls_session_t session, int again)\n{\n\tuint8_t *data;\n\tmbuffer_st *bufel;\n\tint ret;\n\tconst version_entry_st *vers;\n\n\tif (again == 0) {\n\t\tbufel = _gnutls_handshake_alloc(session, 1);\n\t\tif (bufel == NULL)\n\t\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\n\t\tvers = get_version(session);\n\t\tif (unlikely(vers == NULL))\n\t\t\treturn gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n\n\t\tif (vers->id == GNUTLS_DTLS0_9)\n\t\t\t_mbuffer_set_uhead_size(bufel, 3);\n\t\telse\n\t\t\t_mbuffer_set_uhead_size(bufel, 1);\n\t\t_mbuffer_set_udata_size(bufel, 0);\n\n\t\tdata = _mbuffer_get_uhead_ptr(bufel);\n\n\t\tdata[0] = 1;\n\t\tif (vers->id == GNUTLS_DTLS0_9) {\n\t\t\t_gnutls_write_uint16(session->internals.dtls.\n\t\t\t\t\t     hsk_write_seq, &data[1]);\n\t\t\tsession->internals.dtls.hsk_write_seq++;\n\t\t}\n\n\t\tret =\n\t\t    _gnutls_handshake_io_cache_int(session,\n\t\t\t\t\t\t   GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC,\n\t\t\t\t\t\t   bufel);\n\t\tif (ret < 0) {\n\t\t\t_mbuffer_xfree(&bufel);\n\t\t\treturn gnutls_assert_val(ret);\n\t\t}\n\n\t\t_gnutls_handshake_log(\"REC[%p]: Sent ChangeCipherSpec\\n\",\n\t\t\t\t      session);\n\t}\n\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-310"], "project": "gnutls", "commit_id": "db9a7d810f9ee4c9cc49731f5fd9bdeae68d7eaa", "hash": 270420471821444832913694257769995495164, "size": 46, "message": "handshake: check for TLS_FALLBACK_SCSV\n\nIf TLS_FALLBACK_SCSV was sent by the client during the handshake, and\nthe advertised protocol version is lower than GNUTLS_TLS_VERSION_MAX,\nsend the \"Inappropriate fallback\" fatal alert and abort the handshake.\n\nThis mechanism was defined in RFC7507.", "idx": 208}
{"func": "static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,\n                                                                     ULONG ulAttribute,\n                                                                     void* pBuffer, ULONG cbBuffer)\n{\n\tMechCred* creds;\n\n\tcreds = sspi_SecureHandleGetLowerPointer(phCredential);\n\n\tif (!creds)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tfor (size_t i = 0; i < MECH_COUNT; i++)\n\t{\n\t\tMechCred* cred = &creds[i];\n\n\t\tif (!cred->valid)\n\t\t\tcontinue;\n\n\t\tWINPR_ASSERT(cred->mech);\n\t\tWINPR_ASSERT(cred->mech->pkg);\n\t\tWINPR_ASSERT(cred->mech->pkg->table);\n\t\tWINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);\n\t\tcred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, ulAttribute, pBuffer,\n\t\t                                                    cbBuffer);\n\t}\n\n\treturn SEC_E_OK;\n}", "target": 1, "cwe": [], "project": "FreeRDP", "commit_id": "479e891545473f01c187daffdfa05fc752b54b72", "hash": 136510810127595485314072137517982747597, "size": 28, "message": "check return values for SetCredentialsAttributes, throw warnings for unsupported attributes", "idx": 209}
{"func": "static int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\n\t/*\n\t * Protect exec's credential calculations against our interference;\n\t * SUID, SGID and LSM creds get determined differently\n\t * under ptrace.\n\t */\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\n\ttask->ptrace = flags;\n\n\tptrace_link(task, current);\n\n\t/* SEIZE doesn't trap tracee on attach */\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\n\tspin_lock(&task->sighand->siglock);\n\n\t/*\n\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and\n\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING\n\t * will be cleared if the child completes the transition or any\n\t * event which clears the group stop states happens.  We'll wait\n\t * for the transition to complete before returning from this\n\t * function.\n\t *\n\t * This hides STOPPED -> RUNNING -> TRACED transition from the\n\t * attaching thread but a different thread in the same group can\n\t * still observe the transient RUNNING state.  IOW, if another\n\t * thread's WNOHANG wait(2) on the stopped tracee races against\n\t * ATTACH, the wait(2) may fail due to the transient RUNNING.\n\t *\n\t * The following task_is_stopped() test is safe as both transitions\n\t * in and out of STOPPED are protected by siglock.\n\t */\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\n\tspin_unlock(&task->sighand->siglock);\n\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\t/*\n\t\t * We do not bother to change retval or clear JOBCTL_TRAPPING\n\t\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will\n\t\t * not return to user-mode, it will exit and clear this bit in\n\t\t * __ptrace_unlink() if it wasn't already cleared by the tracee;\n\t\t * and until then nobody can ptrace this task.\n\t\t */\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\n\treturn retval;\n}", "target": 1, "cwe": ["CWE-276", "CWE-703", "CWE-863"], "project": "linux", "commit_id": "ee1fee900537b5d9560e9f937402de5ddc8412f3", "hash": 5385277698898368464207342287484526383, "size": 101, "message": "ptrace: Check PTRACE_O_SUSPEND_SECCOMP permission on PTRACE_SEIZE\n\nSetting PTRACE_O_SUSPEND_SECCOMP is supposed to be a highly privileged\noperation because it allows the tracee to completely bypass all seccomp\nfilters on kernels with CONFIG_CHECKPOINT_RESTORE=y. It is only supposed to\nbe settable by a process with global CAP_SYS_ADMIN, and only if that\nprocess is not subject to any seccomp filters at all.\n\nHowever, while these permission checks were done on the PTRACE_SETOPTIONS\npath, they were missing on the PTRACE_SEIZE path, which also sets\nuser-specified ptrace flags.\n\nMove the permissions checks out into a helper function and let both\nptrace_attach() and ptrace_setoptions() call it.\n\nCc: stable@kernel.org\nFixes: 13c4a90119d2 (\"seccomp: add ptrace options for suspend/resume\")\nSigned-off-by: Jann Horn <jannh@google.com>\nLink: https://lkml.kernel.org/r/20220319010838.1386861-1-jannh@google.com\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>", "idx": 210}
{"func": "add_connection (NMConnectionList *self,\n                NMConnectionEditor *editor,\n                NMConnection *connection,\n                ConnectionAddedFn callback,\n                gpointer user_data)\n{\n\tNMExportedConnection *exported = NULL;\n\tNMConnectionScope scope;\n\tgboolean success = FALSE;\n\n\tscope = nm_connection_get_scope (connection);\n\tif (scope == NM_CONNECTION_SCOPE_SYSTEM) {\n\t\tGError *error = NULL;\n\n\t\tutils_fill_connection_certs (connection);\n\t\tsuccess = nm_dbus_settings_system_add_connection (self->system_settings, connection, &error);\n\t\tutils_clear_filled_connection_certs (connection);\n\n\t\tif (!success) {\n\t\t\tgboolean pending_auth = FALSE;\n\t\t\tGtkWindow *parent;\n\n\t\t\tparent = nm_connection_editor_get_window (editor);\n\t\t\tif (pk_helper_is_permission_denied_error (error)) {\n\t\t\t\tConnectionAddInfo *info;\n\t\t\t\tGError *auth_error = NULL;\n\n\t\t\t\tinfo = g_slice_new (ConnectionAddInfo);\n\t\t\t\tinfo->list = self;\n\t\t\t\tinfo->editor = editor;\n\t\t\t\tinfo->connection = g_object_ref (connection);\n\t\t\t\tinfo->callback = callback;\n\t\t\t\tinfo->user_data = user_data;\n\n\t\t\t\tpending_auth = pk_helper_obtain_auth (error, parent, add_connection_cb, info, &auth_error);\n\t\t\t\tif (auth_error) {\n\t\t\t\t\terror_dialog (parent,\n\t\t\t\t\t              _(\"Could not add connection\"),\n\t\t\t\t\t              \"%s\", auth_error->message);\n\t\t\t\t\tg_error_free (auth_error);\n\t\t\t\t}\n\n\t\t\t\tif (!pending_auth) {\n\t\t\t\t\tg_object_unref (info->connection);\n\t\t\t\t\tg_slice_free (ConnectionAddInfo, info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror_dialog (parent,\n\t\t\t\t              _(\"Could not add connection\"),\n\t\t\t\t              \"%s\", error->message);\n\t\t\t}\n\n\t\t\tg_error_free (error);\n\n\t\t\tif (pending_auth)\n\t\t\t\treturn;\n\t\t}\n\t} else if (scope == NM_CONNECTION_SCOPE_USER) {\n\t\texported = (NMExportedConnection *) nma_gconf_settings_add_connection (self->gconf_settings, connection);\n\t\tsuccess = exported != NULL;\n\t\tif (success && editor)\n\t\t\tnm_connection_editor_save_vpn_secrets (editor);\n\t} else\n\t\tg_warning (\"%s: unhandled connection scope %d!\", __func__, scope);\n\n\tif (callback)\n\t\tcallback (exported, success, user_data);\n\n\tif (exported)\n\t\tg_object_unref (exported);\n}", "target": 1, "cwe": ["CWE-310"], "project": "network-manager-applet", "commit_id": "4020594dfbf566f1852f0acb36ad631a9e73a82b", "hash": 164502455550204190886085855244323838272, "size": 71, "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet).", "idx": 211}
{"func": "BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,\n                                    int LeftOfs, int TopOfs, int Delay,\n                                    int Disposal, gdImagePtr previm)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) return;\n\tgdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);\n\tout->gd_free(out);\n}", "target": 0, "cwe": ["CWE-415"], "project": "libgd", "commit_id": "553702980ae89c83f2d6e254d62cf82e204956d0", "hash": 17155093626727442810191245885082191111, "size": 9, "message": "Fix #492: Potential double-free in gdImage*Ptr()\n\nWhenever `gdImage*Ptr()` calls `gdImage*Ctx()` and the latter fails, we\nmust not call `gdDPExtractData()`; otherwise a double-free would\nhappen.  Since `gdImage*Ctx()` are void functions, and we can't change\nthat for BC reasons, we're introducing static helpers which are used\ninternally.\n\nWe're adding a regression test for `gdImageJpegPtr()`, but not for\n`gdImageGifPtr()` and `gdImageWbmpPtr()` since we don't know how to\ntrigger failure of the respective `gdImage*Ctx()` calls.\n\nThis potential security issue has been reported by Solmaz Salimi (aka.\nRooney).", "idx": 212}
{"func": "const char* RtmpProtocol::handle_C2(const char *data, size_t len) {\n    if (len < C1_HANDSHARK_SIZE) {\n        //need more data!\n        return nullptr;\n    }\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_rtmp(data, len);\n    };\n\n    //握手结束，进入命令模式\n    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);\n}", "target": 0, "cwe": ["CWE-703"], "project": "ZLMediaKit", "commit_id": "7d8b212a3c3368bc2f6507cb74664fc419eb9327", "hash": 38202698136966593550700194469772575199, "size": 12, "message": "修复rtmp汇报窗口太小导致循环递归的bug：#1839", "idx": 213}
{"func": "EXPORTED void simple_hdr(struct transaction_t *txn,\n                         const char *name, const char *value, ...)\n{\n    struct buf buf = BUF_INITIALIZER;\n    va_list args;\n\n    va_start(args, value);\n    buf_vprintf(&buf, value, args);\n    va_end(args);\n\n    syslog(LOG_DEBUG, \"simple_hdr(%s: %s)\", name, buf_cstring(&buf));\n\n    if (txn->flags.ver == VER_2) {\n        http2_add_header(txn, name, &buf);\n    }\n    else {\n        prot_printf(txn->conn->pout, \"%c%s: \", toupper(name[0]), name+1);\n        prot_puts(txn->conn->pout, buf_cstring(&buf));\n        prot_puts(txn->conn->pout, \"\\r\\n\");\n\n        buf_free(&buf);\n    }\n}", "target": 0, "cwe": [], "project": "cyrus-imapd", "commit_id": "602f12ed2af0a49ac4a58affbfea57d0fc23dea5", "hash": 286395642597424464449758685739539107868, "size": 23, "message": "httpd.c: only allow reuse of auth creds on a persistent connection against a backend server in a Murder", "idx": 214}
{"func": "ldns_rdf_new_frm_str(ldns_rdf_type type, const char *str)\n{\n\tldns_rdf *rdf = NULL;\n\tldns_status status;\n\n\tswitch (type) {\n\tcase LDNS_RDF_TYPE_DNAME:\n\t\tstatus = ldns_str2rdf_dname(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_INT8:\n\t\tstatus = ldns_str2rdf_int8(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_INT16:\n\t\tstatus = ldns_str2rdf_int16(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_INT32:\n\t\tstatus = ldns_str2rdf_int32(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_A:\n\t\tstatus = ldns_str2rdf_a(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_AAAA:\n\t\tstatus = ldns_str2rdf_aaaa(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_STR:\n\t\tstatus = ldns_str2rdf_str(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_APL:\n\t\tstatus = ldns_str2rdf_apl(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_B64:\n\t\tstatus = ldns_str2rdf_b64(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_B32_EXT:\n\t\tstatus = ldns_str2rdf_b32_ext(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_HEX:\n\t\tstatus = ldns_str2rdf_hex(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_NSEC:\n\t\tstatus = ldns_str2rdf_nsec(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_TYPE:\n\t\tstatus = ldns_str2rdf_type(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_CLASS:\n\t\tstatus = ldns_str2rdf_class(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_CERT_ALG:\n\t\tstatus = ldns_str2rdf_cert_alg(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_ALG:\n\t\tstatus = ldns_str2rdf_alg(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_UNKNOWN:\n\t\tstatus = ldns_str2rdf_unknown(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_TIME:\n\t\tstatus = ldns_str2rdf_time(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_PERIOD:\n\t\tstatus = ldns_str2rdf_period(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_TSIG:\n\t\tstatus = ldns_str2rdf_tsig(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_SERVICE:\n\t\tstatus = ldns_str2rdf_service(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_LOC:\n\t\tstatus = ldns_str2rdf_loc(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_WKS:\n\t\tstatus = ldns_str2rdf_wks(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_NSAP:\n\t\tstatus = ldns_str2rdf_nsap(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_ATMA:\n\t\tstatus = ldns_str2rdf_atma(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_IPSECKEY:\n\t\tstatus = ldns_str2rdf_ipseckey(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_NSEC3_SALT:\n\t\tstatus = ldns_str2rdf_nsec3_salt(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_NSEC3_NEXT_OWNER:\n\t\tstatus = ldns_str2rdf_b32_ext(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_ILNP64:\n\t\tstatus = ldns_str2rdf_ilnp64(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_EUI48:\n\t\tstatus = ldns_str2rdf_eui48(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_EUI64:\n\t\tstatus = ldns_str2rdf_eui64(&rdf, str);\n\t\tbreak;\n\tcase LDNS_RDF_TYPE_NONE:\n\tdefault:\n\t\t/* default default ??? */\n\t\tstatus = LDNS_STATUS_ERR;\n\t\tbreak;\n\t}\n\tif (LDNS_STATUS_OK == status) {\n\t\tldns_rdf_set_type(rdf, type);\n\t\treturn rdf;\n\t}\n\tif (rdf) {\n\t\tLDNS_FREE(rdf);\n\t}\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-415"], "project": "ldns", "commit_id": "070b4595981f48a21cc6b4f5047fdc2d09d3da91", "hash": 287626854186204485015890450410879258692, "size": 114, "message": "CAA and URI", "idx": 215}
{"func": "void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\n\t{\n\tif (ctx->cleanup) ctx->cleanup(ctx);\n\tif (ctx->param != NULL)\n\t\t{\n\t\tif (ctx->parent == NULL)\n\t\t\tX509_VERIFY_PARAM_free(ctx->param);\n\t\tctx->param=NULL;\n\t\t}\n\tif (ctx->tree != NULL)\n\t\t{\n\t\tX509_policy_tree_free(ctx->tree);\n\t\tctx->tree=NULL;\n\t\t}\n\tif (ctx->chain != NULL)\n\t\t{\n\t\tsk_X509_pop_free(ctx->chain,X509_free);\n\t\tctx->chain=NULL;\n\t\t}\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));\n\tmemset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));\n\t}", "target": 0, "cwe": [], "project": "openssl", "commit_id": "d65b8b2162f33ac0d53dace588a0847ed827626c", "hash": 169746238165587853548537720262224085002, "size": 22, "message": "Backport OCSP fixes.", "idx": 216}
{"func": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tput_device(&dev->dev);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-416", "CWE-401"], "project": "linux", "commit_id": "fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57", "hash": 25955652333888999451066889011133654892, "size": 7, "message": "ALSA: seq: Cancel pending autoload work at unbinding device\n\nALSA sequencer core has a mechanism to load the enumerated devices\nautomatically, and it's performed in an off-load work.  This seems\ncausing some race when a sequencer is removed while the pending\nautoload work is running.  As syzkaller spotted, it may lead to some\nuse-after-free:\n  BUG: KASAN: use-after-free in snd_rawmidi_dev_seq_free+0x69/0x70\n  sound/core/rawmidi.c:1617\n  Write of size 8 at addr ffff88006c611d90 by task kworker/2:1/567\n\n  CPU: 2 PID: 567 Comm: kworker/2:1 Not tainted 4.13.0+ #29\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n  Workqueue: events autoload_drivers\n  Call Trace:\n   __dump_stack lib/dump_stack.c:16 [inline]\n   dump_stack+0x192/0x22c lib/dump_stack.c:52\n   print_address_description+0x78/0x280 mm/kasan/report.c:252\n   kasan_report_error mm/kasan/report.c:351 [inline]\n   kasan_report+0x230/0x340 mm/kasan/report.c:409\n   __asan_report_store8_noabort+0x1c/0x20 mm/kasan/report.c:435\n   snd_rawmidi_dev_seq_free+0x69/0x70 sound/core/rawmidi.c:1617\n   snd_seq_dev_release+0x4f/0x70 sound/core/seq_device.c:192\n   device_release+0x13f/0x210 drivers/base/core.c:814\n   kobject_cleanup lib/kobject.c:648 [inline]\n   kobject_release lib/kobject.c:677 [inline]\n   kref_put include/linux/kref.h:70 [inline]\n   kobject_put+0x145/0x240 lib/kobject.c:694\n   put_device+0x25/0x30 drivers/base/core.c:1799\n   klist_devices_put+0x36/0x40 drivers/base/bus.c:827\n   klist_next+0x264/0x4a0 lib/klist.c:403\n   next_device drivers/base/bus.c:270 [inline]\n   bus_for_each_dev+0x17e/0x210 drivers/base/bus.c:312\n   autoload_drivers+0x3b/0x50 sound/core/seq_device.c:117\n   process_one_work+0x9fb/0x1570 kernel/workqueue.c:2097\n   worker_thread+0x1e4/0x1350 kernel/workqueue.c:2231\n   kthread+0x324/0x3f0 kernel/kthread.c:231\n   ret_from_fork+0x25/0x30 arch/x86/entry/entry_64.S:425\n\nThe fix is simply to assure canceling the autoload work at removing\nthe device.\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "idx": 217}
{"func": "static void dense_rankStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ) p->nStep = 1;\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}", "target": 0, "cwe": ["CWE-476"], "project": "sqlite", "commit_id": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54", "hash": 46589029038798076215747856662783614719, "size": 11, "message": "When processing constant integer values in ORDER BY clauses of window\ndefinitions (see check-in [7e4809eadfe99ebf]) be sure to fully disable\nthe constant value to avoid an invalid pointer dereference if the expression\nis ever duplicated. This fixes a crash report from Yongheng and Rui.\n\nFossilOrigin-Name: 1ca0bd982ab1183bbafce0d260e4dceda5eb766ed2e7793374a88d1ae0bdd2ca", "idx": 218}
{"func": "toomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s header sections (%u)\", name, num\n\t    ) == -1)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "project": "file", "commit_id": "ce90e05774dd77d86cfc8dfa6da57b32816841c4", "hash": 318461886892725009419932947279062306431, "size": 7, "message": "- Add a limit to the number of ELF notes processed (Suggested by Alexander\n  Cherepanov)\n- Restructure ELF note printing so that we don't print the same message\n  multiple times on repeated notes of the same kind.", "idx": 219}
{"func": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\t/* Special case, because of NET_IP_ALIGN. Given metadata sits\n\t\t * right in front, treat it the very same way.\n\t\t */\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}", "target": 1, "cwe": ["CWE-476", "CWE-119"], "project": "linux", "commit_id": "a5ec6ae161d72f01411169a938fa5f8baea16e8f", "hash": 295321014633785702020344943744244675370, "size": 29, "message": "bpf: force strict alignment checks for stack pointers\n\nForce strict alignment checks for stack pointers because the tracking of\nstack spills relies on it; unaligned stack accesses can lead to corruption\nof spilled registers, which is exploitable.\n\nFixes: f1174f77b50c (\"bpf/verifier: rework value tracking\")\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>", "idx": 220}
{"func": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}", "target": 1, "cwe": ["CWE-400", "CWE-703"], "project": "envoy", "commit_id": "afc39bea36fd436e54262f150c009e8d72db5014", "hash": 222288481864682740229091358403770277552, "size": 9, "message": "Track byteSize of HeaderMap internally.\n\nIntroduces a cached byte size updated internally in HeaderMap. The value\nis stored as an optional, and is cleared whenever a non-const pointer or\nreference to a HeaderEntry is accessed. The cached value can be set with\nrefreshByteSize() which performs an iteration over the HeaderMap to sum\nthe size of each key and value in the HeaderMap.\n\nSigned-off-by: Asra Ali <asraa@google.com>", "idx": 221}
{"func": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}", "target": 1, "cwe": ["CWE-78"], "project": "newsbeuter", "commit_id": "c8fea2f60c18ed30bdd1bb6f798e994e51a58260", "hash": 189077926802611257347537593580827529283, "size": 12, "message": "Work around shell code in podcast names (#598)", "idx": 222}
{"func": "lou_setDataPath (char *path)\n{\n  dataPathPtr = NULL;\n  if (path == NULL)\n    return NULL;\n  strcpy (dataPath, path);\n  dataPathPtr = dataPath;\n  return dataPathPtr;\n}", "target": 0, "cwe": [], "project": "liblouis", "commit_id": "dc97ef791a4fae9da11592c79f9f79e010596e0c", "hash": 69509947786985296903722461727240810862, "size": 9, "message": "Merge branch 'table_resolver'", "idx": 223}
{"func": "evdns_shutdown(int fail_requests)\n{\n\tif (current_base) {\n\t\tstruct evdns_base *b = current_base;\n\t\tcurrent_base = NULL;\n\t\tevdns_base_free(b, fail_requests);\n\t}\n\tevdns_log_fn = NULL;\n}", "target": 0, "cwe": ["CWE-125"], "project": "libevent", "commit_id": "96f64a022014a208105ead6c8a7066018449d86d", "hash": 207382650143118894950023280930864526894, "size": 9, "message": "evdns: name_parse(): fix remote stack overread\n\n@asn-the-goblin-slayer:\n  \"the name_parse() function in libevent's DNS code is vulnerable to a buffer overread.\n\n   971         if (cp != name_out) {\n   972             if (cp + 1 >= end) return -1;\n   973             *cp++ = '.';\n   974         }\n   975         if (cp + label_len >= end) return -1;\n   976         memcpy(cp, packet + j, label_len);\n   977         cp += label_len;\n   978         j += label_len;\n   No check is made against length before the memcpy occurs.\n\n   This was found through the Tor bug bounty program and the discovery should be credited to 'Guido Vranken'.\"\n\nReproducer for gdb (https://gist.github.com/azat/e4fcf540e9b89ab86d02):\n  set $PROT_NONE=0x0\n  set $PROT_READ=0x1\n  set $PROT_WRITE=0x2\n  set $MAP_ANONYMOUS=0x20\n  set $MAP_SHARED=0x01\n  set $MAP_FIXED=0x10\n  set $MAP_32BIT=0x40\n\n  start\n\n  set $length=202\n  # overread\n  set $length=2\n  # allocate with mmap to have a seg fault on page boundary\n  set $l=(1<<20)*2\n  p mmap(0, $l, $PROT_READ|$PROT_WRITE, $MAP_ANONYMOUS|$MAP_SHARED|$MAP_32BIT, -1, 0)\n  set $packet=(char *)$1+$l-$length\n  # hack the packet\n  set $packet[0]=63\n  set $packet[1]='/'\n\n  p malloc(sizeof(int))\n  set $idx=(int *)$2\n  set $idx[0]=0\n  set $name_out_len=202\n\n  p malloc($name_out_len)\n  set $name_out=$3\n\n  # have WRITE only mapping to fail on read\n  set $end=$1+$l\n  p (void *)mmap($end, 1<<12, $PROT_NONE, $MAP_ANONYMOUS|$MAP_SHARED|$MAP_FIXED|$MAP_32BIT, -1, 0)\n  set $m=$4\n\n  p name_parse($packet, $length, $idx, $name_out, $name_out_len)\n  x/2s (char *)$name_out\n\nBefore this patch:\n$ gdb -ex 'source gdb' dns-example\n$1 = 1073741824\n$2 = (void *) 0x633010\n$3 = (void *) 0x633030\n$4 = (void *) 0x40200000\n\nProgram received signal SIGSEGV, Segmentation fault.\n__memcpy_sse2_unaligned () at memcpy-sse2-unaligned.S:33\n\nAfter this patch:\n$ gdb -ex 'source gdb' dns-example\n$1 = 1073741824\n$2 = (void *) 0x633010\n$3 = (void *) 0x633030\n$4 = (void *) 0x40200000\n$5 = -1\n0x633030:       \"/\"\n0x633032:       \"\"\n(gdb) p $m\n$6 = (void *) 0x40200000\n(gdb) p $1\n$7 = 1073741824\n(gdb) p/x $1\n$8 = 0x40000000\n(gdb) quit\n\nP.S. plus drop one condition duplicate.\n\nFixes: #317", "idx": 224}
{"func": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\n\t\tALLOC_INIT_ZVAL(key);\n\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\n\t\tALLOC_INIT_ZVAL(data);\n\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* object properties should include no integers */\n\t\t\tconvert_to_string(key);\n\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t}\n\t\t\tzend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n\t\t\t\t\tsizeof data, NULL);\n\t\t}\n\t\t\n\t\tzval_dtor(key);\n\t\tFREE_ZVAL(key);\n\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-94"], "project": "php-src", "commit_id": "b585a3aed7880a5fa5c18e2b838fc96f40e075bd", "hash": 55884705804334807409142873125961586865, "size": 65, "message": "Fix for bug #68710 (Use After Free Vulnerability in PHP's unserialize())", "idx": 225}
{"func": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}", "target": 1, "cwe": ["CWE-190"], "project": "net", "commit_id": "6399f1fae4ec29fab5ec76070435555e256ca3a6", "hash": 190209632527746058360709051335190075289, "size": 41, "message": "ipv6: avoid overflow of offset in ip6_find_1stfragopt\n\nIn some cases, offset can overflow and can cause an infinite loop in\nip6_find_1stfragopt(). Make it unsigned int to prevent the overflow, and\ncap it at IPV6_MAXPLEN, since packets larger than that should be invalid.\n\nThis problem has been here since before the beginning of git history.\n\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 226}
{"func": "static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_export_directory))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_export_directory));\n}", "target": 0, "cwe": ["CWE-400", "CWE-703"], "project": "radare2", "commit_id": "634b886e84a5c568d243e744becc6b3223e089cf", "hash": 182778081778535728534813199193733598568, "size": 21, "message": "Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash\n\n* Reported by lazymio\n* Reproducer: AAA4AAAAAB4=", "idx": 227}
{"func": "static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)\n{\n    return cirrus_bitblt_common_patterncopy(s,\n\t\t\t\t\t    s->vram_ptr +\n                                            (s->cirrus_blt_srcaddr & ~7));\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 58384268221957848687614989550830035306, "size": 6, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162", "idx": 228}
{"func": "RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {\n    _createBuiltinRolesForDBIfNeeded(dbname);\n\n    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName(\"\", dbname));\n    std::string afterDB = dbname;\n    afterDB.push_back('\\0');\n    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName(\"\", afterDB));\n    return makeRoleNameIterator(lower, upper);\n}", "target": 0, "cwe": ["CWE-863"], "project": "mongo", "commit_id": "fb87cc88ecb5d300f14cda7bc238d7d5132118f5", "hash": 152656596879982577385770858253148438910, "size": 9, "message": "SERVER-45472 Ensure RoleGraph can serialize authentication restrictions to BSON\n\n(cherry picked from commit 521e56b407ac72bc69a97a24d1253f51a5b6e81b)\n(cherry picked from commit a10d0a22d5d009d27664967181042933ec1bef36)", "idx": 229}
{"func": "int fullSpeedBench(char** fileNamesTable, int nbFiles)\n{\n  int fileIdx=0;\n  char* orig_buff;\n# define NB_COMPRESSION_ALGORITHMS 13\n# define MINCOMPRESSIONCHAR '0'\n  double totalCTime[NB_COMPRESSION_ALGORITHMS+1] = {0};\n  double totalCSize[NB_COMPRESSION_ALGORITHMS+1] = {0};\n# define NB_DECOMPRESSION_ALGORITHMS 7\n# define MINDECOMPRESSIONCHAR '0'\n# define MAXDECOMPRESSIONCHAR (MINDECOMPRESSIONCHAR + NB_DECOMPRESSION_ALGORITHMS)\n  static char* decompressionNames[] = { \"LZ4_decompress_fast\", \"LZ4_decompress_fast_withPrefix64k\", \"LZ4_decompress_fast_usingDict\",\n                                        \"LZ4_decompress_safe\", \"LZ4_decompress_safe_withPrefix64k\", \"LZ4_decompress_safe_usingDict\", \"LZ4_decompress_safe_partial\" };\n  double totalDTime[NB_DECOMPRESSION_ALGORITHMS+1] = {0};\n\n  U64 totals = 0;\n\n\n  // Loop for each file\n  while (fileIdx<nbFiles)\n  {\n      FILE* inFile;\n      char* inFileName;\n      U64   inFileSize;\n      size_t benchedSize;\n      int nbChunks;\n      int maxCompressedChunkSize;\n      struct chunkParameters* chunkP;\n      size_t readSize;\n      char* compressed_buff; int compressedBuffSize;\n      U32 crcOriginal;\n\n\n      // Init\n      stateLZ4   = malloc(LZ4_sizeofState());\n      stateLZ4HC = malloc(LZ4_sizeofStateHC());\n\n      // Check file existence\n      inFileName = fileNamesTable[fileIdx++];\n      inFile = fopen( inFileName, \"rb\" );\n      if (inFile==NULL)\n      {\n        DISPLAY( \"Pb opening %s\\n\", inFileName);\n        return 11;\n      }\n\n      // Memory allocation & restrictions\n      inFileSize = BMK_GetFileSize(inFileName);\n      benchedSize = (size_t) BMK_findMaxMem(inFileSize) / 2;\n      if ((U64)benchedSize > inFileSize) benchedSize = (size_t)inFileSize;\n      if (benchedSize < inFileSize)\n      {\n          DISPLAY(\"Not enough memory for '%s' full size; testing %i MB only...\\n\", inFileName, (int)(benchedSize>>20));\n      }\n\n      // Alloc\n      chunkP = (struct chunkParameters*) malloc(((benchedSize / (size_t)chunkSize)+1) * sizeof(struct chunkParameters));\n      orig_buff = (char*) malloc((size_t)benchedSize);\n      nbChunks = (int) ((int)benchedSize / chunkSize) + 1;\n      maxCompressedChunkSize = LZ4_compressBound(chunkSize);\n      compressedBuffSize = nbChunks * maxCompressedChunkSize;\n      compressed_buff = (char*)malloc((size_t)compressedBuffSize);\n\n\n      if(!orig_buff || !compressed_buff)\n      {\n        DISPLAY(\"\\nError: not enough memory!\\n\");\n        free(orig_buff);\n        free(compressed_buff);\n        free(chunkP);\n        fclose(inFile);\n        return 12;\n      }\n\n      // Init chunks data\n      {\n          int i;\n          size_t remaining = benchedSize;\n          char* in = orig_buff;\n          char* out = compressed_buff;\n          for (i=0; i<nbChunks; i++)\n          {\n              chunkP[i].id = i;\n              chunkP[i].origBuffer = in; in += chunkSize;\n              if ((int)remaining > chunkSize) { chunkP[i].origSize = chunkSize; remaining -= chunkSize; } else { chunkP[i].origSize = (int)remaining; remaining = 0; }\n              chunkP[i].compressedBuffer = out; out += maxCompressedChunkSize;\n              chunkP[i].compressedSize = 0;\n          }\n      }\n\n      // Fill input buffer\n      DISPLAY(\"Loading %s...       \\r\", inFileName);\n      readSize = fread(orig_buff, 1, benchedSize, inFile);\n      fclose(inFile);\n\n      if(readSize != benchedSize)\n      {\n        DISPLAY(\"\\nError: problem reading file '%s' !!    \\n\", inFileName);\n        free(orig_buff);\n        free(compressed_buff);\n        free(chunkP);\n        return 13;\n      }\n\n      // Calculating input Checksum\n      crcOriginal = XXH32(orig_buff, (unsigned int)benchedSize,0);\n\n\n      // Bench\n      {\n        int loopNb, nb_loops, chunkNb, cAlgNb, dAlgNb;\n        size_t cSize=0;\n        double ratio=0.;\n\n        DISPLAY(\"\\r%79s\\r\", \"\");\n        DISPLAY(\" %s : \\n\", inFileName);\n\n        // Compression Algorithms\n        for (cAlgNb=1; (cAlgNb <= NB_COMPRESSION_ALGORITHMS) && (compressionTest); cAlgNb++)\n        {\n            char* compressorName;\n            int (*compressionFunction)(const char*, char*, int);\n            void* (*initFunction)(const char*) = NULL;\n            double bestTime = 100000000.;\n\n            if ((compressionAlgo != ALL_COMPRESSORS) && (compressionAlgo != cAlgNb)) continue;\n\n            switch(cAlgNb)\n            {\n            case 1 : compressionFunction = LZ4_compress; compressorName = \"LZ4_compress\"; break;\n            case 2 : compressionFunction = local_LZ4_compress_limitedOutput; compressorName = \"LZ4_compress_limitedOutput\"; break;\n            case 3 : compressionFunction = local_LZ4_compress_withState; compressorName = \"LZ4_compress_withState\"; break;\n            case 4 : compressionFunction = local_LZ4_compress_limitedOutput_withState; compressorName = \"LZ4_compress_limitedOutput_withState\"; break;\n            case 5 : compressionFunction = local_LZ4_compress_continue; initFunction = LZ4_create; compressorName = \"LZ4_compress_continue\"; break;\n            case 6 : compressionFunction = local_LZ4_compress_limitedOutput_continue; initFunction = LZ4_create; compressorName = \"LZ4_compress_limitedOutput_continue\"; break;\n            case 7 : compressionFunction = LZ4_compressHC; compressorName = \"LZ4_compressHC\"; break;\n            case 8 : compressionFunction = local_LZ4_compressHC_limitedOutput; compressorName = \"LZ4_compressHC_limitedOutput\"; break;\n            case 9 : compressionFunction = local_LZ4_compressHC_withStateHC; compressorName = \"LZ4_compressHC_withStateHC\"; break;\n            case 10: compressionFunction = local_LZ4_compressHC_limitedOutput_withStateHC; compressorName = \"LZ4_compressHC_limitedOutput_withStateHC\"; break;\n            case 11: compressionFunction = local_LZ4_compressHC_continue; initFunction = LZ4_createHC; compressorName = \"LZ4_compressHC_continue\"; break;\n            case 12: compressionFunction = local_LZ4_compressHC_limitedOutput_continue; initFunction = LZ4_createHC; compressorName = \"LZ4_compressHC_limitedOutput_continue\"; break;\n            case 13: compressionFunction = local_LZ4_compress_forceDict; initFunction = local_LZ4_resetDictT; compressorName = \"LZ4_compress_forceDict\"; break;\n            default : DISPLAY(\"ERROR ! Bad algorithm Id !! \\n\"); free(chunkP); return 1;\n            }\n\n            for (loopNb = 1; loopNb <= nbIterations; loopNb++)\n            {\n                double averageTime;\n                int milliTime;\n\n                PROGRESS(\"%1i-%-26.26s : %9i ->\\r\", loopNb, compressorName, (int)benchedSize);\n                { size_t i; for (i=0; i<benchedSize; i++) compressed_buff[i]=(char)i; }     // warmimg up memory\n\n                nb_loops = 0;\n                milliTime = BMK_GetMilliStart();\n                while(BMK_GetMilliStart() == milliTime);\n                milliTime = BMK_GetMilliStart();\n                while(BMK_GetMilliSpan(milliTime) < TIMELOOP)\n                {\n                    if (initFunction!=NULL) ctx = initFunction(chunkP[0].origBuffer);\n                    for (chunkNb=0; chunkNb<nbChunks; chunkNb++)\n                    {\n                        chunkP[chunkNb].compressedSize = compressionFunction(chunkP[chunkNb].origBuffer, chunkP[chunkNb].compressedBuffer, chunkP[chunkNb].origSize);\n                        if (chunkP[chunkNb].compressedSize==0) DISPLAY(\"ERROR ! %s() = 0 !! \\n\", compressorName), exit(1);\n                    }\n                    if (initFunction!=NULL) free(ctx);\n                    nb_loops++;\n                }\n                milliTime = BMK_GetMilliSpan(milliTime);\n\n                averageTime = (double)milliTime / nb_loops;\n                if (averageTime < bestTime) bestTime = averageTime;\n                cSize=0; for (chunkNb=0; chunkNb<nbChunks; chunkNb++) cSize += chunkP[chunkNb].compressedSize;\n                ratio = (double)cSize/(double)benchedSize*100.;\n                PROGRESS(\"%1i-%-26.26s : %9i -> %9i (%5.2f%%),%7.1f MB/s\\r\", loopNb, compressorName, (int)benchedSize, (int)cSize, ratio, (double)benchedSize / bestTime / 1000.);\n            }\n\n            if (ratio<100.)\n                DISPLAY(\"%-28.28s : %9i -> %9i (%5.2f%%),%7.1f MB/s\\n\", compressorName, (int)benchedSize, (int)cSize, ratio, (double)benchedSize / bestTime / 1000.);\n            else\n                DISPLAY(\"%-28.28s : %9i -> %9i (%5.1f%%),%7.1f MB/s\\n\", compressorName, (int)benchedSize, (int)cSize, ratio, (double)benchedSize / bestTime / 1000.);\n\n            totalCTime[cAlgNb] += bestTime;\n            totalCSize[cAlgNb] += cSize;\n        }\n\n        // Prepare layout for decompression\n        for (chunkNb=0; chunkNb<nbChunks; chunkNb++)\n        {\n            chunkP[chunkNb].compressedSize = LZ4_compress(chunkP[chunkNb].origBuffer, chunkP[chunkNb].compressedBuffer, chunkP[chunkNb].origSize);\n            if (chunkP[chunkNb].compressedSize==0) DISPLAY(\"ERROR ! %s() = 0 !! \\n\", \"LZ4_compress\"), exit(1);\n        }\n        { size_t i; for (i=0; i<benchedSize; i++) orig_buff[i]=0; }     // zeroing source area, for CRC checking\n\n        // Decompression Algorithms\n        for (dAlgNb=0; (dAlgNb < NB_DECOMPRESSION_ALGORITHMS) && (decompressionTest); dAlgNb++)\n        {\n            char* dName = decompressionNames[dAlgNb];\n            int (*decompressionFunction)(const char*, char*, int, int);\n            double bestTime = 100000000.;\n\n            if ((decompressionAlgo != ALL_DECOMPRESSORS) && (decompressionAlgo != dAlgNb+1)) continue;\n\n            switch(dAlgNb)\n            {\n            case 0: decompressionFunction = local_LZ4_decompress_fast; break;\n            case 1: decompressionFunction = local_LZ4_decompress_fast_withPrefix64k; break;\n            case 2: decompressionFunction = local_LZ4_decompress_fast_usingDict; break;\n            case 3: decompressionFunction = LZ4_decompress_safe; break;\n            case 4: decompressionFunction = LZ4_decompress_safe_withPrefix64k; break;\n            case 5: decompressionFunction = local_LZ4_decompress_safe_usingDict; break;\n            case 6: decompressionFunction = local_LZ4_decompress_safe_partial; break;\n            default : DISPLAY(\"ERROR ! Bad decompression algorithm Id !! \\n\"); free(chunkP); return 1;\n            }\n\n            for (loopNb = 1; loopNb <= nbIterations; loopNb++)\n            {\n                double averageTime;\n                int milliTime;\n                U32 crcDecoded;\n\n                PROGRESS(\"%1i-%-29.29s :%10i ->\\r\", loopNb, dName, (int)benchedSize);\n\n                nb_loops = 0;\n                milliTime = BMK_GetMilliStart();\n                while(BMK_GetMilliStart() == milliTime);\n                milliTime = BMK_GetMilliStart();\n                while(BMK_GetMilliSpan(milliTime) < TIMELOOP)\n                {\n                    for (chunkNb=0; chunkNb<nbChunks; chunkNb++)\n                    {\n                        int decodedSize = decompressionFunction(chunkP[chunkNb].compressedBuffer, chunkP[chunkNb].origBuffer, chunkP[chunkNb].compressedSize, chunkP[chunkNb].origSize);\n                        if (chunkP[chunkNb].origSize != decodedSize) DISPLAY(\"ERROR ! %s() == %i != %i !! \\n\", dName, decodedSize, chunkP[chunkNb].origSize), exit(1);\n                    }\n                    nb_loops++;\n                }\n                milliTime = BMK_GetMilliSpan(milliTime);\n\n                averageTime = (double)milliTime / nb_loops;\n                if (averageTime < bestTime) bestTime = averageTime;\n\n                PROGRESS(\"%1i-%-29.29s :%10i -> %7.1f MB/s\\r\", loopNb, dName, (int)benchedSize, (double)benchedSize / bestTime / 1000.);\n\n                // CRC Checking\n                crcDecoded = XXH32(orig_buff, (int)benchedSize, 0);\n                if (crcOriginal!=crcDecoded) { DISPLAY(\"\\n!!! WARNING !!! %14s : Invalid Checksum : %x != %x\\n\", inFileName, (unsigned)crcOriginal, (unsigned)crcDecoded); exit(1); }\n            }\n\n            DISPLAY(\"%-31.31s :%10i -> %7.1f MB/s\\n\", dName, (int)benchedSize, (double)benchedSize / bestTime / 1000.);\n\n            totalDTime[dAlgNb] += bestTime;\n        }\n\n        totals += benchedSize;\n      }\n\n      free(orig_buff);\n      free(compressed_buff);\n      free(chunkP);\n  }\n\n  if (BMK_pause) { printf(\"press enter...\\n\"); getchar(); }\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-20"], "project": "lz4", "commit_id": "da5373197e84ee49d75b8334d4510689731d6e90", "hash": 93400832562426626857764628389725995656, "size": 265, "message": "Fixed : issue 52 (reported by Ludwig Strigeus)", "idx": 230}
{"func": "static my_bool get_view_structure(char *table, char* db)\n{\n  MYSQL_RES  *table_res;\n  MYSQL_ROW  row;\n  MYSQL_FIELD *field;\n  char       *result_table, *opt_quoted_table;\n  char       table_buff[NAME_LEN*2+3];\n  char       table_buff2[NAME_LEN*2+3];\n  char       query[QUERY_LENGTH];\n  FILE       *sql_file= md_result_file;\n  DBUG_ENTER(\"get_view_structure\");\n\n  if (opt_no_create_info) /* Don't write table creation info */\n    DBUG_RETURN(0);\n\n  verbose_msg(\"-- Retrieving view structure for table %s...\\n\", table);\n\n#ifdef NOT_REALLY_USED_YET\n  dynstr_append_checked(&insert_pat, \"SET SQL_QUOTE_SHOW_CREATE=\");\n  dynstr_append_checked(&insert_pat, (opt_quoted || opt_keywords)? \"1\":\"0\");\n#endif\n\n  result_table=     quote_name(table, table_buff, 1);\n  opt_quoted_table= quote_name(table, table_buff2, 0);\n\n  if (switch_character_set_results(mysql, \"binary\"))\n    DBUG_RETURN(1);\n\n  my_snprintf(query, sizeof(query), \"SHOW CREATE TABLE %s\", result_table);\n\n  if (mysql_query_with_error_report(mysql, &table_res, query))\n  {\n    switch_character_set_results(mysql, default_charset);\n    DBUG_RETURN(0);\n  }\n\n  /* Check if this is a view */\n  field= mysql_fetch_field_direct(table_res, 0);\n  if (strcmp(field->name, \"View\") != 0)\n  {\n    mysql_free_result(table_res);\n    switch_character_set_results(mysql, default_charset);\n    verbose_msg(\"-- It's base table, skipped\\n\");\n    DBUG_RETURN(0);\n  }\n\n  /* If requested, open separate .sql file for this view */\n  if (path)\n  {\n    if (!(sql_file= open_sql_file_for_table(table, O_WRONLY)))\n    {\n      mysql_free_result(table_res);\n      DBUG_RETURN(1);\n    }\n    write_header(sql_file, db);\n  }\n\n  print_comment(sql_file, 0,\n                \"\\n--\\n-- Final view structure for view %s\\n--\\n\\n\",\n                result_table);\n\n  /* Table might not exist if this view was dumped with --tab. */\n  fprintf(sql_file, \"/*!50001 DROP TABLE IF EXISTS %s*/;\\n\", opt_quoted_table);\n  if (opt_drop)\n  {\n    fprintf(sql_file, \"/*!50001 DROP VIEW IF EXISTS %s*/;\\n\",\n            opt_quoted_table);\n    check_io(sql_file);\n  }\n\n\n  my_snprintf(query, sizeof(query),\n              \"SELECT CHECK_OPTION, DEFINER, SECURITY_TYPE, \"\n              \"       CHARACTER_SET_CLIENT, COLLATION_CONNECTION \"\n              \"FROM information_schema.views \"\n              \"WHERE table_name=\\\"%s\\\" AND table_schema=\\\"%s\\\"\", table, db);\n\n  if (mysql_query(mysql, query))\n  {\n    /*\n      Use the raw output from SHOW CREATE TABLE if\n       information_schema query fails.\n     */\n    row= mysql_fetch_row(table_res);\n    fprintf(sql_file, \"/*!50001 %s */;\\n\", row[1]);\n    check_io(sql_file);\n    mysql_free_result(table_res);\n  }\n  else\n  {\n    char *ptr;\n    ulong *lengths;\n    char search_buf[256], replace_buf[256];\n    ulong search_len, replace_len;\n    DYNAMIC_STRING ds_view;\n\n    /* Save the result of SHOW CREATE TABLE in ds_view */\n    row= mysql_fetch_row(table_res);\n    lengths= mysql_fetch_lengths(table_res);\n    init_dynamic_string_checked(&ds_view, row[1], lengths[1] + 1, 1024);\n    mysql_free_result(table_res);\n\n    /* Get the result from \"select ... information_schema\" */\n    if (!(table_res= mysql_store_result(mysql)) ||\n        !(row= mysql_fetch_row(table_res)))\n    {\n      if (table_res)\n        mysql_free_result(table_res);\n      dynstr_free(&ds_view);\n      DB_error(mysql, \"when trying to save the result of SHOW CREATE TABLE in ds_view.\");\n      DBUG_RETURN(1);\n    }\n\n    lengths= mysql_fetch_lengths(table_res);\n\n    /*\n      \"WITH %s CHECK OPTION\" is available from 5.0.2\n      Surround it with !50002 comments\n    */\n    if (strcmp(row[0], \"NONE\"))\n    {\n\n      ptr= search_buf;\n      search_len= (ulong)(strxmov(ptr, \"WITH \", row[0],\n                                  \" CHECK OPTION\", NullS) - ptr);\n      ptr= replace_buf;\n      replace_len=(ulong)(strxmov(ptr, \"*/\\n/*!50002 WITH \", row[0],\n                                  \" CHECK OPTION\", NullS) - ptr);\n      replace(&ds_view, search_buf, search_len, replace_buf, replace_len);\n    }\n\n    /*\n      \"DEFINER=%s SQL SECURITY %s\" is available from 5.0.13\n      Surround it with !50013 comments\n    */\n    {\n      size_t     user_name_len;\n      char       user_name_str[USERNAME_LENGTH + 1];\n      char       quoted_user_name_str[USERNAME_LENGTH * 2 + 3];\n      size_t     host_name_len;\n      char       host_name_str[HOSTNAME_LENGTH + 1];\n      char       quoted_host_name_str[HOSTNAME_LENGTH * 2 + 3];\n\n      parse_user(row[1], lengths[1], user_name_str, &user_name_len,\n                 host_name_str, &host_name_len);\n\n      ptr= search_buf;\n      search_len=\n        (ulong)(strxmov(ptr, \"DEFINER=\",\n                        quote_name(user_name_str, quoted_user_name_str, FALSE),\n                        \"@\",\n                        quote_name(host_name_str, quoted_host_name_str, FALSE),\n                        \" SQL SECURITY \", row[2], NullS) - ptr);\n      ptr= replace_buf;\n      replace_len=\n        (ulong)(strxmov(ptr, \"*/\\n/*!50013 DEFINER=\",\n                        quote_name(user_name_str, quoted_user_name_str, FALSE),\n                        \"@\",\n                        quote_name(host_name_str, quoted_host_name_str, FALSE),\n                        \" SQL SECURITY \", row[2],\n                        \" */\\n/*!50001\", NullS) - ptr);\n      replace(&ds_view, search_buf, search_len, replace_buf, replace_len);\n    }\n\n    /* Dump view structure to file */\n\n    fprintf(sql_file,\n            \"/*!50001 SET @saved_cs_client          = @@character_set_client */;\\n\"\n            \"/*!50001 SET @saved_cs_results         = @@character_set_results */;\\n\"\n            \"/*!50001 SET @saved_col_connection     = @@collation_connection */;\\n\"\n            \"/*!50001 SET character_set_client      = %s */;\\n\"\n            \"/*!50001 SET character_set_results     = %s */;\\n\"\n            \"/*!50001 SET collation_connection      = %s */;\\n\"\n            \"/*!50001 %s */;\\n\"\n            \"/*!50001 SET character_set_client      = @saved_cs_client */;\\n\"\n            \"/*!50001 SET character_set_results     = @saved_cs_results */;\\n\"\n            \"/*!50001 SET collation_connection      = @saved_col_connection */;\\n\",\n            (const char *) row[3],\n            (const char *) row[3],\n            (const char *) row[4],\n            (const char *) ds_view.str);\n\n    check_io(sql_file);\n    mysql_free_result(table_res);\n    dynstr_free(&ds_view);\n  }\n\n  if (switch_character_set_results(mysql, default_charset))\n    DBUG_RETURN(1);\n\n  /* If a separate .sql file was opened, close it now */\n  if (sql_file != md_result_file)\n  {\n    fputs(\"\\n\", sql_file);\n    write_footer(sql_file);\n    my_fclose(sql_file, MYF(MY_WME));\n  }\n  DBUG_RETURN(0);\n}", "target": 1, "cwe": [], "project": "server", "commit_id": "5a43a31ee81bc181eeb5ef2bf0704befa6e0594d", "hash": 124211253597303410432152016730475404466, "size": 199, "message": "mysqldump: comments and identifiers with new lines\n\ndon't let identifiers with new lines to break a comment", "idx": 231}
{"func": "inline TfLiteTensor* GetTemporary(TfLiteContext* context,\n                                  const TfLiteNode* node, int index) {\n  return &context->tensors[node->temporaries->data[index]];\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tensorflow", "commit_id": "46d5b0852528ddfd614ded79bccc75589f801bd9", "hash": 239483298842527642878234526112271389719, "size": 4, "message": "[tflite] Test for `kTfLiteOptionalTensor` in `GetInput`.\n\n`GetInput`, `GetVariableInput` and `GetOutput` all fail to check for the case where `node->inputs->data[index]` is the special `kTfLiteOptionalTensor` value (-1) which then causes `context->tensors[node->inputs->data[index]]` to read from invalid memory location.\n\nThis fix makes `GetInput` and related return `nullptr` in those cases, asking the caller to check for `nullptr`. This is better than having `GetOptionalInputTensor` and `GetOptionalOutputTensor` (does not exist but could be added) as using the patched `GetInput` in error would be caught by a sanitizer test in the default optimized build (due to the `-fsanitize=null` option).\n\nPiperOrigin-RevId: 332512190\nChange-Id: Iabca54da2f2de02b6ece3c38b54f76d4277d689e", "idx": 232}
{"func": "static int esp_init_authenc(struct xfrm_state *x)\n{\n\tstruct crypto_aead *aead;\n\tstruct crypto_authenc_key_param *param;\n\tstruct rtattr *rta;\n\tchar *key;\n\tchar *p;\n\tchar authenc_name[CRYPTO_MAX_ALG_NAME];\n\tunsigned int keylen;\n\tint err;\n\n\terr = -EINVAL;\n\tif (!x->ealg)\n\t\tgoto error;\n\n\terr = -ENAMETOOLONG;\n\n\tif ((x->props.flags & XFRM_STATE_ESN)) {\n\t\tif (snprintf(authenc_name, CRYPTO_MAX_ALG_NAME,\n\t\t\t     \"%s%sauthencesn(%s,%s)%s\",\n\t\t\t     x->geniv ?: \"\", x->geniv ? \"(\" : \"\",\n\t\t\t     x->aalg ? x->aalg->alg_name : \"digest_null\",\n\t\t\t     x->ealg->alg_name,\n\t\t\t     x->geniv ? \")\" : \"\") >= CRYPTO_MAX_ALG_NAME)\n\t\t\tgoto error;\n\t} else {\n\t\tif (snprintf(authenc_name, CRYPTO_MAX_ALG_NAME,\n\t\t\t     \"%s%sauthenc(%s,%s)%s\",\n\t\t\t     x->geniv ?: \"\", x->geniv ? \"(\" : \"\",\n\t\t\t     x->aalg ? x->aalg->alg_name : \"digest_null\",\n\t\t\t     x->ealg->alg_name,\n\t\t\t     x->geniv ? \")\" : \"\") >= CRYPTO_MAX_ALG_NAME)\n\t\t\tgoto error;\n\t}\n\n\taead = crypto_alloc_aead(authenc_name, 0, 0);\n\terr = PTR_ERR(aead);\n\tif (IS_ERR(aead))\n\t\tgoto error;\n\n\tx->data = aead;\n\n\tkeylen = (x->aalg ? (x->aalg->alg_key_len + 7) / 8 : 0) +\n\t\t (x->ealg->alg_key_len + 7) / 8 + RTA_SPACE(sizeof(*param));\n\terr = -ENOMEM;\n\tkey = kmalloc(keylen, GFP_KERNEL);\n\tif (!key)\n\t\tgoto error;\n\n\tp = key;\n\trta = (void *)p;\n\trta->rta_type = CRYPTO_AUTHENC_KEYA_PARAM;\n\trta->rta_len = RTA_LENGTH(sizeof(*param));\n\tparam = RTA_DATA(rta);\n\tp += RTA_SPACE(sizeof(*param));\n\n\tif (x->aalg) {\n\t\tstruct xfrm_algo_desc *aalg_desc;\n\n\t\tmemcpy(p, x->aalg->alg_key, (x->aalg->alg_key_len + 7) / 8);\n\t\tp += (x->aalg->alg_key_len + 7) / 8;\n\n\t\taalg_desc = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\n\t\tBUG_ON(!aalg_desc);\n\n\t\terr = -EINVAL;\n\t\tif (aalg_desc->uinfo.auth.icv_fullbits / 8 !=\n\t\t    crypto_aead_authsize(aead)) {\n\t\t\tpr_info(\"ESP: %s digestsize %u != %hu\\n\",\n\t\t\t\tx->aalg->alg_name,\n\t\t\t\tcrypto_aead_authsize(aead),\n\t\t\t\taalg_desc->uinfo.auth.icv_fullbits / 8);\n\t\t\tgoto free_key;\n\t\t}\n\n\t\terr = crypto_aead_setauthsize(\n\t\t\taead, x->aalg->alg_trunc_len / 8);\n\t\tif (err)\n\t\t\tgoto free_key;\n\t}\n\n\tparam->enckeylen = cpu_to_be32((x->ealg->alg_key_len + 7) / 8);\n\tmemcpy(p, x->ealg->alg_key, (x->ealg->alg_key_len + 7) / 8);\n\n\terr = crypto_aead_setkey(aead, key, keylen);\n\nfree_key:\n\tkfree(key);\n\nerror:\n\treturn err;\n}", "target": 0, "cwe": ["CWE-787"], "project": "linux", "commit_id": "ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "hash": 220926508253526611011761714183021132953, "size": 92, "message": "esp: Fix possible buffer overflow in ESP transformation\n\nThe maximum message size that can be send is bigger than\nthe  maximum site that skb_page_frag_refill can allocate.\nSo it is possible to write beyond the allocated buffer.\n\nFix this by doing a fallback to COW in that case.\n\nv2:\n\nAvoid get get_order() costs as suggested by Linus Torvalds.\n\nFixes: cac2661c53f3 (\"esp4: Avoid skb_cow_data whenever possible\")\nFixes: 03e2a30f6a27 (\"esp6: Avoid skb_cow_data whenever possible\")\nReported-by: valis <sec@valis.email>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "idx": 233}
{"func": "  Item** addr(uint i) { return arg_count ? args + i : NULL; }", "target": 0, "cwe": ["CWE-617"], "project": "server", "commit_id": "807945f2eb5fa22e6f233cc17b85a2e141efe2c8", "hash": 43121497305033483395902343229233877215, "size": 1, "message": "MDEV-26402: A SEGV in Item_field::used_tables/update_depend_map_for_order...\n\nWhen doing condition pushdown from HAVING into WHERE,\nItem_equal::create_pushable_equalities() calls\nitem->set_extraction_flag(IMMUTABLE_FL) for constant items.\nThen, Item::cleanup_excluding_immutables_processor() checks for this flag\nto see if it should call item->cleanup() or leave the item as-is.\n\nThe failure happens when a constant item has a non-constant one inside it,\nlike:\n\n   (tbl.col=0 AND impossible_cond)\n\nitem->walk(cleanup_excluding_immutables_processor) works in a bottom-up\nway so it\n1. will call Item_func_eq(tbl.col=0)->cleanup()\n2. will not call Item_cond_and->cleanup (as the AND is constant)\n\nThis creates an item tree where a fixed Item has an un-fixed Item inside\nit which eventually causes an assertion failure.\n\nFixed by introducing this rule: instead of just calling\n\n  item->set_extraction_flag(IMMUTABLE_FL);\n\nwe call Item::walk() to set the flag for all sub-items of the item.", "idx": 234}
{"func": "__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}", "target": 0, "cwe": ["CWE-119"], "project": "linux", "commit_id": "1be7107fbe18eed3e319a6c3e83c78254b693acb", "hash": 20113987283230552260989941116230190687, "size": 7, "message": "mm: larger stack guard gap, between vmas\n\nStack guard page is a useful feature to reduce a risk of stack smashing\ninto a different mapping. We have been using a single page gap which\nis sufficient to prevent having stack adjacent to a different mapping.\nBut this seems to be insufficient in the light of the stack usage in\nuserspace. E.g. glibc uses as large as 64kB alloca() in many commonly\nused functions. Others use constructs liks gid_t buffer[NGROUPS_MAX]\nwhich is 256kB or stack strings with MAX_ARG_STRLEN.\n\nThis will become especially dangerous for suid binaries and the default\nno limit for the stack size limit because those applications can be\ntricked to consume a large portion of the stack and a single glibc call\ncould jump over the guard page. These attacks are not theoretical,\nunfortunatelly.\n\nMake those attacks less probable by increasing the stack guard gap\nto 1MB (on systems with 4k pages; but make it depend on the page size\nbecause systems with larger base pages might cap stack allocations in\nthe PAGE_SIZE units) which should cover larger alloca() and VLA stack\nallocations. It is obviously not a full fix because the problem is\nsomehow inherent, but it should reduce attack space a lot.\n\nOne could argue that the gap size should be configurable from userspace,\nbut that can be done later when somebody finds that the new 1MB is wrong\nfor some special case applications.  For now, add a kernel command line\noption (stack_guard_gap) to specify the stack gap size (in page units).\n\nImplementation wise, first delete all the old code for stack guard page:\nbecause although we could get away with accounting one extra page in a\nstack vma, accounting a larger gap can break userspace - case in point,\na program run with \"ulimit -S -v 20000\" failed when the 1MB gap was\ncounted for RLIMIT_AS; similar problems could come with RLIMIT_MLOCK\nand strict non-overcommit mode.\n\nInstead of keeping gap inside the stack vma, maintain the stack guard\ngap as a gap between vmas: using vm_start_gap() in place of vm_start\n(or vm_end_gap() in place of vm_end if VM_GROWSUP) in just those few\nplaces which need to respect the gap - mainly arch_get_unmapped_area(),\nand and the vma tree's subtree_gap support for that.\n\nOriginal-patch-by: Oleg Nesterov <oleg@redhat.com>\nOriginal-patch-by: Michal Hocko <mhocko@suse.com>\nSigned-off-by: Hugh Dickins <hughd@google.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nTested-by: Helge Deller <deller@gmx.de> # parisc\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 235}
{"func": "  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {\n    if (!time) {\n      return {};\n    }\n\n    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -\n                                                                start_time_monotonic_);\n  }", "target": 0, "cwe": ["CWE-416"], "project": "envoy", "commit_id": "fe7c69c248f4fe5a9080c7ccb35275b5218bb5ab", "hash": 20427596462520448423972439700983071698, "size": 8, "message": "internal redirect: fix a lifetime bug (#785)\n\nSigned-off-by: Alyssa Wilk <alyssar@chromium.org>\nSigned-off-by: Matt Klein <mklein@lyft.com>\nSigned-off-by: Pradeep Rao <pcrao@google.com>", "idx": 236}
{"func": "int pci_piix3_xen_ide_unplug(DeviceState *dev)\n{\n    PCIIDEState *pci_ide;\n    DriveInfo *di;\n    int i;\n    IDEDevice *idedev;\n\n    pci_ide = PCI_IDE(dev);\n\n    for (i = 0; i < 4; i++) {\n        di = drive_get_by_index(IF_IDE, i);\n        if (di != NULL && !di->media_cd) {\n            BlockBackend *blk = blk_by_legacy_dinfo(di);\n            DeviceState *ds = blk_get_attached_dev(blk);\n            if (ds) {\n                blk_detach_dev(blk, ds);\n            }\n            pci_ide->bus[di->bus].ifs[di->unit].blk = NULL;\n            if (!(i % 2)) {\n                idedev = pci_ide->bus[di->bus].master;\n            } else {\n                idedev = pci_ide->bus[di->bus].slave;\n            }\n            idedev->conf.blk = NULL;\n            blk_unref(blk);\n        }\n    }\n    qdev_reset_all(DEVICE(dev));\n    return 0;\n}", "target": 0, "cwe": [], "project": "qemu", "commit_id": "6cd387833d05e8ad31829d97e474dc420625aed9", "hash": 50331044897901214962169569223095064355, "size": 30, "message": "Fix release_drive on unplugged devices (pci_piix3_xen_ide_unplug)\n\npci_piix3_xen_ide_unplug should completely unhook the unplugged\nIDEDevice from the corresponding BlockBackend, otherwise the next call\nto release_drive will try to detach the drive again.\n\nSuggested-by: Kevin Wolf <kwolf@redhat.com>\nSigned-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>", "idx": 237}
{"func": "resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,\n                                      const struct lys_node *first_node, int abs_path)\n{\n    int dep1, dep2;\n    const struct lys_node *node;\n\n    if (!op_node) {\n        /* leafref pointing to a different module */\n        if (local_mod != lys_node_module(first_node)) {\n            return 1;\n        }\n    } else if (lys_parent(op_node)) {\n        /* inner operation (notif/action) */\n        if (abs_path) {\n            return 1;\n        } else {\n            /* compare depth of both nodes */\n            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));\n            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));\n            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {\n                return 1;\n            }\n        }\n    } else {\n        /* top-level operation (notif/rpc) */\n        if (op_node != first_node) {\n            return 1;\n        }\n    }\n\n    return 0;\n}", "target": 0, "cwe": ["CWE-119"], "project": "libyang", "commit_id": "32fb4993bc8bb49e93e84016af3c10ea53964be5", "hash": 150118524747710880459615699681778129121, "size": 32, "message": "schema tree BUGFIX do not check features while still resolving schema\n\nFixes #723", "idx": 238}
{"func": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\t/* Allow zero-byte read from NULL, regardless of pointer type */\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\n\t/* Only allow fixed-offset stack reads */\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n\t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n\t\t\tregno, tn_buf);\n\t}\n\toff = regs[regno].off + regs[regno].var_off.value;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "linux", "commit_id": "ea25f914dc164c8d56b36147ecc86bc65f83c469", "hash": 90478386754737835442152434891241640702, "size": 58, "message": "bpf: fix missing error return in check_stack_boundary()\n\nPrevent indirect stack accesses at non-constant addresses, which would\npermit reading and corrupting spilled pointers.\n\nFixes: f1174f77b50c (\"bpf/verifier: rework value tracking\")\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>", "idx": 239}
{"func": "static int rtnl_group_changelink(struct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev;\n\tint err;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\terr = do_setlink(dev, ifm, tb, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "project": "net", "commit_id": "90f62cf30a78721641e08737bda787552428061e", "hash": 27312865428109439726522011955916168900, "size": 17, "message": "net: Use netlink_ns_capable to verify the permisions of netlink messages\n\nIt is possible by passing a netlink socket to a more privileged\nexecutable and then to fool that executable into writing to the socket\ndata that happens to be valid netlink message to do something that\nprivileged executable did not intend to do.\n\nTo keep this from happening replace bare capable and ns_capable calls\nwith netlink_capable, netlink_net_calls and netlink_ns_capable calls.\nWhich act the same as the previous calls except they verify that the\nopener of the socket had the desired permissions as well.\n\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 240}
{"func": "static MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    adjoin,\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    imageListLength,\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric,\n    predictor;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=(HOST_FILLORDER == FILLORDER_LSB2MSB) ? LSBEndian : MSBEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;\n    }\n  mode=endian_type == LSBEndian ? \"wl\" : \"wb\";\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    mode=endian_type == LSBEndian ? \"wl8\" : \"wb8\";\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      return(MagickFalse);\n    }\n  (void) DeleteImageProfile(image,\"tiff:37724\");\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  adjoin=image_info->adjoin;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType,exception);\n        (void) SetImageDepth(image,1,exception);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          {\n            quantum_info=DestroyQuantumInfo(quantum_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        option=GetImageOption(image_info,\"quantum:polarity\");\n        if (option == (const char *) NULL)\n          SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n#if defined(COMPRESSION_ZSTD)\n      case ZstdCompression:\n      {\n        compress_tag=COMPRESSION_ZSTD;\n        break;\n      }\n#endif\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              (void) SetImageDepth(image,8,exception);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) ||\n        (compress_tag == COMPRESSION_CCITTFAX4))\n      {\n         if ((photometric != PHOTOMETRIC_MINISWHITE) &&\n             (photometric != PHOTOMETRIC_MINISBLACK))\n          {\n            compress_tag=COMPRESSION_NONE;\n            endian=FILLORDER_MSB2LSB;\n          }\n      }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    predictor=0;\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            if (image->colorspace == YCbCrColorspace)\n              {\n                const char\n                  *sampling_factor;\n\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                sampling_factor=(const char *) NULL;\n                value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n                if (value != (char *) NULL)\n                  {\n                    sampling_factor=value;\n                    if (image->debug != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Input sampling-factors=%s\",sampling_factor);\n                  }\n                if (image_info->sampling_factor != (char *) NULL)\n                  sampling_factor=image_info->sampling_factor;\n                if (sampling_factor != (const char *) NULL)\n                  {\n                    flags=ParseGeometry(sampling_factor,&geometry_info);\n                    if ((flags & SigmaValue) == 0)\n                      geometry_info.sigma=geometry_info.rho;\n                    (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                      geometry_info.rho,(uint16) geometry_info.sigma);\n                  }\n                }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        break;\n      }\n#if defined(WEBP_SUPPORT) && defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_WEBP_LEVEL,image_info->quality);\n        if (image_info->quality >= 100)\n          (void) TIFFSetField(tiff,TIFFTAG_WEBP_LOSSLESS,1);\n        break;\n      }\n#endif\n#if defined(ZSTD_SUPPORT) && defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_SEPARATED) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          predictor=PREDICTOR_HORIZONTAL;\n        (void) TIFFSetField(tiff,TIFFTAG_ZSTD_LEVEL,22*image_info->quality/\n          100.0);\n        break;\n      }\n#endif\n      default:\n        break;\n    }\n    option=GetImageOption(image_info,\"tiff:predictor\");\n    if (option != (const char * ) NULL)\n      predictor=(uint16) strtol(option,(char **) NULL,10);\n    if (predictor != 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,predictor);\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    option=GetImageOption(image_info,\"tiff:write-layers\");\n    if (IsStringTrue(option) != MagickFalse)\n      {\n        (void) TIFFWritePhotoshopLayers(image,image_info,endian_type,exception);\n        adjoin=MagickFalse;\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (adjoin != MagickFalse) && (imageListLength > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            imageListLength);\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    else\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) imageListLength;\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,adjoin,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          {\n            if (red != (uint16 *) NULL)\n              red=(uint16 *) RelinquishMagickMemory(red);\n            if (green != (uint16 *) NULL)\n              green=(uint16 *) RelinquishMagickMemory(green);\n            if (blue != (uint16 *) NULL)\n              blue=(uint16 *) RelinquishMagickMemory(blue);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) memset(red,0,65536*sizeof(*red));\n        (void) memset(green,0,65536*sizeof(*green));\n        (void) memset(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}", "target": 1, "cwe": ["CWE-125"], "project": "ImageMagick", "commit_id": "f06925afeabe3f01045db33d5a33d55e64378ebc", "hash": 308553004386214867640328749929192981673, "size": 903, "message": "https://github.com/ImageMagick/ImageMagick/issues/1555", "idx": 241}
{"func": "wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)\n{\n\twStream* s;\n\n\tif (!response)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_file_contents_response(s, response);\n\treturn s;\n}", "target": 0, "cwe": ["CWE-125"], "project": "FreeRDP", "commit_id": "b73143cf7ee5fe4cdabcbf56908aa15d8a883821", "hash": 67244558931113018275091978990244193302, "size": 15, "message": "Fixed oob read in cliprdr_read_format_list", "idx": 242}
{"func": "static void generateWithRecursiveQuery(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The recursive SELECT to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  SrcList *pSrc = p->pSrc;      /* The FROM clause of the recursive query */\n  int nCol = p->pEList->nExpr;  /* Number of columns in the recursive table */\n  Vdbe *v = pParse->pVdbe;      /* The prepared statement under construction */\n  Select *pSetup = p->pPrior;   /* The setup query */\n  int addrTop;                  /* Top of the loop */\n  int addrCont, addrBreak;      /* CONTINUE and BREAK addresses */\n  int iCurrent = 0;             /* The Current table */\n  int regCurrent;               /* Register holding Current table */\n  int iQueue;                   /* The Queue table */\n  int iDistinct = 0;            /* To ensure unique results if UNION */\n  int eDest = SRT_Fifo;         /* How to write to Queue */\n  SelectDest destQueue;         /* SelectDest targetting the Queue table */\n  int i;                        /* Loop counter */\n  int rc;                       /* Result code */\n  ExprList *pOrderBy;           /* The ORDER BY clause */\n  Expr *pLimit;                 /* Saved LIMIT and OFFSET */\n  int regLimit, regOffset;      /* Registers used by LIMIT and OFFSET */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( p->pWin ){\n    sqlite3ErrorMsg(pParse, \"cannot use window functions in recursive queries\");\n    return;\n  }\n#endif\n\n  /* Obtain authorization to do a recursive query */\n  if( sqlite3AuthCheck(pParse, SQLITE_RECURSIVE, 0, 0, 0) ) return;\n\n  /* Process the LIMIT and OFFSET clauses, if they exist */\n  addrBreak = sqlite3VdbeMakeLabel(pParse);\n  p->nSelectRow = 320;  /* 4 billion rows */\n  computeLimitRegisters(pParse, p, addrBreak);\n  pLimit = p->pLimit;\n  regLimit = p->iLimit;\n  regOffset = p->iOffset;\n  p->pLimit = 0;\n  p->iLimit = p->iOffset = 0;\n  pOrderBy = p->pOrderBy;\n\n  /* Locate the cursor number of the Current table */\n  for(i=0; ALWAYS(i<pSrc->nSrc); i++){\n    if( pSrc->a[i].fg.isRecursive ){\n      iCurrent = pSrc->a[i].iCursor;\n      break;\n    }\n  }\n\n  /* Allocate cursors numbers for Queue and Distinct.  The cursor number for\n  ** the Distinct table must be exactly one greater than Queue in order\n  ** for the SRT_DistFifo and SRT_DistQueue destinations to work. */\n  iQueue = pParse->nTab++;\n  if( p->op==TK_UNION ){\n    eDest = pOrderBy ? SRT_DistQueue : SRT_DistFifo;\n    iDistinct = pParse->nTab++;\n  }else{\n    eDest = pOrderBy ? SRT_Queue : SRT_Fifo;\n  }\n  sqlite3SelectDestInit(&destQueue, eDest, iQueue);\n\n  /* Allocate cursors for Current, Queue, and Distinct. */\n  regCurrent = ++pParse->nMem;\n  sqlite3VdbeAddOp3(v, OP_OpenPseudo, iCurrent, regCurrent, nCol);\n  if( pOrderBy ){\n    KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);\n    sqlite3VdbeAddOp4(v, OP_OpenEphemeral, iQueue, pOrderBy->nExpr+2, 0,\n                      (char*)pKeyInfo, P4_KEYINFO);\n    destQueue.pOrderBy = pOrderBy;\n  }else{\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iQueue, nCol);\n  }\n  VdbeComment((v, \"Queue table\"));\n  if( iDistinct ){\n    p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iDistinct, 0);\n    p->selFlags |= SF_UsesEphemeral;\n  }\n\n  /* Detach the ORDER BY clause from the compound SELECT */\n  p->pOrderBy = 0;\n\n  /* Store the results of the setup-query in Queue. */\n  pSetup->pNext = 0;\n  ExplainQueryPlan((pParse, 1, \"SETUP\"));\n  rc = sqlite3Select(pParse, pSetup, &destQueue);\n  pSetup->pNext = p;\n  if( rc ) goto end_of_recursive_query;\n\n  /* Find the next row in the Queue and output that row */\n  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iQueue, addrBreak); VdbeCoverage(v);\n\n  /* Transfer the next row in Queue over to Current */\n  sqlite3VdbeAddOp1(v, OP_NullRow, iCurrent); /* To reset column cache */\n  if( pOrderBy ){\n    sqlite3VdbeAddOp3(v, OP_Column, iQueue, pOrderBy->nExpr+1, regCurrent);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_RowData, iQueue, regCurrent);\n  }\n  sqlite3VdbeAddOp1(v, OP_Delete, iQueue);\n\n  /* Output the single row in Current */\n  addrCont = sqlite3VdbeMakeLabel(pParse);\n  codeOffset(v, regOffset, addrCont);\n  selectInnerLoop(pParse, p, iCurrent,\n      0, 0, pDest, addrCont, addrBreak);\n  if( regLimit ){\n    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, regLimit, addrBreak);\n    VdbeCoverage(v);\n  }\n  sqlite3VdbeResolveLabel(v, addrCont);\n\n  /* Execute the recursive SELECT taking the single row in Current as\n  ** the value for the recursive-table. Store the results in the Queue.\n  */\n  if( p->selFlags & SF_Aggregate ){\n    sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");\n  }else{\n    p->pPrior = 0;\n    ExplainQueryPlan((pParse, 1, \"RECURSIVE STEP\"));\n    sqlite3Select(pParse, p, &destQueue);\n    assert( p->pPrior==0 );\n    p->pPrior = pSetup;\n  }\n\n  /* Keep running the loop until the Queue is empty */\n  sqlite3VdbeGoto(v, addrTop);\n  sqlite3VdbeResolveLabel(v, addrBreak);\n\nend_of_recursive_query:\n  sqlite3ExprListDelete(pParse->db, p->pOrderBy);\n  p->pOrderBy = pOrderBy;\n  p->pLimit = pLimit;\n  return;\n}", "target": 0, "cwe": ["CWE-20"], "project": "sqlite", "commit_id": "e59c562b3f6894f84c715772c4b116d7b5c01348", "hash": 218890749155864288673860499110508464101, "size": 137, "message": "Fix a crash that could occur if a sub-select that uses both DISTINCT and window functions also used an ORDER BY that is the same as its select list.\n\nFossilOrigin-Name: bcdd66c1691955c697f3d756c2b035acfe98f6aad72e90b0021bab6e9023b3ba", "idx": 243}
{"func": "TEST(RoleParsingTest, BuildRoleBSON) {\n    RoleGraph graph;\n    RoleName roleA(\"roleA\", \"dbA\");\n    RoleName roleB(\"roleB\", \"dbB\");\n    RoleName roleC(\"roleC\", \"dbC\");\n    ActionSet actions;\n    actions.addAction(ActionType::find);\n    actions.addAction(ActionType::insert);\n\n    ASSERT_OK(graph.createRole(roleA));\n    ASSERT_OK(graph.createRole(roleB));\n    ASSERT_OK(graph.createRole(roleC));\n\n    ASSERT_OK(graph.addRoleToRole(roleA, roleC));\n    ASSERT_OK(graph.addRoleToRole(roleA, roleB));\n    ASSERT_OK(graph.addRoleToRole(roleB, roleC));\n\n    ASSERT_OK(graph.addPrivilegeToRole(\n        roleA, Privilege(ResourcePattern::forAnyNormalResource(), actions)));\n    ASSERT_OK(graph.addPrivilegeToRole(\n        roleB, Privilege(ResourcePattern::forExactNamespace(NamespaceString(\"dbB.foo\")), actions)));\n    ASSERT_OK(\n        graph.addPrivilegeToRole(roleC, Privilege(ResourcePattern::forClusterResource(), actions)));\n    ASSERT_OK(graph.recomputePrivilegeData());\n\n\n    // Role A\n    mutablebson::Document doc;\n    ASSERT_OK(AuthorizationManager::getBSONForRole(&graph, roleA, doc.root()));\n    BSONObj roleDoc = doc.getObject();\n\n    ASSERT_EQUALS(\"dbA.roleA\", roleDoc[\"_id\"].String());\n    ASSERT_EQUALS(\"roleA\", roleDoc[\"role\"].String());\n    ASSERT_EQUALS(\"dbA\", roleDoc[\"db\"].String());\n\n    vector<BSONElement> privs = roleDoc[\"privileges\"].Array();\n    ASSERT_EQUALS(1U, privs.size());\n    ASSERT_EQUALS(\"\", privs[0].Obj()[\"resource\"].Obj()[\"db\"].String());\n    ASSERT_EQUALS(\"\", privs[0].Obj()[\"resource\"].Obj()[\"collection\"].String());\n    ASSERT(privs[0].Obj()[\"resource\"].Obj()[\"cluster\"].eoo());\n    vector<BSONElement> actionElements = privs[0].Obj()[\"actions\"].Array();\n    ASSERT_EQUALS(2U, actionElements.size());\n    ASSERT_EQUALS(\"find\", actionElements[0].String());\n    ASSERT_EQUALS(\"insert\", actionElements[1].String());\n\n    vector<BSONElement> roles = roleDoc[\"roles\"].Array();\n    ASSERT_EQUALS(2U, roles.size());\n    ASSERT_EQUALS(\"roleC\", roles[0].Obj()[\"role\"].String());\n    ASSERT_EQUALS(\"dbC\", roles[0].Obj()[\"db\"].String());\n    ASSERT_EQUALS(\"roleB\", roles[1].Obj()[\"role\"].String());\n    ASSERT_EQUALS(\"dbB\", roles[1].Obj()[\"db\"].String());\n\n    // Role B\n    doc.reset();\n    ASSERT_OK(AuthorizationManager::getBSONForRole(&graph, roleB, doc.root()));\n    roleDoc = doc.getObject();\n\n    ASSERT_EQUALS(\"dbB.roleB\", roleDoc[\"_id\"].String());\n    ASSERT_EQUALS(\"roleB\", roleDoc[\"role\"].String());\n    ASSERT_EQUALS(\"dbB\", roleDoc[\"db\"].String());\n\n    privs = roleDoc[\"privileges\"].Array();\n    ASSERT_EQUALS(1U, privs.size());\n    ASSERT_EQUALS(\"dbB\", privs[0].Obj()[\"resource\"].Obj()[\"db\"].String());\n    ASSERT_EQUALS(\"foo\", privs[0].Obj()[\"resource\"].Obj()[\"collection\"].String());\n    ASSERT(privs[0].Obj()[\"resource\"].Obj()[\"cluster\"].eoo());\n    actionElements = privs[0].Obj()[\"actions\"].Array();\n    ASSERT_EQUALS(2U, actionElements.size());\n    ASSERT_EQUALS(\"find\", actionElements[0].String());\n    ASSERT_EQUALS(\"insert\", actionElements[1].String());\n\n    roles = roleDoc[\"roles\"].Array();\n    ASSERT_EQUALS(1U, roles.size());\n    ASSERT_EQUALS(\"roleC\", roles[0].Obj()[\"role\"].String());\n    ASSERT_EQUALS(\"dbC\", roles[0].Obj()[\"db\"].String());\n\n    // Role C\n    doc.reset();\n    ASSERT_OK(AuthorizationManager::getBSONForRole(&graph, roleC, doc.root()));\n    roleDoc = doc.getObject();\n\n    ASSERT_EQUALS(\"dbC.roleC\", roleDoc[\"_id\"].String());\n    ASSERT_EQUALS(\"roleC\", roleDoc[\"role\"].String());\n    ASSERT_EQUALS(\"dbC\", roleDoc[\"db\"].String());\n\n    privs = roleDoc[\"privileges\"].Array();\n    ASSERT_EQUALS(1U, privs.size());\n    ASSERT(privs[0].Obj()[\"resource\"].Obj()[\"cluster\"].Bool());\n    ASSERT(privs[0].Obj()[\"resource\"].Obj()[\"db\"].eoo());\n    ASSERT(privs[0].Obj()[\"resource\"].Obj()[\"collection\"].eoo());\n    actionElements = privs[0].Obj()[\"actions\"].Array();\n    ASSERT_EQUALS(2U, actionElements.size());\n    ASSERT_EQUALS(\"find\", actionElements[0].String());\n    ASSERT_EQUALS(\"insert\", actionElements[1].String());\n\n    roles = roleDoc[\"roles\"].Array();\n    ASSERT_EQUALS(0U, roles.size());\n}", "target": 1, "cwe": ["CWE-863"], "project": "mongo", "commit_id": "a93cfd354467981c9cf944a4ada748d0226fdfb0", "hash": 58180322929180817023150354550118242505, "size": 98, "message": "SERVER-45472 Ensure RoleGraph can serialize authentication restrictions to BSON\n\n(cherry picked from commit 521e56b407ac72bc69a97a24d1253f51a5b6e81b)\n(cherry picked from commit a10d0a22d5d009d27664967181042933ec1bef36)\n(cherry picked from commit fb87cc88ecb5d300f14cda7bc238d7d5132118f5)", "idx": 244}
{"func": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1, "cwe": ["CWE-119", "CWE-772", "CWE-401"], "project": "krb5", "commit_id": "83ed75feba32e46f736fcce0d96a0445f29b96c2", "hash": 274817004337032409486517793448301815352, "size": 50, "message": "Fix leaks in kadmin server stubs [CVE-2015-8631]\n\nIn each kadmind server stub, initialize the client_name and\nserver_name variables, and release them in the cleanup handler.  Many\nof the stubs will otherwise leak the client and server name if\nkrb5_unparse_name() fails.  Also make sure to free the prime_arg\nvariables in rename_principal_2_svc(), or we can leak the first one if\nunparsing the second one fails.  Discovered by Simo Sorce.\n\nCVE-2015-8631:\n\nIn all versions of MIT krb5, an authenticated attacker can cause\nkadmind to leak memory by supplying a null principal name in a request\nwhich uses one.  Repeating these requests will eventually cause\nkadmind to exhaust all available memory.\n\n    CVSSv2 Vector: AV:N/AC:L/Au:S/C:N/I:N/A:C/E:POC/RL:OF/RC:C\n\nticket: 8343 (new)\ntarget_version: 1.14-next\ntarget_version: 1.13-next\ntags: pullup", "idx": 245}
{"func": "static unsigned long long decodeLZ4S(FILE* finput, FILE* foutput)\n{\n    unsigned long long filesize = 0;\n    char* in_buff;\n    char* out_buff, *out_start, *out_end;\n    unsigned char descriptor[LZ4S_MAXHEADERSIZE];\n    size_t nbReadBytes;\n    int decodedBytes=0;\n    unsigned int maxBlockSize;\n    size_t sizeCheck;\n    int blockChecksumFlag, streamChecksumFlag, blockIndependenceFlag;\n    void* streamChecksumState=NULL;\n    int (*decompressionFunction)(void* ctx, const char* src, char* dst, int cSize, int maxOSize) = LZ4_decompress_safe_continue;\n    LZ4_streamDecode_t ctx;\n\n    // init\n    memset(&ctx, 0, sizeof(ctx));\n    (void)blockIndependenceFlag;\n\n    // Decode stream descriptor\n    nbReadBytes = fread(descriptor, 1, 3, finput);\n    if (nbReadBytes != 3) EXM_THROW(61, \"Unreadable header\");\n    {\n        int version       = (descriptor[0] >> 6) & _2BITS;\n        int streamSize    = (descriptor[0] >> 3) & _1BIT;\n        int reserved1     = (descriptor[0] >> 1) & _1BIT;\n        int dictionary    = (descriptor[0] >> 0) & _1BIT;\n\n        int reserved2     = (descriptor[1] >> 7) & _1BIT;\n        int blockSizeId   = (descriptor[1] >> 4) & _3BITS;\n        int reserved3     = (descriptor[1] >> 0) & _4BITS;\n        int checkBits     = (descriptor[2] >> 0) & _8BITS;\n        int checkBits_xxh32;\n\n        blockIndependenceFlag=(descriptor[0] >> 5) & _1BIT;\n        blockChecksumFlag = (descriptor[0] >> 4) & _1BIT;\n        streamChecksumFlag= (descriptor[0] >> 2) & _1BIT;\n\n        if (version != 1)       EXM_THROW(62, \"Wrong version number\");\n        if (streamSize == 1)    EXM_THROW(64, \"Does not support stream size\");\n        if (reserved1 != 0)     EXM_THROW(65, \"Wrong value for reserved bits\");\n        if (dictionary == 1)    EXM_THROW(66, \"Does not support dictionary\");\n        if (reserved2 != 0)     EXM_THROW(67, \"Wrong value for reserved bits\");\n        if (blockSizeId < 4)    EXM_THROW(68, \"Unsupported block size\");\n        if (reserved3 != 0)     EXM_THROW(67, \"Wrong value for reserved bits\");\n        maxBlockSize = LZ4S_GetBlockSize_FromBlockId(blockSizeId);\n        // Checkbits verification\n        descriptor[1] &= 0xF0;\n        checkBits_xxh32 = XXH32(descriptor, 2, LZ4S_CHECKSUM_SEED);\n        checkBits_xxh32 = LZ4S_GetCheckBits_FromXXH(checkBits_xxh32);\n        if (checkBits != checkBits_xxh32) EXM_THROW(69, \"Stream descriptor error detected\");\n    }\n\n    // Allocate Memory\n    {\n        size_t outBuffSize = maxBlockSize + 64 KB;\n        if (outBuffSize < MIN_STREAM_BUFSIZE) outBuffSize = MIN_STREAM_BUFSIZE;\n        in_buff  = (char*)malloc(maxBlockSize);\n        out_buff = (char*)malloc(outBuffSize);\n        out_start = out_buff;\n        out_end = out_start + outBuffSize;\n        if (!in_buff || !out_buff) EXM_THROW(70, \"Allocation error : not enough memory\");\n        if (streamChecksumFlag) streamChecksumState = XXH32_init(LZ4S_CHECKSUM_SEED);\n    }\n\n    // Main Loop\n    while (1)\n    {\n        unsigned int blockSize, uncompressedFlag;\n\n        // Block Size\n        nbReadBytes = fread(&blockSize, 1, 4, finput);\n        if( nbReadBytes != 4 ) EXM_THROW(71, \"Read error : cannot read next block size\");\n        if (blockSize == LZ4S_EOS) break;          // End of Stream Mark : stream is completed\n        blockSize = LITTLE_ENDIAN_32(blockSize);   // Convert to little endian\n        uncompressedFlag = blockSize >> 31;\n        blockSize &= 0x7FFFFFFF;\n        if (blockSize > maxBlockSize) EXM_THROW(72, \"Error : invalid block size\");\n\n        // Read Block\n        nbReadBytes = fread(in_buff, 1, blockSize, finput);\n        if( nbReadBytes != blockSize ) EXM_THROW(73, \"Read error : cannot read data block\" );\n\n        // Check Block\n        if (blockChecksumFlag)\n        {\n            unsigned int checksum = XXH32(in_buff, blockSize, LZ4S_CHECKSUM_SEED);\n            unsigned int readChecksum;\n            sizeCheck = fread(&readChecksum, 1, 4, finput);\n            if( sizeCheck != 4 ) EXM_THROW(74, \"Read error : cannot read next block size\");\n            readChecksum = LITTLE_ENDIAN_32(readChecksum);   // Convert to little endian\n            if (checksum != readChecksum) EXM_THROW(75, \"Error : invalid block checksum detected\");\n        }\n\n        if (uncompressedFlag)\n        {\n            // Write uncompressed Block\n            sizeCheck = fwrite(in_buff, 1, blockSize, foutput);\n            if (sizeCheck != (size_t)blockSize) EXM_THROW(76, \"Write error : cannot write data block\");\n            filesize += blockSize;\n            if (streamChecksumFlag) XXH32_update(streamChecksumState, in_buff, blockSize);\n            if (!independentBlocks)\n            {\n                // handle dictionary for streaming\n                memcpy(in_buff + blockSize - 64 KB, out_buff, 64 KB);\n                LZ4_setDictDecode(&ctx, out_buff, 64 KB);\n                out_start = out_buff + 64 KB;\n            }\n        }\n        else\n        {\n            // Decode Block\n            if (out_start + maxBlockSize > out_end) out_start = out_buff;\n            decodedBytes = decompressionFunction(&ctx, in_buff, out_start, blockSize, maxBlockSize);\n            if (decodedBytes < 0) EXM_THROW(77, \"Decoding Failed ! Corrupted input detected !\");\n            filesize += decodedBytes;\n            if (streamChecksumFlag) XXH32_update(streamChecksumState, out_start, decodedBytes);\n\n            // Write Block\n            sizeCheck = fwrite(out_start, 1, decodedBytes, foutput);\n            if (sizeCheck != (size_t)decodedBytes) EXM_THROW(78, \"Write error : cannot write decoded block\\n\");\n            out_start += decodedBytes;\n        }\n\n    }\n\n    // Stream Checksum\n    if (streamChecksumFlag)\n    {\n        unsigned int checksum = XXH32_digest(streamChecksumState);\n        unsigned int readChecksum;\n        sizeCheck = fread(&readChecksum, 1, 4, finput);\n        if (sizeCheck != 4) EXM_THROW(74, \"Read error : cannot read stream checksum\");\n        readChecksum = LITTLE_ENDIAN_32(readChecksum);   // Convert to little endian\n        if (checksum != readChecksum) EXM_THROW(79, \"Error : invalid stream checksum detected\");\n    }\n\n    // Free\n    free(in_buff);\n    free(out_buff);\n\n    return filesize;\n}", "target": 1, "cwe": ["CWE-20"], "project": "lz4", "commit_id": "da5373197e84ee49d75b8334d4510689731d6e90", "hash": 106949657820258566140333235733654325479, "size": 143, "message": "Fixed : issue 52 (reported by Ludwig Strigeus)", "idx": 246}
{"func": "static int rtnetlink_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t int type, u32 pid, u32 seq, u32 change, \n\t\t\t\t unsigned int flags)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev_get_flags(dev);\n\tr->ifi_change = change;\n\n\tRTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);\n\n\tif (1) {\n\t\tu32 txqlen = dev->tx_queue_len;\n\t\tRTA_PUT(skb, IFLA_TXQLEN, sizeof(txqlen), &txqlen);\n\t}\n\n\tif (1) {\n\t\tu32 weight = dev->weight;\n\t\tRTA_PUT(skb, IFLA_WEIGHT, sizeof(weight), &weight);\n\t}\n\n\tif (1) {\n\t\tstruct rtnl_link_ifmap map = {\n\t\t\t.mem_start   = dev->mem_start,\n\t\t\t.mem_end     = dev->mem_end,\n\t\t\t.base_addr   = dev->base_addr,\n\t\t\t.irq         = dev->irq,\n\t\t\t.dma         = dev->dma,\n\t\t\t.port        = dev->if_port,\n\t\t};\n\t\tRTA_PUT(skb, IFLA_MAP, sizeof(map), &map);\n\t}\n\n\tif (dev->addr_len) {\n\t\tRTA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);\n\t\tRTA_PUT(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast);\n\t}\n\n\tif (1) {\n\t\tu32 mtu = dev->mtu;\n\t\tRTA_PUT(skb, IFLA_MTU, sizeof(mtu), &mtu);\n\t}\n\n\tif (dev->ifindex != dev->iflink) {\n\t\tu32 iflink = dev->iflink;\n\t\tRTA_PUT(skb, IFLA_LINK, sizeof(iflink), &iflink);\n\t}\n\n\tif (dev->qdisc_sleeping)\n\t\tRTA_PUT(skb, IFLA_QDISC,\n\t\t\tstrlen(dev->qdisc_sleeping->ops->id) + 1,\n\t\t\tdev->qdisc_sleeping->ops->id);\n\t\n\tif (dev->master) {\n\t\tu32 master = dev->master->ifindex;\n\t\tRTA_PUT(skb, IFLA_MASTER, sizeof(master), &master);\n\t}\n\n\tif (dev->get_stats) {\n\t\tunsigned long *stats = (unsigned long*)dev->get_stats(dev);\n\t\tif (stats) {\n\t\t\tstruct rtattr  *a;\n\t\t\t__u32\t       *s;\n\t\t\tint\t\ti;\n\t\t\tint\t\tn = sizeof(struct rtnl_link_stats)/4;\n\n\t\t\ta = __RTA_PUT(skb, IFLA_STATS, n*4);\n\t\t\ts = RTA_DATA(a);\n\t\t\tfor (i=0; i<n; i++)\n\t\t\t\ts[i] = stats[i];\n\t\t}\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "project": "linux-2.6", "commit_id": "9ef1d4c7c7aca1cd436612b6ca785b726ffb8ed8", "hash": 76076890665048112793227967865792712660, "size": 87, "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 247}
{"func": "Http::Stream::buildRangeHeader(HttpReply *rep)\n{\n    HttpHeader *hdr = rep ? &rep->header : nullptr;\n    const char *range_err = nullptr;\n    HttpRequest *request = http->request;\n    assert(request->range);\n    /* check if we still want to do ranges */\n    int64_t roffLimit = request->getRangeOffsetLimit();\n    auto contentRange = rep ? rep->contentRange() : nullptr;\n\n    if (!rep)\n        range_err = \"no [parse-able] reply\";\n    else if ((rep->sline.status() != Http::scOkay) && (rep->sline.status() != Http::scPartialContent))\n        range_err = \"wrong status code\";\n    else if (rep->sline.status() == Http::scPartialContent)\n        range_err = \"too complex response\"; // probably contains what the client needs\n    else if (rep->sline.status() != Http::scOkay)\n        range_err = \"wrong status code\";\n    else if (hdr->has(Http::HdrType::CONTENT_RANGE)) {\n        Must(!contentRange); // this is a 200, not 206 response\n        range_err = \"meaningless response\"; // the status code or the header is wrong\n    }\n    else if (rep->content_length < 0)\n        range_err = \"unknown length\";\n    else if (rep->content_length != http->storeEntry()->mem().baseReply().content_length)\n        range_err = \"INCONSISTENT length\";  /* a bug? */\n\n    /* hits only - upstream CachePeer determines correct behaviour on misses,\n     * and client_side_reply determines hits candidates\n     */\n    else if (http->logType.isTcpHit() &&\n             http->request->header.has(Http::HdrType::IF_RANGE) &&\n             !clientIfRangeMatch(http, rep))\n        range_err = \"If-Range match failed\";\n\n    else if (!http->request->range->canonize(rep))\n        range_err = \"canonization failed\";\n    else if (http->request->range->isComplex())\n        range_err = \"too complex range header\";\n    else if (!http->logType.isTcpHit() && http->request->range->offsetLimitExceeded(roffLimit))\n        range_err = \"range outside range_offset_limit\";\n\n    /* get rid of our range specs on error */\n    if (range_err) {\n        /* XXX We do this here because we need canonisation etc. However, this current\n         * code will lead to incorrect store offset requests - the store will have the\n         * offset data, but we won't be requesting it.\n         * So, we can either re-request, or generate an error\n         */\n        http->request->ignoreRange(range_err);\n    } else {\n        /* XXX: TODO: Review, this unconditional set may be wrong. */\n        rep->sline.set(rep->sline.version, Http::scPartialContent);\n        // web server responded with a valid, but unexpected range.\n        // will (try-to) forward as-is.\n        //TODO: we should cope with multirange request/responses\n        // TODO: review, since rep->content_range is always nil here.\n        bool replyMatchRequest = contentRange != nullptr ?\n                                 request->range->contains(contentRange->spec) :\n                                 true;\n        const int spec_count = http->request->range->specs.size();\n        int64_t actual_clen = -1;\n\n        debugs(33, 3, \"range spec count: \" << spec_count <<\n               \" virgin clen: \" << rep->content_length);\n        assert(spec_count > 0);\n        /* append appropriate header(s) */\n        if (spec_count == 1) {\n            if (!replyMatchRequest) {\n                hdr->putContRange(contentRange);\n                actual_clen = rep->content_length;\n                //http->range_iter.pos = rep->content_range->spec.begin();\n                (*http->range_iter.pos)->offset = contentRange->spec.offset;\n                (*http->range_iter.pos)->length = contentRange->spec.length;\n\n            } else {\n                HttpHdrRange::iterator pos = http->request->range->begin();\n                assert(*pos);\n                /* append Content-Range */\n\n                if (!contentRange) {\n                    /* No content range, so this was a full object we are\n                     * sending parts of.\n                     */\n                    httpHeaderAddContRange(hdr, **pos, rep->content_length);\n                }\n\n                /* set new Content-Length to the actual number of bytes\n                 * transmitted in the message-body */\n                actual_clen = (*pos)->length;\n            }\n        } else {\n            /* multipart! */\n            /* generate boundary string */\n            http->range_iter.boundary = http->rangeBoundaryStr();\n            /* delete old Content-Type, add ours */\n            hdr->delById(Http::HdrType::CONTENT_TYPE);\n            httpHeaderPutStrf(hdr, Http::HdrType::CONTENT_TYPE,\n                              \"multipart/byteranges; boundary=\\\"\" SQUIDSTRINGPH \"\\\"\",\n                              SQUIDSTRINGPRINT(http->range_iter.boundary));\n            /* Content-Length is not required in multipart responses\n             * but it is always nice to have one */\n            actual_clen = http->mRangeCLen();\n\n            /* http->out needs to start where we want data at */\n            http->out.offset = http->range_iter.currentSpec()->offset;\n        }\n\n        /* replace Content-Length header */\n        assert(actual_clen >= 0);\n        hdr->delById(Http::HdrType::CONTENT_LENGTH);\n        hdr->putInt64(Http::HdrType::CONTENT_LENGTH, actual_clen);\n        debugs(33, 3, \"actual content length: \" << actual_clen);\n\n        /* And start the range iter off */\n        http->range_iter.updateSpec();\n    }\n}", "target": 1, "cwe": ["CWE-116"], "project": "squid", "commit_id": "7024fb734a59409889e53df2257b3fc817809fb4", "hash": 218442151567123971005165938909910991547, "size": 118, "message": "Handle more Range requests (#790)\n\nAlso removed some effectively unused code.", "idx": 248}
{"func": "    static CImg<T> get_load_dcraw_external(const char *const filename) {\n      return CImg<T>().load_dcraw_external(filename);\n    }", "target": 0, "cwe": ["CWE-770"], "project": "cimg", "commit_id": "619cb58dd90b4e03ac68286c70ed98acbefd1c90", "hash": 202349848987980666647550214089121118452, "size": 3, "message": "CImg<>::load_bmp() and CImg<>::load_pandore(): Check that dimensions encoded in file does not exceed file size.", "idx": 249}
{"func": "static void kvm_set_mmio_data(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);\n\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(&p->data, vcpu->mmio_data, 8);\n\tp->state = STATE_IORESP_READY;\n}", "target": 1, "cwe": [], "project": "linux", "commit_id": "f78146b0f9230765c6315b2e14f56112513389ad", "hash": 319830191342842529452718727066063517929, "size": 8, "message": "KVM: Fix page-crossing MMIO\n\nMMIO that are split across a page boundary are currently broken - the\ncode does not expect to be aborted by the exit to userspace for the\nfirst MMIO fragment.\n\nThis patch fixes the problem by generalizing the current code for handling\n16-byte MMIOs to handle a number of \"fragments\", and changes the MMIO\ncode to create those fragments.\n\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>", "idx": 250}
{"func": "static void jas_icclut8_destroy(jas_iccattrval_t *attrval)\n{\n\tjas_icclut8_t *lut8 = &attrval->data.lut8;\n\tif (lut8->clut)\n\t\tjas_free(lut8->clut);\n\tif (lut8->intabs)\n\t\tjas_free(lut8->intabs);\n\tif (lut8->intabsbuf)\n\t\tjas_free(lut8->intabsbuf);\n\tif (lut8->outtabs)\n\t\tjas_free(lut8->outtabs);\n\tif (lut8->outtabsbuf)\n\t\tjas_free(lut8->outtabsbuf);\n}", "target": 1, "cwe": [], "project": "jasper", "commit_id": "4bb93a6c49da7c1b6ad2acb60b18954a6547c637", "hash": 69199513729603911759693214062297758878, "size": 14, "message": "Add fixes for CVE-2014-8137.", "idx": 251}
{"func": "xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {\n    xmlDumpElementDecl(buf, elem);\n}", "target": 0, "cwe": [], "project": "libxml2", "commit_id": "932cc9896ab41475d4aa429c27d9afd175959d74", "hash": 46677028051573852628670701995392512463, "size": 3, "message": "Fix buffer size checks in xmlSnprintfElementContent\n\nxmlSnprintfElementContent failed to correctly check the available\nbuffer space in two locations.\n\nFixes bug 781333 (CVE-2017-9047) and bug 781701 (CVE-2017-9048).\n\nThanks to Marcel Böhme and Thuan Pham for the report.", "idx": 252}
{"func": "static void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n    /* position in x and y of tile */\n    OPJ_UINT32 p, q;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n    q = p_tileno / p_cp->tw;\n\n    /* find extent of tile */\n    *p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx),\n                         (OPJ_INT32)p_image->x0);\n    *p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx),\n                         (OPJ_INT32)p_image->x1);\n    *p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy),\n                         (OPJ_INT32)p_image->y0);\n    *p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy),\n                         (OPJ_INT32)p_image->y1);\n\n    /* max precision is 0 (can only grow) */\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts */\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            /* take the minimum size for dx for each comp and resolution */\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            /* various calculations of extents */\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            /* update precision */\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}", "target": 1, "cwe": ["CWE-190"], "project": "openjpeg", "commit_id": "c58df149900df862806d0e892859b41115875845", "hash": 217874498574185466048058471804311896792, "size": 116, "message": "[OPENJP2] change the way to compute *p_tx0, *p_tx1, *p_ty0, *p_ty1 in function\nopj_get_encoding_parameters\n\nSigned-off-by: Young_X <YangX92@hotmail.com>", "idx": 253}
{"func": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n#if !defined(HAVE_VLA)\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n#else\n\tjpc_fix_t splitbuf[bufsize * numcols];\n#endif\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n#if !defined(HAVE_VLA)\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n#endif\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = (parity) ? hstartcol : (numrows - hstartcol);\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n#if !defined(HAVE_VLA)\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n#endif\n\n}", "target": 1, "cwe": ["CWE-119"], "project": "jasper", "commit_id": "0d64bde2b3ba7e1450710d540136a8ce4199ef30", "hash": 28448826090202570261525388462256818321, "size": 88, "message": "CVE-2014-8158", "idx": 254}
{"func": "static void io_mem_init(void)\n{\n    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);\n    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,\n                          NULL, UINT64_MAX);\n\n    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,\n     * which can be called without the iothread mutex.\n     */\n    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,\n                          NULL, UINT64_MAX);\n    memory_region_clear_global_locking(&io_mem_notdirty);\n\n    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,\n                          NULL, UINT64_MAX);\n}", "target": 0, "cwe": ["CWE-125"], "project": "qemu", "commit_id": "04bf2526ce87f21b32c9acba1c5518708c243ad0", "hash": 55564384481553079969086082069959469076, "size": 16, "message": "exec: use qemu_ram_ptr_length to access guest ram\n\nWhen accessing guest's ram block during DMA operation, use\n'qemu_ram_ptr_length' to get ram block pointer. It ensures\nthat DMA operation of given length is possible; And avoids\nany OOB memory access situations.\n\nReported-by: Alex <broscutamaker@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <20170712123840.29328-1-ppandit@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 255}
{"func": "process_copy_pass ()\n{\n  dynamic_string input_name;\t/* Name of file from stdin.  */\n  dynamic_string output_name;\t/* Name of new file.  */\n  size_t dirname_len;\t\t/* Length of `directory_name'.  */\n  int res;\t\t\t/* Result of functions.  */\n  char *slash;\t\t\t/* For moving past slashes in input name.  */\n  struct stat in_file_stat;\t/* Stat record for input file.  */\n  struct stat out_file_stat;\t/* Stat record for output file.  */\n  int in_file_des;\t\t/* Input file descriptor.  */\n  int out_file_des;\t\t/* Output file descriptor.  */\n  int existing_dir;\t\t/* True if file is a dir & already exists.  */\n\n  newdir_umask = umask (0);     /* Reset umask to preserve modes of\n\t\t\t\t   created files  */\n\n  /* Initialize the copy pass.  */\n  ds_init (&input_name, 128);\n  \n  dirname_len = strlen (directory_name);\n  if (change_directory_option && !ISSLASH (directory_name[0]))\n    {\n      char *pwd = xgetcwd ();\n\n      dirname_len += strlen (pwd) + 1;\n      ds_init (&output_name, dirname_len + 2);\n      strcpy (output_name.ds_string, pwd);\n      strcat (output_name.ds_string, \"/\");\n      strcat (output_name.ds_string, directory_name);\n    }\n  else\n    {\n      ds_init (&output_name, dirname_len + 2);\n      strcpy (output_name.ds_string, directory_name);\n    }\n  output_name.ds_string[dirname_len] = '/';\n  output_is_seekable = true;\n\n  change_dir ();\n  \n  /* Copy files with names read from stdin.  */\n  while (ds_fgetstr (stdin, &input_name, name_end) != NULL)\n    {\n      int link_res = -1;\n\n      /* Check for blank line and ignore it if found.  */\n      if (input_name.ds_string[0] == '\\0')\n\t{\n\t  error (0, 0, _(\"blank line ignored\"));\n\t  continue;\n\t}\n\n      /* Check for current directory and ignore it if found.  */\n      if (input_name.ds_string[0] == '.'\n\t  && (input_name.ds_string[1] == '\\0'\n\t      || (input_name.ds_string[1] == '/'\n\t\t  && input_name.ds_string[2] == '\\0')))\n\tcontinue;\n\n      if ((*xstat) (input_name.ds_string, &in_file_stat) < 0)\n\t{\n\t  stat_error (input_name.ds_string);\n\t  continue;\n\t}\n\n      /* Make the name of the new file.  */\n      for (slash = input_name.ds_string; *slash == '/'; ++slash)\n\t;\n      ds_resize (&output_name, dirname_len + strlen (slash) + 2);\n      strcpy (output_name.ds_string + dirname_len + 1, slash);\n\n      existing_dir = false;\n      if (lstat (output_name.ds_string, &out_file_stat) == 0)\n\t{\n\t  if (S_ISDIR (out_file_stat.st_mode)\n\t      && S_ISDIR (in_file_stat.st_mode))\n\t    {\n\t      /* If there is already a directory there that\n\t\t we are trying to create, don't complain about it.  */\n\t      existing_dir = true;\n\t    }\n\t  else if (!unconditional_flag\n\t\t   && in_file_stat.st_mtime <= out_file_stat.st_mtime)\n\t    {\n\t      error (0, 0, _(\"%s not created: newer or same age version exists\"),\n\t\t     output_name.ds_string);\n\t      continue;\t\t/* Go to the next file.  */\n\t    }\n\t  else if (S_ISDIR (out_file_stat.st_mode)\n\t\t\t? rmdir (output_name.ds_string)\n\t\t\t: unlink (output_name.ds_string))\n\t    {\n\t      error (0, errno, _(\"cannot remove current %s\"),\n\t\t     output_name.ds_string);\n\t      continue;\t\t/* Go to the next file.  */\n\t    }\n\t}\n\n      /* Do the real copy or link.  */\n      if (S_ISREG (in_file_stat.st_mode))\n\t{\n\t  /* Can the current file be linked to a another file?\n\t     Set link_name to the original file name.  */\n\t  if (link_flag)\n\t    /* User said to link it if possible.  Try and link to\n\t       the original copy.  If that fails we'll still try\n\t       and link to a copy we've already made.  */\n\t    link_res = link_to_name (output_name.ds_string, \n\t\t\t\t     input_name.ds_string);\n\t  if ( (link_res < 0) && (in_file_stat.st_nlink > 1) )\n\t    link_res = link_to_maj_min_ino (output_name.ds_string, \n\t\t\t\tmajor (in_file_stat.st_dev), \n\t\t\t\tminor (in_file_stat.st_dev), \n\t\t\t\tin_file_stat.st_ino);\n\n\t  /* If the file was not linked, copy contents of file.  */\n\t  if (link_res < 0)\n\t    {\n\t      in_file_des = open (input_name.ds_string,\n\t\t\t\t  O_RDONLY | O_BINARY, 0);\n\t      if (in_file_des < 0)\n\t\t{\n\t\t  open_error (input_name.ds_string);\n\t\t  continue;\n\t\t}\n\t      out_file_des = open (output_name.ds_string,\n\t\t\t\t   O_CREAT | O_WRONLY | O_BINARY, 0600);\n\t      if (out_file_des < 0 && create_dir_flag)\n\t\t{\n\t\t  create_all_directories (output_name.ds_string);\n\t\t  out_file_des = open (output_name.ds_string,\n\t\t\t\t       O_CREAT | O_WRONLY | O_BINARY, 0600);\n\t\t}\n\t      if (out_file_des < 0)\n\t\t{\n\t\t  open_error (output_name.ds_string);\n\t\t  close (in_file_des);\n\t\t  continue;\n\t\t}\n\n\t      copy_files_disk_to_disk (in_file_des, out_file_des, in_file_stat.st_size, input_name.ds_string);\n\t      disk_empty_output_buffer (out_file_des, true);\n\t      \n\t      set_copypass_perms (out_file_des,\n\t\t\t\t  output_name.ds_string, &in_file_stat);\n\n\t      if (reset_time_flag)\n                {\n                  set_file_times (in_file_des,\n\t\t\t\t  input_name.ds_string,\n                                  in_file_stat.st_atime,\n                                  in_file_stat.st_mtime);\n                  set_file_times (out_file_des,\n\t\t\t\t  output_name.ds_string,\n                                  in_file_stat.st_atime,\n                                  in_file_stat.st_mtime);\n\t        } \n\n\t      if (close (in_file_des) < 0)\n\t\tclose_error (input_name.ds_string);\n\n\t      if (close (out_file_des) < 0)\n\t\tclose_error (output_name.ds_string);\n\n\t      warn_if_file_changed(input_name.ds_string, in_file_stat.st_size,\n                                   in_file_stat.st_mtime);\n\t    }\n\t}\n      else if (S_ISDIR (in_file_stat.st_mode))\n\t{\n\t  struct cpio_file_stat file_stat;\n\t  \n\t  stat_to_cpio (&file_stat, &in_file_stat);\n\t  file_stat.c_name = output_name.ds_string;\n\t  cpio_create_dir (&file_stat, existing_dir);\n\t}\n      else if (S_ISCHR (in_file_stat.st_mode) ||\n\t       S_ISBLK (in_file_stat.st_mode) ||\n#ifdef S_ISFIFO\n\t       S_ISFIFO (in_file_stat.st_mode) ||\n#endif\n#ifdef S_ISSOCK\n\t       S_ISSOCK (in_file_stat.st_mode) ||\n#endif\n\t       0)\n\t{\n\t  /* Can the current file be linked to a another file?\n\t     Set link_name to the original file name.  */\n\t  if (link_flag)\n\t    /* User said to link it if possible.  */\n\t    link_res = link_to_name (output_name.ds_string, \n\t\t\t\t     input_name.ds_string);\n\t  if ( (link_res < 0) && (in_file_stat.st_nlink > 1) )\n\t    link_res = link_to_maj_min_ino (output_name.ds_string, \n\t\t\tmajor (in_file_stat.st_dev),\n\t\t\tminor (in_file_stat.st_dev),\n\t\t\tin_file_stat.st_ino);\n\n\t  if (link_res < 0)\n\t    {\n\t      res = mknod (output_name.ds_string, in_file_stat.st_mode,\n\t\t\t   in_file_stat.st_rdev);\n\t      if (res < 0 && create_dir_flag)\n\t\t{\n\t\t  create_all_directories (output_name.ds_string);\n\t\t  res = mknod (output_name.ds_string, in_file_stat.st_mode,\n\t\t\t       in_file_stat.st_rdev);\n\t\t}\n\t      if (res < 0)\n\t\t{\n\t\t  mknod_error (output_name.ds_string);\n\t\t  continue;\n\t\t}\n\t      set_copypass_perms (-1, output_name.ds_string, &in_file_stat);\n\t    }\n\t}\n\n#ifdef S_ISLNK\n      else if (S_ISLNK (in_file_stat.st_mode))\n\t{\n\t  char *link_name;\n\t  int link_size;\n\t  link_name = (char *) xmalloc ((unsigned int) in_file_stat.st_size + 1);\n\n\t  link_size = readlink (input_name.ds_string, link_name,\n\t\t\t        in_file_stat.st_size);\n\t  if (link_size < 0)\n\t    {\n\t      readlink_error (input_name.ds_string);\n\t      free (link_name);\n\t      continue;\n\t    }\n\t  link_name[link_size] = '\\0';\n\n\t  res = UMASKED_SYMLINK (link_name, output_name.ds_string,\n\t\t\t\t in_file_stat.st_mode);\n\t  if (res < 0 && create_dir_flag)\n\t    {\n\t      create_all_directories (output_name.ds_string);\n\t      res = UMASKED_SYMLINK (link_name, output_name.ds_string,\n\t\t\t\t     in_file_stat.st_mode);\n\t    }\n\t  if (res < 0)\n\t    {\n\t      symlink_error (output_name.ds_string, link_name);\n\t      free (link_name);\n\t      continue;\n\t    }\n\n\t  /* Set the attributes of the new link.  */\n\t  if (!no_chown_flag)\n            {\n              uid_t uid = set_owner_flag ? set_owner : in_file_stat.st_uid;\n              gid_t gid = set_group_flag ? set_group : in_file_stat.st_gid;\n\t      if ((lchown (output_name.ds_string, uid, gid) < 0)\n\t\t  && errno != EPERM)\n\t        chown_error_details (output_name.ds_string, uid, gid);\n            }\n\t  free (link_name);\n\t}\n#endif\n      else\n\t{\n\t  error (0, 0, _(\"%s: unknown file type\"), input_name.ds_string);\n\t}\n\n      if (verbose_flag)\n\tfprintf (stderr, \"%s\\n\", output_name.ds_string);\n      if (dot_flag)\n\tfputc ('.', stderr);\n    }\n\n  if (dot_flag)\n    fputc ('\\n', stderr);\n\n  apply_delayed_set_stat ();\n  \n  if (!quiet_flag)\n    {\n      size_t blocks = (output_bytes + io_block_size - 1) / io_block_size;\n      fprintf (stderr,\n\t       ngettext (\"%lu block\\n\", \"%lu blocks\\n\",\n\t\t\t (unsigned long) blocks),\n\t       (unsigned long) blocks);\n    }\n}", "target": 1, "cwe": ["CWE-190"], "project": "cpio", "commit_id": "dd96882877721703e19272fe25034560b794061b", "hash": 322839294556470847614635303516413940931, "size": 286, "message": "Rewrite dynamic string support.\n\n* src/dstring.c (ds_init): Take a single argument.\n(ds_free): New function.\n(ds_resize): Take a single argument.  Use x2nrealloc to expand\nthe storage.\n(ds_reset,ds_append,ds_concat,ds_endswith): New function.\n(ds_fgetstr): Rewrite.  In particular, this fixes integer overflow.\n* src/dstring.h (dynamic_string): Keep both the allocated length\n(ds_size) and index of the next free byte in the string (ds_idx).\n(ds_init,ds_resize): Change signature.\n(ds_len): New macro.\n(ds_free,ds_reset,ds_append,ds_concat,ds_endswith): New protos.\n* src/copyin.c: Use new ds_ functions.\n* src/copyout.c: Likewise.\n* src/copypass.c: Likewise.\n* src/util.c: Likewise.", "idx": 256}
{"func": "static int smapsGetSharedDirty(unsigned long addr) {\n    int ret, in_mapping = 0, val = -1;\n    unsigned long from, to;\n    char buf[64];\n    FILE *f;\n\n    f = fopen(\"/proc/self/smaps\", \"r\");\n    if (!f) return -1;\n\n    while (1) {\n        if (!fgets(buf, sizeof(buf), f))\n            break;\n\n        ret = sscanf(buf, \"%lx-%lx\", &from, &to);\n        if (ret == 2)\n            in_mapping = from <= addr && addr < to;\n\n        if (in_mapping && !memcmp(buf, \"Shared_Dirty:\", 13)) {\n            sscanf(buf, \"%*s %d\", &val);\n            /* If parsing fails, we remain with val == -1 */\n            break;\n        }\n    }\n\n    fclose(f);\n    return val;\n}", "target": 0, "cwe": ["CWE-770"], "project": "redis", "commit_id": "5674b0057ff2903d43eaff802017eddf37c360f8", "hash": 153660337552831289639696707252018669875, "size": 27, "message": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)", "idx": 257}
{"func": "hb_buffer_clear( HB_Buffer buffer )\n{\n  buffer->in_length = 0;\n  buffer->out_length = 0;\n  buffer->in_pos = 0;\n  buffer->out_pos = 0;\n  buffer->out_string = buffer->in_string;\n  buffer->separate_out = FALSE;\n  buffer->max_ligID = 0;\n}", "target": 1, "cwe": [], "project": "pango", "commit_id": "336bb3201096bdd0494d29926dd44e8cca8bed26", "hash": 136695699471913207061836837646363571846, "size": 10, "message": "[HB] Remove all references to the old code!", "idx": 258}
{"func": "_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)\n{\n\tDropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);\n\n\tCOPY_STRING_FIELD(tablespacename);\n\tCOPY_SCALAR_FIELD(missing_ok);\n\n\treturn newnode;\n}", "target": 0, "cwe": ["CWE-362"], "project": "postgres", "commit_id": "5f173040e324f6c2eebb90d86cf1b0cdb5890f0a", "hash": 78304605885883062935417209212715594754, "size": 9, "message": "Avoid repeated name lookups during table and index DDL.\n\nIf the name lookups come to different conclusions due to concurrent\nactivity, we might perform some parts of the DDL on a different table\nthan other parts.  At least in the case of CREATE INDEX, this can be\nused to cause the permissions checks to be performed against a\ndifferent table than the index creation, allowing for a privilege\nescalation attack.\n\nThis changes the calling convention for DefineIndex, CreateTrigger,\ntransformIndexStmt, transformAlterTableStmt, CheckIndexCompatible\n(in 9.2 and newer), and AlterTable (in 9.1 and older).  In addition,\nCheckRelationOwnership is removed in 9.2 and newer and the calling\nconvention is changed in older branches.  A field has also been added\nto the Constraint node (FkConstraint in 8.4).  Third-party code calling\nthese functions or using the Constraint node will require updating.\n\nReport by Andres Freund.  Patch by Robert Haas and Andres Freund,\nreviewed by Tom Lane.\n\nSecurity: CVE-2014-0062", "idx": 259}
{"func": "static RedCharDeviceWriteBuffer *vdagent_new_write_buffer(RedCharDeviceVDIPort *agent_dev,\n                                                          uint32_t type,\n                                                          size_t size,\n                                                          bool use_token)\n{\n    uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;\n\n    RedCharDeviceWriteBuffer *char_dev_buf;\n        char_dev_buf = agent_dev->write_buffer_get_server(total_msg_size,\n                                                          use_token);\n    if (!char_dev_buf) {\n        return NULL;  // no token was available\n    }\n\n    char_dev_buf->buf_used = total_msg_size;\n    VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;\n    internal_buf->chunk_header.port = VDP_SERVER_PORT;\n    internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;\n    internal_buf->header.protocol = VD_AGENT_PROTOCOL;\n    internal_buf->header.type = type;\n    internal_buf->header.opaque = 0;\n    internal_buf->header.size = size;\n\n    return char_dev_buf;\n}", "target": 0, "cwe": [], "project": "spice", "commit_id": "ca5bbc5692e052159bce1a75f55dc60b36078749", "hash": 171765590417837468202051071045373925828, "size": 25, "message": "With OpenSSL 1.1: Disable client-initiated renegotiation.\n\nFixes issue #49\nFixes BZ#1904459\n\nSigned-off-by: Julien Ropé <jrope@redhat.com>\nReported-by: BlackKD\nAcked-by: Frediano Ziglio <fziglio@redhat.com>", "idx": 260}
{"func": "int gfs2_quota_sync(struct super_block *sb, int type, int wait)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_quota_data **qda;\n\tunsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);\n\tunsigned int num_qd;\n\tunsigned int x;\n\tint error = 0;\n\n\tsdp->sd_quota_sync_gen++;\n\n\tqda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);\n\tif (!qda)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tnum_qd = 0;\n\n\t\tfor (;;) {\n\t\t\terror = qd_fish(sdp, qda + num_qd);\n\t\t\tif (error || !qda[num_qd])\n\t\t\t\tbreak;\n\t\t\tif (++num_qd == max_qd)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (num_qd) {\n\t\t\tif (!error)\n\t\t\t\terror = do_sync(num_qd, qda);\n\t\t\tif (!error)\n\t\t\t\tfor (x = 0; x < num_qd; x++)\n\t\t\t\t\tqda[x]->qd_sync_gen =\n\t\t\t\t\t\tsdp->sd_quota_sync_gen;\n\n\t\t\tfor (x = 0; x < num_qd; x++)\n\t\t\t\tqd_unlock(qda[x]);\n\t\t}\n\t} while (!error && num_qd == max_qd);\n\n\tkfree(qda);\n\n\treturn error;\n}", "target": 0, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "7e619bc3e6252dc746f64ac3b486e784822e9533", "hash": 132971824515393242901770614632160348387, "size": 43, "message": "GFS2: Fix writing to non-page aligned gfs2_quota structures\n\nThis is the upstream fix for this bug. This patch differs\nfrom the RHEL5 fix (Red Hat bz #555754) which simply writes to the 8-byte\nvalue field of the quota. In upstream quota code, we're\nrequired to write the entire quota (88 bytes) which can be split\nacross a page boundary. We check for such quotas, and read/write\nthe two parts from/to the corresponding pages holding these parts.\n\nWith this patch, I don't see the bug anymore using the reproducer\nin Red Hat bz 555754. I successfully ran a couple of simple tests/mounts/\numounts and it doesn't seem like this patch breaks anything else.\n\nSigned-off-by: Abhi Das <adas@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>", "idx": 261}
{"func": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\n\tmsg->msg_namelen = 0;\n\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\n\tkfree_skb(skb);\nend:\n\treturn err;\n}", "target": 1, "cwe": ["CWE-20", "CWE-269"], "project": "linux", "commit_id": "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c", "hash": 302854640964098992316211442818368848442, "size": 33, "message": "net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include/linux/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 262}
{"func": "static bool isIdIndex(const BSONObj& pattern) {\n    BSONObjIterator i(pattern);\n    BSONElement e = i.next();\n    //_id index must have form exactly {_id : 1} or {_id : -1}.\n    // Allows an index of form {_id : \"hashed\"} to exist but\n    // do not consider it to be the primary _id index\n    if (!(strcmp(e.fieldName(), \"_id\") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))\n        return false;\n    return i.next().eoo();\n}", "target": 0, "cwe": ["CWE-755"], "project": "mongo", "commit_id": "c8ced6df8f620daaa2e539f192f2eef356c63e9c", "hash": 36726084885115675200636544695593839254, "size": 10, "message": "SERVER-47773 Error consistently when tailable cursors and $near are used together", "idx": 263}
{"func": "use_socks (struct sockaddr_storage *addr)\n{\n  int mode;\n\n  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, \"tor-mode\", &mode) || !mode)\n    return 0;  /* Not in Tor mode.  */\n  else if (addr->ss_family == AF_INET6)\n    {\n      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;\n      const unsigned char *s;\n      int i;\n\n      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;\n      if (s[15] != 1)\n        return 1;   /* Last octet is not 1 - not the loopback address.  */\n      for (i=0; i < 15; i++, s++)\n        if (*s)\n          return 1; /* Non-zero octet found - not the loopback address.  */\n\n      return 0; /* This is the loopback address.  */\n    }\n  else if (addr->ss_family == AF_INET)\n    {\n      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;\n\n      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)\n        return 0; /* Loopback (127.0.0.0/8) */\n\n      return 1;\n    }\n  else\n    return 0;\n}", "target": 0, "cwe": ["CWE-352"], "project": "gnupg", "commit_id": "4a4bb874f63741026bd26264c43bb32b1099f060", "hash": 289322005577720856390412559596439722496, "size": 33, "message": "dirmngr: Avoid possible CSRF attacks via http redirects.\n\n* dirmngr/http.h (parsed_uri_s): Add fields off_host and off_path.\n(http_redir_info_t): New.\n* dirmngr/http.c (do_parse_uri): Set new fields.\n(same_host_p): New.\n(http_prepare_redirect): New.\n* dirmngr/t-http-basic.c: New test.\n* dirmngr/ks-engine-hkp.c (send_request): Use http_prepare_redirect\ninstead of the open code.\n* dirmngr/ks-engine-http.c (ks_http_fetch): Ditto.\n--\n\nWith this change a http query will not follow a redirect unless the\nLocation header gives the same host.  If the host is different only\nthe host and port is taken from the Location header and the original\npath and query parts are kept.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>\n(cherry picked from commit fa1b1eaa4241ff3f0634c8bdf8591cbc7c464144)", "idx": 264}
{"func": "static int imap_open_mailbox (CONTEXT* ctx)\n{\n  IMAP_DATA *idata;\n  IMAP_STATUS* status;\n  char buf[LONG_STRING];\n  char bufout[LONG_STRING*2];\n  int count = 0;\n  IMAP_MBOX mx, pmx;\n  int rc;\n  const char *condstore;\n\n  if (imap_parse_path (ctx->path, &mx))\n  {\n    mutt_error (_(\"%s is an invalid IMAP path\"), ctx->path);\n    return -1;\n  }\n\n  /* we require a connection which isn't currently in IMAP_SELECTED state */\n  if (!(idata = imap_conn_find (&(mx.account), MUTT_IMAP_CONN_NOSELECT)))\n    goto fail_noidata;\n\n  /* once again the context is new */\n  ctx->data = idata;\n\n  /* Clean up path and replace the one in the ctx */\n  imap_fix_path (idata, mx.mbox, buf, sizeof (buf));\n  if (!*buf)\n    strfcpy (buf, \"INBOX\", sizeof (buf));\n  FREE(&(idata->mailbox));\n  idata->mailbox = safe_strdup (buf);\n  imap_qualify_path (buf, sizeof (buf), &mx, idata->mailbox);\n\n  FREE (&(ctx->path));\n  FREE (&(ctx->realpath));\n  ctx->path = safe_strdup (buf);\n  ctx->realpath = safe_strdup (ctx->path);\n\n  idata->ctx = ctx;\n\n  /* clear mailbox status */\n  idata->status = 0;\n  memset (idata->ctx->rights, 0, sizeof (idata->ctx->rights));\n  idata->newMailCount = 0;\n  idata->max_msn = 0;\n\n  if (!ctx->quiet)\n    mutt_message (_(\"Selecting %s...\"), idata->mailbox);\n  imap_munge_mbox_name (idata, buf, sizeof(buf), idata->mailbox);\n\n  /* pipeline ACL test */\n  if (mutt_bit_isset (idata->capabilities, ACL))\n  {\n    snprintf (bufout, sizeof (bufout), \"MYRIGHTS %s\", buf);\n    imap_exec (idata, bufout, IMAP_CMD_QUEUE);\n  }\n  /* assume we have all rights if ACL is unavailable */\n  else\n  {\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_LOOKUP);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_READ);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_SEEN);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_WRITE);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_INSERT);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_POST);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_CREATE);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_DELETE);\n  }\n  /* pipeline the postponed count if possible */\n  pmx.mbox = NULL;\n  if (mx_is_imap (Postponed) && !imap_parse_path (Postponed, &pmx)\n      && mutt_account_match (&pmx.account, &mx.account))\n    imap_status (Postponed, 1);\n  FREE (&pmx.mbox);\n\n#if USE_HCACHE\n  if (mutt_bit_isset (idata->capabilities, CONDSTORE) &&\n      option (OPTIMAPCONDSTORE))\n    condstore = \" (CONDSTORE)\";\n  else\n#endif\n    condstore = \"\";\n\n  snprintf (bufout, sizeof (bufout), \"%s %s%s\",\n            ctx->readonly ? \"EXAMINE\" : \"SELECT\",\n            buf, condstore);\n\n  idata->state = IMAP_SELECTED;\n\n  imap_cmd_start (idata, bufout);\n\n  status = imap_mboxcache_get (idata, idata->mailbox, 1);\n\n  do\n  {\n    char *pc;\n\n    if ((rc = imap_cmd_step (idata)) != IMAP_CMD_CONTINUE)\n      break;\n\n    pc = idata->buf + 2;\n\n    /* Obtain list of available flags here, may be overridden by a\n     * PERMANENTFLAGS tag in the OK response */\n    if (ascii_strncasecmp (\"FLAGS\", pc, 5) == 0)\n    {\n      /* don't override PERMANENTFLAGS */\n      if (!idata->flags)\n      {\n\tdprint (3, (debugfile, \"Getting mailbox FLAGS\\n\"));\n\tif ((pc = imap_get_flags (&(idata->flags), pc)) == NULL)\n\t  goto fail;\n      }\n    }\n    /* PERMANENTFLAGS are massaged to look like FLAGS, then override FLAGS */\n    else if (ascii_strncasecmp (\"OK [PERMANENTFLAGS\", pc, 18) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox PERMANENTFLAGS\\n\"));\n      /* safe to call on NULL */\n      mutt_free_list (&(idata->flags));\n      /* skip \"OK [PERMANENT\" so syntax is the same as FLAGS */\n      pc += 13;\n      if ((pc = imap_get_flags (&(idata->flags), pc)) == NULL)\n\tgoto fail;\n    }\n    /* save UIDVALIDITY for the header cache */\n    else if (ascii_strncasecmp (\"OK [UIDVALIDITY\", pc, 14) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox UIDVALIDITY\\n\"));\n      pc += 3;\n      pc = imap_next_word (pc);\n      if (mutt_atoui (pc, &idata->uid_validity) < 0)\n        goto fail;\n      status->uidvalidity = idata->uid_validity;\n    }\n    else if (ascii_strncasecmp (\"OK [UIDNEXT\", pc, 11) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox UIDNEXT\\n\"));\n      pc += 3;\n      pc = imap_next_word (pc);\n      if (mutt_atoui (pc, &idata->uidnext) < 0)\n        goto fail;\n      status->uidnext = idata->uidnext;\n    }\n    else if (ascii_strncasecmp (\"OK [HIGHESTMODSEQ\", pc, 17) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox HIGHESTMODSEQ\\n\"));\n      pc += 3;\n      pc = imap_next_word (pc);\n      if (mutt_atoull (pc, &idata->modseq) < 0)\n        goto fail;\n      status->modseq = idata->modseq;\n    }\n    else if (ascii_strncasecmp (\"OK [NOMODSEQ\", pc, 12) == 0)\n    {\n      dprint (3, (debugfile, \"Mailbox has NOMODSEQ set\\n\"));\n      status->modseq = idata->modseq = 0;\n    }\n    else\n    {\n      pc = imap_next_word (pc);\n      if (!ascii_strncasecmp (\"EXISTS\", pc, 6))\n      {\n\tcount = idata->newMailCount;\n\tidata->newMailCount = 0;\n      }\n    }\n  }\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc == IMAP_CMD_NO)\n  {\n    char *s;\n    s = imap_next_word (idata->buf); /* skip seq */\n    s = imap_next_word (s); /* Skip response */\n    mutt_error (\"%s\", s);\n    mutt_sleep (2);\n    goto fail;\n  }\n\n  if (rc != IMAP_CMD_OK)\n    goto fail;\n\n  /* check for READ-ONLY notification */\n  if (!ascii_strncasecmp (imap_get_qualifier (idata->buf), \"[READ-ONLY]\", 11) &&\n      !mutt_bit_isset (idata->capabilities, ACL))\n  {\n    dprint (2, (debugfile, \"Mailbox is read-only.\\n\"));\n    ctx->readonly = 1;\n  }\n\n#ifdef DEBUG\n  /* dump the mailbox flags we've found */\n  if (debuglevel > 2)\n  {\n    if (!idata->flags)\n      dprint (3, (debugfile, \"No folder flags found\\n\"));\n    else\n    {\n      LIST* t = idata->flags;\n\n      dprint (3, (debugfile, \"Mailbox flags: \"));\n\n      t = t->next;\n      while (t)\n      {\n        dprint (3, (debugfile, \"[%s] \", t->data));\n        t = t->next;\n      }\n      dprint (3, (debugfile, \"\\n\"));\n    }\n  }\n#endif\n\n  if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))\n    ctx->readonly = 1;\n\n  ctx->hdrmax = count;\n  ctx->hdrs = safe_calloc (count, sizeof (HEADER *));\n  ctx->v2r = safe_calloc (count, sizeof (int));\n  ctx->msgcount = 0;\n\n  if (count && (imap_read_headers (idata, 1, count, 1) < 0))\n  {\n    mutt_error _(\"Error opening mailbox\");\n    mutt_sleep (1);\n    goto fail;\n  }\n\n  imap_disallow_reopen (ctx);\n\n  dprint (2, (debugfile, \"imap_open_mailbox: msgcount is %d\\n\", ctx->msgcount));\n  FREE (&mx.mbox);\n  return 0;\n\nfail:\n  if (idata->state == IMAP_SELECTED)\n    idata->state = IMAP_AUTHENTICATED;\nfail_noidata:\n  FREE (&mx.mbox);\n  return -1;\n}", "target": 0, "cwe": ["CWE-200", "CWE-319"], "project": "mutt", "commit_id": "3e88866dc60b5fa6aaba6fd7c1710c12c1c3cd01", "hash": 157975209057246974262732403124248421701, "size": 244, "message": "Prevent possible IMAP MITM via PREAUTH response.\n\nThis is similar to CVE-2014-2567 and CVE-2020-12398.  STARTTLS is not\nallowed in the Authenticated state, so previously Mutt would\nimplicitly mark the connection as authenticated and skip any\nencryption checking/enabling.\n\nNo credentials are exposed, but it does allow messages to be sent to\nan attacker, via postpone or fcc'ing for instance.\n\nReuse the $ssl_starttls quadoption \"in reverse\" to prompt to abort the\nconnection if it is unencrypted.\n\nThanks very much to Damian Poddebniak and Fabian Ising from the\nMünster University of Applied Sciences for reporting this issue, and\ntheir help in testing the fix.", "idx": 265}
{"func": "static void SSLLogErrors(char * action, int ret, int ssl_err, int len, \n\t\t\t pj_ssl_sock_t *ssock)\n{\n    char *ssl_err_str = SSLErrorString(ssl_err);\n\n    if (!action) {\n\taction = \"UNKNOWN\";\n    }\n\n    switch (ssl_err) {\n    case SSL_ERROR_SYSCALL:\n    {\n\tunsigned long err2 = ERR_get_error();\n\tif (err2) {\n\t    int level = 0;\n\t    while (err2) {\n\t        ERROR_LOG(\"SSL_ERROR_SYSCALL\", err2, ssock);\n\t\tlevel++;\n\t\terr2 = ERR_get_error();\n\t    }\n\t} else if (ret == 0) {\n\t    /* An EOF was observed that violates the protocol */\n\n\t    /* The TLS/SSL handshake was not successful but was shut down\n\t     * controlled and by the specifications of the TLS/SSL protocol.\n\t     */\n\t} else if (ret == -1) {\n\t    /* BIO error - look for more info in errno... */\n\t    char errStr[250] = \"\";\n\t    strerror_r(errno, errStr, sizeof(errStr));\n\t    /* for now - continue logging these if they occur.... */\n\t    PJ_LOG(4,(\"SSL\", \"BIO error, SSL_ERROR_SYSCALL (%s): \"\n\t    \t\t     \"errno: <%d> <%s> len: %d\",\n\t\t      \t     action, errno, errStr, len));\n\t} else {\n\t    /* ret!=0 & ret!=-1 & nothing on error stack - is this valid??? */\n\t    PJ_LOG(2,(\"SSL\", \"SSL_ERROR_SYSCALL (%s) ret: %d len: %d\",\n\t\t      action, ret, len));\n\t}\n\tbreak;\n    }\n    case SSL_ERROR_SSL:\n    {\n\tunsigned long err2 = ERR_get_error();\n\tint level = 0;\n\n\twhile (err2) {\n\t    ERROR_LOG(\"SSL_ERROR_SSL\", err2, ssock);\n\t    level++;\n\t    err2 = ERR_get_error();\n\t}\n\tbreak;\n    }\n    default:\n\tPJ_LOG(2,(\"SSL\", \"%lu [%s] (%s) ret: %d len: %d\",\n\t\t  ssl_err, ssl_err_str, action, ret, len));\n\tbreak;\n    }\n}", "target": 0, "cwe": ["CWE-362", "CWE-703"], "project": "pjproject", "commit_id": "d5f95aa066f878b0aef6a64e60b61e8626e664cd", "hash": 296646698429179006424248199166422490975, "size": 59, "message": "Merge pull request from GHSA-cv8x-p47p-99wr\n\n* - Avoid SSL socket parent/listener getting destroyed during handshake by increasing parent's reference count.\n- Add missing SSL socket close when the newly accepted SSL socket is discarded in SIP TLS transport.\n\n* - Fix silly mistake: accepted active socket created without group lock in SSL socket.\n- Replace assertion with normal validation check of SSL socket instance in OpenSSL verification callback (verify_cb()) to avoid crash, e.g: if somehow race condition with SSL socket destroy happens or OpenSSL application data index somehow gets corrupted.", "idx": 266}
{"func": "static void save_key_to(const char *algo, const char *name, const char *keydata)\n{\n\tconst char *error;\n\tstruct dict_transaction_context *ctx =\n\t\tdict_transaction_begin(keys_dict);\n\n\tdict_set(ctx, t_strconcat(DICT_PATH_SHARED, \"default/\", algo, \"/\",\n\t\t\t\t  name, NULL),\n\t\t keydata);\n\tif (dict_transaction_commit(&ctx, &error) < 0)\n\t\ti_error(\"dict_set(%s) failed: %s\", name, error);\n}", "target": 1, "cwe": ["CWE-22"], "project": "core", "commit_id": "cf8f670629cf2b9ff862eb42d5446ac4a9383a84", "hash": 40978935506850828155560774447548854266, "size": 12, "message": "lib-oauth2: Add test for token escape", "idx": 267}
{"func": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\tvalue[i] = v;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}", "target": 1, "cwe": ["CWE-787"], "project": "gpac", "commit_id": "f3698bb1bce62402805c3fda96551a23101a32f9", "hash": 5091138800974276859898826210401590380, "size": 28, "message": "fix buffer overrun in gf_bin128_parse\n\ncloses #1204\ncloses #1205", "idx": 268}
{"func": "dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags, int sh_num)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tconst char *linking_style = \"statically\";\n\tconst char *interp = \"\";\n\tunsigned char nbuf[BUFSIZ];\n\tchar ibuf[BUFSIZ];\n\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n  \tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\tlinking_style = \"dynamically\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\tif (sh_num)\t/* Did this through section headers */\n\t\t\t\tcontinue;\n\t\t\tif (((align = xph_align) & 0x80000000UL) != 0 ||\n\t\t\t    align < 4) {\n\t\t\t\tif (file_printf(ms, \n\t\t\t\t    \", invalid note alignment 0x%lx\",\n\t\t\t\t    (unsigned long)align) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\talign = 4;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tcase PT_INTERP:\n\t\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz\n\t\t\t    : sizeof(nbuf);\n\t\t\tbufsize = pread(fd, nbuf, len, xph_offset);\n\t\t\tif (bufsize == -1) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t\t/* Maybe warn here? */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_INTERP:\n\t\t\tif (bufsize && nbuf[0]) {\n\t\t\t\tnbuf[bufsize - 1] = '\\0';\n\t\t\t\tinterp = (const char *)nbuf;\n\t\t\t} else\n\t\t\t\tinterp = \"*empty*\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\t/*\n\t\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t\t * in the section.\n\t\t\t */\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = donote(ms, nbuf, offset,\n\t\t\t\t    (size_t)bufsize, clazz, swap, align,\n\t\t\t\t    flags);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (file_printf(ms, \", %s linked\", linking_style)\n\t    == -1)\n\t\treturn -1;\n\tif (interp[0])\n\t\tif (file_printf(ms, \", interpreter %s\",\n\t\t    file_printable(ibuf, sizeof(ibuf), interp)) == -1)\n\t\t\treturn -1;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "project": "file", "commit_id": "ce90e05774dd77d86cfc8dfa6da57b32816841c4", "hash": 132823570134533901798282325790741232601, "size": 100, "message": "- Add a limit to the number of ELF notes processed (Suggested by Alexander\n  Cherepanov)\n- Restructure ELF note printing so that we don't print the same message\n  multiple times on repeated notes of the same kind.", "idx": 269}
{"func": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "linux", "commit_id": "54d83fc74aa9ec72794373cb47432c5f7fb1a309", "hash": 165482155979293648477633461165874609378, "size": 51, "message": "netfilter: x_tables: fix unconditional helper\n\nBen Hawkes says:\n\n In the mark_source_chains function (net/ipv4/netfilter/ip_tables.c) it\n is possible for a user-supplied ipt_entry structure to have a large\n next_offset field. This field is not bounds checked prior to writing a\n counter value at the supplied offset.\n\nProblem is that mark_source_chains should not have been called --\nthe rule doesn't have a next entry, so its supposed to return\nan absolute verdict of either ACCEPT or DROP.\n\nHowever, the function conditional() doesn't work as the name implies.\nIt only checks that the rule is using wildcard address matching.\n\nHowever, an unconditional rule must also not be using any matches\n(no -m args).\n\nThe underflow validator only checked the addresses, therefore\npassing the 'unconditional absolute verdict' test, while\nmark_source_chains also tested for presence of matches, and thus\nproceeeded to the next (not-existent) rule.\n\nUnify this so that all the callers have same idea of 'unconditional rule'.\n\nReported-by: Ben Hawkes <hawkes@google.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "idx": 270}
{"func": "libraw_processed_image_t *LibRaw::dcraw_make_mem_thumb(int *errcode)\n{\n  if (!T.thumb)\n  {\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      if (errcode)\n        *errcode = LIBRAW_NO_THUMBNAIL;\n    }\n    else\n    {\n      if (errcode)\n        *errcode = LIBRAW_OUT_OF_ORDER_CALL;\n    }\n    return NULL;\n  }\n\n  if (T.tlength < 64u)\n  {\n      if (errcode)\n          *errcode = EINVAL;\n      return NULL;\n  }\n\n  if (INT64(T.tlength) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n  {\n      if (errcode)\n          *errcode = LIBRAW_TOO_BIG;\n      return NULL;\n  }\n\n  if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)\n  {\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(\n        sizeof(libraw_processed_image_t) + T.tlength);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n    ret->type = LIBRAW_IMAGE_BITMAP;\n    ret->height = T.theight;\n    ret->width = T.twidth;\n    ret->colors = 3;\n    ret->bits = 8;\n    ret->data_size = T.tlength;\n    memmove(ret->data, T.thumb, T.tlength);\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)\n  {\n    ushort exif[5];\n    int mk_exif = 0;\n    if (strcmp(T.thumb + 6, \"Exif\"))\n      mk_exif = 1;\n\n    int dsize = T.tlength + mk_exif * (sizeof(exif) + sizeof(tiff_hdr));\n\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(\n        sizeof(libraw_processed_image_t) + dsize);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n\n    ret->type = LIBRAW_IMAGE_JPEG;\n    ret->data_size = dsize;\n\n    ret->data[0] = 0xff;\n    ret->data[1] = 0xd8;\n    if (mk_exif)\n    {\n      struct tiff_hdr th;\n      memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n      exif[1] = htons(8 + sizeof th);\n      memmove(ret->data + 2, exif, sizeof(exif));\n      tiff_head(&th, 0);\n      memmove(ret->data + (2 + sizeof(exif)), &th, sizeof(th));\n      memmove(ret->data + (2 + sizeof(exif) + sizeof(th)), T.thumb + 2,\n              T.tlength - 2);\n    }\n    else\n    {\n      memmove(ret->data + 2, T.thumb + 2, T.tlength - 2);\n    }\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else\n  {\n    if (errcode)\n      *errcode = LIBRAW_UNSUPPORTED_THUMBNAIL;\n    return NULL;\n  }\n}", "target": 0, "cwe": ["CWE-20", "CWE-125"], "project": "LibRaw", "commit_id": "20ad21c0d87ca80217aee47533d91e633ce1864d", "hash": 16356814336993197997397830742437910843, "size": 109, "message": "Thumbnail size range check", "idx": 271}
{"func": "miniflow_extract(struct dp_packet *packet, struct miniflow *dst)\n{\n    const struct pkt_metadata *md = &packet->md;\n    const void *data = dp_packet_data(packet);\n    size_t size = dp_packet_size(packet);\n    ovs_be32 packet_type = packet->packet_type;\n    uint64_t *values = miniflow_values(dst);\n    struct mf_ctx mf = { FLOWMAP_EMPTY_INITIALIZER, values,\n                         values + FLOW_U64S };\n    const char *frame;\n    ovs_be16 dl_type = OVS_BE16_MAX;\n    uint8_t nw_frag, nw_tos, nw_ttl, nw_proto;\n    uint8_t *ct_nw_proto_p = NULL;\n    ovs_be16 ct_tp_src = 0, ct_tp_dst = 0;\n\n    /* Metadata. */\n    if (flow_tnl_dst_is_set(&md->tunnel)) {\n        miniflow_push_words(mf, tunnel, &md->tunnel,\n                            offsetof(struct flow_tnl, metadata) /\n                            sizeof(uint64_t));\n\n        if (!(md->tunnel.flags & FLOW_TNL_F_UDPIF)) {\n            if (md->tunnel.metadata.present.map) {\n                miniflow_push_words(mf, tunnel.metadata, &md->tunnel.metadata,\n                                    sizeof md->tunnel.metadata /\n                                    sizeof(uint64_t));\n            }\n        } else {\n            if (md->tunnel.metadata.present.len) {\n                miniflow_push_words(mf, tunnel.metadata.present,\n                                    &md->tunnel.metadata.present, 1);\n                miniflow_push_words(mf, tunnel.metadata.opts.gnv,\n                                    md->tunnel.metadata.opts.gnv,\n                                    DIV_ROUND_UP(md->tunnel.metadata.present.len,\n                                                 sizeof(uint64_t)));\n            }\n        }\n    }\n    if (md->skb_priority || md->pkt_mark) {\n        miniflow_push_uint32(mf, skb_priority, md->skb_priority);\n        miniflow_push_uint32(mf, pkt_mark, md->pkt_mark);\n    }\n    miniflow_push_uint32(mf, dp_hash, md->dp_hash);\n    miniflow_push_uint32(mf, in_port, odp_to_u32(md->in_port.odp_port));\n    if (md->ct_state) {\n        miniflow_push_uint32(mf, recirc_id, md->recirc_id);\n        miniflow_push_uint8(mf, ct_state, md->ct_state);\n        ct_nw_proto_p = miniflow_pointer(mf, ct_nw_proto);\n        miniflow_push_uint8(mf, ct_nw_proto, 0);\n        miniflow_push_uint16(mf, ct_zone, md->ct_zone);\n    } else if (md->recirc_id) {\n        miniflow_push_uint32(mf, recirc_id, md->recirc_id);\n        miniflow_pad_to_64(mf, recirc_id);\n    }\n\n    if (md->ct_state) {\n        miniflow_push_uint32(mf, ct_mark, md->ct_mark);\n        miniflow_push_be32(mf, packet_type, packet_type);\n\n        if (!ovs_u128_is_zero(md->ct_label)) {\n            miniflow_push_words(mf, ct_label, &md->ct_label,\n                                sizeof md->ct_label / sizeof(uint64_t));\n        }\n    } else {\n        miniflow_pad_from_64(mf, packet_type);\n        miniflow_push_be32(mf, packet_type, packet_type);\n    }\n\n    /* Initialize packet's layer pointer and offsets. */\n    frame = data;\n    dp_packet_reset_offsets(packet);\n\n    if (packet_type == htonl(PT_ETH)) {\n        /* Must have full Ethernet header to proceed. */\n        if (OVS_UNLIKELY(size < sizeof(struct eth_header))) {\n            goto out;\n        } else {\n            /* Link layer. */\n            ASSERT_SEQUENTIAL(dl_dst, dl_src);\n            miniflow_push_macs(mf, dl_dst, data);\n\n            /* VLAN */\n            union flow_vlan_hdr vlans[FLOW_MAX_VLAN_HEADERS];\n            size_t num_vlans = parse_vlan(&data, &size, vlans);\n\n            dl_type = parse_ethertype(&data, &size);\n            miniflow_push_be16(mf, dl_type, dl_type);\n            miniflow_pad_to_64(mf, dl_type);\n            if (num_vlans > 0) {\n                miniflow_push_words_32(mf, vlans, vlans, num_vlans);\n            }\n\n        }\n    } else {\n        /* Take dl_type from packet_type. */\n        dl_type = pt_ns_type_be(packet_type);\n        miniflow_pad_from_64(mf, dl_type);\n        miniflow_push_be16(mf, dl_type, dl_type);\n        /* Do not push vlan_tci, pad instead */\n        miniflow_pad_to_64(mf, dl_type);\n    }\n\n    /* Parse mpls. */\n    if (OVS_UNLIKELY(eth_type_mpls(dl_type))) {\n        int count;\n        const void *mpls = data;\n\n        packet->l2_5_ofs = (char *)data - frame;\n        count = parse_mpls(&data, &size);\n        miniflow_push_words_32(mf, mpls_lse, mpls, count);\n    }\n\n    /* Network layer. */\n    packet->l3_ofs = (char *)data - frame;\n\n    nw_frag = 0;\n    if (OVS_LIKELY(dl_type == htons(ETH_TYPE_IP))) {\n        const struct ip_header *nh = data;\n        int ip_len;\n        uint16_t tot_len;\n\n        if (OVS_UNLIKELY(size < IP_HEADER_LEN)) {\n            goto out;\n        }\n        ip_len = IP_IHL(nh->ip_ihl_ver) * 4;\n\n        if (OVS_UNLIKELY(ip_len < IP_HEADER_LEN)) {\n            goto out;\n        }\n        if (OVS_UNLIKELY(size < ip_len)) {\n            goto out;\n        }\n        tot_len = ntohs(nh->ip_tot_len);\n        if (OVS_UNLIKELY(tot_len > size || ip_len > tot_len)) {\n            goto out;\n        }\n        if (OVS_UNLIKELY(size - tot_len > UINT8_MAX)) {\n            goto out;\n        }\n        dp_packet_set_l2_pad_size(packet, size - tot_len);\n        size = tot_len;   /* Never pull padding. */\n\n        /* Push both source and destination address at once. */\n        miniflow_push_words(mf, nw_src, &nh->ip_src, 1);\n        if (ct_nw_proto_p && !md->ct_orig_tuple_ipv6) {\n            *ct_nw_proto_p = md->ct_orig_tuple.ipv4.ipv4_proto;\n            if (*ct_nw_proto_p) {\n                miniflow_push_words(mf, ct_nw_src,\n                                    &md->ct_orig_tuple.ipv4.ipv4_src, 1);\n                ct_tp_src = md->ct_orig_tuple.ipv4.src_port;\n                ct_tp_dst = md->ct_orig_tuple.ipv4.dst_port;\n            }\n        }\n\n        miniflow_push_be32(mf, ipv6_label, 0); /* Padding for IPv4. */\n\n        nw_tos = nh->ip_tos;\n        nw_ttl = nh->ip_ttl;\n        nw_proto = nh->ip_proto;\n        if (OVS_UNLIKELY(IP_IS_FRAGMENT(nh->ip_frag_off))) {\n            nw_frag = FLOW_NW_FRAG_ANY;\n            if (nh->ip_frag_off & htons(IP_FRAG_OFF_MASK)) {\n                nw_frag |= FLOW_NW_FRAG_LATER;\n            }\n        }\n        data_pull(&data, &size, ip_len);\n    } else if (dl_type == htons(ETH_TYPE_IPV6)) {\n        const struct ovs_16aligned_ip6_hdr *nh;\n        ovs_be32 tc_flow;\n        uint16_t plen;\n\n        if (OVS_UNLIKELY(size < sizeof *nh)) {\n            goto out;\n        }\n        nh = data_pull(&data, &size, sizeof *nh);\n\n        plen = ntohs(nh->ip6_plen);\n        if (OVS_UNLIKELY(plen > size)) {\n            goto out;\n        }\n        /* Jumbo Payload option not supported yet. */\n        if (OVS_UNLIKELY(size - plen > UINT8_MAX)) {\n            goto out;\n        }\n        dp_packet_set_l2_pad_size(packet, size - plen);\n        size = plen;   /* Never pull padding. */\n\n        miniflow_push_words(mf, ipv6_src, &nh->ip6_src,\n                            sizeof nh->ip6_src / 8);\n        miniflow_push_words(mf, ipv6_dst, &nh->ip6_dst,\n                            sizeof nh->ip6_dst / 8);\n        if (ct_nw_proto_p && md->ct_orig_tuple_ipv6) {\n            *ct_nw_proto_p = md->ct_orig_tuple.ipv6.ipv6_proto;\n            if (*ct_nw_proto_p) {\n                miniflow_push_words(mf, ct_ipv6_src,\n                                    &md->ct_orig_tuple.ipv6.ipv6_src,\n                                    2 *\n                                    sizeof md->ct_orig_tuple.ipv6.ipv6_src / 8);\n                ct_tp_src = md->ct_orig_tuple.ipv6.src_port;\n                ct_tp_dst = md->ct_orig_tuple.ipv6.dst_port;\n            }\n        }\n\n        tc_flow = get_16aligned_be32(&nh->ip6_flow);\n        nw_tos = ntohl(tc_flow) >> 20;\n        nw_ttl = nh->ip6_hlim;\n        nw_proto = nh->ip6_nxt;\n\n        if (!parse_ipv6_ext_hdrs__(&data, &size, &nw_proto, &nw_frag)) {\n            goto out;\n        }\n\n        /* This needs to be after the parse_ipv6_ext_hdrs__() call because it\n         * leaves the nw_frag word uninitialized. */\n        ASSERT_SEQUENTIAL(ipv6_label, nw_frag);\n        ovs_be32 label = tc_flow & htonl(IPV6_LABEL_MASK);\n        miniflow_push_be32(mf, ipv6_label, label);\n    } else {\n        if (dl_type == htons(ETH_TYPE_ARP) ||\n            dl_type == htons(ETH_TYPE_RARP)) {\n            struct eth_addr arp_buf[2];\n            const struct arp_eth_header *arp = (const struct arp_eth_header *)\n                data_try_pull(&data, &size, ARP_ETH_HEADER_LEN);\n\n            if (OVS_LIKELY(arp) && OVS_LIKELY(arp->ar_hrd == htons(1))\n                && OVS_LIKELY(arp->ar_pro == htons(ETH_TYPE_IP))\n                && OVS_LIKELY(arp->ar_hln == ETH_ADDR_LEN)\n                && OVS_LIKELY(arp->ar_pln == 4)) {\n                miniflow_push_be32(mf, nw_src,\n                                   get_16aligned_be32(&arp->ar_spa));\n                miniflow_push_be32(mf, nw_dst,\n                                   get_16aligned_be32(&arp->ar_tpa));\n\n                /* We only match on the lower 8 bits of the opcode. */\n                if (OVS_LIKELY(ntohs(arp->ar_op) <= 0xff)) {\n                    miniflow_push_be32(mf, ipv6_label, 0); /* Pad with ARP. */\n                    miniflow_push_be32(mf, nw_frag, htonl(ntohs(arp->ar_op)));\n                }\n\n                /* Must be adjacent. */\n                ASSERT_SEQUENTIAL(arp_sha, arp_tha);\n\n                arp_buf[0] = arp->ar_sha;\n                arp_buf[1] = arp->ar_tha;\n                miniflow_push_macs(mf, arp_sha, arp_buf);\n                miniflow_pad_to_64(mf, arp_tha);\n            }\n        } else if (dl_type == htons(ETH_TYPE_NSH)) {\n            struct ovs_key_nsh nsh;\n\n            if (OVS_LIKELY(parse_nsh(&data, &size, &nsh))) {\n                miniflow_push_words(mf, nsh, &nsh,\n                                    sizeof(struct ovs_key_nsh) /\n                                    sizeof(uint64_t));\n            }\n        }\n        goto out;\n    }\n\n    packet->l4_ofs = (char *)data - frame;\n    miniflow_push_be32(mf, nw_frag,\n                       bytes_to_be32(nw_frag, nw_tos, nw_ttl, nw_proto));\n\n    if (OVS_LIKELY(!(nw_frag & FLOW_NW_FRAG_LATER))) {\n        if (OVS_LIKELY(nw_proto == IPPROTO_TCP)) {\n            if (OVS_LIKELY(size >= TCP_HEADER_LEN)) {\n                const struct tcp_header *tcp = data;\n\n                miniflow_push_be32(mf, arp_tha.ea[2], 0);\n                miniflow_push_be32(mf, tcp_flags,\n                                   TCP_FLAGS_BE32(tcp->tcp_ctl));\n                miniflow_push_be16(mf, tp_src, tcp->tcp_src);\n                miniflow_push_be16(mf, tp_dst, tcp->tcp_dst);\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_UDP)) {\n            if (OVS_LIKELY(size >= UDP_HEADER_LEN)) {\n                const struct udp_header *udp = data;\n\n                miniflow_push_be16(mf, tp_src, udp->udp_src);\n                miniflow_push_be16(mf, tp_dst, udp->udp_dst);\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_SCTP)) {\n            if (OVS_LIKELY(size >= SCTP_HEADER_LEN)) {\n                const struct sctp_header *sctp = data;\n\n                miniflow_push_be16(mf, tp_src, sctp->sctp_src);\n                miniflow_push_be16(mf, tp_dst, sctp->sctp_dst);\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_ICMP)) {\n            if (OVS_LIKELY(size >= ICMP_HEADER_LEN)) {\n                const struct icmp_header *icmp = data;\n\n                miniflow_push_be16(mf, tp_src, htons(icmp->icmp_type));\n                miniflow_push_be16(mf, tp_dst, htons(icmp->icmp_code));\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_IGMP)) {\n            if (OVS_LIKELY(size >= IGMP_HEADER_LEN)) {\n                const struct igmp_header *igmp = data;\n\n                miniflow_push_be16(mf, tp_src, htons(igmp->igmp_type));\n                miniflow_push_be16(mf, tp_dst, htons(igmp->igmp_code));\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n                miniflow_push_be32(mf, igmp_group_ip4,\n                                   get_16aligned_be32(&igmp->group));\n                miniflow_pad_to_64(mf, igmp_group_ip4);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_ICMPV6)) {\n            if (OVS_LIKELY(size >= sizeof(struct icmp6_hdr))) {\n                const struct in6_addr *nd_target;\n                struct eth_addr arp_buf[2];\n                const struct icmp6_hdr *icmp = data_pull(&data, &size,\n                                                         sizeof *icmp);\n                if (parse_icmpv6(&data, &size, icmp, &nd_target, arp_buf)) {\n                    if (nd_target) {\n                        miniflow_push_words(mf, nd_target, nd_target,\n                                            sizeof *nd_target / sizeof(uint64_t));\n                    }\n                    miniflow_push_macs(mf, arp_sha, arp_buf);\n                    miniflow_pad_to_64(mf, arp_tha);\n                    miniflow_push_be16(mf, tp_src, htons(icmp->icmp6_type));\n                    miniflow_push_be16(mf, tp_dst, htons(icmp->icmp6_code));\n                    miniflow_pad_to_64(mf, tp_dst);\n                } else {\n                    /* ICMPv6 but not ND. */\n                    miniflow_push_be16(mf, tp_src, htons(icmp->icmp6_type));\n                    miniflow_push_be16(mf, tp_dst, htons(icmp->icmp6_code));\n                    miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                    miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n                }\n            }\n        }\n    }\n out:\n    dst->map = mf.map;\n}", "target": 1, "cwe": ["CWE-400"], "project": "ovs", "commit_id": "48ceca0446b1c2c2c03e7551048c5b19ed23cc97", "hash": 14181464177610588670654675453707387200, "size": 344, "message": "flow: Support extra padding length.\n\nAlthough not required, padding can be optionally added until\nthe packet length is MTU bytes. A packet with extra padding\ncurrently fails sanity checks.\n\nVulnerability: CVE-2020-35498\nFixes: fa8d9001a624 (\"miniflow_extract: Properly handle small IP packets.\")\nReported-by: Joakim Hindersson <joakim.hindersson@elastx.se>\nAcked-by: Ilya Maximets <i.maximets@ovn.org>\nSigned-off-by: Flavio Leitner <fbl@sysclose.org>\nSigned-off-by: Ilya Maximets <i.maximets@ovn.org>", "idx": 272}
{"func": "void vnc_display_open(const char *id, Error **errp)\n{\n    VncDisplay *vd = vnc_display_find(id);\n    QemuOpts *opts = qemu_opts_find(&qemu_vnc_opts, id);\n    SocketAddress **saddr = NULL, **wsaddr = NULL;\n    size_t nsaddr, nwsaddr;\n    const char *share, *device_id;\n    QemuConsole *con;\n    bool password = false;\n    bool reverse = false;\n    const char *credid;\n    bool sasl = false;\n#ifdef CONFIG_VNC_SASL\n    int saslErr;\n#endif\n    int acl = 0;\n    int lock_key_sync = 1;\n    int key_delay_ms;\n    size_t i;\n\n    if (!vd) {\n        error_setg(errp, \"VNC display not active\");\n        return;\n    }\n    vnc_display_close(vd);\n\n    if (!opts) {\n        return;\n    }\n\n    reverse = qemu_opt_get_bool(opts, \"reverse\", false);\n    if (vnc_display_get_addresses(opts, reverse, &saddr, &nsaddr,\n                                  &wsaddr, &nwsaddr, errp) < 0) {\n        goto fail;\n    }\n\n    password = qemu_opt_get_bool(opts, \"password\", false);\n    if (password) {\n        if (fips_get_state()) {\n            error_setg(errp,\n                       \"VNC password auth disabled due to FIPS mode, \"\n                       \"consider using the VeNCrypt or SASL authentication \"\n                       \"methods as an alternative\");\n            goto fail;\n        }\n        if (!qcrypto_cipher_supports(\n                QCRYPTO_CIPHER_ALG_DES_RFB, QCRYPTO_CIPHER_MODE_ECB)) {\n            error_setg(errp,\n                       \"Cipher backend does not support DES RFB algorithm\");\n            goto fail;\n        }\n    }\n\n    lock_key_sync = qemu_opt_get_bool(opts, \"lock-key-sync\", true);\n    key_delay_ms = qemu_opt_get_number(opts, \"key-delay-ms\", 1);\n    sasl = qemu_opt_get_bool(opts, \"sasl\", false);\n#ifndef CONFIG_VNC_SASL\n    if (sasl) {\n        error_setg(errp, \"VNC SASL auth requires cyrus-sasl support\");\n        goto fail;\n    }\n#endif /* CONFIG_VNC_SASL */\n    credid = qemu_opt_get(opts, \"tls-creds\");\n    if (credid) {\n        Object *creds;\n        if (qemu_opt_get(opts, \"tls\") ||\n            qemu_opt_get(opts, \"x509\") ||\n            qemu_opt_get(opts, \"x509verify\")) {\n            error_setg(errp,\n                       \"'tls-creds' parameter is mutually exclusive with \"\n                       \"'tls', 'x509' and 'x509verify' parameters\");\n            goto fail;\n        }\n\n        creds = object_resolve_path_component(\n            object_get_objects_root(), credid);\n        if (!creds) {\n            error_setg(errp, \"No TLS credentials with id '%s'\",\n                       credid);\n            goto fail;\n        }\n        vd->tlscreds = (QCryptoTLSCreds *)\n            object_dynamic_cast(creds,\n                                TYPE_QCRYPTO_TLS_CREDS);\n        if (!vd->tlscreds) {\n            error_setg(errp, \"Object with id '%s' is not TLS credentials\",\n                       credid);\n            goto fail;\n        }\n        object_ref(OBJECT(vd->tlscreds));\n\n        if (vd->tlscreds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {\n            error_setg(errp,\n                       \"Expecting TLS credentials with a server endpoint\");\n            goto fail;\n        }\n    } else {\n        const char *path;\n        bool tls = false, x509 = false, x509verify = false;\n        tls  = qemu_opt_get_bool(opts, \"tls\", false);\n        if (tls) {\n            path = qemu_opt_get(opts, \"x509\");\n\n            if (path) {\n                x509 = true;\n            } else {\n                path = qemu_opt_get(opts, \"x509verify\");\n                if (path) {\n                    x509 = true;\n                    x509verify = true;\n                }\n            }\n            vd->tlscreds = vnc_display_create_creds(x509,\n                                                    x509verify,\n                                                    path,\n                                                    vd->id,\n                                                    errp);\n            if (!vd->tlscreds) {\n                goto fail;\n            }\n        }\n    }\n    acl = qemu_opt_get_bool(opts, \"acl\", false);\n\n    share = qemu_opt_get(opts, \"share\");\n    if (share) {\n        if (strcmp(share, \"ignore\") == 0) {\n            vd->share_policy = VNC_SHARE_POLICY_IGNORE;\n        } else if (strcmp(share, \"allow-exclusive\") == 0) {\n            vd->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n        } else if (strcmp(share, \"force-shared\") == 0) {\n            vd->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;\n        } else {\n            error_setg(errp, \"unknown vnc share= option\");\n            goto fail;\n        }\n    } else {\n        vd->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n    }\n    vd->connections_limit = qemu_opt_get_number(opts, \"connections\", 32);\n\n#ifdef CONFIG_VNC_JPEG\n    vd->lossy = qemu_opt_get_bool(opts, \"lossy\", false);\n#endif\n    vd->non_adaptive = qemu_opt_get_bool(opts, \"non-adaptive\", false);\n    /* adaptive updates are only used with tight encoding and\n     * if lossy updates are enabled so we can disable all the\n     * calculations otherwise */\n    if (!vd->lossy) {\n        vd->non_adaptive = true;\n    }\n\n    if (acl) {\n        if (strcmp(vd->id, \"default\") == 0) {\n            vd->tlsaclname = g_strdup(\"vnc.x509dname\");\n        } else {\n            vd->tlsaclname = g_strdup_printf(\"vnc.%s.x509dname\", vd->id);\n        }\n        qemu_acl_init(vd->tlsaclname);\n    }\n#ifdef CONFIG_VNC_SASL\n    if (acl && sasl) {\n        char *aclname;\n\n        if (strcmp(vd->id, \"default\") == 0) {\n            aclname = g_strdup(\"vnc.username\");\n        } else {\n            aclname = g_strdup_printf(\"vnc.%s.username\", vd->id);\n        }\n        vd->sasl.acl = qemu_acl_init(aclname);\n        g_free(aclname);\n    }\n#endif\n\n    if (vnc_display_setup_auth(&vd->auth, &vd->subauth,\n                               vd->tlscreds, password,\n                               sasl, false, errp) < 0) {\n        goto fail;\n    }\n\n    if (vnc_display_setup_auth(&vd->ws_auth, &vd->ws_subauth,\n                               vd->tlscreds, password,\n                               sasl, true, errp) < 0) {\n        goto fail;\n    }\n\n#ifdef CONFIG_VNC_SASL\n    if ((saslErr = sasl_server_init(NULL, \"qemu\")) != SASL_OK) {\n        error_setg(errp, \"Failed to initialize SASL auth: %s\",\n                   sasl_errstring(saslErr, NULL, NULL));\n        goto fail;\n    }\n#endif\n    vd->lock_key_sync = lock_key_sync;\n    if (lock_key_sync) {\n        vd->led = qemu_add_led_event_handler(kbd_leds, vd);\n    }\n    vd->ledstate = 0;\n    vd->key_delay_ms = key_delay_ms;\n\n    device_id = qemu_opt_get(opts, \"display\");\n    if (device_id) {\n        int head = qemu_opt_get_number(opts, \"head\", 0);\n        Error *err = NULL;\n\n        con = qemu_console_lookup_by_device_name(device_id, head, &err);\n        if (err) {\n            error_propagate(errp, err);\n            goto fail;\n        }\n    } else {\n        con = NULL;\n    }\n\n    if (con != vd->dcl.con) {\n        unregister_displaychangelistener(&vd->dcl);\n        vd->dcl.con = con;\n        register_displaychangelistener(&vd->dcl);\n    }\n\n    if (saddr == NULL) {\n        goto cleanup;\n    }\n\n    if (reverse) {\n        if (vnc_display_connect(vd, saddr, nsaddr, wsaddr, nwsaddr, errp) < 0) {\n            goto fail;\n        }\n    } else {\n        if (vnc_display_listen(vd, saddr, nsaddr, wsaddr, nwsaddr, errp) < 0) {\n            goto fail;\n        }\n    }\n\n    if (qemu_opt_get(opts, \"to\")) {\n        vnc_display_print_local_addr(vd);\n    }\n\n cleanup:\n    for (i = 0; i < nsaddr; i++) {\n        qapi_free_SocketAddress(saddr[i]);\n    }\n    for (i = 0; i < nwsaddr; i++) {\n        qapi_free_SocketAddress(wsaddr[i]);\n    }\n    return;\n\nfail:\n    vnc_display_close(vd);\n    goto cleanup;\n}", "target": 1, "cwe": ["CWE-772"], "project": "qemu", "commit_id": "d3b0db6dfea6b3a9ee0d96aceb796bdcafa84314", "hash": 42107995299967280486479540817683844546, "size": 251, "message": "vnc: Set default kbd delay to 10ms\n\nThe current VNC default keyboard delay is 1ms. With that we're constantly\ntyping faster than the guest receives keyboard events from an XHCI attached\nUSB HID device.\n\nThe default keyboard delay time in the input layer however is 10ms. I don't know\nhow that number came to be, but empirical tests on some OpenQA driven ARM\nsystems show that 10ms really is a reasonable default number for the delay.\n\nThis patch moves the VNC delay also to 10ms. That way our default is much\nsafer (good!) and also consistent with the input layer default (also good!).\n\nSigned-off-by: Alexander Graf <agraf@suse.de>\nReviewed-by: Daniel P. Berrange <berrange@redhat.com>\nMessage-id: 1499863425-103133-1-git-send-email-agraf@suse.de\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>", "idx": 273}
{"func": "static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t const u8 *mac,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint err;\n\tint layer2_update;\n\n\tif (params->vlan) {\n\t\tsdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tif (ether_addr_equal(mac, sdata->vif.addr))\n\t\treturn -EINVAL;\n\n\tif (is_multicast_ether_addr(mac))\n\t\treturn -EINVAL;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER) &&\n\t    sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    !sdata->u.mgd.associated)\n\t\treturn -EINVAL;\n\n\tsta = sta_info_alloc(sdata, mac, GFP_KERNEL);\n\tif (!sta)\n\t\treturn -ENOMEM;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\tsta->sta.tdls = true;\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err) {\n\t\tsta_info_free(local, sta);\n\t\treturn err;\n\t}\n\n\t/*\n\t * for TDLS and for unassociated station, rate control should be\n\t * initialized only when rates are known and station is marked\n\t * authorized/associated\n\t */\n\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER) &&\n\t    test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\trate_control_rate_init(sta);\n\n\tlayer2_update = sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t\tsdata->vif.type == NL80211_IFTYPE_AP;\n\n\terr = sta_info_insert_rcu(sta);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\treturn err;\n\t}\n\n\tif (layer2_update)\n\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);\n\n\trcu_read_unlock();\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-287"], "project": "linux", "commit_id": "3e493173b7841259a08c5c8e5cbe90adb349da7e", "hash": 68277235885659921283486638943855726312, "size": 68, "message": "mac80211: Do not send Layer 2 Update frame before authorization\n\nThe Layer 2 Update frame is used to update bridges when a station roams\nto another AP even if that STA does not transmit any frames after the\nreassociation. This behavior was described in IEEE Std 802.11F-2003 as\nsomething that would happen based on MLME-ASSOCIATE.indication, i.e.,\nbefore completing 4-way handshake. However, this IEEE trial-use\nrecommended practice document was published before RSN (IEEE Std\n802.11i-2004) and as such, did not consider RSN use cases. Furthermore,\nIEEE Std 802.11F-2003 was withdrawn in 2006 and as such, has not been\nmaintained amd should not be used anymore.\n\nSending out the Layer 2 Update frame immediately after association is\nfine for open networks (and also when using SAE, FT protocol, or FILS\nauthentication when the station is actually authenticated by the time\nassociation completes). However, it is not appropriate for cases where\nRSN is used with PSK or EAP authentication since the station is actually\nfully authenticated only once the 4-way handshake completes after\nauthentication and attackers might be able to use the unauthenticated\ntriggering of Layer 2 Update frame transmission to disrupt bridge\nbehavior.\n\nFix this by postponing transmission of the Layer 2 Update frame from\nstation entry addition to the point when the station entry is marked\nauthorized. Similarly, send out the VLAN binding update only if the STA\nentry has already been authorized.\n\nSigned-off-by: Jouni Malinen <jouni@codeaurora.org>\nReviewed-by: Johannes Berg <johannes@sipsolutions.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 274}
{"func": "static int vhdx_reopen_prepare(BDRVReopenState *state,\n                               BlockReopenQueue *queue, Error **errp)\n{\n    return 0;\n}", "target": 0, "cwe": ["CWE-835"], "project": "qemu", "commit_id": "1d7678dec4761acdc43439da6ceda41a703ba1a6", "hash": 268537774760759630495738471705638209483, "size": 5, "message": "vhdx: Bounds checking for block_size and logical_sector_size (CVE-2014-0148)\n\nOther variables (e.g. sectors_per_block) are calculated using these\nvariables, and if not range-checked illegal values could be obtained\ncausing infinite loops and other potential issues when calculating\nBAT entries.\n\nThe 1.00 VHDX spec requires BlockSize to be min 1MB, max 256MB.\nLogicalSectorSize is required to be either 512 or 4096 bytes.\n\nReported-by: Kevin Wolf <kwolf@redhat.com>\nSigned-off-by: Jeff Cody <jcody@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>", "idx": 275}
{"func": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  uint pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}", "target": 1, "cwe": ["CWE-20"], "project": "taglib", "commit_id": "ab8a0ee8937256311e649a88e8ddd7c7f870ad59", "hash": 205178597703581419533641652806213513623, "size": 47, "message": "Don't store the output of ByteVector::toUInt() in int, use uint instead", "idx": 276}
{"func": "listener_ref_entry_remove_for_connection (GSListener  *listener,\n                                          int          entry_type,\n                                          const char  *connection)\n{\n        gboolean    removed;\n        guint       n_removed;\n        GHashTable *hash;\n\n        hash = get_hash_for_entry_type (listener, entry_type);\n\n        removed = FALSE;\n        n_removed = g_hash_table_foreach_remove (hash, listener_ref_entry_has_connection, (gpointer)connection);\n\n        removed = (n_removed > 0);\n\n        return removed;\n}", "target": 1, "cwe": [], "project": "gnome-screensaver", "commit_id": "284c9924969a49dbf2d5fae1d680d3310c4df4a3", "hash": 261259337663707599403502771928874625351, "size": 17, "message": "Remove session inhibitors if the originator falls of the bus\n\nThis fixes a problem where totem leaves inhibitors behind, see\nbug 600488.", "idx": 277}
{"func": "int inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\tif (sb->s_xattr)\n\t\tinode->i_opflags |= IOP_XATTR;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_write_hint = WRITE_LIFE_NOT_SET;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_link = NULL;\n\tinode->i_dir_seq = 0;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tinode->i_wb_frn_winner = 0;\n\tinode->i_wb_frn_avg_time = 0;\n\tinode->i_wb_frn_history = 0;\n#endif\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tinit_rwsem(&inode->i_rwsem);\n\tlockdep_set_class(&inode->i_rwsem, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping->wb_err = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n#ifdef CONFIG_READ_ONLY_THP_FOR_FS\n\tatomic_set(&mapping->nr_thps, 0);\n#endif\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}", "target": 1, "cwe": ["CWE-416"], "project": "tip", "commit_id": "8019ad13ef7f64be44d4f892af9c840179009254", "hash": 62128350903241000083853244891306571080, "size": 76, "message": "futex: Fix inode life-time issue\n\nAs reported by Jann, ihold() does not in fact guarantee inode\npersistence. And instead of making it so, replace the usage of inode\npointers with a per boot, machine wide, unique inode identifier.\n\nThis sequence number is global, but shared (file backed) futexes are\nrare enough that this should not become a performance issue.\n\nReported-by: Jann Horn <jannh@google.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>", "idx": 278}
{"func": "SPL_METHOD(SplDoublyLinkedList, prev)\n{\n\tspl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);\n}", "target": 1, "cwe": ["CWE-416"], "project": "php-src", "commit_id": "863bf294feb9ad425eadb94f288bc7f18673089d", "hash": 21753307163106473438733591401474262998, "size": 10, "message": "Fixed bug #70169 (Use After Free Vulnerability in unserialize() with SplDoublyLinkedList)", "idx": 279}
{"func": "static inline char *tok_text_buf(struct Token *t)\n{\n    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;\n}", "target": 0, "cwe": [], "project": "nasm", "commit_id": "6299a3114ce0f3acd55d07de201a8ca2f0a83059", "hash": 117324319606872123701724055296222799593, "size": 4, "message": "BR 3392708: fix NULL pointer reference for invalid %stacksize\n\nAfter issuing an error message for a missing %stacksize argument, need\nto quit rather than continuing to try to access the pointer.\n\nFold uses of tok_text() while we are at it.\n\nReported-by: Suhwan <prada960808@gmail.com>\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>", "idx": 280}
{"func": "    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {\n      return resize(disp.width(),disp.height(),force_redraw);\n    }", "target": 0, "cwe": ["CWE-770"], "project": "cimg", "commit_id": "619cb58dd90b4e03ac68286c70ed98acbefd1c90", "hash": 89559422812765707989766685736628163636, "size": 3, "message": "CImg<>::load_bmp() and CImg<>::load_pandore(): Check that dimensions encoded in file does not exceed file size.", "idx": 281}
{"func": "static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x0d\\x0a\\x87\\x0a\",4) == 0)\n    return(MagickTrue);\n  if (length < 12)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x00\\x00\\x00\\x0c\\x6a\\x50\\x20\\x20\\x0d\\x0a\\x87\\x0a\",12) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}", "target": 0, "cwe": ["CWE-665"], "project": "ImageMagick", "commit_id": "90c4afcde1bf3ad5aead4477716161c350b049f8", "hash": 254213186574993474102278002152292374962, "size": 12, "message": "https://github.com/ImageMagick/ImageMagick/issues/1518", "idx": 282}
{"func": "ia64_patch_vtop (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip;\n\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\n\t\t/* replace virtual address with corresponding physical address: */\n\t\tia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n\tia64_srlz_i();\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "linux", "commit_id": "4dcc29e1574d88f4465ba865ed82800032f76418", "hash": 249922107420941823529335639841556786685, "size": 16, "message": "[IA64] Workaround for RSE issue\n\nProblem: An application violating the architectural rules regarding\noperation dependencies and having specific Register Stack Engine (RSE)\nstate at the time of the violation, may result in an illegal operation\nfault and invalid RSE state.  Such faults may initiate a cascade of\nrepeated illegal operation faults within OS interruption handlers.\nThe specific behavior is OS dependent.\n\nImplication: An application causing an illegal operation fault with\nspecific RSE state may result in a series of illegal operation faults\nand an eventual OS stack overflow condition.\n\nWorkaround: OS interruption handlers that switch to kernel backing\nstore implement a check for invalid RSE state to avoid the series\nof illegal operation faults.\n\nThe core of the workaround is the RSE_WORKAROUND code sequence\ninserted into each invocation of the SAVE_MIN_WITH_COVER and\nSAVE_MIN_WITH_COVER_R19 macros.  This sequence includes hard-coded\nconstants that depend on the number of stacked physical registers\nbeing 96.  The rest of this patch consists of code to disable this\nworkaround should this not be the case (with the presumption that\nif a future Itanium processor increases the number of registers, it\nwould also remove the need for this patch).\n\nMove the start of the RBS up to a mod32 boundary to avoid some\ncorner cases.\n\nThe dispatch_illegal_op_fault code outgrew the spot it was\nsquatting in when built with this patch and CONFIG_VIRT_CPU_ACCOUNTING=y\nMove it out to the end of the ivt.\n\nSigned-off-by: Tony Luck <tony.luck@intel.com>", "idx": 283}
{"func": "spool_write_header(uschar *id, int where, uschar **errmsg)\n{\nint fd;\nint i;\nint size_correction;\nFILE *f;\nheader_line *h;\nstruct stat statbuf;\nuschar name[256];\nuschar temp_name[256];\n\nsprintf(CS temp_name, \"%s/input/%s/hdr.%d\", spool_directory, message_subdir,\n  (int)getpid());\nfd = spool_open_temp(temp_name);\nif (fd < 0) return spool_write_error(where, errmsg, US\"open\", NULL, NULL);\nf = fdopen(fd, \"wb\");\nDEBUG(D_receive|D_deliver) debug_printf(\"Writing spool header file\\n\");\n\n/* We now have an open file to which the header data is to be written. Start\nwith the file's leaf name, to make the file self-identifying. Continue with the\nidentity of the submitting user, followed by the sender's address. The sender's\naddress is enclosed in <> because it might be the null address. Then write the\nreceived time and the number of warning messages that have been sent. */\n\nfprintf(f, \"%s-H\\n\", message_id);\nfprintf(f, \"%.63s %ld %ld\\n\", originator_login, (long int)originator_uid,\n  (long int)originator_gid);\nfprintf(f, \"<%s>\\n\", sender_address);\nfprintf(f, \"%d %d\\n\", received_time, warning_count);\n\n/* If there is information about a sending host, remember it. The HELO\ndata can be set for local SMTP as well as remote. */\n\nif (sender_helo_name != NULL)\n  fprintf(f, \"-helo_name %s\\n\", sender_helo_name);\n\nif (sender_host_address != NULL)\n  {\n  fprintf(f, \"-host_address %s.%d\\n\", sender_host_address, sender_host_port);\n  if (sender_host_name != NULL)\n    fprintf(f, \"-host_name %s\\n\", sender_host_name);\n  if (sender_host_authenticated != NULL)\n    fprintf(f, \"-host_auth %s\\n\", sender_host_authenticated);\n  }\n\n/* Also about the interface a message came in on */\n\nif (interface_address != NULL)\n  fprintf(f, \"-interface_address %s.%d\\n\", interface_address, interface_port);\n\nif (smtp_active_hostname != primary_hostname)\n  fprintf(f, \"-active_hostname %s\\n\", smtp_active_hostname);\n\n/* Likewise for any ident information; for local messages this is\nlikely to be the same as originator_login, but will be different if\nthe originator was root, forcing a different ident. */\n\nif (sender_ident != NULL) fprintf(f, \"-ident %s\\n\", sender_ident);\n\n/* Ditto for the received protocol */\n\nif (received_protocol != NULL)\n  fprintf(f, \"-received_protocol %s\\n\", received_protocol);\n\n/* Preserve any ACL variables that are set. */\n\ntree_walk(acl_var_c, &acl_var_write, f);\ntree_walk(acl_var_m, &acl_var_write, f);\n\n/* Now any other data that needs to be remembered. */\n\nfprintf(f, \"-body_linecount %d\\n\", body_linecount);\nfprintf(f, \"-max_received_linelength %d\\n\", max_received_linelength);\n\nif (body_zerocount > 0) fprintf(f, \"-body_zerocount %d\\n\", body_zerocount);\n\nif (authenticated_id != NULL)\n  fprintf(f, \"-auth_id %s\\n\", authenticated_id);\nif (authenticated_sender != NULL)\n  fprintf(f, \"-auth_sender %s\\n\", authenticated_sender);\n\nif (allow_unqualified_recipient) fprintf(f, \"-allow_unqualified_recipient\\n\");\nif (allow_unqualified_sender) fprintf(f, \"-allow_unqualified_sender\\n\");\nif (deliver_firsttime) fprintf(f, \"-deliver_firsttime\\n\");\nif (deliver_freeze) fprintf(f, \"-frozen %d\\n\", deliver_frozen_at);\nif (dont_deliver) fprintf(f, \"-N\\n\");\nif (host_lookup_deferred) fprintf(f, \"-host_lookup_deferred\\n\");\nif (host_lookup_failed) fprintf(f, \"-host_lookup_failed\\n\");\nif (sender_local) fprintf(f, \"-local\\n\");\nif (local_error_message) fprintf(f, \"-localerror\\n\");\nif (local_scan_data != NULL) fprintf(f, \"-local_scan %s\\n\", local_scan_data);\n#ifdef WITH_CONTENT_SCAN\nif (spam_score_int != NULL) fprintf(f,\"-spam_score_int %s\\n\", spam_score_int);\n#endif\nif (deliver_manual_thaw) fprintf(f, \"-manual_thaw\\n\");\nif (sender_set_untrusted) fprintf(f, \"-sender_set_untrusted\\n\");\n\n#ifdef EXPERIMENTAL_BRIGHTMAIL\nif (bmi_verdicts != NULL) fprintf(f, \"-bmi_verdicts %s\\n\", bmi_verdicts);\n#endif\n\n#ifdef SUPPORT_TLS\nif (tls_certificate_verified) fprintf(f, \"-tls_certificate_verified\\n\");\nif (tls_cipher != NULL) fprintf(f, \"-tls_cipher %s\\n\", tls_cipher);\nif (tls_peerdn != NULL) fprintf(f, \"-tls_peerdn %s\\n\", string_printing(tls_peerdn));\n#endif\n\n/* To complete the envelope, write out the tree of non-recipients, followed by\nthe list of recipients. These won't be disjoint the first time, when no\nchecking has been done. If a recipient is a \"one-time\" alias, it is followed by\na space and its parent address number (pno). */\n\ntree_write(tree_nonrecipients, f);\nfprintf(f, \"%d\\n\", recipients_count);\nfor (i = 0; i < recipients_count; i++)\n  {\n  recipient_item *r = recipients_list + i;\n  if (r->pno < 0 && r->errors_to == NULL)\n    fprintf(f, \"%s\\n\", r->address);\n  else\n    {\n    uschar *errors_to = (r->errors_to == NULL)? US\"\" : r->errors_to;\n    fprintf(f, \"%s %s %d,%d#1\\n\", r->address, errors_to,\n      Ustrlen(errors_to), r->pno);\n    }\n  }\n\n/* Put a blank line before the headers */\n\nfprintf(f, \"\\n\");\n\n/* Save the size of the file so far so we can subtract it from the final length\nto get the actual size of the headers. */\n\nfflush(f);\nfstat(fd, &statbuf);\nsize_correction = statbuf.st_size;\n\n/* Finally, write out the message's headers. To make it easier to read them\nin again, precede each one with the count of its length. Make the count fixed\nlength to aid human eyes when debugging and arrange for it not be included in\nthe size. It is followed by a space for normal headers, a flagging letter for\nvarious other headers, or an asterisk for old headers that have been rewritten.\nThese are saved as a record for debugging. Don't included them in the message's\nsize. */\n\nfor (h = header_list; h != NULL; h = h->next)\n  {\n  fprintf(f, \"%03d%c %s\", h->slen, h->type, h->text);\n  size_correction += 5;\n  if (h->type == '*') size_correction += h->slen;\n  }\n\n/* Flush and check for any errors while writing */\n\nif (fflush(f) != 0 || ferror(f))\n  return spool_write_error(where, errmsg, US\"write\", temp_name, f);\n\n/* Force the file's contents to be written to disk. Note that fflush()\njust pushes it out of C, and fclose() doesn't guarantee to do the write\neither. That's just the way Unix works... */\n\nif (EXIMfsync(fileno(f)) < 0)\n  return spool_write_error(where, errmsg, US\"sync\", temp_name, f);\n\n/* Get the size of the file, and close it. */\n\nfstat(fd, &statbuf);\nif (fclose(f) != 0)\n  return spool_write_error(where, errmsg, US\"close\", temp_name, NULL);\n\n/* Rename the file to its correct name, thereby replacing any previous\nincarnation. */\n\nsprintf(CS name, \"%s/input/%s/%s-H\", spool_directory, message_subdir, id);\n\nif (Urename(temp_name, name) < 0)\n  return spool_write_error(where, errmsg, US\"rename\", temp_name, NULL);\n\n/* Linux (and maybe other OS?) does not automatically sync a directory after\nan operation like rename. We therefore have to do it forcibly ourselves in\nthese cases, to make sure the file is actually accessible on disk, as opposed\nto just the data being accessible from a file in lost+found. Linux also has\nO_DIRECTORY, for opening a directory.\n\nHowever, it turns out that some file systems (some versions of NFS?) do not\nsupport directory syncing. It seems safe enough to ignore EINVAL to cope with\nthese cases. One hack on top of another... but that's life. */\n\n#ifdef NEED_SYNC_DIRECTORY\n\nsprintf(CS temp_name, \"%s/input/%s/.\", spool_directory, message_subdir);\n\n#ifndef O_DIRECTORY\n#define O_DIRECTORY 0\n#endif\n\nif ((fd = Uopen(temp_name, O_RDONLY|O_DIRECTORY, 0)) < 0)\n  return spool_write_error(where, errmsg, US\"directory open\", name, NULL);\n\nif (EXIMfsync(fd) < 0 && errno != EINVAL)\n  return spool_write_error(where, errmsg, US\"directory sync\", name, NULL);\n\nif (close(fd) < 0)\n  return spool_write_error(where, errmsg, US\"directory close\", name, NULL);\n\n#endif  /* NEED_SYNC_DIRECTORY */\n\n/* Return the number of characters in the headers, which is the file size, less\nthe prelimary stuff, less the additional count fields on the headers. */\n\nDEBUG(D_receive) debug_printf(\"Size of headers = %d\\n\",\n  (int)(statbuf.st_size - size_correction));\n\nreturn statbuf.st_size - size_correction;\n}", "target": 1, "cwe": [], "project": "exim", "commit_id": "7be682ca5ebd9571a01b762195b11c34cd231830", "hash": 240331202273847297960210834628871692429, "size": 216, "message": "TLS SNI support for OpenSSL ($tls_sni)", "idx": 284}
{"func": "ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)\n{\n    OutgoingDataQueue::putData(stamp, data, len);\n}", "target": 0, "cwe": ["CWE-119"], "project": "ZRTPCPP", "commit_id": "c8617100f359b217a974938c5539a1dd8a120b0e", "hash": 95958498663918206879850432320964402346, "size": 4, "message": "Fix vulnerabilities found and reported by Mark Dowd\n\n- limit length of memcpy\n- limit number of offered algorithms in Hello packet\n- length check in PING packet\n- fix a small coding error", "idx": 285}
{"func": "xps_parse_gradient_stops(xps_document *doc, char *base_uri, fz_xml *node,\n\tstruct stop *stops, int maxcount)\n{\n\tfz_colorspace *colorspace;\n\tfloat sample[8];\n\tfloat rgb[3];\n\tint before, after;\n\tint count;\n\tint i;\n\n\t/* We may have to insert 2 extra stops when postprocessing */\n\tmaxcount -= 2;\n\n\tcount = 0;\n\twhile (node && count < maxcount)\n\t{\n\t\tif (!strcmp(fz_xml_tag(node), \"GradientStop\"))\n\t\t{\n\t\t\tchar *offset = fz_xml_att(node, \"Offset\");\n\t\t\tchar *color = fz_xml_att(node, \"Color\");\n\t\t\tif (offset && color)\n\t\t\t{\n\t\t\t\tstops[count].offset = fz_atof(offset);\n\t\t\t\tstops[count].index = count;\n\n\t\t\t\txps_parse_color(doc, base_uri, color, &colorspace, sample);\n\n\t\t\t\tfz_convert_color(doc->ctx, fz_device_rgb(doc->ctx), rgb, colorspace, sample + 1);\n\n\t\t\t\tstops[count].r = rgb[0];\n\t\t\t\tstops[count].g = rgb[1];\n\t\t\t\tstops[count].b = rgb[2];\n\t\t\t\tstops[count].a = sample[0];\n\n\t\t\t\tcount ++;\n\t\t\t}\n\t\t}\n\t\tnode = fz_xml_next(node);\n\t}\n\n\tif (count == 0)\n\t{\n\t\tfz_warn(doc->ctx, \"gradient brush has no gradient stops\");\n\t\tstops[0].offset = 0;\n\t\tstops[0].r = 0;\n\t\tstops[0].g = 0;\n\t\tstops[0].b = 0;\n\t\tstops[0].a = 1;\n\t\tstops[1].offset = 1;\n\t\tstops[1].r = 1;\n\t\tstops[1].g = 1;\n\t\tstops[1].b = 1;\n\t\tstops[1].a = 1;\n\t\treturn 2;\n\t}\n\n\tif (count == maxcount)\n\t\tfz_warn(doc->ctx, \"gradient brush exceeded maximum number of gradient stops\");\n\n\t/* Postprocess to make sure the range of offsets is 0.0 to 1.0 */\n\n\tqsort(stops, count, sizeof(struct stop), cmp_stop);\n\n\tbefore = -1;\n\tafter = -1;\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tif (stops[i].offset < 0)\n\t\t\tbefore = i;\n\t\tif (stops[i].offset > 1)\n\t\t{\n\t\t\tafter = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Remove all stops < 0 except the largest one */\n\tif (before > 0)\n\t{\n\t\tmemmove(stops, stops + before, (count - before) * sizeof(struct stop));\n\t\tcount -= before;\n\t}\n\n\t/* Remove all stops > 1 except the smallest one */\n\tif (after >= 0)\n\t\tcount = after + 1;\n\n\t/* Expand single stop to 0 .. 1 */\n\tif (count == 1)\n\t{\n\t\tstops[1] = stops[0];\n\t\tstops[0].offset = 0;\n\t\tstops[1].offset = 1;\n\t\treturn 2;\n\t}\n\n\t/* First stop < 0 -- interpolate value to 0 */\n\tif (stops[0].offset < 0)\n\t{\n\t\tfloat d = -stops[0].offset / (stops[1].offset - stops[0].offset);\n\t\tstops[0].offset = 0;\n\t\tstops[0].r = lerp(stops[0].r, stops[1].r, d);\n\t\tstops[0].g = lerp(stops[0].g, stops[1].g, d);\n\t\tstops[0].b = lerp(stops[0].b, stops[1].b, d);\n\t\tstops[0].a = lerp(stops[0].a, stops[1].a, d);\n\t}\n\n\t/* Last stop > 1 -- interpolate value to 1 */\n\tif (stops[count-1].offset > 1)\n\t{\n\t\tfloat d = (1 - stops[count-2].offset) / (stops[count-1].offset - stops[count-2].offset);\n\t\tstops[count-1].offset = 1;\n\t\tstops[count-1].r = lerp(stops[count-2].r, stops[count-1].r, d);\n\t\tstops[count-1].g = lerp(stops[count-2].g, stops[count-1].g, d);\n\t\tstops[count-1].b = lerp(stops[count-2].b, stops[count-1].b, d);\n\t\tstops[count-1].a = lerp(stops[count-2].a, stops[count-1].a, d);\n\t}\n\n\t/* First stop > 0 -- insert a duplicate at 0 */\n\tif (stops[0].offset > 0)\n\t{\n\t\tmemmove(stops + 1, stops, count * sizeof(struct stop));\n\t\tstops[0] = stops[1];\n\t\tstops[0].offset = 0;\n\t\tcount++;\n\t}\n\n\t/* Last stop < 1 -- insert a duplicate at 1 */\n\tif (stops[count-1].offset < 1)\n\t{\n\t\tstops[count] = stops[count-1];\n\t\tstops[count].offset = 1;\n\t\tcount++;\n\t}\n\n\treturn count;\n}", "target": 1, "cwe": ["CWE-119"], "project": "mupdf", "commit_id": "60dabde18d7fe12b19da8b509bdfee9cc886aafc", "hash": 24075888185480823160412764902592804124, "size": 138, "message": "Bug 694957: fix stack buffer overflow in xps_parse_color\n\nxps_parse_color happily reads more than FZ_MAX_COLORS values out of a\nContextColor array which overflows the passed in samples array.\nLimiting the number of allowed samples to FZ_MAX_COLORS and make sure\nto use that constant for all callers fixes the problem.\n\nThanks to Jean-Jamil Khalifé for reporting and investigating the issue\nand providing a sample exploit file.", "idx": 286}
{"func": "static void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\n\t/* read drive info out of physical CMOS */\n\tdrive = 0;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!UDP->cmos && FLOPPY1_TYPE)\n\t\tUDP->cmos = FLOPPY1_TYPE;\n\n\t/* FIXME: additional physical CMOS drive detection should go here */\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = UDP->cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tstatic char temparea[32];\n\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsprintf(temparea, \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\t*UDP = *params;\n\t}\n\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}", "target": 0, "cwe": ["CWE-264", "CWE-754"], "project": "linux", "commit_id": "ef87dbe7614341c2e7bfe8d32fcb7028cc97442c", "hash": 39815728179091721018445478361079215685, "size": 51, "message": "floppy: ignore kernel-only members in FDRAWCMD ioctl input\n\nAlways clear out these floppy_raw_cmd struct members after copying the\nentire structure from userspace so that the in-kernel version is always\nvalid and never left in an interdeterminate state.\n\nSigned-off-by: Matthew Daley <mattd@bugfuzz.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 287}
{"func": "static int check_options(int argc, char **argv, char *operation)\n{\n  int i= 0;                    // loop counter\n  int num_found= 0;            // number of options found (shortcut loop)\n  char config_file[FN_REFLEN]; // configuration file name\n  char plugin_name[FN_REFLEN]; // plugin name\n  \n  /* Form prefix strings for the options. */\n  const char *basedir_prefix = \"--basedir=\";\n  int basedir_len= strlen(basedir_prefix);\n  const char *datadir_prefix = \"--datadir=\";\n  int datadir_len= strlen(datadir_prefix);\n  const char *plugin_dir_prefix = \"--plugin_dir=\";\n  int plugin_dir_len= strlen(plugin_dir_prefix);\n\n  strcpy(plugin_name, \"\");\n  for (i = 0; i < argc && num_found < 5; i++)\n  {\n\n    if (!argv[i])\n    {\n      continue;\n    }\n    if ((strcasecmp(argv[i], \"ENABLE\") == 0) ||\n        (strcasecmp(argv[i], \"DISABLE\") == 0))\n    {\n      strcpy(operation, argv[i]);\n      num_found++;\n    }\n    else if ((strncasecmp(argv[i], basedir_prefix, basedir_len) == 0) &&\n             !opt_basedir)\n    {\n      opt_basedir= my_strndup(argv[i]+basedir_len,\n                              strlen(argv[i])-basedir_len, MYF(MY_FAE));\n      num_found++;\n    }\n    else if ((strncasecmp(argv[i], datadir_prefix, datadir_len) == 0) &&\n             !opt_datadir)\n    {\n      opt_datadir= my_strndup(argv[i]+datadir_len,\n                              strlen(argv[i])-datadir_len, MYF(MY_FAE));\n      num_found++;\n    }\n    else if ((strncasecmp(argv[i], plugin_dir_prefix, plugin_dir_len) == 0) &&\n             !opt_plugin_dir)\n    {\n      opt_plugin_dir= my_strndup(argv[i]+plugin_dir_len,\n                                 strlen(argv[i])-plugin_dir_len, MYF(MY_FAE));\n      num_found++;\n    }\n    /* read the plugin config file and check for match against argument */\n    else\n    {\n      strcpy(plugin_name, argv[i]);\n      strcpy(config_file, argv[i]);\n      strcat(config_file, \".ini\");\n    }\n  }\n\n  if (!opt_basedir)\n  {\n    fprintf(stderr, \"ERROR: Missing --basedir option.\\n\");\n    return 1;\n  }\n\n  if (!opt_datadir)\n  {\n    fprintf(stderr, \"ERROR: Missing --datadir option.\\n\");\n    return 1;\n  }\n\n  if (!opt_plugin_dir)\n  {\n    fprintf(stderr, \"ERROR: Missing --plugin_dir option.\\n\");\n    return 1;\n  }\n  /* If a plugin was specified, read the config file. */\n  else if (strlen(plugin_name) > 0) \n  {\n    if (load_plugin_data(plugin_name, config_file))\n    {\n      return 1;\n    }\n    if (strcasecmp(plugin_data.name, plugin_name) != 0)\n    {\n      fprintf(stderr, \"ERROR: plugin name requested does not match config \"\n              \"file data.\\n\");\n      return 1;\n    }\n  }\n  else\n  {\n    fprintf(stderr, \"ERROR: No plugin specified.\\n\");\n    return 1;\n  }\n\n  if ((strlen(operation) == 0))\n  {\n    fprintf(stderr, \"ERROR: missing operation. Please specify either \"\n            \"'<plugin> ENABLE' or '<plugin> DISABLE'.\\n\");\n    return 1;\n  }\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-200"], "project": "mysql-server", "commit_id": "0dbd5a8797ed4bd18e8b883988fb62177eb0f73f", "hash": 42628573069294011712358653717197810146, "size": 105, "message": "Bug#21973610: BUFFER OVERFLOW ISSUES\n\nDescription : Incorrect usage of sprintf/strcpy caused\n              possible buffer overflow issues at various\n              places.\n\nSolution : - Fixed mysql_plugin and mysqlshow\n           - Fixed regex library issues\n\nReviewed-By : Georgi Kodinov <georgi.kodinov@oracle.com>\nReviewed-By : Venkata S Murthy Sidagam <venkata.sidagam@oracle.com>", "idx": 288}
{"func": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "efc7ffcb4237f8cb9938909041c4ed38f6e1bf40", "hash": 256655408888579656518249099852758355696, "size": 22, "message": "hfsplus: fix Buffer overflow with a corrupted image\n\nWhen an hfsplus image gets corrupted it might happen that the catalog\nnamelength field gets b0rked.  If we mount such an image the memcpy() in\nhfsplus_cat_build_key_uni() writes more than the 255 that fit in the name\nfield.  Depending on the size of the overwritten data, we either only get\nmemory corruption or also trigger an oops like this:\n\n[  221.628020] BUG: unable to handle kernel paging request at c82b0000\n[  221.629066] IP: [<c022d4b1>] hfsplus_find_cat+0x10d/0x151\n[  221.629066] *pde = 0ea29163 *pte = 082b0160\n[  221.629066] Oops: 0002 [#1] PREEMPT DEBUG_PAGEALLOC\n[  221.629066] Modules linked in:\n[  221.629066]\n[  221.629066] Pid: 4845, comm: mount Not tainted (2.6.27-rc4-00123-gd3ee1b4-dirty #28)\n[  221.629066] EIP: 0060:[<c022d4b1>] EFLAGS: 00010206 CPU: 0\n[  221.629066] EIP is at hfsplus_find_cat+0x10d/0x151\n[  221.629066] EAX: 00000029 EBX: 00016210 ECX: 000042c2 EDX: 00000002\n[  221.629066] ESI: c82d70ca EDI: c82b0000 EBP: c82d1bcc ESP: c82d199c\n[  221.629066]  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 0068\n[  221.629066] Process mount (pid: 4845, ti=c82d1000 task=c8224060 task.ti=c82d1000)\n[  221.629066] Stack: c080b3c4 c82aa8f8 c82d19c2 00016210 c080b3be c82d1bd4 c82aa8f0 00000300\n[  221.629066]        01000000 750008b1 74006e00 74006900 65006c00 c82d6400 c013bd35 c8224060\n[  221.629066]        00000036 00000046 c82d19f0 00000082 c8224548 c8224060 00000036 c0d653cc\n[  221.629066] Call Trace:\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c0107aa3>] ? native_sched_clock+0x82/0x96\n[  221.629066]  [<c01302d2>] ? __kernel_text_address+0x1b/0x27\n[  221.629066]  [<c010487a>] ? dump_trace+0xca/0xd6\n[  221.629066]  [<c0109e32>] ? save_stack_address+0x0/0x2c\n[  221.629066]  [<c0109eaf>] ? save_stack_trace+0x1c/0x3a\n[  221.629066]  [<c013b571>] ? save_trace+0x37/0x8d\n[  221.629066]  [<c013b62e>] ? add_lock_to_list+0x67/0x8d\n[  221.629066]  [<c013ea1c>] ? validate_chain+0x8a4/0x9f4\n[  221.629066]  [<c013553d>] ? down+0xc/0x2f\n[  221.629066]  [<c013f1f6>] ? __lock_acquire+0x68a/0x6e0\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c0107aa3>] ? native_sched_clock+0x82/0x96\n[  221.629066]  [<c013da5d>] ? mark_held_locks+0x43/0x5a\n[  221.629066]  [<c013dc3a>] ? trace_hardirqs_on+0xb/0xd\n[  221.629066]  [<c013dbf4>] ? trace_hardirqs_on_caller+0xf4/0x12f\n[  221.629066]  [<c06abec8>] ? _spin_unlock_irqrestore+0x42/0x58\n[  221.629066]  [<c013555c>] ? down+0x2b/0x2f\n[  221.629066]  [<c022aa68>] ? hfsplus_iget+0xa0/0x154\n[  221.629066]  [<c022b0b9>] ? hfsplus_fill_super+0x280/0x447\n[  221.629066]  [<c0107aa3>] ? native_sched_clock+0x82/0x96\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013f1f6>] ? __lock_acquire+0x68a/0x6e0\n[  221.629066]  [<c041c9e4>] ? string+0x2b/0x74\n[  221.629066]  [<c041cd16>] ? vsnprintf+0x2e9/0x512\n[  221.629066]  [<c010487a>] ? dump_trace+0xca/0xd6\n[  221.629066]  [<c0109eaf>] ? save_stack_trace+0x1c/0x3a\n[  221.629066]  [<c0109eaf>] ? save_stack_trace+0x1c/0x3a\n[  221.629066]  [<c013b571>] ? save_trace+0x37/0x8d\n[  221.629066]  [<c013b62e>] ? add_lock_to_list+0x67/0x8d\n[  221.629066]  [<c013ea1c>] ? validate_chain+0x8a4/0x9f4\n[  221.629066]  [<c01354d3>] ? up+0xc/0x2f\n[  221.629066]  [<c013f1f6>] ? __lock_acquire+0x68a/0x6e0\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c0107aa3>] ? native_sched_clock+0x82/0x96\n[  221.629066]  [<c041cfb7>] ? snprintf+0x1b/0x1d\n[  221.629066]  [<c01ba466>] ? disk_name+0x25/0x67\n[  221.629066]  [<c0183960>] ? get_sb_bdev+0xcd/0x10b\n[  221.629066]  [<c016ad92>] ? kstrdup+0x2a/0x4c\n[  221.629066]  [<c022a7b3>] ? hfsplus_get_sb+0x13/0x15\n[  221.629066]  [<c022ae39>] ? hfsplus_fill_super+0x0/0x447\n[  221.629066]  [<c0183583>] ? vfs_kern_mount+0x3b/0x76\n[  221.629066]  [<c0183602>] ? do_kern_mount+0x32/0xba\n[  221.629066]  [<c01960d4>] ? do_new_mount+0x46/0x74\n[  221.629066]  [<c0196277>] ? do_mount+0x175/0x193\n[  221.629066]  [<c013dbf4>] ? trace_hardirqs_on_caller+0xf4/0x12f\n[  221.629066]  [<c01663b2>] ? __get_free_pages+0x1e/0x24\n[  221.629066]  [<c06ac07b>] ? lock_kernel+0x19/0x8c\n[  221.629066]  [<c01962e6>] ? sys_mount+0x51/0x9b\n[  221.629066]  [<c01962f9>] ? sys_mount+0x64/0x9b\n[  221.629066]  [<c01038bd>] ? sysenter_do_call+0x12/0x31\n[  221.629066]  =======================\n[  221.629066] Code: 89 c2 c1 e2 08 c1 e8 08 09 c2 8b 85 e8 fd ff ff 66 89 50 06 89 c7 53 83 c7 08 56 57 68 c4 b3 80 c0 e8 8c 5c ef ff 89 d9 c1 e9 02 <f3> a5 89 d9 83 e1 03 74 02 f3 a4 83 c3 06 8b 95 e8 fd ff ff 0f\n[  221.629066] EIP: [<c022d4b1>] hfsplus_find_cat+0x10d/0x151 SS:ESP 0068:c82d199c\n[  221.629066] ---[ end trace e417a1d67f0d0066 ]---\n\nSince hfsplus_cat_build_key_uni() returns void and only has one callsite,\nthe check is performed at the callsite.\n\nSigned-off-by: Eric Sesterhenn <snakebyte@gmx.de>\nReviewed-by: Pekka Enberg <penberg@cs.helsinki.fi>\nCc: Roman Zippel <zippel@linux-m68k.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 289}
{"func": "int term_addstr(TERM_WINDOW *window, const char *str)\n{\n\tint len, raw_len;\n\tunichar tmp;\n\tconst char *ptr;\n\n\tif (vcmove) term_move_real();\n\n\tlen = 0;\n\traw_len = strlen(str);\n\n\t/* The string length depends on the terminal encoding */\n\n\tptr = str;\n\n\tif (term_type == TERM_TYPE_UTF8) {\n\t\twhile (*ptr != '\\0') {\n\t\t\ttmp = g_utf8_get_char(ptr);\n\t\t\tlen += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;\n\t\t\tptr = g_utf8_next_char(ptr);\n\t\t}\n\t} else\n\t\tlen = raw_len;\n\n        term_printed_text(len);\n\n\t/* Use strlen() here since we need the number of raw bytes */\n\tfwrite(str, 1, raw_len, window->term->out);\n\n\treturn len;\n}", "target": 1, "cwe": ["CWE-476"], "project": "irssi", "commit_id": "6c6c42e3d1b49d90aacc0b67f8540471cae02a1d", "hash": 166286681299970671700464928008142093148, "size": 31, "message": "Merge branch 'security' into 'master'\n\nSee merge request !7", "idx": 290}
{"func": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tchar buf[BUFSIZE];\n\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\n\t*cp = '\\0';\n\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\n\treturn (tp->e_name);\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tcpdump", "commit_id": "730fc35968c5433b9e2a829779057f4f9495dc51", "hash": 25567725577366776895813098463014496601, "size": 28, "message": "CVE-2017-12894/In lookup_bytestring(), take the length of the byte string into account.\n\nOtherwise, if, in our search of the hash table, we come across a byte\nstring that's shorter than the string we're looking for, we'll search\npast the end of the string in the hash table.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levomäki.\n\nAdd a test using the capture file supplied by the reporter(s).", "idx": 291}
{"func": "unix_sck_send_disconnect(hsm_com_client_hdl_t *hdl, int timeout)\r\n{\r\n\thsm_com_discon_data_t\tmsg;\r\n\r\n\tmemset(&msg,0,sizeof(msg));\r\n\r\n\tmsg.header.cmd = HSM_COM_CMD_DISC;\r\n\tmsg.header.ver = HSM_COM_VER;\r\n\tmsg.header.trans_id = hdl->trans_id++;\r\n\tmsg.header.payload_len = 0;\r\n\r\n\tif(unix_sck_send_msg(hdl, (char*)&msg, sizeof(msg), (char*)&msg, \r\n\t\t\t\t\t\t sizeof(msg), timeout) != sizeof(msg))\r\n\t{\r\n\t\t// COM Error...\r\n\t\t// Close our connection\r\n\t\tclose(hdl->client_fd);\r\n\t\thdl->client_state = HSM_COM_C_STATE_IN;\r\n\r\n\t\treturn HSM_COM_BAD;\r\n\t}\r\n\r\n\tif(msg.header.resp_code == HSM_COM_RESP_OK){\r\n\t\treturn HSM_COM_OK;\r\n\t}\r\n\r\n\treturn HSM_COM_BAD;\r\n\r\n}\r", "target": 0, "cwe": ["CWE-362"], "project": "opa-fm", "commit_id": "c5759e7b76f5bf844be6c6641cc1b356bbc83869", "hash": 92649357152402146751778023284447802793, "size": 29, "message": "Fix scripts and code that use well-known tmp files.", "idx": 292}
{"func": "static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct inet6_dev *idev = NULL;\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct sock *sk;\n\tstruct ipv6_pinfo *np;\n\tconst struct in6_addr *saddr = NULL;\n\tstruct dst_entry *dst;\n\tstruct icmp6hdr tmp_hdr;\n\tstruct flowi6 fl6;\n\tstruct icmpv6_msg msg;\n\tint iif = 0;\n\tint addr_type = 0;\n\tint len;\n\tint hlimit;\n\tint err = 0;\n\tu32 mark = IP6_REPLY_MARK(net, skb->mark);\n\n\tif ((u8 *)hdr < skb->head ||\n\t    (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb))\n\t\treturn;\n\n\t/*\n\t *\tMake sure we respect the rules\n\t *\ti.e. RFC 1885 2.4(e)\n\t *\tRule (e.1) is enforced by not using icmp6_send\n\t *\tin any code that processes icmp errors.\n\t */\n\taddr_type = ipv6_addr_type(&hdr->daddr);\n\n\tif (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) ||\n\t    ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr))\n\t\tsaddr = &hdr->daddr;\n\n\t/*\n\t *\tDest addr check\n\t */\n\n\tif (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) {\n\t\tif (type != ICMPV6_PKT_TOOBIG &&\n\t\t    !(type == ICMPV6_PARAMPROB &&\n\t\t      code == ICMPV6_UNK_OPTION &&\n\t\t      (opt_unrec(skb, info))))\n\t\t\treturn;\n\n\t\tsaddr = NULL;\n\t}\n\n\taddr_type = ipv6_addr_type(&hdr->saddr);\n\n\t/*\n\t *\tSource addr check\n\t */\n\n\tif (__ipv6_addr_needs_scope_id(addr_type))\n\t\tiif = skb->dev->ifindex;\n\n\t/*\n\t *\tMust not send error if the source does not uniquely\n\t *\tidentify a single node (RFC2463 Section 2.4).\n\t *\tWe check unspecified / multicast addresses here,\n\t *\tand anycast addresses will be checked later.\n\t */\n\tif ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\t/*\n\t *\tNever answer to a ICMP packet.\n\t */\n\tif (is_ineligible(skb)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: no reply to icmp error [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\tmip6_addr_swap(skb);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.daddr = hdr->saddr;\n\tif (saddr)\n\t\tfl6.saddr = *saddr;\n\tfl6.flowi6_mark = mark;\n\tfl6.flowi6_oif = iif;\n\tfl6.fl6_icmp_type = type;\n\tfl6.fl6_icmp_code = code;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\tsk = icmpv6_xmit_lock(net);\n\tif (!sk)\n\t\treturn;\n\tsk->sk_mark = mark;\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_xrlim_allow(sk, type, &fl6))\n\t\tgoto out;\n\n\ttmp_hdr.icmp6_type = type;\n\ttmp_hdr.icmp6_code = code;\n\ttmp_hdr.icmp6_cksum = 0;\n\ttmp_hdr.icmp6_pointer = htonl(info);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = l3mdev_master_ifindex(skb->dev);\n\n\tdst = icmpv6_route_lookup(net, skb, sk, &fl6);\n\tif (IS_ERR(dst))\n\t\tgoto out;\n\n\thlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tmsg.skb = skb;\n\tmsg.offset = skb_network_offset(skb);\n\tmsg.type = type;\n\n\tlen = skb->len - msg.offset;\n\tlen = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr));\n\tif (len < 0) {\n\t\tnet_dbg_ratelimited(\"icmp: len problem [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\tgoto out_dst_release;\n\t}\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(skb->dev);\n\n\terr = ip6_append_data(sk, icmpv6_getfrag, &msg,\n\t\t\t      len + sizeof(struct icmp6hdr),\n\t\t\t      sizeof(struct icmp6hdr), hlimit,\n\t\t\t      np->tclass, NULL, &fl6, (struct rt6_info *)dst,\n\t\t\t      MSG_DONTWAIT, np->dontfrag);\n\tif (err) {\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\terr = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,\n\t\t\t\t\t\t len + sizeof(struct icmp6hdr));\n\t}\n\trcu_read_unlock();\nout_dst_release:\n\tdst_release(dst);\nout:\n\ticmpv6_xmit_unlock(sk);\n}", "target": 1, "cwe": [], "project": "linux", "commit_id": "1d2f7b2d956e242179aaf4a08f3545f99c81f9a3", "hash": 266530907129945752539119938466199916773, "size": 153, "message": "net: ipv6: tcp reset, icmp need to consider L3 domain\n\nResponses for packets to unused ports are getting lost with L3 domains.\n\nIPv4 has ip_send_unicast_reply for sending TCP responses which accounts\nfor L3 domains; update the IPv6 counterpart tcp_v6_send_response.\nFor icmp the L3 master check needs to be moved up in icmp6_send\nto properly respond to UDP packets to a port with no listener.\n\nFixes: ca254490c8df (\"net: Add VRF support to IPv6 stack\")\nSigned-off-by: David Ahern <dsa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 293}
{"func": "dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)\n{\n    dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);\n}", "target": 0, "cwe": ["CWE-400"], "project": "ovs", "commit_id": "79349cbab0b2a755140eedb91833ad2760520a83", "hash": 275645312661337417995271424048486867385, "size": 4, "message": "flow: Support extra padding length.\n\nAlthough not required, padding can be optionally added until\nthe packet length is MTU bytes. A packet with extra padding\ncurrently fails sanity checks.\n\nVulnerability: CVE-2020-35498\nFixes: fa8d9001a624 (\"miniflow_extract: Properly handle small IP packets.\")\nReported-by: Joakim Hindersson <joakim.hindersson@elastx.se>\nAcked-by: Ilya Maximets <i.maximets@ovn.org>\nSigned-off-by: Flavio Leitner <fbl@sysclose.org>\nSigned-off-by: Ilya Maximets <i.maximets@ovn.org>", "idx": 294}
{"func": "static void emit_mov_imm32(u8 **pprog, bool sign_propagate,\n\t\t\t   u32 dst_reg, const u32 imm32)\n{\n\tu8 *prog = *pprog;\n\tu8 b1, b2, b3;\n\tint cnt = 0;\n\n\t/*\n\t * Optimization: if imm32 is positive, use 'mov %eax, imm32'\n\t * (which zero-extends imm32) to save 2 bytes.\n\t */\n\tif (sign_propagate && (s32)imm32 < 0) {\n\t\t/* 'mov %rax, imm32' sign extends imm32 */\n\t\tb1 = add_1mod(0x48, dst_reg);\n\t\tb2 = 0xC7;\n\t\tb3 = 0xC0;\n\t\tEMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Optimization: if imm32 is zero, use 'xor %eax, %eax'\n\t * to save 3 bytes.\n\t */\n\tif (imm32 == 0) {\n\t\tif (is_ereg(dst_reg))\n\t\t\tEMIT1(add_2mod(0x40, dst_reg, dst_reg));\n\t\tb2 = 0x31; /* xor */\n\t\tb3 = 0xC0;\n\t\tEMIT2(b2, add_2reg(b3, dst_reg, dst_reg));\n\t\tgoto done;\n\t}\n\n\t/* mov %eax, imm32 */\n\tif (is_ereg(dst_reg))\n\t\tEMIT1(add_1mod(0x40, dst_reg));\n\tEMIT1_off32(add_1reg(0xB8, dst_reg), imm32);\ndone:\n\t*pprog = prog;\n}", "target": 0, "cwe": ["CWE-77"], "project": "linux", "commit_id": "e4d4d456436bfb2fe412ee2cd489f7658449b098", "hash": 157168120502437421067603969317525055005, "size": 40, "message": "bpf, x86: Validate computation of branch displacements for x86-64\n\nThe branch displacement logic in the BPF JIT compilers for x86 assumes\nthat, for any generated branch instruction, the distance cannot\nincrease between optimization passes.\n\nBut this assumption can be violated due to how the distances are\ncomputed. Specifically, whenever a backward branch is processed in\ndo_jit(), the distance is computed by subtracting the positions in the\nmachine code from different optimization passes. This is because part\nof addrs[] is already updated for the current optimization pass, before\nthe branch instruction is visited.\n\nAnd so the optimizer can expand blocks of machine code in some cases.\n\nThis can confuse the optimizer logic, where it assumes that a fixed\npoint has been reached for all machine code blocks once the total\nprogram size stops changing. And then the JIT compiler can output\nabnormal machine code containing incorrect branch displacements.\n\nTo mitigate this issue, we assert that a fixed point is reached while\npopulating the output image. This rejects any problematic programs.\nThe issue affects both x86-32 and x86-64. We mitigate separately to\nease backporting.\n\nSigned-off-by: Piotr Krysiuk <piotras@gmail.com>\nReviewed-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>", "idx": 295}
{"func": "int MAIN(int argc, char **argv)\n\t{\n\tENGINE *e = NULL;\n\tchar **args;\n\tchar *host = NULL, *port = NULL, *path = \"/\";\n\tchar *reqin = NULL, *respin = NULL;\n\tchar *reqout = NULL, *respout = NULL;\n\tchar *signfile = NULL, *keyfile = NULL;\n\tchar *rsignfile = NULL, *rkeyfile = NULL;\n\tchar *outfile = NULL;\n\tint add_nonce = 1, noverify = 0, use_ssl = -1;\n\tSTACK_OF(CONF_VALUE) *headers = NULL;\n\tOCSP_REQUEST *req = NULL;\n\tOCSP_RESPONSE *resp = NULL;\n\tOCSP_BASICRESP *bs = NULL;\n\tX509 *issuer = NULL, *cert = NULL;\n\tX509 *signer = NULL, *rsigner = NULL;\n\tEVP_PKEY *key = NULL, *rkey = NULL;\n\tBIO *acbio = NULL, *cbio = NULL;\n\tBIO *derbio = NULL;\n\tBIO *out = NULL;\n\tint req_timeout = -1;\n\tint req_text = 0, resp_text = 0;\n\tlong nsec = MAX_VALIDITY_PERIOD, maxage = -1;\n\tchar *CAfile = NULL, *CApath = NULL;\n\tX509_STORE *store = NULL;\n\tSTACK_OF(X509) *sign_other = NULL, *verify_other = NULL, *rother = NULL;\n\tchar *sign_certfile = NULL, *verify_certfile = NULL, *rcertfile = NULL;\n\tunsigned long sign_flags = 0, verify_flags = 0, rflags = 0;\n\tint ret = 1;\n\tint accept_count = -1;\n\tint badarg = 0;\n\tint i;\n\tint ignore_err = 0;\n\tSTACK_OF(OPENSSL_STRING) *reqnames = NULL;\n\tSTACK_OF(OCSP_CERTID) *ids = NULL;\n\n\tX509 *rca_cert = NULL;\n\tchar *ridx_filename = NULL;\n\tchar *rca_filename = NULL;\n\tCA_DB *rdb = NULL;\n\tint nmin = 0, ndays = -1;\n\tconst EVP_MD *cert_id_md = NULL;\n\n\tif (bio_err == NULL) bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n\n\tif (!load_config(bio_err, NULL))\n\t\tgoto end;\n\tSSL_load_error_strings();\n\tOpenSSL_add_ssl_algorithms();\n\targs = argv + 1;\n\treqnames = sk_OPENSSL_STRING_new_null();\n\tids = sk_OCSP_CERTID_new_null();\n\twhile (!badarg && *args && *args[0] == '-')\n\t\t{\n\t\tif (!strcmp(*args, \"-out\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\toutfile = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-timeout\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\treq_timeout = atol(*args);\n\t\t\t\tif (req_timeout < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t\t\t\"Illegal timeout value %s\\n\",\n\t\t\t\t\t\t*args);\n\t\t\t\t\tbadarg = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-url\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tif (!OCSP_parse_url(*args, &host, &port, &path, &use_ssl))\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err, \"Error parsing URL\\n\");\n\t\t\t\t\tbadarg = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-host\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\thost = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-port\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tport = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-header\"))\n\t\t\t{\n\t\t\tif (args[1] && args[2])\n\t\t\t\t{\n\t\t\t\tif (!X509V3_add_value(args[1], args[2], &headers))\n\t\t\t\t\tgoto end;\n\t\t\t\targs += 2;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-ignore_err\"))\n\t\t\tignore_err = 1;\n\t\telse if (!strcmp(*args, \"-noverify\"))\n\t\t\tnoverify = 1;\n\t\telse if (!strcmp(*args, \"-nonce\"))\n\t\t\tadd_nonce = 2;\n\t\telse if (!strcmp(*args, \"-no_nonce\"))\n\t\t\tadd_nonce = 0;\n\t\telse if (!strcmp(*args, \"-resp_no_certs\"))\n\t\t\trflags |= OCSP_NOCERTS;\n\t\telse if (!strcmp(*args, \"-resp_key_id\"))\n\t\t\trflags |= OCSP_RESPID_KEY;\n\t\telse if (!strcmp(*args, \"-no_certs\"))\n\t\t\tsign_flags |= OCSP_NOCERTS;\n\t\telse if (!strcmp(*args, \"-no_signature_verify\"))\n\t\t\tverify_flags |= OCSP_NOSIGS;\n\t\telse if (!strcmp(*args, \"-no_cert_verify\"))\n\t\t\tverify_flags |= OCSP_NOVERIFY;\n\t\telse if (!strcmp(*args, \"-no_chain\"))\n\t\t\tverify_flags |= OCSP_NOCHAIN;\n\t\telse if (!strcmp(*args, \"-no_cert_checks\"))\n\t\t\tverify_flags |= OCSP_NOCHECKS;\n\t\telse if (!strcmp(*args, \"-no_explicit\"))\n\t\t\tverify_flags |= OCSP_NOEXPLICIT;\n\t\telse if (!strcmp(*args, \"-trust_other\"))\n\t\t\tverify_flags |= OCSP_TRUSTOTHER;\n\t\telse if (!strcmp(*args, \"-no_intern\"))\n\t\t\tverify_flags |= OCSP_NOINTERN;\n\t\telse if (!strcmp(*args, \"-text\"))\n\t\t\t{\n\t\t\treq_text = 1;\n\t\t\tresp_text = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-req_text\"))\n\t\t\treq_text = 1;\n\t\telse if (!strcmp(*args, \"-resp_text\"))\n\t\t\tresp_text = 1;\n\t\telse if (!strcmp(*args, \"-reqin\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\treqin = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-respin\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\trespin = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-signer\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tsignfile = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp (*args, \"-VAfile\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tverify_certfile = *args;\n\t\t\t\tverify_flags |= OCSP_TRUSTOTHER;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-sign_other\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tsign_certfile = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-verify_other\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tverify_certfile = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp (*args, \"-CAfile\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tCAfile = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp (*args, \"-CApath\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tCApath = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp (*args, \"-validity_period\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tnsec = atol(*args);\n\t\t\t\tif (nsec < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t\t\t\"Illegal validity period %s\\n\",\n\t\t\t\t\t\t*args);\n\t\t\t\t\tbadarg = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp (*args, \"-status_age\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tmaxage = atol(*args);\n\t\t\t\tif (maxage < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t\t\t\"Illegal validity age %s\\n\",\n\t\t\t\t\t\t*args);\n\t\t\t\t\tbadarg = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\t else if (!strcmp(*args, \"-signkey\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tkeyfile = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-reqout\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\treqout = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-respout\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\trespout = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\t else if (!strcmp(*args, \"-path\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tpath = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-issuer\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tX509_free(issuer);\n\t\t\t\tissuer = load_cert(bio_err, *args, FORMAT_PEM,\n\t\t\t\t\tNULL, e, \"issuer certificate\");\n\t\t\t\tif(!issuer) goto end;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp (*args, \"-cert\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tX509_free(cert);\n\t\t\t\tcert = load_cert(bio_err, *args, FORMAT_PEM,\n\t\t\t\t\tNULL, e, \"certificate\");\n\t\t\t\tif(!cert) goto end;\n\t\t\t\tif (!cert_id_md) cert_id_md = EVP_sha1();\n\t\t\t\tif(!add_ocsp_cert(&req, cert, cert_id_md, issuer, ids))\n\t\t\t\t\tgoto end;\n\t\t\t\tif(!sk_OPENSSL_STRING_push(reqnames, *args))\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-serial\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tif (!cert_id_md) cert_id_md = EVP_sha1();\n\t\t\t\tif(!add_ocsp_serial(&req, *args, cert_id_md, issuer, ids))\n\t\t\t\t\tgoto end;\n\t\t\t\tif(!sk_OPENSSL_STRING_push(reqnames, *args))\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-index\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tridx_filename = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-CA\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\trca_filename = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp (*args, \"-nmin\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tnmin = atol(*args);\n\t\t\t\tif (nmin < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t\t\t\"Illegal update period %s\\n\",\n\t\t\t\t\t\t*args);\n\t\t\t\t\tbadarg = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ndays == -1)\n\t\t\t\t\tndays = 0;\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp (*args, \"-nrequest\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\taccept_count = atol(*args);\n\t\t\t\tif (accept_count < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t\t\t\"Illegal accept count %s\\n\",\n\t\t\t\t\t\t*args);\n\t\t\t\t\tbadarg = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp (*args, \"-ndays\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\tndays = atol(*args);\n\t\t\t\tif (ndays < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t\t\t\"Illegal update period %s\\n\",\n\t\t\t\t\t\t*args);\n\t\t\t\t\tbadarg = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-rsigner\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\trsignfile = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-rkey\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\trkeyfile = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if (!strcmp(*args, \"-rother\"))\n\t\t\t{\n\t\t\tif (args[1])\n\t\t\t\t{\n\t\t\t\targs++;\n\t\t\t\trcertfile = *args;\n\t\t\t\t}\n\t\t\telse badarg = 1;\n\t\t\t}\n\t\telse if ((cert_id_md = EVP_get_digestbyname((*args)+1))==NULL)\n\t\t\t{\n\t\t\tbadarg = 1;\n\t\t\t}\n\t\targs++;\n\t\t}\n\n\t/* Have we anything to do? */\n\tif (!req && !reqin && !respin && !(port && ridx_filename)) badarg = 1;\n\n\tif (badarg)\n\t\t{\n\t\tBIO_printf (bio_err, \"OCSP utility\\n\");\n\t\tBIO_printf (bio_err, \"Usage ocsp [options]\\n\");\n\t\tBIO_printf (bio_err, \"where options are\\n\");\n\t\tBIO_printf (bio_err, \"-out file          output filename\\n\");\n\t\tBIO_printf (bio_err, \"-issuer file       issuer certificate\\n\");\n\t\tBIO_printf (bio_err, \"-cert file         certificate to check\\n\");\n\t\tBIO_printf (bio_err, \"-serial n          serial number to check\\n\");\n\t\tBIO_printf (bio_err, \"-signer file       certificate to sign OCSP request with\\n\");\n\t\tBIO_printf (bio_err, \"-signkey file      private key to sign OCSP request with\\n\");\n\t\tBIO_printf (bio_err, \"-sign_other file   additional certificates to include in signed request\\n\");\n\t\tBIO_printf (bio_err, \"-no_certs          don't include any certificates in signed request\\n\");\n\t\tBIO_printf (bio_err, \"-req_text          print text form of request\\n\");\n\t\tBIO_printf (bio_err, \"-resp_text         print text form of response\\n\");\n\t\tBIO_printf (bio_err, \"-text              print text form of request and response\\n\");\n\t\tBIO_printf (bio_err, \"-reqout file       write DER encoded OCSP request to \\\"file\\\"\\n\");\n\t\tBIO_printf (bio_err, \"-respout file      write DER encoded OCSP reponse to \\\"file\\\"\\n\");\n\t\tBIO_printf (bio_err, \"-reqin file        read DER encoded OCSP request from \\\"file\\\"\\n\");\n\t\tBIO_printf (bio_err, \"-respin file       read DER encoded OCSP reponse from \\\"file\\\"\\n\");\n\t\tBIO_printf (bio_err, \"-nonce             add OCSP nonce to request\\n\");\n\t\tBIO_printf (bio_err, \"-no_nonce          don't add OCSP nonce to request\\n\");\n\t\tBIO_printf (bio_err, \"-url URL           OCSP responder URL\\n\");\n\t\tBIO_printf (bio_err, \"-host host:n       send OCSP request to host on port n\\n\");\n\t\tBIO_printf (bio_err, \"-path              path to use in OCSP request\\n\");\n\t\tBIO_printf (bio_err, \"-CApath dir        trusted certificates directory\\n\");\n\t\tBIO_printf (bio_err, \"-CAfile file       trusted certificates file\\n\");\n\t\tBIO_printf (bio_err, \"-VAfile file       validator certificates file\\n\");\n\t\tBIO_printf (bio_err, \"-validity_period n maximum validity discrepancy in seconds\\n\");\n\t\tBIO_printf (bio_err, \"-status_age n      maximum status age in seconds\\n\");\n\t\tBIO_printf (bio_err, \"-noverify          don't verify response at all\\n\");\n\t\tBIO_printf (bio_err, \"-verify_other file additional certificates to search for signer\\n\");\n\t\tBIO_printf (bio_err, \"-trust_other       don't verify additional certificates\\n\");\n\t\tBIO_printf (bio_err, \"-no_intern         don't search certificates contained in response for signer\\n\");\n\t\tBIO_printf (bio_err, \"-no_signature_verify don't check signature on response\\n\");\n\t\tBIO_printf (bio_err, \"-no_cert_verify    don't check signing certificate\\n\");\n\t\tBIO_printf (bio_err, \"-no_chain          don't chain verify response\\n\");\n\t\tBIO_printf (bio_err, \"-no_cert_checks    don't do additional checks on signing certificate\\n\");\n\t\tBIO_printf (bio_err, \"-port num\t\t port to run responder on\\n\");\n\t\tBIO_printf (bio_err, \"-index file\t certificate status index file\\n\");\n\t\tBIO_printf (bio_err, \"-CA file\t\t CA certificate\\n\");\n\t\tBIO_printf (bio_err, \"-rsigner file\t responder certificate to sign responses with\\n\");\n\t\tBIO_printf (bio_err, \"-rkey file\t responder key to sign responses with\\n\");\n\t\tBIO_printf (bio_err, \"-rother file\t other certificates to include in response\\n\");\n\t\tBIO_printf (bio_err, \"-resp_no_certs     don't include any certificates in response\\n\");\n\t\tBIO_printf (bio_err, \"-nmin n\t \t number of minutes before next update\\n\");\n\t\tBIO_printf (bio_err, \"-ndays n\t \t number of days before next update\\n\");\n\t\tBIO_printf (bio_err, \"-resp_key_id       identify reponse by signing certificate key ID\\n\");\n\t\tBIO_printf (bio_err, \"-nrequest n        number of requests to accept (default unlimited)\\n\");\n\t\tBIO_printf (bio_err, \"-<dgst alg>     use specified digest in the request\");\n\t\tgoto end;\n\t\t}\n\n\tif(outfile) out = BIO_new_file(outfile, \"w\");\n\telse out = BIO_new_fp(stdout, BIO_NOCLOSE);\n\n\tif(!out)\n\t\t{\n\t\tBIO_printf(bio_err, \"Error opening output file\\n\");\n\t\tgoto end;\n\t\t}\n\n\tif (!req && (add_nonce != 2)) add_nonce = 0;\n\n\tif (!req && reqin)\n\t\t{\n\t\tderbio = BIO_new_file(reqin, \"rb\");\n\t\tif (!derbio)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Error Opening OCSP request file\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\treq = d2i_OCSP_REQUEST_bio(derbio, NULL);\n\t\tBIO_free(derbio);\n\t\tif(!req)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Error reading OCSP request\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif (!req && port)\n\t\t{\n\t\tacbio = init_responder(port);\n\t\tif (!acbio)\n\t\t\tgoto end;\n\t\t}\n\n\tif (rsignfile && !rdb)\n\t\t{\n\t\tif (!rkeyfile) rkeyfile = rsignfile;\n\t\trsigner = load_cert(bio_err, rsignfile, FORMAT_PEM,\n\t\t\tNULL, e, \"responder certificate\");\n\t\tif (!rsigner)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Error loading responder certificate\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\trca_cert = load_cert(bio_err, rca_filename, FORMAT_PEM,\n\t\t\tNULL, e, \"CA certificate\");\n\t\tif (rcertfile)\n\t\t\t{\n\t\t\trother = load_certs(bio_err, rcertfile, FORMAT_PEM,\n\t\t\t\tNULL, e, \"responder other certificates\");\n\t\t\tif (!rother) goto end;\n\t\t\t}\n\t\trkey = load_key(bio_err, rkeyfile, FORMAT_PEM, 0, NULL, NULL,\n\t\t\t\"responder private key\");\n\t\tif (!rkey)\n\t\t\tgoto end;\n\t\t}\n\tif(acbio)\n\t\tBIO_printf(bio_err, \"Waiting for OCSP client connections...\\n\");\n\n\tredo_accept:\n\n\tif (acbio)\n\t\t{\n\t\tif (!do_responder(&req, &cbio, acbio, port))\n\t\t\tgoto end;\n\t\tif (!req)\n\t\t\t{\n\t\t\tresp = OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, NULL);\n\t\t\tsend_ocsp_response(cbio, resp);\n\t\t\tgoto done_resp;\n\t\t\t}\n\t\t}\n\n\tif (!req && (signfile || reqout || host || add_nonce || ridx_filename))\n\t\t{\n\t\tBIO_printf(bio_err, \"Need an OCSP request for this operation!\\n\");\n\t\tgoto end;\n\t\t}\n\n\tif (req && add_nonce) OCSP_request_add1_nonce(req, NULL, -1);\n\n\tif (signfile)\n\t\t{\n\t\tif (!keyfile) keyfile = signfile;\n\t\tsigner = load_cert(bio_err, signfile, FORMAT_PEM,\n\t\t\tNULL, e, \"signer certificate\");\n\t\tif (!signer)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Error loading signer certificate\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tif (sign_certfile)\n\t\t\t{\n\t\t\tsign_other = load_certs(bio_err, sign_certfile, FORMAT_PEM,\n\t\t\t\tNULL, e, \"signer certificates\");\n\t\t\tif (!sign_other) goto end;\n\t\t\t}\n\t\tkey = load_key(bio_err, keyfile, FORMAT_PEM, 0, NULL, NULL,\n\t\t\t\"signer private key\");\n\t\tif (!key)\n\t\t\tgoto end;\n\n\t\tif (!OCSP_request_sign(req, signer, key, NULL, sign_other, sign_flags))\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Error signing OCSP request\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif (req_text && req) OCSP_REQUEST_print(out, req, 0);\n\n\tif (reqout)\n\t\t{\n\t\tderbio = BIO_new_file(reqout, \"wb\");\n\t\tif(!derbio)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Error opening file %s\\n\", reqout);\n\t\t\tgoto end;\n\t\t\t}\n\t\ti2d_OCSP_REQUEST_bio(derbio, req);\n\t\tBIO_free(derbio);\n\t\t}\n\n\tif (ridx_filename && (!rkey || !rsigner || !rca_cert))\n\t\t{\n\t\tBIO_printf(bio_err, \"Need a responder certificate, key and CA for this operation!\\n\");\n\t\tgoto end;\n\t\t}\n\n\tif (ridx_filename && !rdb)\n\t\t{\n\t\trdb = load_index(ridx_filename, NULL);\n\t\tif (!rdb) goto end;\n\t\tif (!index_index(rdb)) goto end;\n\t\t}\n\n\tif (rdb)\n\t\t{\n\t\ti = make_ocsp_response(&resp, req, rdb, rca_cert, rsigner, rkey, rother, rflags, nmin, ndays);\n\t\tif (cbio)\n\t\t\tsend_ocsp_response(cbio, resp);\n\t\t}\n\telse if (host)\n\t\t{\n#ifndef OPENSSL_NO_SOCK\n\t\tresp = process_responder(bio_err, req, host, path,\n\t\t\t\t\tport, use_ssl, headers, req_timeout);\n\t\tif (!resp)\n\t\t\tgoto end;\n#else\n\t\tBIO_printf(bio_err, \"Error creating connect BIO - sockets not supported.\\n\");\n\t\tgoto end;\n#endif\n\t\t}\n\telse if (respin)\n\t\t{\n\t\tderbio = BIO_new_file(respin, \"rb\");\n\t\tif (!derbio)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Error Opening OCSP response file\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tresp = d2i_OCSP_RESPONSE_bio(derbio, NULL);\n\t\tBIO_free(derbio);\n\t\tif(!resp)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Error reading OCSP response\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\n\t\t}\n\telse\n\t\t{\n\t\tret = 0;\n\t\tgoto end;\n\t\t}\n\n\tdone_resp:\n\n\tif (respout)\n\t\t{\n\t\tderbio = BIO_new_file(respout, \"wb\");\n\t\tif(!derbio)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Error opening file %s\\n\", respout);\n\t\t\tgoto end;\n\t\t\t}\n\t\ti2d_OCSP_RESPONSE_bio(derbio, resp);\n\t\tBIO_free(derbio);\n\t\t}\n\n\ti = OCSP_response_status(resp);\n\n\tif (i != OCSP_RESPONSE_STATUS_SUCCESSFUL)\n\t\t{\n\t\tBIO_printf(out, \"Responder Error: %s (%d)\\n\",\n\t\t\t\tOCSP_response_status_str(i), i);\n\t\tif (ignore_err)\n\t\t\tgoto redo_accept;\n\t\tret = 0;\n\t\tgoto end;\n\t\t}\n\n\tif (resp_text) OCSP_RESPONSE_print(out, resp, 0);\n\n\t/* If running as responder don't verify our own response */\n\tif (cbio)\n\t\t{\n\t\tif (accept_count > 0)\n\t\t\taccept_count--;\n\t\t/* Redo if more connections needed */\n\t\tif (accept_count)\n\t\t\t{\n\t\t\tBIO_free_all(cbio);\n\t\t\tcbio = NULL;\n\t\t\tOCSP_REQUEST_free(req);\n\t\t\treq = NULL;\n\t\t\tOCSP_RESPONSE_free(resp);\n\t\t\tresp = NULL;\n\t\t\tgoto redo_accept;\n\t\t\t}\n\t\tgoto end;\n\t\t}\n\n\tif (!store)\n\t\tstore = setup_verify(bio_err, CAfile, CApath);\n\tif (!store)\n\t\tgoto end;\n\tif (verify_certfile)\n\t\t{\n\t\tverify_other = load_certs(bio_err, verify_certfile, FORMAT_PEM,\n\t\t\tNULL, e, \"validator certificate\");\n\t\tif (!verify_other) goto end;\n\t\t}\n\n\tbs = OCSP_response_get1_basic(resp);\n\n\tif (!bs)\n\t\t{\n\t\tBIO_printf(bio_err, \"Error parsing response\\n\");\n\t\tgoto end;\n\t\t}\n\n\tif (!noverify)\n\t\t{\n\t\tif (req && ((i = OCSP_check_nonce(req, bs)) <= 0))\n\t\t\t{\n\t\t\tif (i == -1)\n\t\t\t\tBIO_printf(bio_err, \"WARNING: no nonce in response\\n\");\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err, \"Nonce Verify error\\n\");\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\n\t\ti = OCSP_basic_verify(bs, verify_other, store, verify_flags);\n                if (i < 0) i = OCSP_basic_verify(bs, NULL, store, 0);\n\n\t\tif(i <= 0)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"Response Verify Failure\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\t}\n\t\telse\n\t\t\tBIO_printf(bio_err, \"Response verify OK\\n\");\n\n\t\t}\n\n\tif (!print_ocsp_summary(out, bs, req, reqnames, ids, nsec, maxage))\n\t\tgoto end;\n\n\tret = 0;\n\nend:\n\tERR_print_errors(bio_err);\n\tX509_free(signer);\n\tX509_STORE_free(store);\n\tEVP_PKEY_free(key);\n\tEVP_PKEY_free(rkey);\n\tX509_free(issuer);\n\tX509_free(cert);\n\tX509_free(rsigner);\n\tX509_free(rca_cert);\n\tfree_index(rdb);\n\tBIO_free_all(cbio);\n\tBIO_free_all(acbio);\n\tBIO_free(out);\n\tOCSP_REQUEST_free(req);\n\tOCSP_RESPONSE_free(resp);\n\tOCSP_BASICRESP_free(bs);\n\tsk_OPENSSL_STRING_free(reqnames);\n\tsk_OCSP_CERTID_free(ids);\n\tsk_X509_pop_free(sign_other, X509_free);\n\tsk_X509_pop_free(verify_other, X509_free);\n\tsk_CONF_VALUE_pop_free(headers, X509V3_conf_free);\n\n\tif (use_ssl != -1)\n\t\t{\n\t\tOPENSSL_free(host);\n\t\tOPENSSL_free(port);\n\t\tOPENSSL_free(path);\n\t\t}\n\n\tOPENSSL_EXIT(ret);\n}", "target": 1, "cwe": [], "project": "openssl", "commit_id": "d65b8b2162f33ac0d53dace588a0847ed827626c", "hash": 132295383346764678944134852566948884065, "size": 807, "message": "Backport OCSP fixes.", "idx": 296}
{"func": "Status ParseActivationMode(OpKernelConstruction* context,\n                           FusedBatchNormActivationMode* activation_mode) {\n  string activation_mode_str;\n  TF_RETURN_IF_ERROR(context->GetAttr(\"activation_mode\", &activation_mode_str));\n\n  if (activation_mode_str == \"Identity\") {\n    *activation_mode = FusedBatchNormActivationMode::kIdentity;\n    return Status::OK();\n  }\n  if (activation_mode_str == \"Relu\") {\n    *activation_mode = FusedBatchNormActivationMode::kRelu;\n    return Status::OK();\n  }\n  return errors::InvalidArgument(\"Unsupported activation mode: \",\n                                 activation_mode_str);\n}", "target": 0, "cwe": ["CWE-476", "CWE-703"], "project": "tensorflow", "commit_id": "6972f9dfe325636b3db4e0bc517ee22a159365c0", "hash": 286665720069751406728375378898840474372, "size": 16, "message": "Add missing valuidation to FusedBatchNorm.\n\nPiperOrigin-RevId: 372460336\nChange-Id: Ic8c4e4de67c58a741bd87f2e182bed07247d1126", "idx": 297}
{"func": "static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize  TSRMLS_DC)\n{\n\tint\ti = 0;\n\tint\tcur_arr_len = 0;\n\tint result = 0;\n\n\tchar* lang_tag = NULL;\n\tzval** ele_value = NULL;\n\tchar** cur_arr = NULL;\n\n\tchar* cur_loc_range\t= NULL;\n\tchar* can_loc_range\t= NULL;\n\tint\tsaved_pos = 0;\n\n\tchar* return_value = NULL;\n\n\tcur_arr = ecalloc(zend_hash_num_elements(hash_arr)*2, sizeof(char *));\n\t/* convert the array to lowercase , also replace hyphens with the underscore and store it in cur_arr */\n\tfor(zend_hash_internal_pointer_reset(hash_arr);\n\t\tzend_hash_has_more_elements(hash_arr) == SUCCESS;\n\t\tzend_hash_move_forward(hash_arr)) {\n\t\t\n\t\tif (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {\n\t\t\t/* Should never actually fail since the key is known to exist.*/\n\t\t\tcontinue;\n\t\t}\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING) {\n\t\t\t/* element value is not a string */\n\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: locale array element is not a string\", 0 TSRMLS_CC);\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t} \n\t\tcur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));\n\t\tresult = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);\n\t\tif(result == 0) {\n\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\", 0 TSRMLS_CC);\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t}\n\t\tcur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);\n\t\tcur_arr_len++ ; \n\t} /* end of for */\n\n\t/* Canonicalize array elements */\n\tif(canonicalize) {\n\t\tfor(i=0; i<cur_arr_len; i++) { \n\t\t\tlang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);\n\t\t\tif(result != 1 || lang_tag == NULL || !lang_tag[0]) {\n\t\t\t\tif(lang_tag) {\n\t\t\t\t\tefree(lang_tag);\n\t\t\t\t}\n\t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n\t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t\t}\n\t\t\tcur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);\n\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\t\n\t\t\tefree(lang_tag);\n\t\t\tif(result == 0) {\n\t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n\t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif(canonicalize) {\n\t\t/* Canonicalize the loc_range */\n\t\tcan_loc_range = get_icu_value_internal(loc_range, LOC_CANONICALIZE_TAG, &result , 0);\n\t\tif( result != 1 || can_loc_range == NULL || !can_loc_range[0]) {\n\t\t\t/* Error */\n\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize loc_range\" , 0 TSRMLS_CC );\n\t\t\tif(can_loc_range) {\n\t\t\t\tefree(can_loc_range);\n\t\t\t}\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t} else {\n\t\t\tloc_range = can_loc_range;\n\t\t}\n\t} \n\n\tcur_loc_range = ecalloc(1, strlen(loc_range)+1);\n\t/* convert to lower and replace hyphens */\n\tresult = strToMatch(loc_range, cur_loc_range);\t\n\tif(can_loc_range) {\n\t\tefree(can_loc_range);\n\t}\n\tif(result == 0) {\n\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t}\n\n\t/* Lookup for the lang_tag match */\n\tsaved_pos = strlen(cur_loc_range);\n\twhile(saved_pos > 0) {\n\t\tfor(i=0; i< cur_arr_len; i++){ \n\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\t\n\t\t\t\t/* Match found */\n\t\t\t\treturn_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);\n\t\t\t\tefree(cur_loc_range);\n\t\t\t\tLOOKUP_CLEAN_RETURN(return_value);\n\t\t\t}\n\t\t}\n\t\tsaved_pos = getStrrtokenPos(cur_loc_range, saved_pos);\n\t}\n\n\t/* Match not found */\n\tefree(cur_loc_range);\n\tLOOKUP_CLEAN_RETURN(NULL);\n}", "target": 1, "cwe": ["CWE-125"], "project": "php-src", "commit_id": "97eff7eb57fc2320c267a949cffd622c38712484", "hash": 72022643148841675151906754348599399764, "size": 107, "message": "Fix bug #72241: get_icu_value_internal out-of-bounds read", "idx": 298}
{"func": "pqEndcopy3(PGconn *conn)\n{\n\tPGresult   *result;\n\n\tif (conn->asyncStatus != PGASYNC_COPY_IN &&\n\t\tconn->asyncStatus != PGASYNC_COPY_OUT &&\n\t\tconn->asyncStatus != PGASYNC_COPY_BOTH)\n\t{\n\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"no COPY in progress\\n\"));\n\t\treturn 1;\n\t}\n\n\t/* Send the CopyDone message if needed */\n\tif (conn->asyncStatus == PGASYNC_COPY_IN ||\n\t\tconn->asyncStatus == PGASYNC_COPY_BOTH)\n\t{\n\t\tif (pqPutMsgStart('c', false, conn) < 0 ||\n\t\t\tpqPutMsgEnd(conn) < 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * If we sent the COPY command in extended-query mode, we must issue a\n\t\t * Sync as well.\n\t\t */\n\t\tif (conn->queryclass != PGQUERY_SIMPLE)\n\t\t{\n\t\t\tif (pqPutMsgStart('S', false, conn) < 0 ||\n\t\t\t\tpqPutMsgEnd(conn) < 0)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * make sure no data is waiting to be sent, abort if we are non-blocking\n\t * and the flush fails\n\t */\n\tif (pqFlush(conn) && pqIsnonblocking(conn))\n\t\treturn 1;\n\n\t/* Return to active duty */\n\tconn->asyncStatus = PGASYNC_BUSY;\n\tresetPQExpBuffer(&conn->errorMessage);\n\n\t/*\n\t * Non blocking connections may have to abort at this point.  If everyone\n\t * played the game there should be no problem, but in error scenarios the\n\t * expected messages may not have arrived yet.\t(We are assuming that the\n\t * backend's packetizing will ensure that CommandComplete arrives along\n\t * with the CopyDone; are there corner cases where that doesn't happen?)\n\t */\n\tif (pqIsnonblocking(conn) && PQisBusy(conn))\n\t\treturn 1;\n\n\t/* Wait for the completion response */\n\tresult = PQgetResult(conn);\n\n\t/* Expecting a successful result */\n\tif (result && result->resultStatus == PGRES_COMMAND_OK)\n\t{\n\t\tPQclear(result);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Trouble. For backwards-compatibility reasons, we issue the error\n\t * message as if it were a notice (would be nice to get rid of this\n\t * silliness, but too many apps probably don't handle errors from\n\t * PQendcopy reasonably).  Note that the app can still obtain the error\n\t * status from the PGconn object.\n\t */\n\tif (conn->errorMessage.len > 0)\n\t{\n\t\t/* We have to strip the trailing newline ... pain in neck... */\n\t\tchar\t\tsvLast = conn->errorMessage.data[conn->errorMessage.len - 1];\n\n\t\tif (svLast == '\\n')\n\t\t\tconn->errorMessage.data[conn->errorMessage.len - 1] = '\\0';\n\t\tpqInternalNotice(&conn->noticeHooks, \"%s\", conn->errorMessage.data);\n\t\tconn->errorMessage.data[conn->errorMessage.len - 1] = svLast;\n\t}\n\n\tPQclear(result);\n\n\treturn 1;\n}", "target": 0, "cwe": ["CWE-119"], "project": "postgres", "commit_id": "01824385aead50e557ca1af28640460fa9877d51", "hash": 67931453728078930687027123350880567147, "size": 86, "message": "Prevent potential overruns of fixed-size buffers.\n\nCoverity identified a number of places in which it couldn't prove that a\nstring being copied into a fixed-size buffer would fit.  We believe that\nmost, perhaps all of these are in fact safe, or are copying data that is\ncoming from a trusted source so that any overrun is not really a security\nissue.  Nonetheless it seems prudent to forestall any risk by using\nstrlcpy() and similar functions.\n\nFixes by Peter Eisentraut and Jozef Mlich based on Coverity reports.\n\nIn addition, fix a potential null-pointer-dereference crash in\ncontrib/chkpass.  The crypt(3) function is defined to return NULL on\nfailure, but chkpass.c didn't check for that before using the result.\nThe main practical case in which this could be an issue is if libc is\nconfigured to refuse to execute unapproved hashing algorithms (e.g.,\n\"FIPS mode\").  This ideally should've been a separate commit, but\nsince it touches code adjacent to one of the buffer overrun changes,\nI included it in this commit to avoid last-minute merge issues.\nThis issue was reported by Honza Horak.\n\nSecurity: CVE-2014-0065 for buffer overruns, CVE-2014-0066 for crypt()", "idx": 299}
{"func": "ignore_dot_names (name)\n     char *name;\n{\n  return (name[0] != '.');\n}", "target": 0, "cwe": ["CWE-20"], "project": "bash", "commit_id": "4f747edc625815f449048579f6e65869914dd715", "hash": 148052930724697890791538024838524799442, "size": 5, "message": "Bash-4.4 patch 7", "idx": 300}
{"func": "Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(\n    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {\n    invariant(*itr == this);\n\n    if (std::next(itr) == container->end()) {\n        return container->end();\n    }\n\n    // If we are not already handling an $unwind stage internally, we can combine with the following\n    // $unwind stage.\n    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());\n    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {\n        _unwind = std::move(nextUnwind);\n        container->erase(std::next(itr));\n        return itr;\n    }\n    return std::next(itr);\n}", "target": 0, "cwe": ["CWE-416"], "project": "mongo", "commit_id": "d6133a3a5464fac202f512b0310dfeb200c126f9", "hash": 248801652689052200993673117489958980731, "size": 18, "message": "SERVER-43350 $lookup with no local default or user-specified collation should explicitly set the simple collation on the foreign expression context", "idx": 301}
{"func": "TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {\n  const std::string yaml_string = R\"EOF(\n  stat_prefix: ingress_http\n  server_header_transformation: APPEND_IF_ABSENT\n  route_config:\n    name: local_route\n  http_filters:\n  - name: envoy.filters.http.router\n  )EOF\";\n\n  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))\n      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,\n                             &Runtime::MockSnapshot::featureEnabledDefault));\n  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,\n                                     date_provider_, route_config_provider_manager_,\n                                     scoped_routes_config_provider_manager_, http_tracer_manager_,\n                                     filter_config_provider_manager_);\n  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,\n            config.serverHeaderTransformation());\n}", "target": 0, "cwe": ["CWE-22"], "project": "envoy", "commit_id": "5333b928d8bcffa26ab19bf018369a835f697585", "hash": 160881667880031969650662785352534360161, "size": 20, "message": "Implement handling of escaped slash characters in URL path\n\nFixes: CVE-2021-29492\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>", "idx": 302}
{"func": "xmlRegExecPushStringInternal(xmlRegExecCtxtPtr exec, const xmlChar *value,\n\t                     void *data, int compound) {\n    xmlRegTransPtr trans;\n    xmlRegAtomPtr atom;\n    int ret;\n    int final = 0;\n    int progress = 1;\n\n    if (exec == NULL)\n\treturn(-1);\n    if (exec->comp == NULL)\n\treturn(-1);\n    if (exec->status != 0)\n\treturn(exec->status);\n\n    if (exec->comp->compact != NULL)\n\treturn(xmlRegCompactPushString(exec, exec->comp, value, data));\n\n    if (value == NULL) {\n        if (exec->state->type == XML_REGEXP_FINAL_STATE)\n\t    return(1);\n\tfinal = 1;\n    }\n\n#ifdef DEBUG_PUSH\n    printf(\"value pushed: %s\\n\", value);\n#endif\n    /*\n     * If we have an active rollback stack push the new value there\n     * and get back to where we were left\n     */\n    if ((value != NULL) && (exec->inputStackNr > 0)) {\n\txmlFARegExecSaveInputString(exec, value, data);\n\tvalue = exec->inputStack[exec->index].value;\n\tdata = exec->inputStack[exec->index].data;\n#ifdef DEBUG_PUSH\n\tprintf(\"value loaded: %s\\n\", value);\n#endif\n    }\n\n    while ((exec->status == 0) &&\n\t   ((value != NULL) ||\n\t    ((final == 1) &&\n\t     (exec->state->type != XML_REGEXP_FINAL_STATE)))) {\n\n\t/*\n\t * End of input on non-terminal state, rollback, however we may\n\t * still have epsilon like transition for counted transitions\n\t * on counters, in that case don't break too early.\n\t */\n\tif ((value == NULL) && (exec->counts == NULL))\n\t    goto rollback;\n\n\texec->transcount = 0;\n\tfor (;exec->transno < exec->state->nbTrans;exec->transno++) {\n\t    trans = &exec->state->trans[exec->transno];\n\t    if (trans->to < 0)\n\t\tcontinue;\n\t    atom = trans->atom;\n\t    ret = 0;\n\t    if (trans->count == REGEXP_ALL_LAX_COUNTER) {\n\t\tint i;\n\t\tint count;\n\t\txmlRegTransPtr t;\n\t\txmlRegCounterPtr counter;\n\n\t\tret = 0;\n\n#ifdef DEBUG_PUSH\n\t\tprintf(\"testing all lax %d\\n\", trans->count);\n#endif\n\t\t/*\n\t\t * Check all counted transitions from the current state\n\t\t */\n\t\tif ((value == NULL) && (final)) {\n\t\t    ret = 1;\n\t\t} else if (value != NULL) {\n\t\t    for (i = 0;i < exec->state->nbTrans;i++) {\n\t\t\tt = &exec->state->trans[i];\n\t\t\tif ((t->counter < 0) || (t == trans))\n\t\t\t    continue;\n\t\t\tcounter = &exec->comp->counters[t->counter];\n\t\t\tcount = exec->counts[t->counter];\n\t\t\tif ((count < counter->max) &&\n\t\t            (t->atom != NULL) &&\n\t\t\t    (xmlStrEqual(value, t->atom->valuep))) {\n\t\t\t    ret = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif ((count >= counter->min) &&\n\t\t\t    (count < counter->max) &&\n\t\t\t    (t->atom != NULL) &&\n\t\t\t    (xmlStrEqual(value, t->atom->valuep))) {\n\t\t\t    ret = 1;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } else if (trans->count == REGEXP_ALL_COUNTER) {\n\t\tint i;\n\t\tint count;\n\t\txmlRegTransPtr t;\n\t\txmlRegCounterPtr counter;\n\n\t\tret = 1;\n\n#ifdef DEBUG_PUSH\n\t\tprintf(\"testing all %d\\n\", trans->count);\n#endif\n\t\t/*\n\t\t * Check all counted transitions from the current state\n\t\t */\n\t\tfor (i = 0;i < exec->state->nbTrans;i++) {\n                    t = &exec->state->trans[i];\n\t\t    if ((t->counter < 0) || (t == trans))\n\t\t\tcontinue;\n                    counter = &exec->comp->counters[t->counter];\n\t\t    count = exec->counts[t->counter];\n\t\t    if ((count < counter->min) || (count > counter->max)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    } else if (trans->count >= 0) {\n\t\tint count;\n\t\txmlRegCounterPtr counter;\n\n\t\t/*\n\t\t * A counted transition.\n\t\t */\n\n\t\tcount = exec->counts[trans->count];\n\t\tcounter = &exec->comp->counters[trans->count];\n#ifdef DEBUG_PUSH\n\t\tprintf(\"testing count %d: val %d, min %d, max %d\\n\",\n\t\t       trans->count, count, counter->min,  counter->max);\n#endif\n\t\tret = ((count >= counter->min) && (count <= counter->max));\n\t    } else if (atom == NULL) {\n\t\tfprintf(stderr, \"epsilon transition left at runtime\\n\");\n\t\texec->status = -2;\n\t\tbreak;\n\t    } else if (value != NULL) {\n\t\tret = xmlRegStrEqualWildcard(atom->valuep, value);\n\t\tif (atom->neg) {\n\t\t    ret = !ret;\n\t\t    if (!compound)\n\t\t        ret = 0;\n\t\t}\n\t\tif ((ret == 1) && (trans->counter >= 0)) {\n\t\t    xmlRegCounterPtr counter;\n\t\t    int count;\n\n\t\t    count = exec->counts[trans->counter];\n\t\t    counter = &exec->comp->counters[trans->counter];\n\t\t    if (count >= counter->max)\n\t\t\tret = 0;\n\t\t}\n\n\t\tif ((ret == 1) && (atom->min > 0) && (atom->max > 0)) {\n\t\t    xmlRegStatePtr to = exec->comp->states[trans->to];\n\n\t\t    /*\n\t\t     * this is a multiple input sequence\n\t\t     */\n\t\t    if (exec->state->nbTrans > exec->transno + 1) {\n\t\t\tif (exec->inputStackNr <= 0) {\n\t\t\t    xmlFARegExecSaveInputString(exec, value, data);\n\t\t\t}\n\t\t\txmlFARegExecSave(exec);\n\t\t    }\n\t\t    exec->transcount = 1;\n\t\t    do {\n\t\t\t/*\n\t\t\t * Try to progress as much as possible on the input\n\t\t\t */\n\t\t\tif (exec->transcount == atom->max) {\n\t\t\t    break;\n\t\t\t}\n\t\t\texec->index++;\n\t\t\tvalue = exec->inputStack[exec->index].value;\n\t\t\tdata = exec->inputStack[exec->index].data;\n#ifdef DEBUG_PUSH\n\t\t\tprintf(\"value loaded: %s\\n\", value);\n#endif\n\n\t\t\t/*\n\t\t\t * End of input: stop here\n\t\t\t */\n\t\t\tif (value == NULL) {\n\t\t\t    exec->index --;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (exec->transcount >= atom->min) {\n\t\t\t    int transno = exec->transno;\n\t\t\t    xmlRegStatePtr state = exec->state;\n\n\t\t\t    /*\n\t\t\t     * The transition is acceptable save it\n\t\t\t     */\n\t\t\t    exec->transno = -1; /* trick */\n\t\t\t    exec->state = to;\n\t\t\t    if (exec->inputStackNr <= 0) {\n\t\t\t\txmlFARegExecSaveInputString(exec, value, data);\n\t\t\t    }\n\t\t\t    xmlFARegExecSave(exec);\n\t\t\t    exec->transno = transno;\n\t\t\t    exec->state = state;\n\t\t\t}\n\t\t\tret = xmlStrEqual(value, atom->valuep);\n\t\t\texec->transcount++;\n\t\t    } while (ret == 1);\n\t\t    if (exec->transcount < atom->min)\n\t\t\tret = 0;\n\n\t\t    /*\n\t\t     * If the last check failed but one transition was found\n\t\t     * possible, rollback\n\t\t     */\n\t\t    if (ret < 0)\n\t\t\tret = 0;\n\t\t    if (ret == 0) {\n\t\t\tgoto rollback;\n\t\t    }\n\t\t}\n\t    }\n\t    if (ret == 1) {\n\t\tif ((exec->callback != NULL) && (atom != NULL) &&\n\t\t\t(data != NULL)) {\n\t\t    exec->callback(exec->data, atom->valuep,\n\t\t\t           atom->data, data);\n\t\t}\n\t\tif (exec->state->nbTrans > exec->transno + 1) {\n\t\t    if (exec->inputStackNr <= 0) {\n\t\t\txmlFARegExecSaveInputString(exec, value, data);\n\t\t    }\n\t\t    xmlFARegExecSave(exec);\n\t\t}\n\t\tif (trans->counter >= 0) {\n#ifdef DEBUG_PUSH\n\t\t    printf(\"Increasing count %d\\n\", trans->counter);\n#endif\n\t\t    exec->counts[trans->counter]++;\n\t\t}\n\t\tif ((trans->count >= 0) &&\n\t\t    (trans->count < REGEXP_ALL_COUNTER)) {\n#ifdef DEBUG_REGEXP_EXEC\n\t\t    printf(\"resetting count %d on transition\\n\",\n\t\t           trans->count);\n#endif\n\t\t    exec->counts[trans->count] = 0;\n\t\t}\n#ifdef DEBUG_PUSH\n\t\tprintf(\"entering state %d\\n\", trans->to);\n#endif\n                if ((exec->comp->states[trans->to] != NULL) &&\n\t\t    (exec->comp->states[trans->to]->type ==\n\t\t     XML_REGEXP_SINK_STATE)) {\n\t\t    /*\n\t\t     * entering a sink state, save the current state as error\n\t\t     * state.\n\t\t     */\n\t\t    if (exec->errString != NULL)\n\t\t\txmlFree(exec->errString);\n\t\t    exec->errString = xmlStrdup(value);\n\t\t    exec->errState = exec->state;\n\t\t    memcpy(exec->errCounts, exec->counts,\n\t\t\t   exec->comp->nbCounters * sizeof(int));\n\t\t}\n\t\texec->state = exec->comp->states[trans->to];\n\t\texec->transno = 0;\n\t\tif (trans->atom != NULL) {\n\t\t    if (exec->inputStack != NULL) {\n\t\t\texec->index++;\n\t\t\tif (exec->index < exec->inputStackNr) {\n\t\t\t    value = exec->inputStack[exec->index].value;\n\t\t\t    data = exec->inputStack[exec->index].data;\n#ifdef DEBUG_PUSH\n\t\t\t    printf(\"value loaded: %s\\n\", value);\n#endif\n\t\t\t} else {\n\t\t\t    value = NULL;\n\t\t\t    data = NULL;\n#ifdef DEBUG_PUSH\n\t\t\t    printf(\"end of input\\n\");\n#endif\n\t\t\t}\n\t\t    } else {\n\t\t\tvalue = NULL;\n\t\t\tdata = NULL;\n#ifdef DEBUG_PUSH\n\t\t\tprintf(\"end of input\\n\");\n#endif\n\t\t    }\n\t\t}\n\t\tgoto progress;\n\t    } else if (ret < 0) {\n\t\texec->status = -4;\n\t\tbreak;\n\t    }\n\t}\n\tif ((exec->transno != 0) || (exec->state->nbTrans == 0)) {\nrollback:\n            /*\n\t     * if we didn't yet rollback on the current input\n\t     * store the current state as the error state.\n\t     */\n\t    if ((progress) && (exec->state != NULL) &&\n\t        (exec->state->type != XML_REGEXP_SINK_STATE)) {\n\t        progress = 0;\n\t\tif (exec->errString != NULL)\n\t\t    xmlFree(exec->errString);\n\t\texec->errString = xmlStrdup(value);\n\t\texec->errState = exec->state;\n\t\tmemcpy(exec->errCounts, exec->counts,\n\t\t       exec->comp->nbCounters * sizeof(int));\n\t    }\n\n\t    /*\n\t     * Failed to find a way out\n\t     */\n\t    exec->determinist = 0;\n\t    xmlFARegExecRollBack(exec);\n\t    if ((exec->inputStack != NULL ) && (exec->status == 0)) {\n\t\tvalue = exec->inputStack[exec->index].value;\n\t\tdata = exec->inputStack[exec->index].data;\n#ifdef DEBUG_PUSH\n\t\tprintf(\"value loaded: %s\\n\", value);\n#endif\n\t    }\n\t}\n\tcontinue;\nprogress:\n        progress = 1;\n\tcontinue;\n    }\n    if (exec->status == 0) {\n        return(exec->state->type == XML_REGEXP_FINAL_STATE);\n    }\n#ifdef DEBUG_ERR\n    if (exec->status < 0) {\n\ttesterr(exec);\n    }\n#endif\n    return(exec->status);\n}", "target": 0, "cwe": ["CWE-119"], "project": "libxml2", "commit_id": "cbb271655cadeb8dbb258a64701d9a3a0c4835b4", "hash": 296274448306071101133183808279294858850, "size": 346, "message": "Bug 757711: heap-buffer-overflow in xmlFAParsePosCharGroup <https://bugzilla.gnome.org/show_bug.cgi?id=757711>\n\n* xmlregexp.c:\n(xmlFAParseCharRange): Only advance to the next character if\nthere is no error.  Advancing to the next character in case of\nan error while parsing regexp leads to an out of bounds access.", "idx": 303}
{"func": "static noinline int compress_file_range(struct inode *inode,\n\t\t\t\t\tstruct page *locked_page,\n\t\t\t\t\tu64 start, u64 end,\n\t\t\t\t\tstruct async_cow *async_cow,\n\t\t\t\t\tint *num_added)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tu64 num_bytes;\n\tu64 blocksize = root->sectorsize;\n\tu64 actual_end;\n\tu64 isize = i_size_read(inode);\n\tint ret = 0;\n\tstruct page **pages = NULL;\n\tunsigned long nr_pages;\n\tunsigned long nr_pages_ret = 0;\n\tunsigned long total_compressed = 0;\n\tunsigned long total_in = 0;\n\tunsigned long max_compressed = 128 * 1024;\n\tunsigned long max_uncompressed = 128 * 1024;\n\tint i;\n\tint will_compress;\n\tint compress_type = root->fs_info->compress_type;\n\n\t/* if this is a small write inside eof, kick off a defrag */\n\tif ((end - start + 1) < 16 * 1024 &&\n\t    (start > 0 || end + 1 < BTRFS_I(inode)->disk_i_size))\n\t\tbtrfs_add_inode_defrag(NULL, inode);\n\n\tactual_end = min_t(u64, isize, end + 1);\nagain:\n\twill_compress = 0;\n\tnr_pages = (end >> PAGE_CACHE_SHIFT) - (start >> PAGE_CACHE_SHIFT) + 1;\n\tnr_pages = min(nr_pages, (128 * 1024UL) / PAGE_CACHE_SIZE);\n\n\t/*\n\t * we don't want to send crud past the end of i_size through\n\t * compression, that's just a waste of CPU time.  So, if the\n\t * end of the file is before the start of our current\n\t * requested range of bytes, we bail out to the uncompressed\n\t * cleanup code that can deal with all of this.\n\t *\n\t * It isn't really the fastest way to fix things, but this is a\n\t * very uncommon corner.\n\t */\n\tif (actual_end <= start)\n\t\tgoto cleanup_and_bail_uncompressed;\n\n\ttotal_compressed = actual_end - start;\n\n\t/* we want to make sure that amount of ram required to uncompress\n\t * an extent is reasonable, so we limit the total size in ram\n\t * of a compressed extent to 128k.  This is a crucial number\n\t * because it also controls how easily we can spread reads across\n\t * cpus for decompression.\n\t *\n\t * We also want to make sure the amount of IO required to do\n\t * a random read is reasonably small, so we limit the size of\n\t * a compressed extent to 128k.\n\t */\n\ttotal_compressed = min(total_compressed, max_uncompressed);\n\tnum_bytes = (end - start + blocksize) & ~(blocksize - 1);\n\tnum_bytes = max(blocksize,  num_bytes);\n\ttotal_in = 0;\n\tret = 0;\n\n\t/*\n\t * we do compression for mount -o compress and when the\n\t * inode has not been flagged as nocompress.  This flag can\n\t * change at any time if we discover bad compression ratios.\n\t */\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NOCOMPRESS) &&\n\t    (btrfs_test_opt(root, COMPRESS) ||\n\t     (BTRFS_I(inode)->force_compress) ||\n\t     (BTRFS_I(inode)->flags & BTRFS_INODE_COMPRESS))) {\n\t\tWARN_ON(pages);\n\t\tpages = kzalloc(sizeof(struct page *) * nr_pages, GFP_NOFS);\n\t\tif (!pages) {\n\t\t\t/* just bail out to the uncompressed code */\n\t\t\tgoto cont;\n\t\t}\n\n\t\tif (BTRFS_I(inode)->force_compress)\n\t\t\tcompress_type = BTRFS_I(inode)->force_compress;\n\n\t\tret = btrfs_compress_pages(compress_type,\n\t\t\t\t\t   inode->i_mapping, start,\n\t\t\t\t\t   total_compressed, pages,\n\t\t\t\t\t   nr_pages, &nr_pages_ret,\n\t\t\t\t\t   &total_in,\n\t\t\t\t\t   &total_compressed,\n\t\t\t\t\t   max_compressed);\n\n\t\tif (!ret) {\n\t\t\tunsigned long offset = total_compressed &\n\t\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\t\tstruct page *page = pages[nr_pages_ret - 1];\n\t\t\tchar *kaddr;\n\n\t\t\t/* zero the tail end of the last page, we might be\n\t\t\t * sending it down to disk\n\t\t\t */\n\t\t\tif (offset) {\n\t\t\t\tkaddr = kmap_atomic(page);\n\t\t\t\tmemset(kaddr + offset, 0,\n\t\t\t\t       PAGE_CACHE_SIZE - offset);\n\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t}\n\t\t\twill_compress = 1;\n\t\t}\n\t}\ncont:\n\tif (start == 0) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tgoto cleanup_and_out;\n\t\t}\n\t\ttrans->block_rsv = &root->fs_info->delalloc_block_rsv;\n\n\t\t/* lets try to make an inline extent */\n\t\tif (ret || total_in < (actual_end - start)) {\n\t\t\t/* we didn't compress the entire range, try\n\t\t\t * to make an uncompressed inline extent.\n\t\t\t */\n\t\t\tret = cow_file_range_inline(trans, root, inode,\n\t\t\t\t\t\t    start, end, 0, 0, NULL);\n\t\t} else {\n\t\t\t/* try making a compressed inline extent */\n\t\t\tret = cow_file_range_inline(trans, root, inode,\n\t\t\t\t\t\t    start, end,\n\t\t\t\t\t\t    total_compressed,\n\t\t\t\t\t\t    compress_type, pages);\n\t\t}\n\t\tif (ret <= 0) {\n\t\t\t/*\n\t\t\t * inline extent creation worked or returned error,\n\t\t\t * we don't need to create any more async work items.\n\t\t\t * Unlock and free up our temp pages.\n\t\t\t */\n\t\t\textent_clear_unlock_delalloc(inode,\n\t\t\t     &BTRFS_I(inode)->io_tree,\n\t\t\t     start, end, NULL,\n\t\t\t     EXTENT_CLEAR_UNLOCK_PAGE | EXTENT_CLEAR_DIRTY |\n\t\t\t     EXTENT_CLEAR_DELALLOC |\n\t\t\t     EXTENT_SET_WRITEBACK | EXTENT_END_WRITEBACK);\n\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tgoto free_pages_out;\n\t\t}\n\t\tbtrfs_end_transaction(trans, root);\n\t}\n\n\tif (will_compress) {\n\t\t/*\n\t\t * we aren't doing an inline extent round the compressed size\n\t\t * up to a block size boundary so the allocator does sane\n\t\t * things\n\t\t */\n\t\ttotal_compressed = (total_compressed + blocksize - 1) &\n\t\t\t~(blocksize - 1);\n\n\t\t/*\n\t\t * one last check to make sure the compression is really a\n\t\t * win, compare the page count read with the blocks on disk\n\t\t */\n\t\ttotal_in = (total_in + PAGE_CACHE_SIZE - 1) &\n\t\t\t~(PAGE_CACHE_SIZE - 1);\n\t\tif (total_compressed >= total_in) {\n\t\t\twill_compress = 0;\n\t\t} else {\n\t\t\tnum_bytes = total_in;\n\t\t}\n\t}\n\tif (!will_compress && pages) {\n\t\t/*\n\t\t * the compression code ran but failed to make things smaller,\n\t\t * free any pages it allocated and our page pointer array\n\t\t */\n\t\tfor (i = 0; i < nr_pages_ret; i++) {\n\t\t\tWARN_ON(pages[i]->mapping);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tkfree(pages);\n\t\tpages = NULL;\n\t\ttotal_compressed = 0;\n\t\tnr_pages_ret = 0;\n\n\t\t/* flag the file so we don't compress in the future */\n\t\tif (!btrfs_test_opt(root, FORCE_COMPRESS) &&\n\t\t    !(BTRFS_I(inode)->force_compress)) {\n\t\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NOCOMPRESS;\n\t\t}\n\t}\n\tif (will_compress) {\n\t\t*num_added += 1;\n\n\t\t/* the async work queues will take care of doing actual\n\t\t * allocation on disk for these compressed pages,\n\t\t * and will submit them to the elevator.\n\t\t */\n\t\tadd_async_extent(async_cow, start, num_bytes,\n\t\t\t\t total_compressed, pages, nr_pages_ret,\n\t\t\t\t compress_type);\n\n\t\tif (start + num_bytes < end) {\n\t\t\tstart += num_bytes;\n\t\t\tpages = NULL;\n\t\t\tcond_resched();\n\t\t\tgoto again;\n\t\t}\n\t} else {\ncleanup_and_bail_uncompressed:\n\t\t/*\n\t\t * No compression, but we still need to write the pages in\n\t\t * the file we've been given so far.  redirty the locked\n\t\t * page if it corresponds to our extent and set things up\n\t\t * for the async work queue to run cow_file_range to do\n\t\t * the normal delalloc dance\n\t\t */\n\t\tif (page_offset(locked_page) >= start &&\n\t\t    page_offset(locked_page) <= end) {\n\t\t\t__set_page_dirty_nobuffers(locked_page);\n\t\t\t/* unlocked later on in the async handlers */\n\t\t}\n\t\tadd_async_extent(async_cow, start, end - start + 1,\n\t\t\t\t 0, NULL, 0, BTRFS_COMPRESS_NONE);\n\t\t*num_added += 1;\n\t}\n\nout:\n\treturn ret;\n\nfree_pages_out:\n\tfor (i = 0; i < nr_pages_ret; i++) {\n\t\tWARN_ON(pages[i]->mapping);\n\t\tpage_cache_release(pages[i]);\n\t}\n\tkfree(pages);\n\n\tgoto out;\n\ncleanup_and_out:\n\textent_clear_unlock_delalloc(inode, &BTRFS_I(inode)->io_tree,\n\t\t\t\t     start, end, NULL,\n\t\t\t\t     EXTENT_CLEAR_UNLOCK_PAGE |\n\t\t\t\t     EXTENT_CLEAR_DIRTY |\n\t\t\t\t     EXTENT_CLEAR_DELALLOC |\n\t\t\t\t     EXTENT_SET_WRITEBACK |\n\t\t\t\t     EXTENT_END_WRITEBACK);\n\tif (!trans || IS_ERR(trans))\n\t\tbtrfs_error(root->fs_info, ret, \"Failed to join transaction\");\n\telse\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\tgoto free_pages_out;\n}", "target": 0, "cwe": ["CWE-310"], "project": "linux-2.6", "commit_id": "9c52057c698fb96f8f07e7a4bcf4801a092bda89", "hash": 170667209019835168008144085564857127480, "size": 257, "message": "Btrfs: fix hash overflow handling\n\nThe handling for directory crc hash overflows was fairly obscure,\nsplit_leaf returns EOVERFLOW when we try to extend the item and that is\nsupposed to bubble up to userland.  For a while it did so, but along the\nway we added better handling of errors and forced the FS readonly if we\nhit IO errors during the directory insertion.\n\nAlong the way, we started testing only for EEXIST and the EOVERFLOW case\nwas dropped.  The end result is that we may force the FS readonly if we\ncatch a directory hash bucket overflow.\n\nThis fixes a few problem spots.  First I add tests for EOVERFLOW in the\nplaces where we can safely just return the error up the chain.\n\nbtrfs_rename is harder though, because it tries to insert the new\ndirectory item only after it has already unlinked anything the rename\nwas going to overwrite.  Rather than adding very complex logic, I added\na helper to test for the hash overflow case early while it is still safe\nto bail out.\n\nSnapshot and subvolume creation had a similar problem, so they are using\nthe new helper now too.\n\nSigned-off-by: Chris Mason <chris.mason@fusionio.com>\nReported-by: Pascal Junod <pascal@junod.info>", "idx": 304}
{"func": "SPL_METHOD(SplFileObject, __construct)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_bool use_include_path = 0;\n\tchar *p1, *p2;\n\tchar *tmp_path;\n\tint   tmp_path_len;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tintern->u.file.open_mode = NULL;\n\tintern->u.file.open_mode_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|sbr!\", \n\t\t\t&intern->file_name, &intern->file_name_len,\n\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len, \n\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\t\t\n\t\tintern->u.file.open_mode = NULL;\n\t\tintern->file_name = NULL;\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\t\n\tif (intern->u.file.open_mode == NULL) {\n\t\tintern->u.file.open_mode = \"r\";\n\t\tintern->u.file.open_mode_len = 1;\n\t}\n\n\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == SUCCESS) {\n\t\ttmp_path_len = strlen(intern->u.file.stream->orig_path);\n\n\t\tif (tmp_path_len > 1 && IS_SLASH_AT(intern->u.file.stream->orig_path, tmp_path_len-1)) {\n\t\t\ttmp_path_len--;\n\t\t}\n\n\t\ttmp_path = estrndup(intern->u.file.stream->orig_path, tmp_path_len);\n\n\t\tp1 = strrchr(tmp_path, '/');\n#if defined(PHP_WIN32) || defined(NETWARE)\n\t\tp2 = strrchr(tmp_path, '\\\\');\n#else\n\t\tp2 = 0;\n#endif\n\t\tif (p1 || p2) {\n\t\t\tintern->_path_len = (p1 > p2 ? p1 : p2) - tmp_path;\n\t\t} else {\n\t\t\tintern->_path_len = 0;\n\t\t}\n\n\t\tefree(tmp_path);\n\n\t\tintern->_path = estrndup(intern->u.file.stream->orig_path, intern->_path_len);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\n} /* }}} */", "target": 1, "cwe": ["CWE-190"], "project": "php-src", "commit_id": "7245bff300d3fa8bacbef7897ff080a6f1c23eba", "hash": 201837791418839097382943781001034230802, "size": 58, "message": "Fix bug #72262 - do not overflow int", "idx": 305}
{"func": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  // Create a top level function that will never be executed, because:\n  // 1. IRGen assumes the first function always has global scope\n  // 2. It serves as the root for dummy functions for lexical data\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n\n  // Save the top-level context, but ensure it doesn't outlive what it is\n  // pointing to.\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n\n  // We restore scoping information in two separate ways:\n  // 1. By adding them to ExternalScopes for resolution here\n  // 2. By adding dummy functions for lexical scoping debug info later\n  //\n  // Instruction selection determines the delta between the ExternalScope\n  // and the dummy function chain, so we add the ExternalScopes with\n  // positive depth.\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n\n  // If lazyData->closureAlias is specified, we must create an alias binding\n  // between originalName (which must be valid) and the variable identified by\n  // closureAlias.\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n\n    // NOTE: the closureAlias target must exist and must be a Variable.\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n\n    // Re-create the alias.\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "hermes", "commit_id": "091835377369c8fd5917d9b87acffa721ad2a168", "hash": 46406995015922664235813284424098649540, "size": 52, "message": "Correctly restore whether or not a function is an inner generator\n\nSummary:\nIf a generator was large enough to be lazily compiled, we would lose\nthat information when reconstituting the function's context. This meant\nthe function was generated as a regular function instead of a generator.\n\n#utd-hermes-ignore-android\n\nReviewed By: tmikov\n\nDifferential Revision: D23580247\n\nfbshipit-source-id: af5628bf322cbdc7c7cdfbb5f8d0756328518ea1", "idx": 306}
{"func": "static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)\n{\n\tstruct thread_info *thread = task_thread_info(tsk);\n\n\tif (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))\n\t\treturn -EACCES;\n\tiwmmxt_task_release(thread);  /* force a reload */\n\treturn copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)\n\t\t? -EFAULT : 0;\n}", "target": 0, "cwe": ["CWE-284", "CWE-264"], "project": "linux", "commit_id": "a4780adeefd042482f624f5e0d577bf9cdcbb760", "hash": 14556586275675420414377377415818718605, "size": 10, "message": "ARM: 7735/2: Preserve the user r/w register TPIDRURW on context switch and fork\n\nSince commit 6a1c53124aa1 the user writeable TLS register was zeroed to\nprevent it from being used as a covert channel between two tasks.\n\nThere are more and more applications coming to Windows RT,\nWine could support them, but mostly they expect to have\nthe thread environment block (TEB) in TPIDRURW.\n\nThis patch preserves that register per thread instead of clearing it.\nUnlike the TPIDRURO, which is already switched, the TPIDRURW\ncan be updated from userspace so needs careful treatment in the case that we\nmodify TPIDRURW and call fork(). To avoid this we must always read\nTPIDRURW in copy_thread.\n\nSigned-off-by: André Hentschel <nerv@dawncrow.de>\nSigned-off-by: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Jonathan Austin <jonathan.austin@arm.com>\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>", "idx": 307}
{"func": "void ieee80211_sta_block_awake(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *pubsta, bool block)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\ttrace_api_sta_block_awake(sta->local, pubsta, block);\n\n\tif (block)\n\t\tset_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\telse if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))\n\t\tieee80211_queue_work(hw, &sta->drv_unblock_wk);\n}", "target": 0, "cwe": ["CWE-362"], "project": "linux", "commit_id": "1d147bfa64293b2723c4fec50922168658e613ba", "hash": 120477216751980831678535121422440833539, "size": 12, "message": "mac80211: fix AP powersave TX vs. wakeup race\n\nThere is a race between the TX path and the STA wakeup: while\na station is sleeping, mac80211 buffers frames until it wakes\nup, then the frames are transmitted. However, the RX and TX\npath are concurrent, so the packet indicating wakeup can be\nprocessed while a packet is being transmitted.\n\nThis can lead to a situation where the buffered frames list\nis emptied on the one side, while a frame is being added on\nthe other side, as the station is still seen as sleeping in\nthe TX path.\n\nAs a result, the newly added frame will not be send anytime\nsoon. It might be sent much later (and out of order) when the\nstation goes to sleep and wakes up the next time.\n\nAdditionally, it can lead to the crash below.\n\nFix all this by synchronising both paths with a new lock.\nBoth path are not fastpath since they handle PS situations.\n\nIn a later patch we'll remove the extra skb queue locks to\nreduce locking overhead.\n\nBUG: unable to handle kernel\nNULL pointer dereference at 000000b0\nIP: [<ff6f1791>] ieee80211_report_used_skb+0x11/0x3e0 [mac80211]\n*pde = 00000000\nOops: 0000 [#1] SMP DEBUG_PAGEALLOC\nEIP: 0060:[<ff6f1791>] EFLAGS: 00210282 CPU: 1\nEIP is at ieee80211_report_used_skb+0x11/0x3e0 [mac80211]\nEAX: e5900da0 EBX: 00000000 ECX: 00000001 EDX: 00000000\nESI: e41d00c0 EDI: e5900da0 EBP: ebe458e4 ESP: ebe458b0\n DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068\nCR0: 8005003b CR2: 000000b0 CR3: 25a78000 CR4: 000407d0\nDR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000\nDR6: ffff0ff0 DR7: 00000400\nProcess iperf (pid: 3934, ti=ebe44000 task=e757c0b0 task.ti=ebe44000)\niwlwifi 0000:02:00.0: I iwl_pcie_enqueue_hcmd Sending command LQ_CMD (#4e), seq: 0x0903, 92 bytes at 3[3]:9\nStack:\n e403b32c ebe458c4 00200002 00200286 e403b338 ebe458cc c10960bb e5900da0\n ff76a6ec ebe458d8 00000000 e41d00c0 e5900da0 ebe458f0 ff6f1b75 e403b210\n ebe4598c ff723dc1 00000000 ff76a6ec e597c978 e403b758 00000002 00000002\nCall Trace:\n [<ff6f1b75>] ieee80211_free_txskb+0x15/0x20 [mac80211]\n [<ff723dc1>] invoke_tx_handlers+0x1661/0x1780 [mac80211]\n [<ff7248a5>] ieee80211_tx+0x75/0x100 [mac80211]\n [<ff7249bf>] ieee80211_xmit+0x8f/0xc0 [mac80211]\n [<ff72550e>] ieee80211_subif_start_xmit+0x4fe/0xe20 [mac80211]\n [<c149ef70>] dev_hard_start_xmit+0x450/0x950\n [<c14b9aa9>] sch_direct_xmit+0xa9/0x250\n [<c14b9c9b>] __qdisc_run+0x4b/0x150\n [<c149f732>] dev_queue_xmit+0x2c2/0xca0\n\nCc: stable@vger.kernel.org\nReported-by: Yaara Rozenblum <yaara.rozenblum@intel.com>\nSigned-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>\nReviewed-by: Stanislaw Gruszka <sgruszka@redhat.com>\n[reword commit log, use a separate lock]\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>", "idx": 308}
{"func": "int isHLLObjectOrReply(client *c, robj *o) {\n    struct hllhdr *hdr;\n\n    /* Key exists, check type */\n    if (checkType(c,o,OBJ_STRING))\n        return C_ERR; /* Error already sent. */\n\n    if (!sdsEncodedObject(o)) goto invalid;\n    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;\n    hdr = o->ptr;\n\n    /* Magic should be \"HYLL\". */\n    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||\n        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;\n\n    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;\n\n    /* Dense representation string length should match exactly. */\n    if (hdr->encoding == HLL_DENSE &&\n        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;\n\n    /* All tests passed. */\n    return C_OK;\n\ninvalid:\n    addReplySds(c,\n        sdsnew(\"-WRONGTYPE Key is not a valid \"\n               \"HyperLogLog string value.\\r\\n\"));\n    return C_ERR;\n}", "target": 0, "cwe": ["CWE-787"], "project": "redis", "commit_id": "e216ceaf0e099536fe3658a29dcb725d812364e0", "hash": 161879575199530538345401099233771977912, "size": 30, "message": "HyperLogLog: handle wrong offset in the base case.", "idx": 309}
{"func": "void gf_dom_event_remove_all_listeners(GF_DOMEventTarget *event_target)\n{\n\twhile (gf_list_count(event_target->listeners)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(event_target->listeners, 0);\n\t\tgf_dom_listener_del(n, event_target);\n\t}\n}", "target": 1, "cwe": ["CWE-416"], "project": "gpac", "commit_id": "9723dd0955894f2cb7be13b94cf7a47f2754b893", "hash": 311702138460666817765258114984013411561, "size": 7, "message": "fixed #2109", "idx": 310}
{"func": "rfbSendAuthCaps(rfbClientPtr cl)\n{\n    rfbAuthenticationCapsMsg caps;\n    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];\n    int count = 0;\n    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);\n\n    rfbLog(\"tightvnc-filetransfer/rfbSendAuthCaps\\n\");\n\n    if(rtcp == NULL)\n\treturn;\n\n    if (cl->screen->authPasswdData && !cl->reverseConnection) {\n\t/* chk if this condition is valid or not. */\n\t    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);\n\t    rtcp->authCaps[count++] = rfbAuthVNC;\n    }\n\n    rtcp->nAuthCaps = count;\n    caps.nAuthTypes = Swap32IfLE((uint32_t)count);\n    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {\n\trfbLogPerror(\"rfbSendAuthCaps: write\");\n\trfbCloseClient(cl);\n\treturn;\n    }\n\n    if (count) {\n\tif (rfbWriteExact(cl, (char *)&caplist[0],\n\t\t       count * sz_rfbCapabilityInfo) < 0) {\n\t    rfbLogPerror(\"rfbSendAuthCaps: write\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\t/* Dispatch client input to rfbProcessClientAuthType. */\n\t/* Call the function for authentication from here */\n\trfbProcessClientAuthType(cl);\n    } else {\n\t/* Dispatch client input to rfbProcessClientInitMessage. */\n\tcl->state = RFB_INITIALISATION;\n    }\n}", "target": 1, "cwe": [], "project": "libvncserver", "commit_id": "804335f9d296440bb708ca844f5d89b58b50b0c6", "hash": 115376196903825075042110736142701822178, "size": 41, "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422.", "idx": 311}
{"func": "static MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    format[MagickPathExtent],\n    name[MagickPathExtent],\n    *resource;\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *info;\n\n  long\n    start,\n    stop;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    id,\n    sub_number;\n\n  /*\n    There are no newlines in path names, so it's safe as terminator.\n  */\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=(ssize_t) sscanf(key,\"8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]\",&start,&stop,\n    name,format);\n  if ((count != 2) && (count != 3) && (count != 4))\n    return(MagickFalse);\n  if (count < 4)\n    (void) CopyMagickString(format,\"SVG\",MagickPathExtent);\n  if (count < 3)\n    *name='\\0';\n  sub_number=1;\n  if (*name == '#')\n    sub_number=(ssize_t) StringToLong(&name[1]);\n  sub_number=MagickMax(sub_number,1L);\n  resource=(char *) NULL;\n  status=MagickFalse;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while ((length > 0) && (status == MagickFalse))\n  {\n    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadPropertyMSBShort(&info,&length);\n    if (id < (ssize_t) start)\n      continue;\n    if (id > (ssize_t) stop)\n      continue;\n    if (resource != (char *) NULL)\n      resource=DestroyString(resource);\n    count=(ssize_t) ReadPropertyByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        resource=(char *) NULL;\n        if (~((size_t) count) >= (MagickPathExtent-1))\n          resource=(char *) AcquireQuantumMemory((size_t) count+\n            MagickPathExtent,sizeof(*resource));\n        if (resource != (char *) NULL)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              resource[i]=(char) ReadPropertyByte(&info,&length);\n            resource[count]='\\0';\n          }\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadPropertyByte(&info,&length);\n    count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n    if ((count < 0) || ((size_t) count > length))\n      {\n        length=0;\n        continue;\n      }\n    if ((*name != '\\0') && (*name != '#'))\n      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n        {\n          /*\n            No name match, scroll forward and try next.\n          */\n          info+=count;\n          length-=MagickMin(count,(ssize_t) length);\n          continue;\n        }\n    if ((*name == '#') && (sub_number != 1))\n      {\n        /*\n          No numbered match, scroll forward and try next.\n        */\n        sub_number--;\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        continue;\n      }\n    /*\n      We have the resource of interest.\n    */\n    attribute=(char *) NULL;\n    if (~((size_t) count) >= (MagickPathExtent-1))\n      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,\n        sizeof(*attribute));\n    if (attribute != (char *) NULL)\n      {\n        (void) memcpy(attribute,(char *) info,(size_t) count);\n        attribute[count]='\\0';\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        if ((id <= 1999) || (id >= 2999))\n          (void) SetImageProperty((Image *) image,key,(const char *) attribute,\n            exception);\n        else\n          {\n            char\n              *path;\n\n            if (LocaleCompare(format,\"svg\") == 0)\n              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,\n                image->columns,image->rows);\n            else\n              path=TracePSClippath((unsigned char *) attribute,(size_t) count);\n            (void) SetImageProperty((Image *) image,key,(const char *) path,\n              exception);\n            path=DestroyString(path);\n          }\n        attribute=DestroyString(attribute);\n        status=MagickTrue;\n      }\n  }\n  if (resource != (char *) NULL)\n    resource=DestroyString(resource);\n  return(status);\n}", "target": 0, "cwe": ["CWE-476"], "project": "ImageMagick", "commit_id": "2c75f301d9ac84f91071393b02d8c88c8341c91c", "hash": 339560536489416712565373371819864384604, "size": 152, "message": "https://github.com/ImageMagick/ImageMagick/issues/1225", "idx": 312}
{"func": "static int intel_engine_setup(struct intel_gt *gt, enum intel_engine_id id)\n{\n\tconst struct engine_info *info = &intel_engines[id];\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_engine_cs *engine;\n\n\tBUILD_BUG_ON(MAX_ENGINE_CLASS >= BIT(GEN11_ENGINE_CLASS_WIDTH));\n\tBUILD_BUG_ON(MAX_ENGINE_INSTANCE >= BIT(GEN11_ENGINE_INSTANCE_WIDTH));\n\n\tif (GEM_DEBUG_WARN_ON(id >= ARRAY_SIZE(gt->engine)))\n\t\treturn -EINVAL;\n\n\tif (GEM_DEBUG_WARN_ON(info->class > MAX_ENGINE_CLASS))\n\t\treturn -EINVAL;\n\n\tif (GEM_DEBUG_WARN_ON(info->instance > MAX_ENGINE_INSTANCE))\n\t\treturn -EINVAL;\n\n\tif (GEM_DEBUG_WARN_ON(gt->engine_class[info->class][info->instance]))\n\t\treturn -EINVAL;\n\n\tengine = kzalloc(sizeof(*engine), GFP_KERNEL);\n\tif (!engine)\n\t\treturn -ENOMEM;\n\n\tBUILD_BUG_ON(BITS_PER_TYPE(engine->mask) < I915_NUM_ENGINES);\n\n\tengine->id = id;\n\tengine->legacy_idx = INVALID_ENGINE;\n\tengine->mask = BIT(id);\n\tengine->i915 = i915;\n\tengine->gt = gt;\n\tengine->uncore = gt->uncore;\n\tengine->hw_id = engine->guc_id = info->hw_id;\n\tengine->mmio_base = __engine_mmio_base(i915, info->mmio_bases);\n\n\tengine->class = info->class;\n\tengine->instance = info->instance;\n\t__sprint_engine_name(engine);\n\n\tengine->props.heartbeat_interval_ms =\n\t\tCONFIG_DRM_I915_HEARTBEAT_INTERVAL;\n\tengine->props.max_busywait_duration_ns =\n\t\tCONFIG_DRM_I915_MAX_REQUEST_BUSYWAIT;\n\tengine->props.preempt_timeout_ms =\n\t\tCONFIG_DRM_I915_PREEMPT_TIMEOUT;\n\tengine->props.stop_timeout_ms =\n\t\tCONFIG_DRM_I915_STOP_TIMEOUT;\n\tengine->props.timeslice_duration_ms =\n\t\tCONFIG_DRM_I915_TIMESLICE_DURATION;\n\n\t/* Override to uninterruptible for OpenCL workloads. */\n\tif (INTEL_GEN(i915) == 12 && engine->class == RENDER_CLASS)\n\t\tengine->props.preempt_timeout_ms = 0;\n\n\tengine->defaults = engine->props; /* never to change again */\n\n\tengine->context_size = intel_engine_context_size(gt, engine->class);\n\tif (WARN_ON(engine->context_size > BIT(20)))\n\t\tengine->context_size = 0;\n\tif (engine->context_size)\n\t\tDRIVER_CAPS(i915)->has_logical_contexts = true;\n\n\t/* Nothing to do here, execute in order of dependencies */\n\tengine->schedule = NULL;\n\n\tewma__engine_latency_init(&engine->latency);\n\tseqlock_init(&engine->stats.lock);\n\n\tATOMIC_INIT_NOTIFIER_HEAD(&engine->context_status_notifier);\n\n\t/* Scrub mmio state on takeover */\n\tintel_engine_sanitize_mmio(engine);\n\n\tgt->engine_class[info->class][info->instance] = engine;\n\tgt->engine[id] = engine;\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20", "CWE-190"], "project": "linux", "commit_id": "c784e5249e773689e38d2bc1749f08b986621a26", "hash": 75452809966664424784907988065715069621, "size": 79, "message": "drm/i915/guc: Update to use firmware v49.0.1\n\nThe latest GuC firmware includes a number of interface changes that\nrequire driver updates to match.\n\n* Starting from Gen11, the ID to be provided to GuC needs to contain\n  the engine class in bits [0..2] and the instance in bits [3..6].\n\n  NOTE: this patch breaks pointer dereferences in some existing GuC\n  functions that use the guc_id to dereference arrays but these functions\n  are not used for now as we have GuC submission disabled and we will\n  update these functions in follow up patch which requires new IDs.\n\n* The new GuC requires the additional data structure (ADS) and associated\n  'private_data' pointer to be setup. This is basically a scratch area\n  of memory that the GuC owns. The size is read from the CSS header.\n\n* There is now a physical to logical engine mapping table in the ADS\n  which needs to be configured in order for the firmware to load. For\n  now, the table is initialised with a 1 to 1 mapping.\n\n* GUC_CTL_CTXINFO has been removed from the initialization params.\n\n* reg_state_buffer is maintained internally by the GuC as part of\n  the private data.\n\n* The ADS layout has changed significantly. This patch updates the\n  shared structure and also adds better documentation of the layout.\n\n* While i915 does not use GuC doorbells, the firmware now requires\n  that some initialisation is done.\n\n* The number of engine classes and instances supported in the ADS has\n  been increased.\n\nSigned-off-by: John Harrison <John.C.Harrison@Intel.com>\nSigned-off-by: Matthew Brost <matthew.brost@intel.com>\nSigned-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>\nSigned-off-by: Oscar Mateo <oscar.mateo@intel.com>\nSigned-off-by: Michel Thierry <michel.thierry@intel.com>\nSigned-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>\nSigned-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>\nCc: Michal Winiarski <michal.winiarski@intel.com>\nCc: Tomasz Lis <tomasz.lis@intel.com>\nCc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>\nReviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>\nSigned-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20201028145826.2949180-2-John.C.Harrison@Intel.com", "idx": 313}
{"func": "sudoers_policy_deserialize_info(void *v)\n{\n    struct sudoers_open_info *info = v;\n    char * const *cur;\n    const char *p, *errstr, *groups = NULL;\n    const char *remhost = NULL;\n    int flags = 0;\n    debug_decl(sudoers_policy_deserialize_info, SUDOERS_DEBUG_PLUGIN);\n\n#define MATCHES(s, v)\t\\\n    (strncmp((s), (v), sizeof(v) - 1) == 0)\n\n#define INVALID(v) do {\t\\\n    sudo_warn(U_(\"invalid %.*s set by sudo front-end\"), \\\n\t(int)(sizeof(v) - 2), (v)); \\\n} while (0)\n\n#define CHECK(s, v) do {\t\\\n    if ((s)[sizeof(v) - 1] == '\\0') { \\\n\tINVALID(v); \\\n\tgoto bad; \\\n    } \\\n} while (0)\n\n    if (sudo_gettime_real(&sudo_user.submit_time) == -1) {\n\tsudo_warn(\"%s\", U_(\"unable to get time of day\"));\n\tgoto bad;\n    }\n\n    /* Parse sudo.conf plugin args. */\n    if (info->plugin_args != NULL) {\n\tfor (cur = info->plugin_args; *cur != NULL; cur++) {\n\t    if (MATCHES(*cur, \"error_recovery=\")) {\n\t\tint val = sudo_strtobool(*cur + sizeof(\"error_recovery=\") - 1);\n\t\tif (val == -1) {\n\t\t    INVALID(\"error_recovery=\");\t/* Not a fatal error. */\n\t\t} else {\n\t\t    sudoers_recovery = val;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (MATCHES(*cur, \"sudoers_file=\")) {\n\t\tCHECK(*cur, \"sudoers_file=\");\n\t\tsudoers_file = *cur + sizeof(\"sudoers_file=\") - 1;\n\t\tcontinue;\n\t    }\n\t    if (MATCHES(*cur, \"sudoers_uid=\")) {\n\t\tp = *cur + sizeof(\"sudoers_uid=\") - 1;\n\t\tsudoers_uid = (uid_t) sudo_strtoid(p, &errstr);\n\t\tif (errstr != NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\t    goto bad;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (MATCHES(*cur, \"sudoers_gid=\")) {\n\t\tp = *cur + sizeof(\"sudoers_gid=\") - 1;\n\t\tsudoers_gid = (gid_t) sudo_strtoid(p, &errstr);\n\t\tif (errstr != NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\t    goto bad;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (MATCHES(*cur, \"sudoers_mode=\")) {\n\t\tp = *cur + sizeof(\"sudoers_mode=\") - 1;\n\t\tsudoers_mode = sudo_strtomode(p, &errstr);\n\t\tif (errstr != NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\t    goto bad;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (MATCHES(*cur, \"ldap_conf=\")) {\n\t\tCHECK(*cur, \"ldap_conf=\");\n\t\tpath_ldap_conf = *cur + sizeof(\"ldap_conf=\") - 1;\n\t\tcontinue;\n\t    }\n\t    if (MATCHES(*cur, \"ldap_secret=\")) {\n\t\tCHECK(*cur, \"ldap_secret=\");\n\t\tpath_ldap_secret = *cur + sizeof(\"ldap_secret=\") - 1;\n\t\tcontinue;\n\t    }\n\t}\n    }\n\n    /* Parse command line settings. */\n    user_closefrom = -1;\n    for (cur = info->settings; *cur != NULL; cur++) {\n\tif (MATCHES(*cur, \"closefrom=\")) {\n\t    errno = 0;\n\t    p = *cur + sizeof(\"closefrom=\") - 1;\n\t    user_closefrom = sudo_strtonum(p, 3, INT_MAX, &errstr);\n\t    if (user_closefrom == 0) {\n\t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"cmnd_chroot=\")) {\n\t    CHECK(*cur, \"cmnd_chroot=\");\n\t    user_runchroot = *cur + sizeof(\"cmnd_chroot=\") - 1;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"cmnd_cwd=\")) {\n\t    CHECK(*cur, \"cmnd_cwd=\");\n\t    user_runcwd = *cur + sizeof(\"cmnd_cwd=\") - 1;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"runas_user=\")) {\n\t    CHECK(*cur, \"runas_user=\");\n\t    sudo_user.runas_user = *cur + sizeof(\"runas_user=\") - 1;\n\t    SET(sudo_user.flags, RUNAS_USER_SPECIFIED);\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"runas_group=\")) {\n\t    CHECK(*cur, \"runas_group=\");\n\t    sudo_user.runas_group = *cur + sizeof(\"runas_group=\") - 1;\n\t    SET(sudo_user.flags, RUNAS_GROUP_SPECIFIED);\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"prompt=\")) {\n\t    /* Allow epmpty prompt. */\n\t    user_prompt = *cur + sizeof(\"prompt=\") - 1;\n\t    def_passprompt_override = true;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"set_home=\")) {\n\t    if (parse_bool(*cur, sizeof(\"set_home\") - 1, &flags,\n\t\tMODE_RESET_HOME) == -1)\n\t\tgoto bad;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"preserve_environment=\")) {\n\t    if (parse_bool(*cur, sizeof(\"preserve_environment\") - 1, &flags,\n\t\tMODE_PRESERVE_ENV) == -1)\n\t\tgoto bad;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"run_shell=\")) {\n\t    if (parse_bool(*cur, sizeof(\"run_shell\") -1, &flags,\n\t\tMODE_SHELL) == -1)\n\t\tgoto bad;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"login_shell=\")) {\n\t    if (parse_bool(*cur, sizeof(\"login_shell\") - 1, &flags,\n\t\tMODE_LOGIN_SHELL) == -1)\n\t\tgoto bad;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"implied_shell=\")) {\n\t    if (parse_bool(*cur, sizeof(\"implied_shell\") - 1, &flags,\n\t\tMODE_IMPLIED_SHELL) == -1)\n\t\tgoto bad;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"preserve_groups=\")) {\n\t    if (parse_bool(*cur, sizeof(\"preserve_groups\") - 1, &flags,\n\t\tMODE_PRESERVE_GROUPS) == -1)\n\t\tgoto bad;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"ignore_ticket=\")) {\n\t    if (parse_bool(*cur, sizeof(\"ignore_ticket\") -1, &flags,\n\t\tMODE_IGNORE_TICKET) == -1)\n\t\tgoto bad;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"noninteractive=\")) {\n\t    if (parse_bool(*cur, sizeof(\"noninteractive\") - 1, &flags,\n\t\tMODE_NONINTERACTIVE) == -1)\n\t\tgoto bad;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"sudoedit=\")) {\n\t    if (parse_bool(*cur, sizeof(\"sudoedit\") - 1, &flags,\n\t\tMODE_EDIT) == -1)\n\t\tgoto bad;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"login_class=\")) {\n\t    CHECK(*cur, \"login_class=\");\n\t    login_class = *cur + sizeof(\"login_class=\") - 1;\n\t    def_use_loginclass = true;\n\t    continue;\n\t}\n#ifdef HAVE_PRIV_SET\n\tif (MATCHES(*cur, \"runas_privs=\")) {\n\t    CHECK(*cur, \"runas_privs=\");\n\t    def_privs = *cur + sizeof(\"runas_privs=\") - 1;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"runas_limitprivs=\")) {\n\t    CHECK(*cur, \"runas_limitprivs=\");\n\t    def_limitprivs = *cur + sizeof(\"runas_limitprivs=\") - 1;\n\t    continue;\n\t}\n#endif /* HAVE_PRIV_SET */\n#ifdef HAVE_SELINUX\n\tif (MATCHES(*cur, \"selinux_role=\")) {\n\t    CHECK(*cur, \"selinux_role=\");\n\t    user_role = *cur + sizeof(\"selinux_role=\") - 1;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"selinux_type=\")) {\n\t    CHECK(*cur, \"selinux_type=\");\n\t    user_type = *cur + sizeof(\"selinux_type=\") - 1;\n\t    continue;\n\t}\n#endif /* HAVE_SELINUX */\n#ifdef HAVE_BSD_AUTH_H\n\tif (MATCHES(*cur, \"bsdauth_type=\")) {\n\t    CHECK(*cur, \"login_style=\");\n\t    login_style = *cur + sizeof(\"bsdauth_type=\") - 1;\n\t    continue;\n\t}\n#endif /* HAVE_BSD_AUTH_H */\n\tif (MATCHES(*cur, \"network_addrs=\")) {\n\t    interfaces_string = *cur + sizeof(\"network_addrs=\") - 1;\n\t    if (!set_interfaces(interfaces_string)) {\n\t\tsudo_warn(\"%s\", U_(\"unable to parse network address list\"));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"max_groups=\")) {\n\t    errno = 0;\n\t    p = *cur + sizeof(\"max_groups=\") - 1;\n\t    sudo_user.max_groups = sudo_strtonum(p, 1, INT_MAX, &errstr);\n\t    if (sudo_user.max_groups == 0) {\n\t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"remote_host=\")) {\n\t    CHECK(*cur, \"remote_host=\");\n\t    remhost = *cur + sizeof(\"remote_host=\") - 1;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"timeout=\")) {\n\t    p = *cur + sizeof(\"timeout=\") - 1;\n\t    user_timeout = parse_timeout(p);\n\t    if (user_timeout == -1) {\n\t\tif (errno == ERANGE)\n\t\t    sudo_warnx(U_(\"%s: %s\"), p, U_(\"timeout value too large\"));\n\t\telse\n\t\t    sudo_warnx(U_(\"%s: %s\"), p, U_(\"invalid timeout value\"));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n#ifdef ENABLE_SUDO_PLUGIN_API\n\tif (MATCHES(*cur, \"plugin_dir=\")) {\n\t    CHECK(*cur, \"plugin_dir=\");\n\t    path_plugin_dir = *cur + sizeof(\"plugin_dir=\") - 1;\n\t    continue;\n\t}\n#endif\n    }\n\n    user_gid = (gid_t)-1;\n    user_sid = (pid_t)-1;\n    user_uid = (gid_t)-1;\n    user_umask = (mode_t)-1;\n    for (cur = info->user_info; *cur != NULL; cur++) {\n\tif (MATCHES(*cur, \"user=\")) {\n\t    CHECK(*cur, \"user=\");\n\t    if ((user_name = strdup(*cur + sizeof(\"user=\") - 1)) == NULL)\n\t\tgoto oom;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"uid=\")) {\n\t    p = *cur + sizeof(\"uid=\") - 1;\n\t    user_uid = (uid_t) sudo_strtoid(p, &errstr);\n\t    if (errstr != NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"gid=\")) {\n\t    p = *cur + sizeof(\"gid=\") - 1;\n\t    user_gid = (gid_t) sudo_strtoid(p, &errstr);\n\t    if (errstr != NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"groups=\")) {\n\t    CHECK(*cur, \"groups=\");\n\t    groups = *cur + sizeof(\"groups=\") - 1;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"cwd=\")) {\n\t    CHECK(*cur, \"cwd=\");\n\t    if ((user_cwd = strdup(*cur + sizeof(\"cwd=\") - 1)) == NULL)\n\t\tgoto oom;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"tty=\")) {\n\t    CHECK(*cur, \"tty=\");\n\t    if ((user_ttypath = strdup(*cur + sizeof(\"tty=\") - 1)) == NULL)\n\t\tgoto oom;\n\t    user_tty = user_ttypath;\n\t    if (strncmp(user_tty, _PATH_DEV, sizeof(_PATH_DEV) - 1) == 0)\n\t\tuser_tty += sizeof(_PATH_DEV) - 1;\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"host=\")) {\n\t    CHECK(*cur, \"host=\");\n\t    if ((user_host = strdup(*cur + sizeof(\"host=\") - 1)) == NULL)\n\t\tgoto oom;\n\t    if ((p = strchr(user_host, '.')) != NULL) {\n\t\tuser_shost = strndup(user_host, (size_t)(p - user_host));\n\t\tif (user_shost == NULL)\n\t\t    goto oom;\n\t    } else {\n\t\tuser_shost = user_host;\n\t    }\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"lines=\")) {\n\t    errno = 0;\n\t    p = *cur + sizeof(\"lines=\") - 1;\n\t    sudo_user.lines = sudo_strtonum(p, 1, INT_MAX, &errstr);\n\t    if (sudo_user.lines == 0) {\n\t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"cols=\")) {\n\t    errno = 0;\n\t    p = *cur + sizeof(\"cols=\") - 1;\n\t    sudo_user.cols = sudo_strtonum(p, 1, INT_MAX, &errstr);\n\t    if (sudo_user.cols == 0) {\n\t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"sid=\")) {\n\t    p = *cur + sizeof(\"sid=\") - 1;\n\t    user_sid = (pid_t) sudo_strtoid(p, &errstr);\n\t    if (errstr != NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n\tif (MATCHES(*cur, \"umask=\")) {\n\t    p = *cur + sizeof(\"umask=\") - 1;\n\t    sudo_user.umask = sudo_strtomode(p, &errstr);\n\t    if (errstr != NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n\t\tgoto bad;\n\t    }\n\t    continue;\n\t}\n    }\n\n    /* User name, user-ID, group-ID and host name must be specified. */\n    if (user_name == NULL) {\n\tsudo_warnx(\"%s\", U_(\"user name not set by sudo front-end\"));\n\tgoto bad;\n    }\n    if (user_uid == (uid_t)-1) {\n\tsudo_warnx(\"%s\", U_(\"user-ID not set by sudo front-end\"));\n\tgoto bad;\n    }\n    if (user_gid == (gid_t)-1) {\n\tsudo_warnx(\"%s\", U_(\"group-ID not set by sudo front-end\"));\n\tgoto bad;\n    }\n    if (user_host == NULL) {\n\tsudo_warnx(\"%s\", U_(\"host name not set by sudo front-end\"));\n\tgoto bad;\n    }\n\n    if ((user_runhost = strdup(remhost ? remhost : user_host)) == NULL)\n\tgoto oom;\n    if ((p = strchr(user_runhost, '.')) != NULL) {\n\tuser_srunhost = strndup(user_runhost, (size_t)(p - user_runhost));\n\tif (user_srunhost == NULL)\n\t    goto oom;\n    } else {\n\tuser_srunhost = user_runhost;\n    }\n    if (user_cwd == NULL) {\n\tif ((user_cwd = strdup(\"unknown\")) == NULL)\n\t    goto oom;\n    }\n    if (user_runcwd == NULL) {\n\tif ((user_runcwd = strdup(user_cwd)) == NULL)\n\t    goto oom;\n    }\n    if (user_tty == NULL) {\n\tif ((user_tty = strdup(\"unknown\")) == NULL)\n\t    goto oom;\n\t/* user_ttypath remains NULL */\n    }\n\n    if (groups != NULL) {\n\t/* sudo_parse_gids() will print a warning on error. */\n\tuser_ngids = sudo_parse_gids(groups, &user_gid, &user_gids);\n\tif (user_ngids == -1)\n\t    goto bad;\n    }\n\n    /* umask is only set in user_info[] for API 1.10 and above. */\n    if (user_umask == (mode_t)-1) {\n\tuser_umask = umask(0);\n\tumask(user_umask);\n    }\n\n    /* Always reset the environment for a login shell. */\n    if (ISSET(flags, MODE_LOGIN_SHELL))\n\tdef_env_reset = true;\n\n    /* Some systems support fexecve() which we use for digest matches. */\n    cmnd_fd = -1;\n\n    /* Dump settings and user info (XXX - plugin args) */\n    for (cur = info->settings; *cur != NULL; cur++)\n\tsudo_debug_printf(SUDO_DEBUG_INFO, \"settings: %s\", *cur);\n    for (cur = info->user_info; *cur != NULL; cur++)\n\tsudo_debug_printf(SUDO_DEBUG_INFO, \"user_info: %s\", *cur);\n\n#undef MATCHES\n#undef INVALID\n#undef CHECK\n    debug_return_int(flags);\n\noom:\n    sudo_warnx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\nbad:\n    debug_return_int(MODE_ERROR);\n}", "target": 1, "cwe": ["CWE-193"], "project": "sudo", "commit_id": "c4d384082fdbc8406cf19e08d05db4cded920a55", "hash": 83391947378302188199193223394572343502, "size": 441, "message": "Add sudoedit flag checks in plugin that are consistent with front-end.\nDon't assume the sudo front-end is sending reasonable mode flags.\nThese checks need to be kept consistent between the sudo front-end\nand the sudoers plugin.", "idx": 314}
{"func": "do_tabs(int *tab_list)\n{\n    int last = 1;\n    int stop;\n\n    putchar('\\r');\n    while ((stop = *tab_list++) > 0) {\n\tif (last < stop) {\n\t    while (last++ < stop) {\n\t\tif (last > max_cols)\n\t\t    break;\n\t\tputchar(' ');\n\t    }\n\t}\n\tif (stop <= max_cols) {\n\t    tputs(tparm(set_tab, stop), 1, putch);\n\t    last = stop;\n\t} else {\n\t    break;\n\t}\n    }\n    putchar('\\r');\n}", "target": 1, "cwe": [], "project": "ncurses", "commit_id": "790a85dbd4a81d5f5d8dd02a44d84f01512ef443", "hash": 234814727589010321248837028746117487078, "size": 23, "message": "ncurses 6.2 - patch 20200531\n\n+ correct configure version-check/warnng for g++ to allow for 10.x\n+ re-enable \"bel\" in konsole-base (report by Nia Huang)\n+ add linux-s entry (patch by Alexandre Montaron).\n+ drop long-obsolete convert_configure.pl\n+ add test/test_parm.c, for checking tparm changes.\n+ improve parameter-checking for tparm, adding function _nc_tiparm() to\n  handle the most-used case, which accepts only numeric parameters\n  (report/testcase by \"puppet-meteor\").\n+ use a more conservative estimate of the buffer-size in lib_tparm.c's\n  save_text() and save_number(), in case the sprintf() function\n  passes-through unexpected characters from a format specifier\n  (report/testcase by \"puppet-meteor\").\n+ add a check for end-of-string in cvtchar to handle a malformed\n  string in infotocap (report/testcase by \"puppet-meteor\").", "idx": 315}
{"func": "static ssize_t auto_online_blocks_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       online_type_to_str[memhp_default_online_type]);\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "aa838896d87af561a33ecefea1caa4c15a68bc47", "hash": 168858347991949788521125156112462680136, "size": 6, "message": "drivers core: Use sysfs_emit and sysfs_emit_at for show(device *...) functions\n\nConvert the various sprintf fmaily calls in sysfs device show functions\nto sysfs_emit and sysfs_emit_at for PAGE_SIZE buffer safety.\n\nDone with:\n\n$ spatch -sp-file sysfs_emit_dev.cocci --in-place --max-width=80 .\n\nAnd cocci script:\n\n$ cat sysfs_emit_dev.cocci\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tstrcpy(buf, chr);\n+\tsysfs_emit(buf, chr);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n-\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n+\tlen += sysfs_emit_at(buf, len,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t...\n-\tstrcpy(buf, chr);\n-\treturn strlen(buf);\n+\treturn sysfs_emit(buf, chr);\n}\n\nSigned-off-by: Joe Perches <joe@perches.com>\nLink: https://lore.kernel.org/r/3d033c33056d88bbe34d4ddb62afd05ee166ab9a.1600285923.git.joe@perches.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 316}
{"func": "TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),\n                                                       TRIO_CONST char* string, size_t max,\n                                                       TRIO_CONST char* substring)\n{\n\tsize_t count;\n\tsize_t size;\n\tchar* result = NULL;\n\n\tassert(string);\n\tassert(substring);\n\n\tsize = trio_length(substring);\n\tif (size <= max)\n\t{\n\t\tfor (count = 0; count <= max - size; count++)\n\t\t{\n\t\t\tif (trio_equal_max(substring, size, &string[count]))\n\t\t\t{\n\t\t\t\tresult = (char*)&string[count];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "target": 0, "cwe": ["CWE-190", "CWE-125"], "project": "FreeRDP", "commit_id": "05cd9ea2290d23931f615c1b004d4b2e69074e27", "hash": 311469469344859040846463287351521723132, "size": 25, "message": "Fixed TrioParse and trio_length limts.\n\nCVE-2020-4030 thanks to @antonio-morales for finding this.", "idx": 317}
{"func": "rsvg_new_clip_path (void)\n{\n    RsvgClipPath *clip_path;\n\n    clip_path = g_new (RsvgClipPath, 1);\n    _rsvg_node_init (&clip_path->super);\n    clip_path->units = userSpaceOnUse;\n    clip_path->super.set_atts = rsvg_clip_path_set_atts;\n    clip_path->super.free = _rsvg_node_free;\n    return &clip_path->super;\n}", "target": 1, "cwe": [], "project": "librsvg", "commit_id": "34c95743ca692ea0e44778e41a7c0a129363de84", "hash": 233278155586470635662811063377134123027, "size": 11, "message": "Store node type separately in RsvgNode\n\nThe node name (formerly RsvgNode:type) cannot be used to infer\nthe sub-type of RsvgNode that we're dealing with, since for unknown\nelements we put type = node-name. This lead to a (potentially exploitable)\ncrash e.g. when the element name started with \"fe\" which tricked\nthe old code into considering it as a RsvgFilterPrimitive.\n\nCVE-2011-3146\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=658014", "idx": 318}
{"func": "dump_global_data(FILE *fp, data_t * data)\n{\n#ifdef _WITH_VRRP_\n\tchar buf[64];\n#endif\n\n\tif (!data)\n\t\treturn;\n\n\tconf_write(fp, \"------< Global definitions >------\");\n\n#if HAVE_DECL_CLONE_NEWNET\n\tconf_write(fp, \" Network namespace = %s\", data->network_namespace ? data->network_namespace : \"(default)\");\n#endif\n\tif (data->instance_name)\n\t\tconf_write(fp, \" Instance name = %s\", data->instance_name);\n\tif (data->router_id)\n\t\tconf_write(fp, \" Router ID = %s\", data->router_id);\n\tif (data->smtp_server.ss_family) {\n\t\tconf_write(fp, \" Smtp server = %s\", inet_sockaddrtos(&data->smtp_server));\n\t\tconf_write(fp, \" Smtp server port = %u\", ntohs(inet_sockaddrport(&data->smtp_server)));\n\t}\n\tif (data->smtp_helo_name)\n\t\tconf_write(fp, \" Smtp HELO name = %s\" , data->smtp_helo_name);\n\tif (data->smtp_connection_to)\n\t\tconf_write(fp, \" Smtp server connection timeout = %lu\"\n\t\t\t\t    , data->smtp_connection_to / TIMER_HZ);\n\tif (data->email_from) {\n\t\tconf_write(fp, \" Email notification from = %s\"\n\t\t\t\t    , data->email_from);\n\t\tdump_list(fp, data->email);\n\t}\n\tconf_write(fp, \" Default smtp_alert = %s\",\n\t\t\tdata->smtp_alert == -1 ? \"unset\" : data->smtp_alert ? \"on\" : \"off\");\n#ifdef _WITH_VRRP_\n\tconf_write(fp, \" Default smtp_alert_vrrp = %s\",\n\t\t\tdata->smtp_alert_vrrp == -1 ? \"unset\" : data->smtp_alert_vrrp ? \"on\" : \"off\");\n#endif\n#ifdef _WITH_LVS_\n\tconf_write(fp, \" Default smtp_alert_checker = %s\",\n\t\t\tdata->smtp_alert_checker == -1 ? \"unset\" : data->smtp_alert_checker ? \"on\" : \"off\");\n#endif\n#ifdef _WITH_VRRP_\n\tconf_write(fp, \" Dynamic interfaces = %s\", data->dynamic_interfaces ? \"true\" : \"false\");\n\tif (data->dynamic_interfaces)\n\t\tconf_write(fp, \" Allow interface changes = %s\", data->allow_if_changes ? \"true\" : \"false\");\n\tif (data->no_email_faults)\n\t\tconf_write(fp, \" Send emails for fault transitions = off\");\n#endif\n#ifdef _WITH_LVS_\n\tif (data->lvs_tcp_timeout)\n\t\tconf_write(fp, \" LVS TCP timeout = %d\", data->lvs_tcp_timeout);\n\tif (data->lvs_tcpfin_timeout)\n\t\tconf_write(fp, \" LVS TCP FIN timeout = %d\", data->lvs_tcpfin_timeout);\n\tif (data->lvs_udp_timeout)\n\t\tconf_write(fp, \" LVS TCP timeout = %d\", data->lvs_udp_timeout);\n#ifdef _WITH_VRRP_\n#ifndef _DEBUG_\n\tif (prog_type == PROG_TYPE_VRRP)\n#endif\n\t\tconf_write(fp, \" Default interface = %s\", data->default_ifp ? data->default_ifp->ifname : DFLT_INT);\n\tif (data->lvs_syncd.vrrp) {\n\t\tconf_write(fp, \" LVS syncd vrrp instance = %s\"\n\t\t\t\t    , data->lvs_syncd.vrrp->iname);\n\t\tif (data->lvs_syncd.ifname)\n\t\t\tconf_write(fp, \" LVS syncd interface = %s\"\n\t\t\t\t    , data->lvs_syncd.ifname);\n\t\tconf_write(fp, \" LVS syncd syncid = %u\"\n\t\t\t\t    , data->lvs_syncd.syncid);\n#ifdef _HAVE_IPVS_SYNCD_ATTRIBUTES_\n\t\tif (data->lvs_syncd.sync_maxlen)\n\t\t\tconf_write(fp, \" LVS syncd maxlen = %u\", data->lvs_syncd.sync_maxlen);\n\t\tif (data->lvs_syncd.mcast_group.ss_family != AF_UNSPEC)\n\t\t\tconf_write(fp, \" LVS mcast group %s\", inet_sockaddrtos(&data->lvs_syncd.mcast_group));\n\t\tif (data->lvs_syncd.mcast_port)\n\t\t\tconf_write(fp, \" LVS syncd mcast port = %d\", data->lvs_syncd.mcast_port);\n\t\tif (data->lvs_syncd.mcast_ttl)\n\t\t\tconf_write(fp, \" LVS syncd mcast ttl = %u\", data->lvs_syncd.mcast_ttl);\n#endif\n\t}\n#endif\n\tconf_write(fp, \" LVS flush = %s\", data->lvs_flush ? \"true\" : \"false\");\n#endif\n\tif (data->notify_fifo.name) {\n\t\tconf_write(fp, \" Global notify fifo = %s\", data->notify_fifo.name);\n\t\tif (data->notify_fifo.script)\n\t\t\tconf_write(fp, \" Global notify fifo script = %s, uid:gid %d:%d\",\n\t\t\t\t    cmd_str(data->notify_fifo.script),\n\t\t\t\t    data->notify_fifo.script->uid,\n\t\t\t\t    data->notify_fifo.script->gid);\n\t}\n#ifdef _WITH_VRRP_\n\tif (data->vrrp_notify_fifo.name) {\n\t\tconf_write(fp, \" VRRP notify fifo = %s\", data->vrrp_notify_fifo.name);\n\t\tif (data->vrrp_notify_fifo.script)\n\t\t\tconf_write(fp, \" VRRP notify fifo script = %s, uid:gid %d:%d\",\n\t\t\t\t    cmd_str(data->vrrp_notify_fifo.script),\n\t\t\t\t    data->vrrp_notify_fifo.script->uid,\n\t\t\t\t    data->vrrp_notify_fifo.script->gid);\n\t}\n#endif\n#ifdef _WITH_LVS_\n\tif (data->lvs_notify_fifo.name) {\n\t\tconf_write(fp, \" LVS notify fifo = %s\", data->lvs_notify_fifo.name);\n\t\tif (data->lvs_notify_fifo.script)\n\t\t\tconf_write(fp, \" LVS notify fifo script = %s, uid:gid %d:%d\",\n\t\t\t\t    cmd_str(data->lvs_notify_fifo.script),\n\t\t\t\t    data->lvs_notify_fifo.script->uid,\n\t\t\t\t    data->lvs_notify_fifo.script->gid);\n\t}\n#endif\n#ifdef _WITH_VRRP_\n\tif (data->vrrp_mcast_group4.sin_family) {\n\t\tconf_write(fp, \" VRRP IPv4 mcast group = %s\"\n\t\t\t\t    , inet_sockaddrtos((struct sockaddr_storage *)&data->vrrp_mcast_group4));\n\t}\n\tif (data->vrrp_mcast_group6.sin6_family) {\n\t\tconf_write(fp, \" VRRP IPv6 mcast group = %s\"\n\t\t\t\t    , inet_sockaddrtos((struct sockaddr_storage *)&data->vrrp_mcast_group6));\n\t}\n\tconf_write(fp, \" Gratuitous ARP delay = %u\",\n\t\t       data->vrrp_garp_delay/TIMER_HZ);\n\tconf_write(fp, \" Gratuitous ARP repeat = %u\", data->vrrp_garp_rep);\n\tconf_write(fp, \" Gratuitous ARP refresh timer = %lu\",\n\t\t       data->vrrp_garp_refresh.tv_sec);\n\tconf_write(fp, \" Gratuitous ARP refresh repeat = %d\", data->vrrp_garp_refresh_rep);\n\tconf_write(fp, \" Gratuitous ARP lower priority delay = %d\", data->vrrp_garp_lower_prio_delay == PARAMETER_UNSET ? PARAMETER_UNSET : data->vrrp_garp_lower_prio_delay / TIMER_HZ);\n\tconf_write(fp, \" Gratuitous ARP lower priority repeat = %d\", data->vrrp_garp_lower_prio_rep);\n\tconf_write(fp, \" Send advert after receive lower priority advert = %s\", data->vrrp_lower_prio_no_advert ? \"false\" : \"true\");\n\tconf_write(fp, \" Send advert after receive higher priority advert = %s\", data->vrrp_higher_prio_send_advert ? \"true\" : \"false\");\n\tconf_write(fp, \" Gratuitous ARP interval = %d\", data->vrrp_garp_interval);\n\tconf_write(fp, \" Gratuitous NA interval = %d\", data->vrrp_gna_interval);\n\tconf_write(fp, \" VRRP default protocol version = %d\", data->vrrp_version);\n\tif (data->vrrp_iptables_inchain[0])\n\t\tconf_write(fp,\" Iptables input chain = %s\", data->vrrp_iptables_inchain);\n\tif (data->vrrp_iptables_outchain[0])\n\t\tconf_write(fp,\" Iptables output chain = %s\", data->vrrp_iptables_outchain);\n#ifdef _HAVE_LIBIPSET_\n\tconf_write(fp, \" Using ipsets = %s\", data->using_ipsets ? \"true\" : \"false\");\n\tif (data->vrrp_ipset_address[0])\n\t\tconf_write(fp,\" ipset IPv4 address set = %s\", data->vrrp_ipset_address);\n\tif (data->vrrp_ipset_address6[0])\n\t\tconf_write(fp,\" ipset IPv6 address set = %s\", data->vrrp_ipset_address6);\n\tif (data->vrrp_ipset_address_iface6[0])\n\t\tconf_write(fp,\" ipset IPv6 address,iface set = %s\", data->vrrp_ipset_address_iface6);\n#endif\n\n\tconf_write(fp, \" VRRP check unicast_src = %s\", data->vrrp_check_unicast_src ? \"true\" : \"false\");\n\tconf_write(fp, \" VRRP skip check advert addresses = %s\", data->vrrp_skip_check_adv_addr ? \"true\" : \"false\");\n\tconf_write(fp, \" VRRP strict mode = %s\", data->vrrp_strict ? \"true\" : \"false\");\n\tconf_write(fp, \" VRRP process priority = %d\", data->vrrp_process_priority);\n\tconf_write(fp, \" VRRP don't swap = %s\", data->vrrp_no_swap ? \"true\" : \"false\");\n#ifdef _HAVE_SCHED_RT_\n\tconf_write(fp, \" VRRP realtime priority = %u\", data->vrrp_realtime_priority);\n#if HAVE_DECL_RLIMIT_RTTIME\n\tconf_write(fp, \" VRRP realtime limit = %lu\", data->vrrp_rlimit_rt);\n#endif\n#endif\n#endif\n#ifdef _WITH_LVS_\n\tconf_write(fp, \" Checker process priority = %d\", data->checker_process_priority);\n\tconf_write(fp, \" Checker don't swap = %s\", data->checker_no_swap ? \"true\" : \"false\");\n#ifdef _HAVE_SCHED_RT_\n\tconf_write(fp, \" Checker realtime priority = %u\", data->checker_realtime_priority);\n#if HAVE_DECL_RLIMIT_RTTIME\n\tconf_write(fp, \" Checker realtime limit = %lu\", data->checker_rlimit_rt);\n#endif\n#endif\n#endif\n#ifdef _WITH_BFD_\n\tconf_write(fp, \" BFD process priority = %d\", data->bfd_process_priority);\n\tconf_write(fp, \" BFD don't swap = %s\", data->bfd_no_swap ? \"true\" : \"false\");\n#ifdef _HAVE_SCHED_RT_\n\tconf_write(fp, \" BFD realtime priority = %u\", data->bfd_realtime_priority);\n#if HAVE_DECL_RLIMIT_RTTIME\n\tconf_write(fp, \" BFD realtime limit = %lu\", data->bfd_rlimit_rt);\n#endif\n#endif\n#endif\n#ifdef _WITH_SNMP_VRRP_\n\tconf_write(fp, \" SNMP vrrp %s\", data->enable_snmp_vrrp ? \"enabled\" : \"disabled\");\n#endif\n#ifdef _WITH_SNMP_CHECKER_\n\tconf_write(fp, \" SNMP checker %s\", data->enable_snmp_checker ? \"enabled\" : \"disabled\");\n#endif\n#ifdef _WITH_SNMP_RFCV2_\n\tconf_write(fp, \" SNMP RFCv2 %s\", data->enable_snmp_rfcv2 ? \"enabled\" : \"disabled\");\n#endif\n#ifdef _WITH_SNMP_RFCV3_\n\tconf_write(fp, \" SNMP RFCv3 %s\", data->enable_snmp_rfcv3 ? \"enabled\" : \"disabled\");\n#endif\n#ifdef _WITH_SNMP_\n\tconf_write(fp, \" SNMP traps %s\", data->enable_traps ? \"enabled\" : \"disabled\");\n\tconf_write(fp, \" SNMP socket = %s\", data->snmp_socket ? data->snmp_socket : \"default (unix:/var/agentx/master)\");\n#endif\n#ifdef _WITH_DBUS_\n\tconf_write(fp, \" DBus %s\", data->enable_dbus ? \"enabled\" : \"disabled\");\n\tconf_write(fp, \" DBus service name = %s\", data->dbus_service_name ? data->dbus_service_name : \"\");\n#endif\n\tconf_write(fp, \" Script security %s\", script_security ? \"enabled\" : \"disabled\");\n\tconf_write(fp, \" Default script uid:gid %d:%d\", default_script_uid, default_script_gid);\n#ifdef _WITH_VRRP_\n\tconf_write(fp, \" vrrp_netlink_cmd_rcv_bufs = %u\", global_data->vrrp_netlink_cmd_rcv_bufs);\n\tconf_write(fp, \" vrrp_netlink_cmd_rcv_bufs_force = %u\", global_data->vrrp_netlink_cmd_rcv_bufs_force);\n\tconf_write(fp, \" vrrp_netlink_monitor_rcv_bufs = %u\", global_data->vrrp_netlink_monitor_rcv_bufs);\n\tconf_write(fp, \" vrrp_netlink_monitor_rcv_bufs_force = %u\", global_data->vrrp_netlink_monitor_rcv_bufs_force);\n#endif\n#ifdef _WITH_LVS_\n\tconf_write(fp, \" lvs_netlink_cmd_rcv_bufs = %u\", global_data->lvs_netlink_cmd_rcv_bufs);\n\tconf_write(fp, \" lvs_netlink_cmd_rcv_bufs_force = %u\", global_data->lvs_netlink_cmd_rcv_bufs_force);\n\tconf_write(fp, \" lvs_netlink_monitor_rcv_bufs = %u\", global_data->lvs_netlink_monitor_rcv_bufs);\n\tconf_write(fp, \" lvs_netlink_monitor_rcv_bufs_force = %u\", global_data->lvs_netlink_monitor_rcv_bufs_force);\n\tconf_write(fp, \" rs_init_notifies = %u\", global_data->rs_init_notifies);\n\tconf_write(fp, \" no_checker_emails = %u\", global_data->no_checker_emails);\n#endif\n#ifdef _WITH_VRRP_\n\tbuf[0] = '\\0';\n\tif (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_MTU)\n\t\tstrcpy(buf, \" rx_bufs_policy = MTU\");\n\telse if (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_ADVERT)\n\t\tstrcpy(buf, \" rx_bufs_policy = ADVERT\");\n\telse if (global_data->vrrp_rx_bufs_policy & RX_BUFS_SIZE)\n\t\tsprintf(buf, \" rx_bufs_size = %lu\", global_data->vrrp_rx_bufs_size);\n\tif (buf[0])\n\t\tconf_write(fp, \"%s\", buf);\n\tconf_write(fp, \" rx_bufs_multiples = %u\", global_data->vrrp_rx_bufs_multiples);\n#endif\n}", "target": 1, "cwe": ["CWE-200"], "project": "keepalived", "commit_id": "c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067", "hash": 153215253141798796518979570508673167403, "size": 228, "message": "Add command line and configuration option to set umask\n\nIssue #1048 identified that files created by keepalived are created\nwith mode 0666. This commit changes the default to 0644, and also\nallows the umask to be specified in the configuration or as a command\nline option.\n\nSigned-off-by: Quentin Armitage <quentin@armitage.org.uk>", "idx": 319}
{"func": "static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *info)\n{\n\tu32 tunnel_id = 0;\n\tu32 session_id;\n\tu32 peer_session_id;\n\tint ret = 0;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\n\tstruct l2tp_session_cfg cfg = { 0, };\n\tstruct net *net = genl_info_net(info);\n\n\tif (!info->attrs[L2TP_ATTR_CONN_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\n\ttunnel = l2tp_tunnel_get(net, tunnel_id);\n\tif (!tunnel) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!info->attrs[L2TP_ATTR_SESSION_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out_tunnel;\n\t}\n\tsession_id = nla_get_u32(info->attrs[L2TP_ATTR_SESSION_ID]);\n\n\tif (!info->attrs[L2TP_ATTR_PEER_SESSION_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out_tunnel;\n\t}\n\tpeer_session_id = nla_get_u32(info->attrs[L2TP_ATTR_PEER_SESSION_ID]);\n\n\tif (!info->attrs[L2TP_ATTR_PW_TYPE]) {\n\t\tret = -EINVAL;\n\t\tgoto out_tunnel;\n\t}\n\tcfg.pw_type = nla_get_u16(info->attrs[L2TP_ATTR_PW_TYPE]);\n\tif (cfg.pw_type >= __L2TP_PWTYPE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out_tunnel;\n\t}\n\n\tif (tunnel->version > 2) {\n\t\tif (info->attrs[L2TP_ATTR_OFFSET])\n\t\t\tcfg.offset = nla_get_u16(info->attrs[L2TP_ATTR_OFFSET]);\n\n\t\tif (info->attrs[L2TP_ATTR_DATA_SEQ])\n\t\t\tcfg.data_seq = nla_get_u8(info->attrs[L2TP_ATTR_DATA_SEQ]);\n\n\t\tcfg.l2specific_type = L2TP_L2SPECTYPE_DEFAULT;\n\t\tif (info->attrs[L2TP_ATTR_L2SPEC_TYPE])\n\t\t\tcfg.l2specific_type = nla_get_u8(info->attrs[L2TP_ATTR_L2SPEC_TYPE]);\n\n\t\tcfg.l2specific_len = 4;\n\t\tif (info->attrs[L2TP_ATTR_L2SPEC_LEN])\n\t\t\tcfg.l2specific_len = nla_get_u8(info->attrs[L2TP_ATTR_L2SPEC_LEN]);\n\n\t\tif (info->attrs[L2TP_ATTR_COOKIE]) {\n\t\t\tu16 len = nla_len(info->attrs[L2TP_ATTR_COOKIE]);\n\t\t\tif (len > 8) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_tunnel;\n\t\t\t}\n\t\t\tcfg.cookie_len = len;\n\t\t\tmemcpy(&cfg.cookie[0], nla_data(info->attrs[L2TP_ATTR_COOKIE]), len);\n\t\t}\n\t\tif (info->attrs[L2TP_ATTR_PEER_COOKIE]) {\n\t\t\tu16 len = nla_len(info->attrs[L2TP_ATTR_PEER_COOKIE]);\n\t\t\tif (len > 8) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_tunnel;\n\t\t\t}\n\t\t\tcfg.peer_cookie_len = len;\n\t\t\tmemcpy(&cfg.peer_cookie[0], nla_data(info->attrs[L2TP_ATTR_PEER_COOKIE]), len);\n\t\t}\n\t\tif (info->attrs[L2TP_ATTR_IFNAME])\n\t\t\tcfg.ifname = nla_data(info->attrs[L2TP_ATTR_IFNAME]);\n\n\t\tif (info->attrs[L2TP_ATTR_VLAN_ID])\n\t\t\tcfg.vlan_id = nla_get_u16(info->attrs[L2TP_ATTR_VLAN_ID]);\n\t}\n\n\tif (info->attrs[L2TP_ATTR_DEBUG])\n\t\tcfg.debug = nla_get_u32(info->attrs[L2TP_ATTR_DEBUG]);\n\n\tif (info->attrs[L2TP_ATTR_RECV_SEQ])\n\t\tcfg.recv_seq = nla_get_u8(info->attrs[L2TP_ATTR_RECV_SEQ]);\n\n\tif (info->attrs[L2TP_ATTR_SEND_SEQ])\n\t\tcfg.send_seq = nla_get_u8(info->attrs[L2TP_ATTR_SEND_SEQ]);\n\n\tif (info->attrs[L2TP_ATTR_LNS_MODE])\n\t\tcfg.lns_mode = nla_get_u8(info->attrs[L2TP_ATTR_LNS_MODE]);\n\n\tif (info->attrs[L2TP_ATTR_RECV_TIMEOUT])\n\t\tcfg.reorder_timeout = nla_get_msecs(info->attrs[L2TP_ATTR_RECV_TIMEOUT]);\n\n\tif (info->attrs[L2TP_ATTR_MTU])\n\t\tcfg.mtu = nla_get_u16(info->attrs[L2TP_ATTR_MTU]);\n\n\tif (info->attrs[L2TP_ATTR_MRU])\n\t\tcfg.mru = nla_get_u16(info->attrs[L2TP_ATTR_MRU]);\n\n#ifdef CONFIG_MODULES\n\tif (l2tp_nl_cmd_ops[cfg.pw_type] == NULL) {\n\t\tgenl_unlock();\n\t\trequest_module(\"net-l2tp-type-%u\", cfg.pw_type);\n\t\tgenl_lock();\n\t}\n#endif\n\tif ((l2tp_nl_cmd_ops[cfg.pw_type] == NULL) ||\n\t    (l2tp_nl_cmd_ops[cfg.pw_type]->session_create == NULL)) {\n\t\tret = -EPROTONOSUPPORT;\n\t\tgoto out_tunnel;\n\t}\n\n\t/* Check that pseudowire-specific params are present */\n\tswitch (cfg.pw_type) {\n\tcase L2TP_PWTYPE_NONE:\n\t\tbreak;\n\tcase L2TP_PWTYPE_ETH_VLAN:\n\t\tif (!info->attrs[L2TP_ATTR_VLAN_ID]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_tunnel;\n\t\t}\n\t\tbreak;\n\tcase L2TP_PWTYPE_ETH:\n\t\tbreak;\n\tcase L2TP_PWTYPE_PPP:\n\tcase L2TP_PWTYPE_PPP_AC:\n\t\tbreak;\n\tcase L2TP_PWTYPE_IP:\n\tdefault:\n\t\tret = -EPROTONOSUPPORT;\n\t\tbreak;\n\t}\n\n\tret = -EPROTONOSUPPORT;\n\tif (l2tp_nl_cmd_ops[cfg.pw_type]->session_create)\n\t\tret = (*l2tp_nl_cmd_ops[cfg.pw_type]->session_create)(net, tunnel_id,\n\t\t\tsession_id, peer_session_id, &cfg);\n\n\tif (ret >= 0) {\n\t\tsession = l2tp_session_get(net, tunnel, session_id, false);\n\t\tif (session) {\n\t\t\tret = l2tp_session_notify(&l2tp_nl_family, info, session,\n\t\t\t\t\t\t  L2TP_CMD_SESSION_CREATE);\n\t\t\tl2tp_session_dec_refcount(session);\n\t\t}\n\t}\n\nout_tunnel:\n\tl2tp_tunnel_dec_refcount(tunnel);\nout:\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-416"], "project": "linux", "commit_id": "f026bc29a8e093edfbb2a77700454b285c97e8ad", "hash": 51203097802253084402224360807139712800, "size": 159, "message": "l2tp: pass tunnel pointer to ->session_create()\n\nUsing l2tp_tunnel_find() in pppol2tp_session_create() and\nl2tp_eth_create() is racy, because no reference is held on the\nreturned session. These functions are only used to implement the\n->session_create callback which is run by l2tp_nl_cmd_session_create().\nTherefore searching for the parent tunnel isn't necessary because\nl2tp_nl_cmd_session_create() already has a pointer to it and holds a\nreference.\n\nThis patch modifies ->session_create()'s prototype to directly pass the\nthe parent tunnel as parameter, thus avoiding searching for it in\npppol2tp_session_create() and l2tp_eth_create().\n\nSince we have to touch the ->session_create() call in\nl2tp_nl_cmd_session_create(), let's also remove the useless conditional:\nwe know that ->session_create isn't NULL at this point because it's\nalready been checked earlier in this same function.\n\nFinally, one might be tempted to think that the removed\nl2tp_tunnel_find() calls were harmless because they would return the\nsame tunnel as the one held by l2tp_nl_cmd_session_create() anyway.\nBut that tunnel might be removed and a new one created with same tunnel\nId before the l2tp_tunnel_find() call. In this case l2tp_tunnel_find()\nwould return the new tunnel which wouldn't be protected by the\nreference held by l2tp_nl_cmd_session_create().\n\nFixes: 309795f4bec2 (\"l2tp: Add netlink control API for L2TP\")\nFixes: d9e31d17ceba (\"l2tp: Add L2TP ethernet pseudowire support\")\nSigned-off-by: Guillaume Nault <g.nault@alphalink.fr>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 320}
{"func": "int getClientTypeByName(char *name) {\n    if (!strcasecmp(name,\"normal\")) return CLIENT_TYPE_NORMAL;\n    else if (!strcasecmp(name,\"slave\")) return CLIENT_TYPE_SLAVE;\n    else if (!strcasecmp(name,\"pubsub\")) return CLIENT_TYPE_PUBSUB;\n    else if (!strcasecmp(name,\"master\")) return CLIENT_TYPE_MASTER;\n    else return -1;\n}", "target": 0, "cwe": ["CWE-254"], "project": "redis", "commit_id": "874804da0c014a7d704b3d285aa500098a931f50", "hash": 160502916726855342333587835432586691668, "size": 7, "message": "Security: Cross Protocol Scripting protection.\n\nThis is an attempt at mitigating problems due to cross protocol\nscripting, an attack targeting services using line oriented protocols\nlike Redis that can accept HTTP requests as valid protocol, by\ndiscarding the invalid parts and accepting the payloads sent, for\nexample, via a POST request.\n\nFor this to be effective, when we detect POST and Host: and terminate\nthe connection asynchronously, the networking code was modified in order\nto never process further input. It was later verified that in a\npipelined request containing a POST command, the successive commands are\nnot executed.", "idx": 321}
{"func": "static int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tax25_dev *ax25_dev;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tsock_orphan(sk);\n\tax25 = sk_to_ax25(sk);\n\tax25_dev = ax25->ax25_dev;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\tif (ax25_dev) {\n\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\tax25_dev_put(ax25_dev);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-476"], "project": "linux", "commit_id": "82e31755e55fbcea6a9dfaae5fe4860ade17cbc0", "hash": 14484612574401833931410649996784256828, "size": 86, "message": "ax25: Fix UAF bugs in ax25 timers\n\nThere are race conditions that may lead to UAF bugs in\nax25_heartbeat_expiry(), ax25_t1timer_expiry(), ax25_t2timer_expiry(),\nax25_t3timer_expiry() and ax25_idletimer_expiry(), when we call\nax25_release() to deallocate ax25_dev.\n\nOne of the UAF bugs caused by ax25_release() is shown below:\n\n      (Thread 1)                    |      (Thread 2)\nax25_dev_device_up() //(1)          |\n...                                 | ax25_kill_by_device()\nax25_bind()          //(2)          |\nax25_connect()                      | ...\n ax25_std_establish_data_link()     |\n  ax25_start_t1timer()              | ax25_dev_device_down() //(3)\n   mod_timer(&ax25->t1timer,..)     |\n                                    | ax25_release()\n   (wait a time)                    |  ...\n                                    |  ax25_dev_put(ax25_dev) //(4)FREE\n   ax25_t1timer_expiry()            |\n    ax25->ax25_dev->values[..] //USE|  ...\n     ...                            |\n\nWe increase the refcount of ax25_dev in position (1) and (2), and\ndecrease the refcount of ax25_dev in position (3) and (4).\nThe ax25_dev will be freed in position (4) and be used in\nax25_t1timer_expiry().\n\nThe fail log is shown below:\n==============================================================\n\n[  106.116942] BUG: KASAN: use-after-free in ax25_t1timer_expiry+0x1c/0x60\n[  106.116942] Read of size 8 at addr ffff88800bda9028 by task swapper/0/0\n[  106.116942] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.17.0-06123-g0905eec574\n[  106.116942] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-14\n[  106.116942] Call Trace:\n...\n[  106.116942]  ax25_t1timer_expiry+0x1c/0x60\n[  106.116942]  call_timer_fn+0x122/0x3d0\n[  106.116942]  __run_timers.part.0+0x3f6/0x520\n[  106.116942]  run_timer_softirq+0x4f/0xb0\n[  106.116942]  __do_softirq+0x1c2/0x651\n...\n\nThis patch adds del_timer_sync() in ax25_release(), which could ensure\nthat all timers stop before we deallocate ax25_dev.\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>", "idx": 322}
{"func": "PHP_FUNCTION(openssl_error_string)\n{\n\tchar buf[256];\n\tunsigned long val;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_openssl_store_errors();\n\n\tif (OPENSSL_G(errors) == NULL || OPENSSL_G(errors)->top == OPENSSL_G(errors)->bottom) {\n\t\tRETURN_FALSE;\n\t}\n\n\tOPENSSL_G(errors)->bottom = (OPENSSL_G(errors)->bottom + 1) % ERR_NUM_ERRORS;\n\tval = OPENSSL_G(errors)->buffer[OPENSSL_G(errors)->bottom];\n\n\tif (val) {\n\t\tERR_error_string_n(val, buf, 256);\n\t\tRETURN_STRING(buf);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0, "cwe": ["CWE-326"], "project": "php-src", "commit_id": "0216630ea2815a5789a24279a1211ac398d4de79", "hash": 165010362180722549608183902312861082605, "size": 25, "message": "Fix bug #79601 (Wrong ciphertext/tag in AES-CCM encryption for a 12 bytes IV)", "idx": 323}
{"func": "void ElectronBrowserClient::RegisterBrowserInterfaceBindersForFrame(\n    content::RenderFrameHost* render_frame_host,\n    mojo::BinderMapWithContext<content::RenderFrameHost*>* map) {\n  map->Add<network_hints::mojom::NetworkHintsHandler>(\n      base::BindRepeating(&BindNetworkHintsHandler));\n  map->Add<blink::mojom::BadgeService>(\n      base::BindRepeating(&badging::BadgeManager::BindFrameReceiver));\n  map->Add<electron::mojom::ElectronBrowser>(\n      base::BindRepeating(&BindElectronBrowser));\n  map->Add<blink::mojom::KeyboardLockService>(base::BindRepeating(\n      &content::KeyboardLockServiceImpl::CreateMojoService));\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  map->Add<extensions::mime_handler::MimeHandlerService>(\n      base::BindRepeating(&BindMimeHandlerService));\n  map->Add<extensions::mime_handler::BeforeUnloadControl>(\n      base::BindRepeating(&BindBeforeUnloadControl));\n\n  content::WebContents* web_contents =\n      content::WebContents::FromRenderFrameHost(render_frame_host);\n  if (!web_contents)\n    return;\n\n  const GURL& site = render_frame_host->GetSiteInstance()->GetSiteURL();\n  if (!site.SchemeIs(extensions::kExtensionScheme))\n    return;\n\n  content::BrowserContext* browser_context =\n      render_frame_host->GetProcess()->GetBrowserContext();\n  auto* extension = extensions::ExtensionRegistry::Get(browser_context)\n                        ->enabled_extensions()\n                        .GetByID(site.host());\n  if (!extension)\n    return;\n  extensions::ExtensionsBrowserClient::Get()\n      ->RegisterBrowserInterfaceBindersForFrame(map, render_frame_host,\n                                                extension);\n#endif\n}", "target": 1, "cwe": [], "project": "electron", "commit_id": "6b04cce91ad1563bd9555f2007a2ad5aa5487304", "hash": 306829735981483477881591841692438401399, "size": 38, "message": "fix: ensure ElectronBrowser mojo service is only bound to appropriate render frames (#33367)\n\n* Make ElectronBrowser mojo interface frame associated. (#32815)\r\n\r\nCo-authored-by: Marek Haranczyk <marek@openfin.co>\r\n\r\n* fix: ensure ElectronBrowser mojo service is only bound to appropriate render frames (#33323) (#33350)\r\n\r\n* fix: ensure ElectronBrowser mojo service is only bound to authorized render frames\r\n\r\nNotes: no-notes\r\n\r\n* refactor: extract electron API IPC to its own mojo interface\r\n\r\n* fix: just check main frame not primary main frame\r\n\r\nCo-authored-by: trop[bot] <37223003+trop[bot]@users.noreply.github.com>\r\nCo-authored-by: Marek Haranczyk <marek@openfin.co>", "idx": 324}
{"func": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t/* Convert (if necessary) to absolute time */\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t/* abs timers don't set remaining time or restart */\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-190"], "project": "linux", "commit_id": "5f936e19cc0ef97dbe3a56e9498922ad5ba1edef", "hash": 2788706287903203404230893690568450998, "size": 40, "message": "alarmtimer: Prevent overflow for relative nanosleep\n\nAir Icy reported:\n\n  UBSAN: Undefined behaviour in kernel/time/alarmtimer.c:811:7\n  signed integer overflow:\n  1529859276030040771 + 9223372036854775807 cannot be represented in type 'long long int'\n  Call Trace:\n   alarm_timer_nsleep+0x44c/0x510 kernel/time/alarmtimer.c:811\n   __do_sys_clock_nanosleep kernel/time/posix-timers.c:1235 [inline]\n   __se_sys_clock_nanosleep kernel/time/posix-timers.c:1213 [inline]\n   __x64_sys_clock_nanosleep+0x326/0x4e0 kernel/time/posix-timers.c:1213\n   do_syscall_64+0xb8/0x3a0 arch/x86/entry/common.c:290\n\nalarm_timer_nsleep() uses ktime_add() to add the current time and the\nrelative expiry value. ktime_add() has no sanity checks so the addition\ncan overflow when the relative timeout is large enough.\n\nUse ktime_add_safe() which has the necessary sanity checks in place and\nlimits the result to the valid range.\n\nFixes: 9a7adcf5c6de (\"timers: Posix interface for alarm-timers\")\nReported-by: Team OWL337 <icytxw@gmail.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: John Stultz <john.stultz@linaro.org>\nLink: https://lkml.kernel.org/r/alpine.DEB.2.21.1807020926360.1595@nanos.tec.linutronix.de", "idx": 325}
{"func": "gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,\n    int length)\n{\n  int i;\n  int n;\n  GstRMDemuxIndex *index;\n\n  /* The number of index records */\n  n = length / 14;\n\n  if (rmdemux->index_stream == NULL)\n    return;\n\n  /* don't parse the index a second time when operating pull-based and\n   * reaching the end of the file */\n  if (rmdemux->index_stream->index_length > 0) {\n    GST_DEBUG_OBJECT (rmdemux, \"Already have an index for this stream\");\n    return;\n  }\n\n  index = g_malloc (sizeof (GstRMDemuxIndex) * n);\n  rmdemux->index_stream->index = index;\n  rmdemux->index_stream->index_length = n;\n\n  for (i = 0; i < n; i++) {\n    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;\n    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);\n\n    GST_DEBUG_OBJECT (rmdemux, \"Index found for timestamp=%f (at offset=%x)\",\n        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,\n        index[i].offset);\n    data += 14;\n  }\n}", "target": 0, "cwe": [], "project": "gst-plugins-ugly", "commit_id": "9726aaf78e6643a5955864f444852423de58de29", "hash": 118829903304733024845365965221425219029, "size": 34, "message": "rmdemux: Make sure we have enough data available when parsing audio/video packets\n\nOtherwise there will be out-of-bounds reads and potential crashes.\n\nThanks to Natalie Silvanovich for reporting.\n\nFixes https://gitlab.freedesktop.org/gstreamer/gst-plugins-ugly/-/issues/37\n\nPart-of: <https://gitlab.freedesktop.org/gstreamer/gst-plugins-ugly/-/merge_requests/75>", "idx": 326}
{"func": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n\t\tgoto out;\n\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  /* Use device */\n\tsk_dst_reset(sk);\n\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn ret;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-416", "CWE-284"], "project": "linux", "commit_id": "32c231164b762dddefa13af5a0101032c70b50ef", "hash": 159103919895129155197131715147137101297, "size": 58, "message": "l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()\n\nLock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().\nWithout lock, a concurrent call could modify the socket flags between\nthe sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,\na socket could be inserted twice in l2tp_ip6_bind_table. Releasing it\nwould then leave a stale pointer there, generating use-after-free\nerrors when walking through the list or modifying adjacent entries.\n\nBUG: KASAN: use-after-free in l2tp_ip6_close+0x22e/0x290 at addr ffff8800081b0ed8\nWrite of size 8 by task syz-executor/10987\nCPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014\n ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0\n ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc\n ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0\nCall Trace:\n [<ffffffff829f835b>] dump_stack+0xb3/0x118 lib/dump_stack.c:15\n [<ffffffff8174d3cc>] kasan_object_err+0x1c/0x70 mm/kasan/report.c:156\n [<     inline     >] print_address_description mm/kasan/report.c:194\n [<ffffffff8174d666>] kasan_report_error+0x1f6/0x4d0 mm/kasan/report.c:283\n [<     inline     >] kasan_report mm/kasan/report.c:303\n [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e/0x40 mm/kasan/report.c:329\n [<     inline     >] __write_once_size ./include/linux/compiler.h:249\n [<     inline     >] __hlist_del ./include/linux/list.h:622\n [<     inline     >] hlist_del_init ./include/linux/list.h:637\n [<ffffffff8579047e>] l2tp_ip6_close+0x22e/0x290 net/l2tp/l2tp_ip6.c:239\n [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415\n [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422\n [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570\n [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017\n [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208\n [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244\n [<ffffffff813774f9>] task_work_run+0xf9/0x170\n [<ffffffff81324aae>] do_exit+0x85e/0x2a00\n [<ffffffff81326dc8>] do_group_exit+0x108/0x330\n [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307\n [<ffffffff811b49af>] do_signal+0x7f/0x18f0\n [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156\n [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190\n [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259\n [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6\nObject at ffff8800081b0ec0, in cache L2TP/IPv6 size: 1448\nAllocated:\nPID = 10987\n [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20\n [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0\n [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad/0xe0\n [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12/0x20\n [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm/slab.h:417\n [ 1116.897025] [<     inline     >] slab_alloc_node mm/slub.c:2708\n [ 1116.897025] [<     inline     >] slab_alloc mm/slub.c:2716\n [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8/0x2b0 mm/slub.c:2721\n [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69/0x2b0 net/core/sock.c:1326\n [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38/0xae0 net/core/sock.c:1388\n [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7/0x1000 net/ipv6/af_inet6.c:182\n [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b/0x640 net/socket.c:1153\n [ 1116.897025] [<     inline     >] sock_create net/socket.c:1193\n [ 1116.897025] [<     inline     >] SYSC_socket net/socket.c:1223\n [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef/0x1b0 net/socket.c:1203\n [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23/0xc6\nFreed:\nPID = 10987\n [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20\n [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0\n [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71/0xb0\n [ 1116.897025] [<     inline     >] slab_free_hook mm/slub.c:1352\n [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm/slub.c:1374\n [ 1116.897025] [<     inline     >] slab_free mm/slub.c:2951\n [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8/0x330 mm/slub.c:2973\n [ 1116.897025] [<     inline     >] sk_prot_free net/core/sock.c:1369\n [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b/0x4f0 net/core/sock.c:1444\n [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44/0x80 net/core/sock.c:1452\n [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53/0x220 net/core/sock.c:1460\n [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23/0x30 net/core/sock.c:1471\n [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c/0x3e0 ./include/net/sock.h:1589\n [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe/0x290 net/l2tp/l2tp_ip6.c:243\n [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415\n [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422\n [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570\n [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017\n [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208\n [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244\n [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9/0x170\n [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e/0x2a00\n [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108/0x330\n [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307\n [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f/0x18f0\n [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156\n [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190\n [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259\n [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6\nMemory state around the buggy address:\n ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb\n                                                    ^\n ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\n==================================================================\n\nThe same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.\n\nFixes: c51ce49735c1 (\"l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case\")\nReported-by: Baozeng Ding <sploving1@gmail.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Baozeng Ding <sploving1@gmail.com>\nSigned-off-by: Guillaume Nault <g.nault@alphalink.fr>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 327}
{"func": "static int nfsd_inet6addr_event(struct notifier_block *this,\n\tunsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->idev->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct sockaddr_in6 sin6;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nn->nfsd_serv) {\n\t\tdprintk(\"nfsd_inet6addr_event: removed %pI6\\n\", &ifa->addr);\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_addr = ifa->addr;\n\t\tif (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tsin6.sin6_scope_id = ifa->idev->dev->ifindex;\n\t\tsvc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}", "target": 0, "cwe": ["CWE-20"], "project": "linux", "commit_id": "e6838a29ecb484c97e4efef9429643b9851fba6e", "hash": 161431155494848421547758302240048015379, "size": 24, "message": "nfsd: check for oversized NFSv2/v3 arguments\n\nA client can append random data to the end of an NFSv2 or NFSv3 RPC call\nwithout our complaining; we'll just stop parsing at the end of the\nexpected data and ignore the rest.\n\nEncoded arguments and replies are stored together in an array of pages,\nand if a call is too large it could leave inadequate space for the\nreply.  This is normally OK because NFS RPC's typically have either\nshort arguments and long replies (like READ) or long arguments and short\nreplies (like WRITE).  But a client that sends an incorrectly long reply\ncan violate those assumptions.  This was observed to cause crashes.\n\nAlso, several operations increment rq_next_page in the decode routine\nbefore checking the argument size, which can leave rq_next_page pointing\nwell past the end of the page array, causing trouble later in\nsvc_free_pages.\n\nSo, following a suggestion from Neil Brown, add a central check to\nenforce our expectation that no NFSv2/v3 call has both a large call and\na large reply.\n\nAs followup we may also want to rewrite the encoding routines to check\nmore carefully that they aren't running off the end of the page array.\n\nWe may also consider rejecting calls that have any extra garbage\nappended.  That would be safer, and within our rights by spec, but given\nthe age of our server and the NFS protocol, and the fact that we've\nnever enforced this before, we may need to balance that against the\npossibility of breaking some oddball client.\n\nReported-by: Tuomas Haanpää <thaan@synopsys.com>\nReported-by: Ari Kauppi <ari@synopsys.com>\nCc: stable@vger.kernel.org\nReviewed-by: NeilBrown <neilb@suse.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>", "idx": 328}
{"func": "static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(\n    OPJ_UINT32 p_id)\n{\n    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(\n                                       opj_jp2_header_handler_t);\n    for (i = 0; i < l_handler_size; ++i) {\n        if (jp2_img_header[i].id == p_id) {\n            return &jp2_img_header[i];\n        }\n    }\n\n    return NULL;\n}", "target": 0, "cwe": ["CWE-20"], "project": "openjpeg", "commit_id": "4edb8c83374f52cd6a8f2c7c875e8ffacccb5fa5", "hash": 289253269938210572047764669325291574111, "size": 13, "message": "Add support for generation of PLT markers in encoder\n\n* -PLT switch added to opj_compress\n* Add a opj_encoder_set_extra_options() function that\n  accepts a PLT=YES option, and could be expanded later\n  for other uses.\n\n-------\n\nTesting with a Sentinel2 10m band, T36JTT_20160914T074612_B02.jp2,\ncoming from S2A_MSIL1C_20160914T074612_N0204_R135_T36JTT_20160914T081456.SAFE\n\nDecompress it to TIFF:\n```\nopj_uncompress -i T36JTT_20160914T074612_B02.jp2 -o T36JTT_20160914T074612_B02.tif\n```\n\nRecompress it with similar parameters as original:\n```\nopj_compress -n 5 -c [256,256],[256,256],[256,256],[256,256],[256,256] -t 1024,1024 -PLT -i T36JTT_20160914T074612_B02.tif -o T36JTT_20160914T074612_B02_PLT.jp2\n```\n\nDump codestream detail with GDAL dump_jp2.py utility (https://github.com/OSGeo/gdal/blob/master/gdal/swig/python/samples/dump_jp2.py)\n```\npython dump_jp2.py T36JTT_20160914T074612_B02.jp2 > /tmp/dump_sentinel2_ori.txt\npython dump_jp2.py T36JTT_20160914T074612_B02_PLT.jp2 > /tmp/dump_sentinel2_openjpeg_plt.txt\n```\n\nThe diff between both show very similar structure, and identical number of packets in PLT markers\n\nNow testing with Kakadu (KDU803_Demo_Apps_for_Linux-x86-64_200210)\n\nFull file decompression:\n```\nkdu_expand -i T36JTT_20160914T074612_B02_PLT.jp2 -o tmp.tif\n\nConsumed 121 tile-part(s) from a total of 121 tile(s).\nConsumed 80,318,806 codestream bytes (excluding any file format) = 5.329697\nbits/pel.\nProcessed using the multi-threaded environment, with\n    8 parallel threads of execution\n```\n\nPartial decompresson (presumably using PLT markers):\n```\nkdu_expand -i T36JTT_20160914T074612_B02.jp2 -o tmp.pgm -region \"{0.5,0.5},{0.01,0.01}\"\nkdu_expand -i T36JTT_20160914T074612_B02_PLT.jp2 -o tmp2.pgm  -region \"{0.5,0.5},{0.01,0.01}\"\ndiff tmp.pgm tmp2.pgm && echo \"same !\"\n```\n\n-------\n\nFunded by ESA for S2-MPC project", "idx": 329}
{"func": "static int blk_mq_hctx_notify(void *data, unsigned long action,\n\t\t\t      unsigned int cpu)\n{\n\tstruct blk_mq_hw_ctx *hctx = data;\n\n\tif (action == CPU_DEAD || action == CPU_DEAD_FROZEN)\n\t\treturn blk_mq_hctx_cpu_offline(hctx, cpu);\n\n\t/*\n\t * In case of CPU online, tags may be reallocated\n\t * in blk_mq_map_swqueue() after mapping is updated.\n\t */\n\n\treturn NOTIFY_OK;\n}", "target": 0, "cwe": ["CWE-362", "CWE-264"], "project": "linux", "commit_id": "0048b4837affd153897ed1222283492070027aa9", "hash": 331519597960773104207616902564013209974, "size": 15, "message": "blk-mq: fix race between timeout and freeing request\n\nInside timeout handler, blk_mq_tag_to_rq() is called\nto retrieve the request from one tag. This way is obviously\nwrong because the request can be freed any time and some\nfiedds of the request can't be trusted, then kernel oops\nmight be triggered[1].\n\nCurrently wrt. blk_mq_tag_to_rq(), the only special case is\nthat the flush request can share same tag with the request\ncloned from, and the two requests can't be active at the same\ntime, so this patch fixes the above issue by updating tags->rqs[tag]\nwith the active request(either flush rq or the request cloned\nfrom) of the tag.\n\nAlso blk_mq_tag_to_rq() gets much simplified with this patch.\n\nGiven blk_mq_tag_to_rq() is mainly for drivers and the caller must\nmake sure the request can't be freed, so in bt_for_each() this\nhelper is replaced with tags->rqs[tag].\n\n[1] kernel oops log\n[  439.696220] BUG: unable to handle kernel NULL pointer dereference at 0000000000000158^M\n[  439.697162] IP: [<ffffffff812d89ba>] blk_mq_tag_to_rq+0x21/0x6e^M\n[  439.700653] PGD 7ef765067 PUD 7ef764067 PMD 0 ^M\n[  439.700653] Oops: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC ^M\n[  439.700653] Dumping ftrace buffer:^M\n[  439.700653]    (ftrace buffer empty)^M\n[  439.700653] Modules linked in: nbd ipv6 kvm_intel kvm serio_raw^M\n[  439.700653] CPU: 6 PID: 2779 Comm: stress-ng-sigfd Not tainted 4.2.0-rc5-next-20150805+ #265^M\n[  439.730500] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011^M\n[  439.730500] task: ffff880605308000 ti: ffff88060530c000 task.ti: ffff88060530c000^M\n[  439.730500] RIP: 0010:[<ffffffff812d89ba>]  [<ffffffff812d89ba>] blk_mq_tag_to_rq+0x21/0x6e^M\n[  439.730500] RSP: 0018:ffff880819203da0  EFLAGS: 00010283^M\n[  439.730500] RAX: ffff880811b0e000 RBX: ffff8800bb465f00 RCX: 0000000000000002^M\n[  439.730500] RDX: 0000000000000000 RSI: 0000000000000202 RDI: 0000000000000000^M\n[  439.730500] RBP: ffff880819203db0 R08: 0000000000000002 R09: 0000000000000000^M\n[  439.730500] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000202^M\n[  439.730500] R13: ffff880814104800 R14: 0000000000000002 R15: ffff880811a2ea00^M\n[  439.730500] FS:  00007f165b3f5740(0000) GS:ffff880819200000(0000) knlGS:0000000000000000^M\n[  439.730500] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b^M\n[  439.730500] CR2: 0000000000000158 CR3: 00000007ef766000 CR4: 00000000000006e0^M\n[  439.730500] Stack:^M\n[  439.730500]  0000000000000008 ffff8808114eed90 ffff880819203e00 ffffffff812dc104^M\n[  439.755663]  ffff880819203e40 ffffffff812d9f5e 0000020000000000 ffff8808114eed80^M\n[  439.755663] Call Trace:^M\n[  439.755663]  <IRQ> ^M\n[  439.755663]  [<ffffffff812dc104>] bt_for_each+0x6e/0xc8^M\n[  439.755663]  [<ffffffff812d9f5e>] ? blk_mq_rq_timed_out+0x6a/0x6a^M\n[  439.755663]  [<ffffffff812d9f5e>] ? blk_mq_rq_timed_out+0x6a/0x6a^M\n[  439.755663]  [<ffffffff812dc1b3>] blk_mq_tag_busy_iter+0x55/0x5e^M\n[  439.755663]  [<ffffffff812d88b4>] ? blk_mq_bio_to_request+0x38/0x38^M\n[  439.755663]  [<ffffffff812d8911>] blk_mq_rq_timer+0x5d/0xd4^M\n[  439.755663]  [<ffffffff810a3e10>] call_timer_fn+0xf7/0x284^M\n[  439.755663]  [<ffffffff810a3d1e>] ? call_timer_fn+0x5/0x284^M\n[  439.755663]  [<ffffffff812d88b4>] ? blk_mq_bio_to_request+0x38/0x38^M\n[  439.755663]  [<ffffffff810a46d6>] run_timer_softirq+0x1ce/0x1f8^M\n[  439.755663]  [<ffffffff8104c367>] __do_softirq+0x181/0x3a4^M\n[  439.755663]  [<ffffffff8104c76e>] irq_exit+0x40/0x94^M\n[  439.755663]  [<ffffffff81031482>] smp_apic_timer_interrupt+0x33/0x3e^M\n[  439.755663]  [<ffffffff815559a4>] apic_timer_interrupt+0x84/0x90^M\n[  439.755663]  <EOI> ^M\n[  439.755663]  [<ffffffff81554350>] ? _raw_spin_unlock_irq+0x32/0x4a^M\n[  439.755663]  [<ffffffff8106a98b>] finish_task_switch+0xe0/0x163^M\n[  439.755663]  [<ffffffff8106a94d>] ? finish_task_switch+0xa2/0x163^M\n[  439.755663]  [<ffffffff81550066>] __schedule+0x469/0x6cd^M\n[  439.755663]  [<ffffffff8155039b>] schedule+0x82/0x9a^M\n[  439.789267]  [<ffffffff8119b28b>] signalfd_read+0x186/0x49a^M\n[  439.790911]  [<ffffffff8106d86a>] ? wake_up_q+0x47/0x47^M\n[  439.790911]  [<ffffffff811618c2>] __vfs_read+0x28/0x9f^M\n[  439.790911]  [<ffffffff8117a289>] ? __fget_light+0x4d/0x74^M\n[  439.790911]  [<ffffffff811620a7>] vfs_read+0x7a/0xc6^M\n[  439.790911]  [<ffffffff8116292b>] SyS_read+0x49/0x7f^M\n[  439.790911]  [<ffffffff81554c17>] entry_SYSCALL_64_fastpath+0x12/0x6f^M\n[  439.790911] Code: 48 89 e5 e8 a9 b8 e7 ff 5d c3 0f 1f 44 00 00 55 89\nf2 48 89 e5 41 54 41 89 f4 53 48 8b 47 60 48 8b 1c d0 48 8b 7b 30 48 8b\n53 38 <48> 8b 87 58 01 00 00 48 85 c0 75 09 48 8b 97 88 0c 00 00 eb 10\n^M\n[  439.790911] RIP  [<ffffffff812d89ba>] blk_mq_tag_to_rq+0x21/0x6e^M\n[  439.790911]  RSP <ffff880819203da0>^M\n[  439.790911] CR2: 0000000000000158^M\n[  439.790911] ---[ end trace d40af58949325661 ]---^M\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Ming Lei <ming.lei@canonical.com>\nSigned-off-by: Jens Axboe <axboe@fb.com>", "idx": 330}
{"func": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264", "CWE-754"], "project": "linux", "commit_id": "ef87dbe7614341c2e7bfe8d32fcb7028cc97442c", "hash": 101361039808854549123951921128936655012, "size": 59, "message": "floppy: ignore kernel-only members in FDRAWCMD ioctl input\n\nAlways clear out these floppy_raw_cmd struct members after copying the\nentire structure from userspace so that the in-kernel version is always\nvalid and never left in an interdeterminate state.\n\nSigned-off-by: Matthew Daley <mattd@bugfuzz.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 331}
{"func": "PHP_FUNCTION(sqlite_open)\n{\n\tlong mode = 0666;\n\tchar *filename, *fullpath = NULL;\n\tint filename_len;\n\tzval *errmsg = NULL;\n\tzval *object = getThis();\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(object ? EH_THROW : EH_NORMAL, sqlite_ce_exception, &error_handling TSRMLS_CC);\n\tif (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|lz/\",\n\t\t\t\t&filename, &filename_len, &mode, &errmsg)) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\tif (errmsg) {\n\t\tzval_dtor(errmsg);\n\t\tZVAL_NULL(errmsg);\n\t}\n\n\tif (strncmp(filename, \":memory:\", sizeof(\":memory:\") - 1)) {\n\t\t/* resolve the fully-qualified path name to use as the hash key */\n\t\tif (!(fullpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\tif (object) {\n\t\t\t\tRETURN_NULL();\n\t\t\t} else {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif ((PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) ||\n\t\t\t\tphp_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\tif (object) {\n\t\t\t\tRETURN_NULL();\n\t\t\t} else {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tphp_sqlite_open(fullpath ? fullpath : filename, (int)mode, NULL, return_value, errmsg, object TSRMLS_CC);\n\n\tif (fullpath) {\n\t\tefree(fullpath);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 1, "cwe": [], "project": "php-src", "commit_id": "ce96fd6b0761d98353761bf78d5bfb55291179fd", "hash": 151930662649138540668234690195831456874, "size": 50, "message": "- fix #39863, do not accept paths with NULL in them. See http://news.php.net/php.internals/50191, trunk will have the patch later (adding a macro and/or changing (some) APIs. Patch by Rasmus", "idx": 332}
{"func": "int acpi_smbus_register_callback(struct acpi_smb_hc *hc,\n\t\t\t         smbus_alarm_callback callback, void *context)\n{\n\tmutex_lock(&hc->lock);\n\thc->callback = callback;\n\thc->context = context;\n\tmutex_unlock(&hc->lock);\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-200"], "project": "linux", "commit_id": "43cdd1b716b26f6af16da4e145b6578f98798bf6", "hash": 337493423112073992962032249868279934233, "size": 9, "message": "ACPI: sbshc: remove raw pointer from printk() message\n\nThere's no need to be printing a raw kernel pointer to the kernel log at\nevery boot.  So just remove it, and change the whole message to use the\ncorrect dev_info() call at the same time.\n\nReported-by: Wang Qize <wang_qize@venustech.com.cn>\nCc: All applicable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>", "idx": 333}
{"func": "static inline void tcp_mtu_check_reprobe(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tu32 interval;\n\ts32 delta;\n\n\tinterval = net->ipv4.sysctl_tcp_probe_interval;\n\tdelta = tcp_jiffies32 - icsk->icsk_mtup.probe_timestamp;\n\tif (unlikely(delta >= interval * HZ)) {\n\t\tint mss = tcp_current_mss(sk);\n\n\t\t/* Update current search range */\n\t\ticsk->icsk_mtup.probe_size = 0;\n\t\ticsk->icsk_mtup.search_high = tp->rx_opt.mss_clamp +\n\t\t\tsizeof(struct tcphdr) +\n\t\t\ticsk->icsk_af_ops->net_header_len;\n\t\ticsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);\n\n\t\t/* Update probe time stamp */\n\t\ticsk->icsk_mtup.probe_timestamp = tcp_jiffies32;\n\t}\n}", "target": 0, "cwe": ["CWE-190"], "project": "net", "commit_id": "3b4929f65b0d8249f19a50245cd88ed1a2f78cff", "hash": 14472865137425983028571423680159172112, "size": 24, "message": "tcp: limit payload size of sacked skbs\n\nJonathan Looney reported that TCP can trigger the following crash\nin tcp_shifted_skb() :\n\n\tBUG_ON(tcp_skb_pcount(skb) < pcount);\n\nThis can happen if the remote peer has advertized the smallest\nMSS that linux TCP accepts : 48\n\nAn skb can hold 17 fragments, and each fragment can hold 32KB\non x86, or 64KB on PowerPC.\n\nThis means that the 16bit witdh of TCP_SKB_CB(skb)->tcp_gso_segs\ncan overflow.\n\nNote that tcp_sendmsg() builds skbs with less than 64KB\nof payload, so this problem needs SACK to be enabled.\nSACK blocks allow TCP to coalesce multiple skbs in the retransmit\nqueue, thus filling the 17 fragments to maximal capacity.\n\nCVE-2019-11477 -- u16 overflow of TCP_SKB_CB(skb)->tcp_gso_segs\n\nFixes: 832d11c5cd07 (\"tcp: Try to restore large SKBs while SACK processing\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Jonathan Looney <jtl@netflix.com>\nAcked-by: Neal Cardwell <ncardwell@google.com>\nReviewed-by: Tyler Hicks <tyhicks@canonical.com>\nCc: Yuchung Cheng <ycheng@google.com>\nCc: Bruce Curtis <brucec@netflix.com>\nCc: Jonathan Lemon <jonathan.lemon@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 334}
{"func": "static int test_x509_time_print(int idx)\n{\n    BIO *m;\n    int ret = 0, rv;\n    char *pp;\n    const char *readable;\n\n    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))\n        goto err;\n\n    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);\n    readable = x509_print_tests[idx].readable;\n\n    if (rv == 0 && !TEST_str_eq(readable, \"Bad time value\")) {\n        /* only if the test case intends to fail... */\n        goto err;\n    }\n    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)\n        || !TEST_int_eq(rv, (int)strlen(readable))\n        || !TEST_strn_eq(pp, readable, rv))\n        goto err;\n\n    ret = 1;\n err:\n    BIO_free(m);\n    return ret;\n}", "target": 0, "cwe": ["CWE-125"], "project": "openssl", "commit_id": "4de66925203ca99189c842136ec4a623137ea447", "hash": 309938493187298443975624449860223968627, "size": 27, "message": "Fix test code to not assume NUL terminated strings\n\nASN.1 strings may not be NUL terminated. Don't assume they are.\n\nCVE-2021-3712\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>", "idx": 335}
{"func": "gdk_pixbuf__gif_image_load_animation (FILE *file,\n                                      GError **error)\n{\n\tGifContext *context;\n\tGdkPixbufAnimation *animation;\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tcontext = new_context ();\n\n        context->error = error;\n\tcontext->file = file;\n\n\tif (gif_main_loop (context) == -1 || context->animation->frames == NULL) {\n                if (context->error && *(context->error) == NULL)\n                        g_set_error (context->error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"GIF file was missing some data (perhaps it was truncated somehow?)\"));\n\n                g_object_unref (G_OBJECT (context->animation));\n                context->animation = NULL;\n        }\n\n        if (context->animation)\n                animation = GDK_PIXBUF_ANIMATION (context->animation);\n        else\n                animation = NULL;\n\n        if (context->error && *(context->error))\n                g_print (\"%s\\n\", (*(context->error))->message);\n        \n        g_free (context->buf);\n\tg_free (context);\n\treturn animation;\n}", "target": 1, "cwe": ["CWE-20"], "project": "gdk-pixbuf", "commit_id": "3bac204e0d0241a0d68586ece7099e6acf0e9bea", "hash": 65997432212018977925658256286394930346, "size": 36, "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better.", "idx": 336}
{"func": "void __hci_abort_conn(struct hci_request *req, struct hci_conn *conn,\n\t\t      u8 reason)\n{\n\tswitch (conn->state) {\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\tif (conn->type == AMP_LINK) {\n\t\t\tstruct hci_cp_disconn_phy_link cp;\n\n\t\t\tcp.phy_handle = HCI_PHY_HANDLE(conn->handle);\n\t\t\tcp.reason = reason;\n\t\t\thci_req_add(req, HCI_OP_DISCONN_PHY_LINK, sizeof(cp),\n\t\t\t\t    &cp);\n\t\t} else {\n\t\t\tstruct hci_cp_disconnect dc;\n\n\t\t\tdc.handle = cpu_to_le16(conn->handle);\n\t\t\tdc.reason = reason;\n\t\t\thci_req_add(req, HCI_OP_DISCONNECT, sizeof(dc), &dc);\n\t\t}\n\n\t\tconn->state = BT_DISCONN;\n\n\t\tbreak;\n\tcase BT_CONNECT:\n\t\tif (conn->type == LE_LINK) {\n\t\t\tif (test_bit(HCI_CONN_SCANNING, &conn->flags))\n\t\t\t\tbreak;\n\t\t\thci_req_add(req, HCI_OP_LE_CREATE_CONN_CANCEL,\n\t\t\t\t    0, NULL);\n\t\t} else if (conn->type == ACL_LINK) {\n\t\t\tif (req->hdev->hci_ver < BLUETOOTH_VER_1_2)\n\t\t\t\tbreak;\n\t\t\thci_req_add(req, HCI_OP_CREATE_CONN_CANCEL,\n\t\t\t\t    6, &conn->dst);\n\t\t}\n\t\tbreak;\n\tcase BT_CONNECT2:\n\t\tif (conn->type == ACL_LINK) {\n\t\t\tstruct hci_cp_reject_conn_req rej;\n\n\t\t\tbacpy(&rej.bdaddr, &conn->dst);\n\t\t\trej.reason = reason;\n\n\t\t\thci_req_add(req, HCI_OP_REJECT_CONN_REQ,\n\t\t\t\t    sizeof(rej), &rej);\n\t\t} else if (conn->type == SCO_LINK || conn->type == ESCO_LINK) {\n\t\t\tstruct hci_cp_reject_sync_conn_req rej;\n\n\t\t\tbacpy(&rej.bdaddr, &conn->dst);\n\n\t\t\t/* SCO rejection has its own limited set of\n\t\t\t * allowed error values (0x0D-0x0F) which isn't\n\t\t\t * compatible with most values passed to this\n\t\t\t * function. To be safe hard-code one of the\n\t\t\t * values that's suitable for SCO.\n\t\t\t */\n\t\t\trej.reason = HCI_ERROR_REJ_LIMITED_RESOURCES;\n\n\t\t\thci_req_add(req, HCI_OP_REJECT_SYNC_CONN_REQ,\n\t\t\t\t    sizeof(rej), &rej);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tconn->state = BT_CLOSED;\n\t\tbreak;\n\t}\n}", "target": 0, "cwe": ["CWE-362"], "project": "linux", "commit_id": "e2cb6b891ad2b8caa9131e3be70f45243df82a80", "hash": 22140180163212457451214472934101833439, "size": 68, "message": "bluetooth: eliminate the potential race condition when removing the HCI controller\n\nThere is a possible race condition vulnerability between issuing a HCI\ncommand and removing the cont.  Specifically, functions hci_req_sync()\nand hci_dev_do_close() can race each other like below:\n\nthread-A in hci_req_sync()      |   thread-B in hci_dev_do_close()\n                                |   hci_req_sync_lock(hdev);\ntest_bit(HCI_UP, &hdev->flags); |\n...                             |   test_and_clear_bit(HCI_UP, &hdev->flags)\nhci_req_sync_lock(hdev);        |\n                                |\nIn this commit we alter the sequence in function hci_req_sync(). Hence,\nthe thread-A cannot issue th.\n\nSigned-off-by: Lin Ma <linma@zju.edu.cn>\nCc: Marcel Holtmann <marcel@holtmann.org>\nFixes: 7c6a329e4447 (\"[Bluetooth] Fix regression from using default link policy\")\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 337}
{"func": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}", "target": 1, "cwe": ["CWE-703", "CWE-189"], "project": "linux", "commit_id": "8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664", "hash": 237185324698045025722576700934452684609, "size": 19, "message": "net: fix divide by zero in tcp algorithm illinois\n\nReading TCP stats when using TCP Illinois congestion control algorithm\ncan cause a divide by zero kernel oops.\n\nThe division by zero occur in tcp_illinois_info() at:\n do_div(t, ca->cnt_rtt);\nwhere ca->cnt_rtt can become zero (when rtt_reset is called)\n\nSteps to Reproduce:\n 1. Register tcp_illinois:\n     # sysctl -w net.ipv4.tcp_congestion_control=illinois\n 2. Monitor internal TCP information via command \"ss -i\"\n     # watch -d ss -i\n 3. Establish new TCP conn to machine\n\nEither it fails at the initial conn, or else it needs to wait\nfor a loss or a reset.\n\nThis is only related to reading stats.  The function avg_delay() also\nperforms the same divide, but is guarded with a (ca->cnt_rtt > 0) at its\ncalling point in update_params().  Thus, simply fix tcp_illinois_info().\n\nFunction tcp_illinois_info() / get_info() is called without\nsocket lock.  Thus, eliminate any race condition on ca->cnt_rtt\nby using a local stack variable.  Simply reuse info.tcpv_rttcnt,\nas its already set to ca->cnt_rtt.\nFunction avg_delay() is not affected by this race condition, as\nits called with the socket lock.\n\nCc: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Jesper Dangaard Brouer <brouer@redhat.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Stephen Hemminger <shemminger@vyatta.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 338}
{"func": "bit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\n\t/* Copy the first bitstring in */\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\n\t/* Copy the second bit string */\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\t/* We need to shift all the bits to fit */\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\n\treturn result;\n}", "target": 1, "cwe": ["CWE-703", "CWE-189"], "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "hash": 179889183012205305238684008504940386013, "size": 46, "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "idx": 339}
{"func": "static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )\n{\n  PixelWand\n    *stroke_color;\n\n  stroke_color=NewPixelWand();\n  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));\n  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));\n  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));\n  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);\n  DrawSetStrokeColor(WmfDrawingWand,stroke_color);\n  stroke_color=DestroyPixelWand(stroke_color);\n}", "target": 0, "cwe": ["CWE-772"], "project": "ImageMagick", "commit_id": "b2b48d50300a9fbcd0aa0d9230fd6d7a08f7671e", "hash": 332276181954210322305455636081017847599, "size": 13, "message": "https://github.com/ImageMagick/ImageMagick/issues/544", "idx": 340}
{"func": "int modbus_set_slave(modbus_t *ctx, int slave)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->set_slave(ctx, slave);\n}", "target": 0, "cwe": ["CWE-125"], "project": "libmodbus", "commit_id": "5ccdf5ef79d742640355d1132fa9e2abc7fbaefc", "hash": 164949334979902675691969690077196882943, "size": 9, "message": "Fix VD-1301 and VD-1302 vulnerabilities\n\nThis patch was contributed by Maor Vermucht and Or Peles from\nVDOO Connected Trust.", "idx": 341}
{"func": "static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;\n\n\t/* if there's a quota refresh soon don't bother with slack */\n\tif (runtime_refresh_within(cfs_b, min_left))\n\t\treturn;\n\n\t/* don't push forwards an existing deferred unthrottle */\n\tif (cfs_b->slack_started)\n\t\treturn;\n\tcfs_b->slack_started = true;\n\n\thrtimer_start(&cfs_b->slack_timer,\n\t\t\tns_to_ktime(cfs_bandwidth_slack_period),\n\t\t\tHRTIMER_MODE_REL);\n}", "target": 0, "cwe": ["CWE-400", "CWE-703"], "project": "linux", "commit_id": "de53fd7aedb100f03e5d2231cfce0e4993282425", "hash": 108829326339206006177145638890441073301, "size": 17, "message": "sched/fair: Fix low cpu usage with high throttling by removing expiration of cpu-local slices\n\nIt has been observed, that highly-threaded, non-cpu-bound applications\nrunning under cpu.cfs_quota_us constraints can hit a high percentage of\nperiods throttled while simultaneously not consuming the allocated\namount of quota. This use case is typical of user-interactive non-cpu\nbound applications, such as those running in kubernetes or mesos when\nrun on multiple cpu cores.\n\nThis has been root caused to cpu-local run queue being allocated per cpu\nbandwidth slices, and then not fully using that slice within the period.\nAt which point the slice and quota expires. This expiration of unused\nslice results in applications not being able to utilize the quota for\nwhich they are allocated.\n\nThe non-expiration of per-cpu slices was recently fixed by\n'commit 512ac999d275 (\"sched/fair: Fix bandwidth timer clock drift\ncondition\")'. Prior to that it appears that this had been broken since\nat least 'commit 51f2176d74ac (\"sched/fair: Fix unlocked reads of some\ncfs_b->quota/period\")' which was introduced in v3.16-rc1 in 2014. That\nadded the following conditional which resulted in slices never being\nexpired.\n\nif (cfs_rq->runtime_expires != cfs_b->runtime_expires) {\n\t/* extend local deadline, drift is bounded above by 2 ticks */\n\tcfs_rq->runtime_expires += TICK_NSEC;\n\nBecause this was broken for nearly 5 years, and has recently been fixed\nand is now being noticed by many users running kubernetes\n(https://github.com/kubernetes/kubernetes/issues/67577) it is my opinion\nthat the mechanisms around expiring runtime should be removed\naltogether.\n\nThis allows quota already allocated to per-cpu run-queues to live longer\nthan the period boundary. This allows threads on runqueues that do not\nuse much CPU to continue to use their remaining slice over a longer\nperiod of time than cpu.cfs_period_us. However, this helps prevent the\nabove condition of hitting throttling while also not fully utilizing\nyour cpu quota.\n\nThis theoretically allows a machine to use slightly more than its\nallotted quota in some periods. This overflow would be bounded by the\nremaining quota left on each per-cpu runqueueu. This is typically no\nmore than min_cfs_rq_runtime=1ms per cpu. For CPU bound tasks this will\nchange nothing, as they should theoretically fully utilize all of their\nquota in each period. For user-interactive tasks as described above this\nprovides a much better user/application experience as their cpu\nutilization will more closely match the amount they requested when they\nhit throttling. This means that cpu limits no longer strictly apply per\nperiod for non-cpu bound applications, but that they are still accurate\nover longer timeframes.\n\nThis greatly improves performance of high-thread-count, non-cpu bound\napplications with low cfs_quota_us allocation on high-core-count\nmachines. In the case of an artificial testcase (10ms/100ms of quota on\n80 CPU machine), this commit resulted in almost 30x performance\nimprovement, while still maintaining correct cpu quota restrictions.\nThat testcase is available at https://github.com/indeedeng/fibtest.\n\nFixes: 512ac999d275 (\"sched/fair: Fix bandwidth timer clock drift condition\")\nSigned-off-by: Dave Chiluk <chiluk+linux@indeed.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nReviewed-by: Phil Auld <pauld@redhat.com>\nReviewed-by: Ben Segall <bsegall@google.com>\nCc: Ingo Molnar <mingo@redhat.com>\nCc: John Hammond <jhammond@indeed.com>\nCc: Jonathan Corbet <corbet@lwn.net>\nCc: Kyle Anderson <kwa@yelp.com>\nCc: Gabriel Munos <gmunoz@netflix.com>\nCc: Peter Oskolkov <posk@posk.io>\nCc: Cong Wang <xiyou.wangcong@gmail.com>\nCc: Brendan Gregg <bgregg@netflix.com>\nLink: https://lkml.kernel.org/r/1563900266-19734-2-git-send-email-chiluk+linux@indeed.com", "idx": 342}
{"func": "int StoreDHparams(byte* out, word32* outLen, mp_int* p, mp_int* g)\n{\n    word32 idx = 0;\n    int pSz;\n    int gSz;\n    unsigned int tmp;\n    word32 headerSz = 4; /* 2*ASN_TAG + 2*LEN(ENUM) */\n\n    /* If the leading bit on the INTEGER is a 1, add a leading zero */\n    int pLeadingZero = mp_leading_bit(p);\n    int gLeadingZero = mp_leading_bit(g);\n    int pLen = mp_unsigned_bin_size(p);\n    int gLen = mp_unsigned_bin_size(g);\n\n    WOLFSSL_ENTER(\"StoreDHparams\");\n    if (out == NULL) {\n        WOLFSSL_MSG(\"Null buffer error\");\n        return BUFFER_E;\n    }\n\n    tmp = pLeadingZero + gLeadingZero + pLen + gLen;\n    if (*outLen < (tmp + headerSz)) {\n        return BUFFER_E;\n    }\n\n    /* Set sequence */\n    idx = SetSequence(tmp + headerSz + 2, out);\n\n    /* Encode p */\n    pSz = SetASNIntMP(p, -1, &out[idx]);\n    if (pSz < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP failed\");\n        return pSz;\n    }\n    idx += pSz;\n\n    /* Encode g */\n    gSz = SetASNIntMP(g, -1, &out[idx]);\n    if (gSz < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP failed\");\n        return gSz;\n    }\n    idx += gSz;\n\n    *outLen = idx;\n\n    return 0;\n}", "target": 0, "cwe": ["CWE-125", "CWE-345"], "project": "wolfssl", "commit_id": "f93083be72a3b3d956b52a7ec13f307a27b6e093", "hash": 21439513154938127428232679395736294851, "size": 48, "message": "OCSP: improve handling of OCSP no check extension", "idx": 343}
{"func": "tor_addr_is_public_for_reject(const tor_addr_t *addr)\n{\n  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)\n          && !tor_addr_is_multicast(addr));\n}", "target": 0, "cwe": [], "project": "tor", "commit_id": "1afc2ed956a35b40dfd1d207652af5b50c295da7", "hash": 204411882721827046865722069687784858096, "size": 5, "message": "Fix policies.c instance of the \"if (r=(a-b)) return r\" pattern\n\nI think this one probably can't underflow, since the input ranges\nare small.  But let's not tempt fate.\n\nThis patch also replaces the \"cmp\" functions here with just \"eq\"\nfunctions, since nothing actually checked for anything besides 0 and\nnonzero.\n\nRelated to 21278.", "idx": 344}
{"func": "static int map_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\tvoid *key;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_delete_elem(map, key);\n\t\tgoto out;\n\t} else if (IS_FD_PROG_ARRAY(map) ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* These maps require sleepable context */\n\t\terr = map->ops->map_delete_elem(map, key);\n\t\tgoto out;\n\t}\n\n\tbpf_disable_instrumentation();\n\trcu_read_lock();\n\terr = map->ops->map_delete_elem(map, key);\n\trcu_read_unlock();\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\nout:\n\tkvfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-367"], "project": "bpf", "commit_id": "353050be4c19e102178ccc05988101887c25ae53", "hash": 27610323787303284109583476916221154875, "size": 49, "message": "bpf: Fix toctou on read-only map's constant scalar tracking\n\nCommit a23740ec43ba (\"bpf: Track contents of read-only maps as scalars\") is\nchecking whether maps are read-only both from BPF program side and user space\nside, and then, given their content is constant, reading out their data via\nmap->ops->map_direct_value_addr() which is then subsequently used as known\nscalar value for the register, that is, it is marked as __mark_reg_known()\nwith the read value at verification time. Before a23740ec43ba, the register\ncontent was marked as an unknown scalar so the verifier could not make any\nassumptions about the map content.\n\nThe current implementation however is prone to a TOCTOU race, meaning, the\nvalue read as known scalar for the register is not guaranteed to be exactly\nthe same at a later point when the program is executed, and as such, the\nprior made assumptions of the verifier with regards to the program will be\ninvalid which can cause issues such as OOB access, etc.\n\nWhile the BPF_F_RDONLY_PROG map flag is always fixed and required to be\nspecified at map creation time, the map->frozen property is initially set to\nfalse for the map given the map value needs to be populated, e.g. for global\ndata sections. Once complete, the loader \"freezes\" the map from user space\nsuch that no subsequent updates/deletes are possible anymore. For the rest\nof the lifetime of the map, this freeze one-time trigger cannot be undone\nanymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*\ncmd calls which would update/delete map entries will be rejected with -EPERM\nsince map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also\nmeans that pending update/delete map entries must still complete before this\nguarantee is given. This corner case is not an issue for loaders since they\ncreate and prepare such program private map in successive steps.\n\nHowever, a malicious user is able to trigger this TOCTOU race in two different\nways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is\nused to expand the competition interval, so that map_update_elem() can modify\nthe contents of the map after map_freeze() and bpf_prog_load() were executed.\nThis works, because userfaultfd halts the parallel thread which triggered a\nmap_update_elem() at the time where we copy key/value from the user buffer and\nthis already passed the FMODE_CAN_WRITE capability test given at that time the\nmap was not \"frozen\". Then, the main thread performs the map_freeze() and\nbpf_prog_load(), and once that had completed successfully, the other thread\nis woken up to complete the pending map_update_elem() which then changes the\nmap content. For ii) the idea of the batched update is similar, meaning, when\nthere are a large number of updates to be processed, it can increase the\ncompetition interval between the two. It is therefore possible in practice to\nmodify the contents of the map after executing map_freeze() and bpf_prog_load().\n\nOne way to fix both i) and ii) at the same time is to expand the use of the\nmap's map->writecnt. The latter was introduced in fc9702273e2e (\"bpf: Add mmap()\nsupport for BPF_MAP_TYPE_ARRAY\") and further refined in 1f6cb19be2e2 (\"bpf:\nPrevent re-mmap()'ing BPF map as writable for initially r/o mapping\") with\nthe rationale to make a writable mmap()'ing of a map mutually exclusive with\nread-only freezing. The counter indicates writable mmap() mappings and then\nprevents/fails the freeze operation. Its semantics can be expanded beyond\njust mmap() by generally indicating ongoing write phases. This would essentially\nspan any parallel regular and batched flavor of update/delete operation and\nthen also have map_freeze() fail with -EBUSY. For the check_mem_access() in\nthe verifier we expand upon the bpf_map_is_rdonly() check ensuring that all\nlast pending writes have completed via bpf_map_write_active() test. Once the\nmap->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0\nonly then we are really guaranteed to use the map's data as known constants.\nFor map->frozen being set and pending writes in process of still being completed\nwe fall back to marking that register as unknown scalar so we don't end up\nmaking assumptions about it. With this, both TOCTOU reproducers from i) and\nii) are fixed.\n\nNote that the map->writecnt has been converted into a atomic64 in the fix in\norder to avoid a double freeze_mutex mutex_{un,}lock() pair when updating\nmap->writecnt in the various map update/delete BPF_* cmd flavors. Spanning\nthe freeze_mutex over entire map update/delete operations in syscall side\nwould not be possible due to then causing everything to be serialized.\nSimilarly, something like synchronize_rcu() after setting map->frozen to wait\nfor update/deletes to complete is not possible either since it would also\nhave to span the user copy which can sleep. On the libbpf side, this won't\nbreak d66562fba1ce (\"libbpf: Add BPF object skeleton support\") as the\nanonymous mmap()-ed \"map initialization image\" is remapped as a BPF map-backed\nmmap()-ed memory where for .rodata it's non-writable.\n\nFixes: a23740ec43ba (\"bpf: Track contents of read-only maps as scalars\")\nReported-by: w1tcher.bupt@gmail.com\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Andrii Nakryiko <andrii@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>", "idx": 345}
{"func": "int ssl3_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long alg_k,Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\n\t/* init things to blank */\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version>>8) != 3)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tBUF_MEM_free(buf);\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\ts->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;\n\t\t\ts->s3->flags &= ~SSL3_FLAGS_CCS_OK;\n\t\t\t/* Should have been reset by ssl3_get_finished, too. */\n\t\t\ts->s3->change_cipher_spec = 0;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t\t */\n\t\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\t\t\t\t\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse if (!s->s3->send_connection_binding &&\n\t\t\t\t!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\t\t{\n\t\t\t\t/* Server attempting to renegotiate with\n\t\t\t\t * client that doesn't support secure\n\t\t\t\t * renegotiation.\n\t\t\t\t */\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* s->state == SSL_ST_RENEGOTIATE,\n\t\t\t\t * we will just send a HelloRequest */\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\ts->shutdown=0;\n\t\t\tif (s->rwstate != SSL_X509_LOOKUP)\n\t\t\t{\n\t\t\t\tret=ssl3_get_client_hello(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t}\n#ifndef OPENSSL_NO_SRP\n\t\t\t{\n\t\t\tint al;\n\t\t\tif ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)\n\t\t\t\t\t{\n\t\t\t\t\t/* callback indicates firther work to be done */\n\t\t\t\t\ts->rwstate=SSL_X509_LOOKUP;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\tif (ret != SSL_ERROR_NONE)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\t\n\t\t\t\t/* This is not really an error but the only means to\n                                   for a client to detect whether srp is supported. */\n \t\t\t\t   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) \t\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);\t\t\t\n\t\t\t\tret = SSL_TLSEXT_ERR_ALERT_FATAL;\t\t\t\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\t\n\t\t\t\t}\n\t\t\t}\n#endif\t\t\n\t\t\t\n\t\t\ts->renegotiate = 2;\n\t\t\ts->state=SSL3_ST_SW_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\t\t}\n#else\n\t\t\tif (s->hit)\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH or anon ECDH, */\n\t\t\t/* normal PSK or KRB5 or SRP */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL|SSL_aKRB5|SSL_aSRP))\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n\t\t\t/* clear this, it may get reset by\n\t\t\t * send_server_key_exchange */\n\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n#ifndef OPENSSL_NO_KRB5\n\t\t\t\t&& !(alg_k & SSL_kKRB5)\n#endif /* OPENSSL_NO_KRB5 */\n\t\t\t\t)\n\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n\t\t\t\t * even when forbidden by protocol specs\n\t\t\t\t * (handshake may fail as clients are not required to\n\t\t\t\t * be able to handle this) */\n\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n\t\t\telse\n\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\n\t\t\t/* only send if a DH key exchange, fortezza or\n\t\t\t * RSA but we have a sign only certificate\n\t\t\t *\n\t\t\t * PSK: may send PSK identity hints\n\t\t\t *\n\t\t\t * For ECC ciphersuites, we send a serverKeyExchange\n\t\t\t * message only if the cipher suite is either\n\t\t\t * ECDH-anon or ECDHE. In other cases, the\n\t\t\t * server certificate contains the server's\n\t\t\t * public key for key exchange.\n\t\t\t */\n\t\t\tif (s->s3->tmp.use_rsa_tmp\n\t\t\t/* PSK: send ServerKeyExchange if PSK identity\n\t\t\t * hint if provided */\n#ifndef OPENSSL_NO_PSK\n\t\t\t    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n#ifndef OPENSSL_NO_SRP\n\t\t\t    /* SRP: send ServerKeyExchange */\n\t\t\t    || (alg_k & SSL_kSRP)\n#endif\n\t\t\t    || (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kEDH))\n\t\t\t    || (alg_k & SSL_kEECDH)\n\t\t\t    || ((alg_k & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n\t\t\t\t /* never request cert in Kerberos ciphersuites */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) ||\n\t\t\t\t/* don't request certificate for SRP auth */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aSRP)\n\t\t\t\t/* With normal PSK Certificates and\n\t\t\t\t * Certificate Requests are omitted */\n\t\t\t\t|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\n\t\t\t/* This code originally checked to see if\n\t\t\t * any data was pending using BIO_CTRL_INFO\n\t\t\t * and then flushed. This caused problems\n\t\t\t * as documented in PR#1939. The proposed\n\t\t\t * fix doesn't completely resolve this issue\n\t\t\t * as buggy implementations of BIO_CTRL_PENDING\n\t\t\t * still exist. So instead we just flush\n\t\t\t * unconditionally.\n\t\t\t */\n\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\t/* Check for second client hello (MS SGC) */\n\t\t\tret = ssl3_check_client_hello(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\ts->state = SSL3_ST_SR_CLNT_HELLO_C;\n\t\t\telse {\n\t\t\t\tif (s->s3->tmp.cert_request)\n\t\t\t\t\t{\n\t\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_num=0;\n\t\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\t/* For the ECDH ciphersuites when\n\t\t\t\t * the client sends its ECDH pub key in\n\t\t\t\t * a certificate, the CertificateVerify\n\t\t\t\t * message is not sent.\n\t\t\t\t * Also for GOST ciphersuites when\n\t\t\t\t * the client uses its key from the certificate\n\t\t\t\t * for key exchange.\n\t\t\t\t */\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\ts->init_num = 0;\n\t\t\t\t}\n\t\t\telse if (TLS1_get_version(s) >= TLS1_2_VERSION)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tif (!s->session->peer)\n\t\t\t\t\tbreak;\n\t\t\t\t/* For TLS v1.2 freeze the handshake buffer\n\t\t\t\t * at this point and digest cached records.\n\t\t\t\t */\n\t\t\t\tif (!s->s3->handshake_buffer)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\ts->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tint offset=0;\n\t\t\t\tint dgst_num;\n\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\n\t\t\t\t/* We need to get hashes here so if there is\n\t\t\t\t * a client cert, it can be verified\n\t\t\t\t * FIXME - digest processing for CertificateVerify\n\t\t\t\t * should be generalized. But it is next step\n\t\t\t\t */\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\tfor (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)\t\n\t\t\t\t\tif (s->s3->handshake_dgst[dgst_num]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tint dgst_size;\n\n\t\t\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));\n\t\t\t\t\t\tdgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);\n\t\t\t\t\t\tif (dgst_size < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\toffset+=dgst_size;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\t\t\t/*\n\t\t\t * This *should* be the first time we enable CCS, but be\n\t\t\t * extra careful about surrounding code changes. We need\n\t\t\t * to set this here because we don't know if we're\n\t\t\t * expecting a CertificateVerify or not.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_SR_NEXT_PROTO_A:\n\t\tcase SSL3_ST_SR_NEXT_PROTO_B:\n\t\t\t/*\n\t\t\t * Enable CCS for resumed handshakes with NPN.\n\t\t\t * In a full handshake with NPN, we end up here through\n\t\t\t * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was\n\t\t\t * already set. Receiving a CCS clears the flag, so make\n\t\t\t * sure not to re-enable it to ban duplicates.\n\t\t\t * s->s3->change_cipher_spec is set when a CCS is\n\t\t\t * processed in s3_pkt.c, and remains set until\n\t\t\t * the client's Finished message is read.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\n\t\t\tret=ssl3_get_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->init_num = 0;\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\t/*\n\t\t\t * Enable CCS for resumed handshakes without NPN.\n\t\t\t * In a full handshake, we end up here through\n\t\t\t * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was\n\t\t\t * already set. Receiving a CCS clears the flag, so make\n\t\t\t * sure not to re-enable it to ban duplicates.\n\t\t\t * s->s3->change_cipher_spec is set when a CCS is\n\t\t\t * processed in s3_pkt.c, and remains set until\n\t\t\t * the client's Finished message is read.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (s->tlsext_ticket_expected)\n\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SESSION_TICKET_A:\n\t\tcase SSL3_ST_SW_SESSION_TICKET_B:\n\t\t\tret=ssl3_send_newsession_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_STATUS_A:\n\t\tcase SSL3_ST_SW_CERT_STATUS_B:\n\t\t\tret=ssl3_send_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#endif\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\t{\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\t{\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */\n\t\t\t\t{\n\t\t\t\ts->renegotiate=0;\n\t\t\t\ts->new_session=0;\n\t\t\t\t\n\t\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\t\t\t\t\n\t\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t\t/* s->server=1; */\n\t\t\t\ts->handshake_func=ssl3_accept;\n\n\t\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\t\t\t\t}\n\t\t\t\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}", "target": 1, "cwe": ["CWE-310"], "project": "openssl", "commit_id": "37580f43b5a39f5f4e920d17273fab9713d3a744", "hash": 139411822298502976008824945647128563676, "size": 665, "message": "Only allow ephemeral RSA keys in export ciphersuites.\n\nOpenSSL clients would tolerate temporary RSA keys in non-export\nciphersuites. It also had an option SSL_OP_EPHEMERAL_RSA which\nenabled this server side. Remove both options as they are a\nprotocol violation.\n\nThanks to Karthikeyan Bhargavan for reporting this issue.\n(CVE-2015-0204)\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Tim Hudson <tjh@openssl.org>\n\n(cherry picked from commit 4b4c1fcc88aec8c9e001b0a0077d3cd4de1ed0e6)\n\nConflicts:\n\tdoc/ssl/SSL_CTX_set_options.pod", "idx": 346}
{"func": "static apr_status_t gset_decode_next(gset_decoder *decoder, apr_uint64_t *phash)\n{\n    apr_uint64_t flex = 0, fixed = 0, delta;\n    int i;\n    \n    /* read 1 bits until we encounter 0, then read log2n(diary-P) bits.\n     * On a malformed bit-string, this will not fail, but produce results\n     * which are pbly too large. Luckily, the diary will modulo the hash.\n     */\n    while (1) {\n        int bit = gset_decode_next_bit(decoder);\n        if (bit == -1) {\n            return APR_EINVAL;\n        }\n        if (!bit) {\n            break;\n        }\n        ++flex;\n    }\n    \n    for (i = 0; i < decoder->log2p; ++i) {\n        int bit = gset_decode_next_bit(decoder);\n        if (bit == -1) {\n            return APR_EINVAL;\n        }\n        fixed = (fixed << 1) | bit;\n    }\n    \n    delta = (flex << decoder->log2p) | fixed;\n    *phash = delta + decoder->last_val;\n    decoder->last_val = *phash;\n    \n    /* Intentional no APLOGNO */\n    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, decoder->pool,\n                  \"h2_push_diary_digest_dec: val=%\"APR_UINT64_T_HEX_FMT\", delta=%\"\n                  APR_UINT64_T_HEX_FMT\", flex=%d, fixed=%\"APR_UINT64_T_HEX_FMT, \n                  *phash, delta, (int)flex, fixed);\n                  \n    return APR_SUCCESS;\n}", "target": 1, "cwe": ["CWE-444"], "project": "mod_h2", "commit_id": "b8a8c5061eada0ce3339b24ba1d587134552bc0c", "hash": 53400188749509747057292426623275901652, "size": 40, "message": "* Removing support for abandoned draft of http-wg regarding cache-digests.", "idx": 347}
{"func": "static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\n\t\t\t    struct mr6_table **mrt)\n{\n\tint err;\n\tstruct ip6mr_result res;\n\tstruct fib_lookup_arg arg = {\n\t\t.result = &res,\n\t\t.flags = FIB_LOOKUP_NOREF,\n\t};\n\n\terr = fib_rules_lookup(net->ipv6.mr6_rules_ops,\n\t\t\t       flowi6_to_flowi(flp6), 0, &arg);\n\tif (err < 0)\n\t\treturn err;\n\t*mrt = res.mrt;\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-20"], "project": "linux", "commit_id": "99253eb750fda6a644d5188fb26c43bad8d5a745", "hash": 120118145699658586654336016449920027225, "size": 17, "message": "ipv6: check sk sk_type and protocol early in ip_mroute_set/getsockopt\n\nCommit 5e1859fbcc3c (\"ipv4: ipmr: various fixes and cleanups\") fixed\nthe issue for ipv4 ipmr:\n\n  ip_mroute_setsockopt() & ip_mroute_getsockopt() should not\n  access/set raw_sk(sk)->ipmr_table before making sure the socket\n  is a raw socket, and protocol is IGMP\n\nThe same fix should be done for ipv6 ipmr as well.\n\nThis patch can fix the panic caused by overwriting the same offset\nas ipmr_table as in raw_sk(sk) when accessing other type's socket\nby ip_mroute_setsockopt().\n\nSigned-off-by: Xin Long <lucien.xin@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 348}
{"func": "void _mutt_mktemp (char *s, size_t slen, const char *src, int line)\n{\n  snprintf (s, slen, \"%s/mutt-%s-%d-%d-%d\", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);\n  dprint (3, (debugfile, \"%s:%d: mutt_mktemp returns \\\"%s\\\".\\n\", src, line, s));\n  unlink (s);\n}", "target": 1, "cwe": ["CWE-668"], "project": "mutt", "commit_id": "6d0624411a979e2e1d76af4dd97d03f47679ea4a", "hash": 50668751234213132589402086400281769045, "size": 6, "message": "use a 64-bit random value in temporary filenames.\n\ncloses #3158", "idx": 349}
{"func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n                               opaque * compress_data,\n                               int compress_size,\n                               gnutls_datum_t ciphertext, uint8_t type,\n                               record_parameters_st * params)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  unsigned int pad;\n  int length;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  opaque preamble[PREAMBLE_SIZE];\n  int preamble_size;\n  int ver = gnutls_protocol_get_version (session);\n  int hash_size = _gnutls_hash_get_algo_len (params->mac_algorithm);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (_gnutls_version_has_explicit_iv\n          (session->security_parameters.version))\n        {\n          ciphertext.size -= blocksize;\n          ciphertext.data += blocksize;\n        }\n\n      if (ciphertext.size < hash_size)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n      pad = ciphertext.data[ciphertext.size - 1] + 1;   /* pad */\n\n      if ((int) pad > (int) ciphertext.size - hash_size)\n        {\n          gnutls_assert ();\n          _gnutls_record_log\n            (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n             session, pad, ciphertext.size, hash_size);\n          /* We do not fail here. We check below for the\n           * the pad_failed. If zero means success.\n           */\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      length = ciphertext.size - hash_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (_gnutls_version_has_variable_padding (ver) && pad_failed == 0)\n        for (i = 2; i <= pad; i++)\n          {\n            if (ciphertext.data[ciphertext.size - i] !=\n                ciphertext.data[ciphertext.size - 1])\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (params->mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      digest_hd_st td;\n\n      ret = mac_init (&td, params->mac_algorithm,\n                      params->read.mac_secret.data,\n                      params->read.mac_secret.size, ver);\n\n      if (ret < 0)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_INTERNAL_ERROR;\n        }\n\n      preamble_size =\n        make_preamble (UINT64DATA\n                       (params->read.sequence_number), type,\n                       c_length, ver, preamble);\n      mac_hash (&td, preamble, preamble_size, ver);\n      if (length > 0)\n        mac_hash (&td, ciphertext.data, length, ver);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    {\n      gnutls_assert ();\n      return pad_failed;\n    }\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-310"], "project": "gnutls", "commit_id": "458c67cf98740e7b12404f6c30e0d5317d56fd30", "hash": 218892439808786904611420072225644025341, "size": 156, "message": "Fixes to avoid a timing attack in TLS CBC record parsing.", "idx": 350}
{"func": "osf_filldir(void *__buf, const char *name, int namlen, loff_t offset,\n\t    u64 ino, unsigned int d_type)\n{\n\tstruct osf_dirent __user *dirent;\n\tstruct osf_dirent_callback *buf = (struct osf_dirent_callback *) __buf;\n\tunsigned int reclen = ALIGN(NAME_OFFSET + namlen + 1, sizeof(u32));\n\tunsigned int d_ino;\n\n\tbuf->error = -EINVAL;\t/* only used if we fail */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tif (buf->basep) {\n\t\tif (put_user(offset, buf->basep))\n\t\t\tgoto Efault;\n\t\tbuf->basep = NULL;\n\t}\n\tdirent = buf->dirent;\n\tif (put_user(d_ino, &dirent->d_ino) ||\n\t    put_user(namlen, &dirent->d_namlen) ||\n\t    put_user(reclen, &dirent->d_reclen) ||\n\t    copy_to_user(dirent->d_name, name, namlen) ||\n\t    put_user(0, dirent->d_name + namlen))\n\t\tgoto Efault;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->dirent = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nEfault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}", "target": 0, "cwe": ["CWE-703", "CWE-264", "CWE-189"], "project": "linux", "commit_id": "21c5977a836e399fc710ff2c5367845ed5c2527f", "hash": 176267895307217785319834094908821837680, "size": 36, "message": "alpha: fix several security issues\n\nFix several security issues in Alpha-specific syscalls.  Untested, but\nmostly trivial.\n\n1. Signedness issue in osf_getdomainname allows copying out-of-bounds\nkernel memory to userland.\n\n2. Signedness issue in osf_sysinfo allows copying large amounts of\nkernel memory to userland.\n\n3. Typo (?) in osf_getsysinfo bounds minimum instead of maximum copy\nsize, allowing copying large amounts of kernel memory to userland.\n\n4. Usage of user pointer in osf_wait4 while under KERNEL_DS allows\nprivilege escalation via writing return value of sys_wait4 to kernel\nmemory.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: Richard Henderson <rth@twiddle.net>\nCc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>\nCc: Matt Turner <mattst88@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 351}
{"func": "int warn(const char *fmt, ...) {\n    static char buf[1024];\n    va_list args;\n\n    va_start(args, fmt);\n    vsnprintf(buf, sizeof(buf), fmt, args);\n    va_end(args);\n    return(message(LOG_WARNING, buf));\n}", "target": 0, "cwe": [], "project": "netmask", "commit_id": "29a9c239bd1008363f5b34ffd6c2cef906f3660c", "hash": 248507369997699910178718667670313507380, "size": 9, "message": "bump version to 2.4.4\n\n * remove checks for negative unsigned ints, fixes #2\n * harden error logging functions, fixes #3", "idx": 352}
{"func": "static int send_solid_rect(VncState *vs)\n{\n    size_t bytes;\n\n    vnc_write_u8(vs, VNC_TIGHT_FILL << 4); /* no flushing, no filter */\n\n    if (vs->tight.pixel24) {\n        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);\n        bytes = 3;\n    } else {\n        bytes = vs->clientds.pf.bytes_per_pixel;\n    }\n\n    vnc_write(vs, vs->tight.tight.buffer, bytes);\n    return 1;\n}", "target": 1, "cwe": ["CWE-125"], "project": "qemu", "commit_id": "9f64916da20eea67121d544698676295bbb105a7", "hash": 230122889483688311384880898321909221361, "size": 16, "message": "pixman/vnc: use pixman images in vnc.\n\nThe vnc code uses *three* DisplaySurfaces:\n\nFirst is the surface of the actual QemuConsole, usually the guest\nscreen, but could also be a text console (monitor/serial reachable via\nCtrl-Alt-<nr> keys).  This is left as-is.\n\nSecond is the current server's view of the screen content.  The vnc code\nuses this to figure which parts of the guest screen did _really_ change\nto reduce the amount of updates sent to the vnc clients.  It is also\nused as data source when sending out the updates to the clients.  This\nsurface gets replaced by a pixman image.  The format changes too,\ninstead of using the guest screen format we'll use fixed 32bit rgb\nframebuffer and convert the pixels on the fly when comparing and\nupdating the server framebuffer.\n\nThird surface carries the format expected by the vnc client.  That isn't\nused to store image data.  This surface is switched to PixelFormat and a\nboolean for bigendian byte order.\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>", "idx": 353}
{"func": "void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t   unsigned long payload)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);\n}", "target": 0, "cwe": ["CWE-476"], "project": "linux", "commit_id": "55749769fe608fa3f4a075e42e89d237c8e37637", "hash": 337162608253610615188646129105982708308, "size": 5, "message": "KVM: x86: Fix wall clock writes in Xen shared_info not to mark page dirty\n\nWhen dirty ring logging is enabled, any dirty logging without an active\nvCPU context will cause a kernel oops. But we've already declared that\nthe shared_info page doesn't get dirty tracking anyway, since it would\nbe kind of insane to mark it dirty every time we deliver an event channel\ninterrupt. Userspace is supposed to just assume it's always dirty any\ntime a vCPU can run or event channels are routed.\n\nSo stop using the generic kvm_write_wall_clock() and just write directly\nthrough the gfn_to_pfn_cache that we already have set up.\n\nWe can make kvm_write_wall_clock() static in x86.c again now, but let's\nnot remove the 'sec_hi_ofs' argument even though it's not used yet. At\nsome point we *will* want to use that for KVM guests too.\n\nFixes: 629b5348841a (\"KVM: x86/xen: update wallclock region\")\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nSigned-off-by: David Woodhouse <dwmw@amazon.co.uk>\nMessage-Id: <20211210163625.2886-6-dwmw2@infradead.org>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 354}
{"func": "acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,\n\t\t     struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct buffer *req = s->req;\n\tstruct http_txn *txn = &s->txn;\n\tstruct http_msg *msg = &txn->req;\n\n\t/* Note: hdr_idx.v cannot be NULL in this ACL because the ACL is tagged\n\t * as a layer7 ACL, which involves automatic allocation of hdr_idx.\n\t */\n\n\tif (!s || !req)\n\t\treturn 0;\n\n\tif (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {\n\t\t/* Already decoded as OK */\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\n\t/* Try to decode HTTP request */\n\tif (likely(req->lr < req->r))\n\t\thttp_msg_analyzer(req, msg, &txn->hdr_idx);\n\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY)) {\n\t\tif ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {\n\t\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\t\treturn 1;\n\t\t}\n\t\t/* wait for final state */\n\t\ttest->flags |= ACL_TEST_F_MAY_CHANGE;\n\t\treturn 0;\n\t}\n\n\t/* OK we got a valid HTTP request. We have some minor preparation to\n\t * perform so that further checks can rely on HTTP tests.\n\t */\n\ttxn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\ts->flags |= SN_REDIRECTABLE;\n\n\tif (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\treturn 1;\n\t}\n\n\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\treturn 1;\n}", "target": 1, "cwe": [], "project": "haproxy-1.4", "commit_id": "dc80672211e085c211f1fc47e15cfe57ab587d38", "hash": 240242818788130392280174552081373055269, "size": 49, "message": "BUG/CRITICAL: using HTTP information in tcp-request content may crash the process\n\nDuring normal HTTP request processing, request buffers are realigned if\nthere are less than global.maxrewrite bytes available after them, in\norder to leave enough room for rewriting headers after the request. This\nis done in http_wait_for_request().\n\nHowever, if some HTTP inspection happens during a \"tcp-request content\"\nrule, this realignment is not performed. In theory this is not a problem\nbecause empty buffers are always aligned and TCP inspection happens at\nthe beginning of a connection. But with HTTP keep-alive, it also happens\nat the beginning of each subsequent request. So if a second request was\npipelined by the client before the first one had a chance to be forwarded,\nthe second request will not be realigned. Then, http_wait_for_request()\nwill not perform such a realignment either because the request was\nalready parsed and marked as such. The consequence of this, is that the\nrewrite of a sufficient number of such pipelined, unaligned requests may\nleave less room past the request been processed than the configured\nreserve, which can lead to a buffer overflow if request processing appends\nsome data past the end of the buffer.\n\nA number of conditions are required for the bug to be triggered :\n  - HTTP keep-alive must be enabled ;\n  - HTTP inspection in TCP rules must be used ;\n  - some request appending rules are needed (reqadd, x-forwarded-for)\n  - since empty buffers are always realigned, the client must pipeline\n    enough requests so that the buffer always contains something till\n    the point where there is no more room for rewriting.\n\nWhile such a configuration is quite unlikely to be met (which is\nconfirmed by the bug's lifetime), a few people do use these features\ntogether for very specific usages. And more importantly, writing such\na configuration and the request to attack it is trivial.\n\nA quick workaround consists in forcing keep-alive off by adding\n\"option httpclose\" or \"option forceclose\" in the frontend. Alternatively,\ndisabling HTTP-based TCP inspection rules enough if the application\nsupports it.\n\nAt first glance, this bug does not look like it could lead to remote code\nexecution, as the overflowing part is controlled by the configuration and\nnot by the user. But some deeper analysis should be performed to confirm\nthis. And anyway, corrupting the process' memory and crashing it is quite\ntrivial.\n\nSpecial thanks go to Yves Lafon from the W3C who reported this bug and\ndeployed significant efforts to collect the relevant data needed to\nunderstand it in less than one week.\n\nCVE-2013-1912 was assigned to this issue.\n\nNote that 1.4 is also affected so the fix must be backported.\n(cherry picked from commit aae75e3279c6c9bd136413a72dafdcd4986bb89a)", "idx": 355}
{"func": "TfLiteStatus LeakyReluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  LeakyReluOpData* data = reinterpret_cast<LeakyReluOpData*>(node->user_data);\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n      output->type == kTfLiteInt16) {\n    const auto* params =\n        reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);\n\n    double alpha_multiplier =\n        input->params.scale * params->alpha / output->params.scale;\n    QuantizeMultiplier(alpha_multiplier, &data->output_multiplier_alpha,\n                       &data->output_shift_alpha);\n    double identity_multiplier = input->params.scale / output->params.scale;\n    QuantizeMultiplier(identity_multiplier, &data->output_multiplier_identity,\n                       &data->output_shift_identity);\n  }\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tensorflow", "commit_id": "1970c2158b1ffa416d159d03c3370b9a462aee35", "hash": 162720992234371050809641547141799713897, "size": 25, "message": "[tflite]: Insert `nullptr` checks when obtaining tensors.\n\nAs part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.\n\nWe also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).\n\nPiperOrigin-RevId: 332521299\nChange-Id: I29af455bcb48d0b92e58132d951a3badbd772d56", "idx": 356}
{"func": "PHP_FUNCTION(imagesetstyle)\n{\n\tzval *IM, *styles;\n\tgdImagePtr im;\n\tint * stylearr;\n\tint index;\n\tHashPosition pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &styles) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\t/* copy the style values in the stylearr */\n\tstylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);\n\n\tzend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);\n\n\tfor (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))\t{\n\t\tzval ** item;\n\n\t\tif (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconvert_to_long_ex(item);\n\n\t\tstylearr[index++] = Z_LVAL_PP(item);\n\t}\n\n\tgdImageSetStyle(im, stylearr, index);\n\n\tefree(stylearr);\n\n\tRETURN_TRUE;\n}", "target": 1, "cwe": ["CWE-703", "CWE-189"], "project": "php-src", "commit_id": "2938329ce19cb8c4197dec146c3ec887c6f61d01", "hash": 301644239078496730681118871803505521624, "size": 37, "message": "Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())\n\nAnd also fixed the bug: arguments are altered after some calls", "idx": 357}
{"func": "receive(\n\tstruct recvbuf *rbufp\n\t)\n{\n\tregister struct peer *peer;\t/* peer structure pointer */\n\tregister struct pkt *pkt;\t/* receive packet pointer */\n\tu_char\thisversion;\t\t/* packet version */\n\tu_char\thisleap;\t\t/* packet leap indicator */\n\tu_char\thismode;\t\t/* packet mode */\n\tu_char\thisstratum;\t\t/* packet stratum */\n\tu_short\trestrict_mask;\t\t/* restrict bits */\n\tint\thas_mac;\t\t/* length of MAC field */\n\tint\tauthlen;\t\t/* offset of MAC field */\n\tint\tis_authentic = 0;\t/* cryptosum ok */\n\tint\tretcode = AM_NOMATCH;\t/* match code */\n\tkeyid_t\tskeyid = 0;\t\t/* key IDs */\n\tu_int32\topcode = 0;\t\t/* extension field opcode */\n\tsockaddr_u *dstadr_sin; \t/* active runway */\n\tstruct peer *peer2;\t\t/* aux peer structure pointer */\n\tendpt *\tmatch_ep;\t\t/* newpeer() local address */\n\tl_fp\tp_org;\t\t\t/* origin timestamp */\n\tl_fp\tp_rec;\t\t\t/* receive timestamp */\n\tl_fp\tp_xmt;\t\t\t/* transmit timestamp */\n#ifdef AUTOKEY\n\tchar\thostname[NTP_MAXSTRLEN + 1];\n\tchar\t*groupname = NULL;\n\tstruct autokey *ap;\t\t/* autokey structure pointer */\n\tint\trval;\t\t\t/* cookie snatcher */\n\tkeyid_t\tpkeyid = 0, tkeyid = 0;\t/* key IDs */\n#endif\t/* AUTOKEY */\n#ifdef HAVE_NTP_SIGND\n\tstatic unsigned char zero_key[16];\n#endif /* HAVE_NTP_SIGND */\n\n\t/*\n\t * Monitor the packet and get restrictions. Note that the packet\n\t * length for control and private mode packets must be checked\n\t * by the service routines. Some restrictions have to be handled\n\t * later in order to generate a kiss-o'-death packet.\n\t */\n\t/*\n\t * Bogus port check is before anything, since it probably\n\t * reveals a clogging attack.\n\t */\n\tsys_received++;\n\tif (0 == SRCPORT(&rbufp->recv_srcadr)) {\n\t\tsys_badlength++;\n\t\treturn;\t\t\t\t/* bogus port */\n\t}\n\trestrict_mask = restrictions(&rbufp->recv_srcadr);\n\tDPRINTF(2, (\"receive: at %ld %s<-%s flags %x restrict %03x\\n\",\n\t\t    current_time, stoa(&rbufp->dstadr->sin),\n\t\t    stoa(&rbufp->recv_srcadr),\n\t\t    rbufp->dstadr->flags, restrict_mask));\n\tpkt = &rbufp->recv_pkt;\n\thisversion = PKT_VERSION(pkt->li_vn_mode);\n\thisleap = PKT_LEAP(pkt->li_vn_mode);\n\thismode = (int)PKT_MODE(pkt->li_vn_mode);\n\thisstratum = PKT_TO_STRATUM(pkt->stratum);\n\tif (restrict_mask & RES_IGNORE) {\n\t\tsys_restricted++;\n\t\treturn;\t\t\t\t/* ignore everything */\n\t}\n\tif (hismode == MODE_PRIVATE) {\n\t\tif (!ntp_mode7 || (restrict_mask & RES_NOQUERY)) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* no query private */\n\t\t}\n\t\tprocess_private(rbufp, ((restrict_mask &\n\t\t    RES_NOMODIFY) == 0));\n\t\treturn;\n\t}\n\tif (hismode == MODE_CONTROL) {\n\t\tif (restrict_mask & RES_NOQUERY) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* no query control */\n\t\t}\n\t\tprocess_control(rbufp, restrict_mask);\n\t\treturn;\n\t}\n\tif (restrict_mask & RES_DONTSERVE) {\n\t\tsys_restricted++;\n\t\treturn;\t\t\t\t/* no time serve */\n\t}\n\n\t/*\n\t * This is for testing. If restricted drop ten percent of\n\t * surviving packets.\n\t */\n\tif (restrict_mask & RES_FLAKE) {\n\t\tif ((double)ntp_random() / 0x7fffffff < .1) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* no flakeway */\n\t\t}\n\t}\n\n\t/*\n\t * Version check must be after the query packets, since they\n\t * intentionally use an early version.\n\t */\n\tif (hisversion == NTP_VERSION) {\n\t\tsys_newversion++;\t\t/* new version */\n\t} else if (!(restrict_mask & RES_VERSION) && hisversion >=\n\t    NTP_OLDVERSION) {\n\t\tsys_oldversion++;\t\t/* previous version */\n\t} else {\n\t\tsys_badlength++;\n\t\treturn;\t\t\t\t/* old version */\n\t}\n\n\t/*\n\t * Figure out his mode and validate the packet. This has some\n\t * legacy raunch that probably should be removed. In very early\n\t * NTP versions mode 0 was equivalent to what later versions\n\t * would interpret as client mode.\n\t */\n\tif (hismode == MODE_UNSPEC) {\n\t\tif (hisversion == NTP_OLDVERSION) {\n\t\t\thismode = MODE_CLIENT;\n\t\t} else {\n\t\t\tsys_badlength++;\n\t\t\treturn;                 /* invalid mode */\n\t\t}\n\t}\n\n\t/*\n\t * Parse the extension field if present. We figure out whether\n\t * an extension field is present by measuring the MAC size. If\n\t * the number of words following the packet header is 0, no MAC\n\t * is present and the packet is not authenticated. If 1, the\n\t * packet is a crypto-NAK; if 3, the packet is authenticated\n\t * with DES; if 5, the packet is authenticated with MD5; if 6,\n\t * the packet is authenticated with SHA. If 2 or * 4, the packet\n\t * is a runt and discarded forthwith. If greater than 6, an\n\t * extension field is present, so we subtract the length of the\n\t * field and go around again.\n\t */\n\tauthlen = LEN_PKT_NOMAC;\n\thas_mac = rbufp->recv_length - authlen;\n\twhile (has_mac > 0) {\n\t\tu_int32\tlen;\n#ifdef AUTOKEY\n\t\tu_int32\thostlen;\n\t\tstruct exten *ep;\n#endif /*AUTOKEY */\n\n\t\tif (has_mac % 4 != 0 || has_mac < (int)MIN_MAC_LEN) {\n\t\t\tsys_badlength++;\n\t\t\treturn;\t\t\t/* bad length */\n\t\t}\n\t\tif (has_mac <= (int)MAX_MAC_LEN) {\n\t\t\tskeyid = ntohl(((u_int32 *)pkt)[authlen / 4]);\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\topcode = ntohl(((u_int32 *)pkt)[authlen / 4]);\n\t\t\tlen = opcode & 0xffff;\n\t\t\tif (len % 4 != 0 || len < 4 || (int)len +\n\t\t\t    authlen > rbufp->recv_length) {\n\t\t\t\tsys_badlength++;\n\t\t\t\treturn;\t\t/* bad length */\n\t\t\t}\n#ifdef AUTOKEY\n\t\t\t/*\n\t\t\t * Extract calling group name for later.  If\n\t\t\t * sys_groupname is non-NULL, there must be\n\t\t\t * a group name provided to elicit a response.\n\t\t\t */\n\t\t\tif ((opcode & 0x3fff0000) == CRYPTO_ASSOC &&\n\t\t\t    sys_groupname != NULL) {\n\t\t\t\tep = (struct exten *)&((u_int32 *)pkt)[authlen / 4];\n\t\t\t\thostlen = ntohl(ep->vallen);\n\t\t\t\tif (hostlen >= sizeof(hostname) ||\n\t\t\t\t    hostlen > len -\n\t\t\t\t    offsetof(struct exten, pkt)) {\n\t\t\t\t\tsys_badlength++;\n\t\t\t\t\treturn;\t\t/* bad length */\n\t\t\t\t}\n\t\t\t\tmemcpy(hostname, &ep->pkt, hostlen);\n\t\t\t\thostname[hostlen] = '\\0';\n\t\t\t\tgroupname = strchr(hostname, '@');\n\t\t\t\tif (groupname == NULL) {\n\t\t\t\t\tsys_declined++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgroupname++;\n\t\t\t}\n#endif /* AUTOKEY */\n\t\t\tauthlen += len;\n\t\t\thas_mac -= len;\n\t\t}\n\t}\n\n\t/*\n\t * If has_mac is < 0 we had a malformed packet.\n\t */\n\tif (has_mac < 0) {\n\t\tsys_badlength++;\n\t\treturn;\t\t/* bad length */\n\t}\n\n\t/*\n\t * If authentication required, a MAC must be present.\n\t */\n\tif (restrict_mask & RES_DONTTRUST && has_mac == 0) {\n\t\tsys_restricted++;\n\t\treturn;\t\t\t\t/* access denied */\n\t}\n\n\t/*\n\t * Update the MRU list and finger the cloggers. It can be a\n\t * little expensive, so turn it off for production use.\n\t * RES_LIMITED and RES_KOD will be cleared in the returned\n\t * restrict_mask unless one or both actions are warranted.\n\t */\n\trestrict_mask = ntp_monitor(rbufp, restrict_mask);\n\tif (restrict_mask & RES_LIMITED) {\n\t\tsys_limitrejected++;\n\t\tif (!(restrict_mask & RES_KOD) || MODE_BROADCAST ==\n\t\t    hismode || MODE_SERVER == hismode) {\n\t\t\tif (MODE_SERVER == hismode)\n\t\t\t\tDPRINTF(1, (\"Possibly self-induced rate limiting of MODE_SERVER from %s\\n\",\n\t\t\t\t\tstoa(&rbufp->recv_srcadr)));\n\t\t\treturn;\t\t\t/* rate exceeded */\n\t\t}\n\t\tif (hismode == MODE_CLIENT)\n\t\t\tfast_xmit(rbufp, MODE_SERVER, skeyid,\n\t\t\t    restrict_mask);\n\t\telse\n\t\t\tfast_xmit(rbufp, MODE_ACTIVE, skeyid,\n\t\t\t    restrict_mask);\n\t\treturn;\t\t\t\t/* rate exceeded */\n\t}\n\trestrict_mask &= ~RES_KOD;\n\n\t/*\n\t * We have tossed out as many buggy packets as possible early in\n\t * the game to reduce the exposure to a clogging attack. Now we\n\t * have to burn some cycles to find the association and\n\t * authenticate the packet if required. Note that we burn only\n\t * digest cycles, again to reduce exposure. There may be no\n\t * matching association and that's okay.\n\t *\n\t * More on the autokey mambo. Normally the local interface is\n\t * found when the association was mobilized with respect to a\n\t * designated remote address. We assume packets arriving from\n\t * the remote address arrive via this interface and the local\n\t * address used to construct the autokey is the unicast address\n\t * of the interface. However, if the sender is a broadcaster,\n\t * the interface broadcast address is used instead.\n\t * Notwithstanding this technobabble, if the sender is a\n\t * multicaster, the broadcast address is null, so we use the\n\t * unicast address anyway. Don't ask.\n\t */\n\tpeer = findpeer(rbufp,  hismode, &retcode);\n\tdstadr_sin = &rbufp->dstadr->sin;\n\tNTOHL_FP(&pkt->org, &p_org);\n\tNTOHL_FP(&pkt->rec, &p_rec);\n\tNTOHL_FP(&pkt->xmt, &p_xmt);\n\n\t/*\n\t * Authentication is conditioned by three switches:\n\t *\n\t * NOPEER  (RES_NOPEER) do not mobilize an association unless\n\t *         authenticated\n\t * NOTRUST (RES_DONTTRUST) do not allow access unless\n\t *         authenticated (implies NOPEER)\n\t * enable  (sys_authenticate) master NOPEER switch, by default\n\t *         on\n\t *\n\t * The NOPEER and NOTRUST can be specified on a per-client basis\n\t * using the restrict command. The enable switch if on implies\n\t * NOPEER for all clients. There are four outcomes:\n\t *\n\t * NONE    The packet has no MAC.\n\t * OK      the packet has a MAC and authentication succeeds\n\t * ERROR   the packet has a MAC and authentication fails\n\t * CRYPTO  crypto-NAK. The MAC has four octets only.\n\t *\n\t * Note: The AUTH(x, y) macro is used to filter outcomes. If x\n\t * is zero, acceptable outcomes of y are NONE and OK. If x is\n\t * one, the only acceptable outcome of y is OK.\n\t */\n\n\tif (has_mac == 0) {\n\t\trestrict_mask &= ~RES_MSSNTP;\n\t\tis_authentic = AUTH_NONE; /* not required */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\n\t\t\t    \"receive: at %ld %s<-%s mode %d len %d\\n\",\n\t\t\t    current_time, stoa(dstadr_sin),\n\t\t\t    stoa(&rbufp->recv_srcadr), hismode,\n\t\t\t    authlen);\n#endif\n\t} else if (has_mac == 4) {\n\t\trestrict_mask &= ~RES_MSSNTP;\n\t\tis_authentic = AUTH_CRYPTO; /* crypto-NAK */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\n\t\t\t    \"receive: at %ld %s<-%s mode %d keyid %08x len %d auth %d\\n\",\n\t\t\t    current_time, stoa(dstadr_sin),\n\t\t\t    stoa(&rbufp->recv_srcadr), hismode, skeyid,\n\t\t\t    authlen + has_mac, is_authentic);\n#endif\n\n#ifdef HAVE_NTP_SIGND\n\t\t/*\n\t\t * If the signature is 20 bytes long, the last 16 of\n\t\t * which are zero, then this is a Microsoft client\n\t\t * wanting AD-style authentication of the server's\n\t\t * reply.\n\t\t *\n\t\t * This is described in Microsoft's WSPP docs, in MS-SNTP:\n\t\t * http://msdn.microsoft.com/en-us/library/cc212930.aspx\n\t\t */\n\t} else if (has_mac == MAX_MD5_LEN && (restrict_mask & RES_MSSNTP) &&\n\t   (retcode == AM_FXMIT || retcode == AM_NEWPASS) &&\n\t   (memcmp(zero_key, (char *)pkt + authlen + 4, MAX_MD5_LEN - 4) ==\n\t   0)) {\n\t\tis_authentic = AUTH_NONE;\n#endif /* HAVE_NTP_SIGND */\n\n\t} else {\n\t\trestrict_mask &= ~RES_MSSNTP;\n#ifdef AUTOKEY\n\t\t/*\n\t\t * For autokey modes, generate the session key\n\t\t * and install in the key cache. Use the socket\n\t\t * broadcast or unicast address as appropriate.\n\t\t */\n\t\tif (crypto_flags && skeyid > NTP_MAXKEY) {\n\n\t\t\t/*\n\t\t\t * More on the autokey dance (AKD). A cookie is\n\t\t\t * constructed from public and private values.\n\t\t\t * For broadcast packets, the cookie is public\n\t\t\t * (zero). For packets that match no\n\t\t\t * association, the cookie is hashed from the\n\t\t\t * addresses and private value. For server\n\t\t\t * packets, the cookie was previously obtained\n\t\t\t * from the server. For symmetric modes, the\n\t\t\t * cookie was previously constructed using an\n\t\t\t * agreement protocol; however, should PKI be\n\t\t\t * unavailable, we construct a fake agreement as\n\t\t\t * the EXOR of the peer and host cookies.\n\t\t\t *\n\t\t\t * hismode\tephemeral\tpersistent\n\t\t\t * =======================================\n\t\t\t * active\t0\t\tcookie#\n\t\t\t * passive\t0%\t\tcookie#\n\t\t\t * client\tsys cookie\t0%\n\t\t\t * server\t0%\t\tsys cookie\n\t\t\t * broadcast\t0\t\t0\n\t\t\t *\n\t\t\t * # if unsync, 0\n\t\t\t * % can't happen\n\t\t\t */\n\t\t\tif (has_mac < (int)MAX_MD5_LEN) {\n\t\t\t\tsys_badauth++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hismode == MODE_BROADCAST) {\n\n\t\t\t\t/*\n\t\t\t\t * For broadcaster, use the interface\n\t\t\t\t * broadcast address when available;\n\t\t\t\t * otherwise, use the unicast address\n\t\t\t\t * found when the association was\n\t\t\t\t * mobilized. However, if this is from\n\t\t\t\t * the wildcard interface, game over.\n\t\t\t\t */\n\t\t\t\tif (crypto_flags && rbufp->dstadr ==\n\t\t\t\t    ANY_INTERFACE_CHOOSE(&rbufp->recv_srcadr)) {\n\t\t\t\t\tsys_restricted++;\n\t\t\t\t\treturn;\t     /* no wildcard */\n\t\t\t\t}\n\t\t\t\tpkeyid = 0;\n\t\t\t\tif (!SOCK_UNSPEC(&rbufp->dstadr->bcast))\n\t\t\t\t\tdstadr_sin =\n\t\t\t\t\t    &rbufp->dstadr->bcast;\n\t\t\t} else if (peer == NULL) {\n\t\t\t\tpkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin, 0,\n\t\t\t\t    sys_private, 0);\n\t\t\t} else {\n\t\t\t\tpkeyid = peer->pcookie;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The session key includes both the public\n\t\t\t * values and cookie. In case of an extension\n\t\t\t * field, the cookie used for authentication\n\t\t\t * purposes is zero. Note the hash is saved for\n\t\t\t * use later in the autokey mambo.\n\t\t\t */\n\t\t\tif (authlen > (int)LEN_PKT_NOMAC && pkeyid != 0) {\n\t\t\t\tsession_key(&rbufp->recv_srcadr,\n\t\t\t\t    dstadr_sin, skeyid, 0, 2);\n\t\t\t\ttkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin,\n\t\t\t\t    skeyid, pkeyid, 0);\n\t\t\t} else {\n\t\t\t\ttkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin,\n\t\t\t\t    skeyid, pkeyid, 2);\n\t\t\t}\n\n\t\t}\n#endif\t/* AUTOKEY */\n\n\t\t/*\n\t\t * Compute the cryptosum. Note a clogging attack may\n\t\t * succeed in bloating the key cache. If an autokey,\n\t\t * purge it immediately, since we won't be needing it\n\t\t * again. If the packet is authentic, it can mobilize an\n\t\t * association. Note that there is no key zero.\n\t\t */\n\t\tif (!authdecrypt(skeyid, (u_int32 *)pkt, authlen,\n\t\t    has_mac))\n\t\t\tis_authentic = AUTH_ERROR;\n\t\telse\n\t\t\tis_authentic = AUTH_OK;\n#ifdef AUTOKEY\n\t\tif (crypto_flags && skeyid > NTP_MAXKEY)\n\t\t\tauthtrust(skeyid, 0);\n#endif\t/* AUTOKEY */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\n\t\t\t    \"receive: at %ld %s<-%s mode %d keyid %08x len %d auth %d\\n\",\n\t\t\t    current_time, stoa(dstadr_sin),\n\t\t\t    stoa(&rbufp->recv_srcadr), hismode, skeyid,\n\t\t\t    authlen + has_mac, is_authentic);\n#endif\n\t}\n\n\t/*\n\t * The association matching rules are implemented by a set of\n\t * routines and an association table. A packet matching an\n\t * association is processed by the peer process for that\n\t * association. If there are no errors, an ephemeral association\n\t * is mobilized: a broadcast packet mobilizes a broadcast client\n\t * aassociation; a manycast server packet mobilizes a manycast\n\t * client association; a symmetric active packet mobilizes a\n\t * symmetric passive association.\n\t */\n\tswitch (retcode) {\n\n\t/*\n\t * This is a client mode packet not matching any association. If\n\t * an ordinary client, simply toss a server mode packet back\n\t * over the fence. If a manycast client, we have to work a\n\t * little harder.\n\t */\n\tcase AM_FXMIT:\n\n\t\t/*\n\t\t * If authentication OK, send a server reply; otherwise,\n\t\t * send a crypto-NAK.\n\t\t */\n\t\tif (!(rbufp->dstadr->flags & INT_MCASTOPEN)) {\n\t\t\tif (AUTH(restrict_mask & RES_DONTTRUST,\n\t\t\t   is_authentic)) {\n\t\t\t\tfast_xmit(rbufp, MODE_SERVER, skeyid,\n\t\t\t\t    restrict_mask);\n\t\t\t} else if (is_authentic == AUTH_ERROR) {\n\t\t\t\tfast_xmit(rbufp, MODE_SERVER, 0,\n\t\t\t\t    restrict_mask);\n\t\t\t\tsys_badauth++;\n\t\t\t} else {\n\t\t\t\tsys_restricted++;\n\t\t\t}\n\t\t\treturn;\t\t\t/* hooray */\n\t\t}\n\n\t\t/*\n\t\t * This must be manycast. Do not respond if not\n\t\t * configured as a manycast server.\n\t\t */\n\t\tif (!sys_manycastserver) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* not enabled */\n\t\t}\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, NULL)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\n\t\t/*\n\t\t * Do not respond if we are not synchronized or our\n\t\t * stratum is greater than the manycaster or the\n\t\t * manycaster has already synchronized to us.\n\t\t */\n\t\tif (sys_leap == LEAP_NOTINSYNC || sys_stratum >=\n\t\t    hisstratum || (!sys_cohort && sys_stratum ==\n\t\t    hisstratum + 1) || rbufp->dstadr->addr_refid ==\n\t\t    pkt->refid) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\n\t\t/*\n\t\t * Respond only if authentication succeeds. Don't do a\n\t\t * crypto-NAK, as that would not be useful.\n\t\t */\n\t\tif (AUTH(restrict_mask & RES_DONTTRUST, is_authentic))\n\t\t\tfast_xmit(rbufp, MODE_SERVER, skeyid,\n\t\t\t    restrict_mask);\n\t\treturn;\t\t\t\t/* hooray */\n\n\t/*\n\t * This is a server mode packet returned in response to a client\n\t * mode packet sent to a multicast group address (for\n\t * manycastclient) or to a unicast address (for pool). The\n\t * origin timestamp is a good nonce to reliably associate the\n\t * reply with what was sent. If there is no match, that's\n\t * curious and could be an intruder attempting to clog, so we\n\t * just ignore it.\n\t *\n\t * If the packet is authentic and the manycastclient or pool\n\t * association is found, we mobilize a client association and\n\t * copy pertinent variables from the manycastclient or pool\n\t * association to the new client association. If not, just\n\t * ignore the packet.\n\t *\n\t * There is an implosion hazard at the manycast client, since\n\t * the manycast servers send the server packet immediately. If\n\t * the guy is already here, don't fire up a duplicate.\n\t */\n\tcase AM_MANYCAST:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, NULL)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tif ((peer2 = findmanycastpeer(rbufp)) == NULL) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* not enabled */\n\t\t}\n\t\tif (!AUTH((!(peer2->cast_flags & MDF_POOL) &&\n\t\t    sys_authenticate) | (restrict_mask & (RES_NOPEER |\n\t\t    RES_DONTTRUST)), is_authentic)) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* access denied */\n\t\t}\n\n\t\t/*\n\t\t * Do not respond if unsynchronized or stratum is below\n\t\t * the floor or at or above the ceiling.\n\t\t */\n\t\tif (hisleap == LEAP_NOTINSYNC || hisstratum <\n\t\t    sys_floor || hisstratum >= sys_ceiling) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\t\tpeer = newpeer(&rbufp->recv_srcadr, NULL, rbufp->dstadr,\n\t\t\t       MODE_CLIENT, hisversion, peer2->minpoll,\n\t\t\t       peer2->maxpoll, FLAG_PREEMPT |\n\t\t\t       (FLAG_IBURST & peer2->flags), MDF_UCAST |\n\t\t\t       MDF_UCLNT, 0, skeyid, sys_ident);\n\t\tif (NULL == peer) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* ignore duplicate  */\n\t\t}\n\n\t\t/*\n\t\t * After each ephemeral pool association is spun,\n\t\t * accelerate the next poll for the pool solicitor so\n\t\t * the pool will fill promptly.\n\t\t */\n\t\tif (peer2->cast_flags & MDF_POOL)\n\t\t\tpeer2->nextdate = current_time + 1;\n\n\t\t/*\n\t\t * Further processing of the solicitation response would\n\t\t * simply detect its origin timestamp as bogus for the\n\t\t * brand-new association (it matches the prototype\n\t\t * association) and tinker with peer->nextdate delaying\n\t\t * first sync.\n\t\t */\n\t\treturn;\t\t/* solicitation response handled */\n\n\t/*\n\t * This is the first packet received from a broadcast server. If\n\t * the packet is authentic and we are enabled as broadcast\n\t * client, mobilize a broadcast client association. We don't\n\t * kiss any frogs here.\n\t */\n\tcase AM_NEWBCL:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, sys_ident)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tif (sys_bclient == 0) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* not enabled */\n\t\t}\n\t\tif (!AUTH(sys_authenticate | (restrict_mask &\n\t\t    (RES_NOPEER | RES_DONTTRUST)), is_authentic)) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* access denied */\n\t\t}\n\n\t\t/*\n\t\t * Do not respond if unsynchronized or stratum is below\n\t\t * the floor or at or above the ceiling.\n\t\t */\n\t\tif (hisleap == LEAP_NOTINSYNC || hisstratum <\n\t\t    sys_floor || hisstratum >= sys_ceiling) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if Autokey and the opcode is not a\n\t\t * CRYPTO_ASSOC response with association ID.\n\t\t */\n\t\tif (crypto_flags && skeyid > NTP_MAXKEY && (opcode &\n\t\t    0xffff0000) != (CRYPTO_ASSOC | CRYPTO_RESP)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* protocol error */\n\t\t}\n#endif\t/* AUTOKEY */\n\n\t\t/*\n\t\t * Broadcasts received via a multicast address may\n\t\t * arrive after a unicast volley has begun\n\t\t * with the same remote address.  newpeer() will not\n\t\t * find duplicate associations on other local endpoints\n\t\t * if a non-NULL endpoint is supplied.  multicastclient\n\t\t * ephemeral associations are unique across all local\n\t\t * endpoints.\n\t\t */\n\t\tif (!(INT_MCASTOPEN & rbufp->dstadr->flags))\n\t\t\tmatch_ep = rbufp->dstadr;\n\t\telse\n\t\t\tmatch_ep = NULL;\n\n\t\t/*\n\t\t * Determine whether to execute the initial volley.\n\t\t */\n\t\tif (sys_bdelay != 0) {\n#ifdef AUTOKEY\n\t\t\t/*\n\t\t\t * If a two-way exchange is not possible,\n\t\t\t * neither is Autokey.\n\t\t\t */\n\t\t\tif (crypto_flags && skeyid > NTP_MAXKEY) {\n\t\t\t\tsys_restricted++;\n\t\t\t\treturn;\t\t/* no autokey */\n\t\t\t}\n#endif\t/* AUTOKEY */\n\n\t\t\t/*\n\t\t\t * Do not execute the volley. Start out in\n\t\t\t * broadcast client mode.\n\t\t\t */\n\t\t\tpeer = newpeer(&rbufp->recv_srcadr, NULL,\n\t\t\t    match_ep, MODE_BCLIENT, hisversion,\n\t\t\t    pkt->ppoll, pkt->ppoll, FLAG_PREEMPT,\n\t\t\t    MDF_BCLNT, 0, skeyid, sys_ident);\n\t\t\tif (NULL == peer) {\n\t\t\t\tsys_restricted++;\n\t\t\t\treturn;\t\t/* ignore duplicate */\n\n\t\t\t} else {\n\t\t\t\tpeer->delay = sys_bdelay;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Execute the initial volley in order to calibrate the\n\t\t * propagation delay and run the Autokey protocol.\n\t\t *\n\t\t * Note that the minpoll is taken from the broadcast\n\t\t * packet, normally 6 (64 s) and that the poll interval\n\t\t * is fixed at this value.\n\t\t */\n\t\tpeer = newpeer(&rbufp->recv_srcadr, NULL, match_ep,\n\t\t    MODE_CLIENT, hisversion, pkt->ppoll, pkt->ppoll,\n\t\t    FLAG_BC_VOL | FLAG_IBURST | FLAG_PREEMPT, MDF_BCLNT,\n\t\t    0, skeyid, sys_ident);\n\t\tif (NULL == peer) {\n\t\t\tsys_restricted++;\n\t\t\treturn;\t\t\t/* ignore duplicate */\n\t\t}\n#ifdef AUTOKEY\n\t\tif (skeyid > NTP_MAXKEY)\n\t\t\tcrypto_recv(peer, rbufp);\n#endif\t/* AUTOKEY */\n\n\t\treturn;\t\t\t\t/* hooray */\n\n\t/*\n\t * This is the first packet received from a symmetric active\n\t * peer. If the packet is authentic and the first he sent,\n\t * mobilize a passive association. If not, kiss the frog.\n\t */\n\tcase AM_NEWPASS:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, sys_ident)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tif (!AUTH(sys_authenticate | (restrict_mask &\n\t\t    (RES_NOPEER | RES_DONTTRUST)), is_authentic)) {\n\n\t\t\t/*\n\t\t\t * If authenticated but cannot mobilize an\n\t\t\t * association, send a symmetric passive\n\t\t\t * response without mobilizing an association.\n\t\t\t * This is for drat broken Windows clients. See\n\t\t\t * Microsoft KB 875424 for preferred workaround.\n\t\t\t */\n\t\t\tif (AUTH(restrict_mask & RES_DONTTRUST,\n\t\t\t    is_authentic)) {\n\t\t\t\tfast_xmit(rbufp, MODE_PASSIVE, skeyid,\n\t\t\t\t    restrict_mask);\n\t\t\t\treturn;\t\t\t/* hooray */\n\t\t\t}\n\t\t\tif (is_authentic == AUTH_ERROR) {\n\t\t\t\tfast_xmit(rbufp, MODE_ACTIVE, 0,\n\t\t\t\t    restrict_mask);\n\t\t\t\tsys_restricted++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Do not respond if synchronized and if stratum is\n\t\t * below the floor or at or above the ceiling. Note,\n\t\t * this allows an unsynchronized peer to synchronize to\n\t\t * us. It would be very strange if he did and then was\n\t\t * nipped, but that could only happen if we were\n\t\t * operating at the top end of the range.  It also means\n\t\t * we will spin an ephemeral association in response to\n\t\t * MODE_ACTIVE KoDs, which will time out eventually.\n\t\t */\n\t\tif (hisleap != LEAP_NOTINSYNC && (hisstratum <\n\t\t    sys_floor || hisstratum >= sys_ceiling)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* no help */\n\t\t}\n\n\t\t/*\n\t\t * The message is correctly authenticated and allowed.\n\t\t * Mobilize a symmetric passive association.\n\t\t */\n\t\tif ((peer = newpeer(&rbufp->recv_srcadr, NULL,\n\t\t    rbufp->dstadr, MODE_PASSIVE, hisversion, pkt->ppoll,\n\t\t    NTP_MAXDPOLL, 0, MDF_UCAST, 0, skeyid,\n\t\t    sys_ident)) == NULL) {\n\t\t\tsys_declined++;\n\t\t\treturn;\t\t\t/* ignore duplicate */\n\t\t}\n\t\tbreak;\n\n\n\t/*\n\t * Process regular packet. Nothing special.\n\t */\n\tcase AM_PROCPKT:\n\n#ifdef AUTOKEY\n\t\t/*\n\t\t * Do not respond if not the same group.\n\t\t */\n\t\tif (group_test(groupname, peer->ident)) {\n\t\t\tsys_declined++;\n\t\t\treturn;\n\t\t}\n#endif /* AUTOKEY */\n\t\tbreak;\n\n\t/*\n\t * A passive packet matches a passive association. This is\n\t * usually the result of reconfiguring a client on the fly. As\n\t * this association might be legitimate and this packet an\n\t * attempt to deny service, just ignore it.\n\t */\n\tcase AM_ERR:\n\t\tsys_declined++;\n\t\treturn;\n\n\t/*\n\t * For everything else there is the bit bucket.\n\t */\n\tdefault:\n\t\tsys_declined++;\n\t\treturn;\n\t}\n\n#ifdef AUTOKEY\n\t/*\n\t * If the association is configured for Autokey, the packet must\n\t * have a public key ID; if not, the packet must have a\n\t * symmetric key ID.\n\t */\n\tif (is_authentic != AUTH_CRYPTO && (((peer->flags &\n\t    FLAG_SKEY) && skeyid <= NTP_MAXKEY) || (!(peer->flags &\n\t    FLAG_SKEY) && skeyid > NTP_MAXKEY))) {\n\t\tsys_badauth++;\n\t\treturn;\n\t}\n#endif\t/* AUTOKEY */\n\tpeer->received++;\n\tpeer->flash &= ~PKT_TEST_MASK;\n\tif (peer->flags & FLAG_XBOGUS) {\n\t\tpeer->flags &= ~FLAG_XBOGUS;\n\t\tpeer->flash |= TEST3;\n\t}\n\n\t/*\n\t * Next comes a rigorous schedule of timestamp checking. If the\n\t * transmit timestamp is zero, the server has not initialized in\n\t * interleaved modes or is horribly broken.\n\t */\n\tif (L_ISZERO(&p_xmt)) {\n\t\tpeer->flash |= TEST3;\t\t\t/* unsynch */\n\n\t/*\n\t * If the transmit timestamp duplicates a previous one, the\n\t * packet is a replay. This prevents the bad guys from replaying\n\t * the most recent packet, authenticated or not.\n\t */\n\t} else if (L_ISEQU(&peer->xmt, &p_xmt)) {\n\t\tpeer->flash |= TEST1;\t\t\t/* duplicate */\n\t\tpeer->oldpkt++;\n\t\treturn;\n\n\t/*\n\t * If this is a broadcast mode packet, skip further checking. If\n\t * an initial volley, bail out now and let the client do its\n\t * stuff. If the origin timestamp is nonzero, this is an\n\t * interleaved broadcast. so restart the protocol.\n\t */\n\t} else if (hismode == MODE_BROADCAST) {\n\t\tif (!L_ISZERO(&p_org) && !(peer->flags & FLAG_XB)) {\n\t\t\tpeer->flags |= FLAG_XB;\n\t\t\tpeer->aorg = p_xmt;\n\t\t\tpeer->borg = rbufp->recv_time;\n\t\t\treport_event(PEVNT_XLEAVE, peer, NULL);\n\t\t\treturn;\n\t\t}\n\n\t/*\n\t * Check for bogus packet in basic mode. If found, switch to\n\t * interleaved mode and resynchronize, but only after confirming\n\t * the packet is not bogus in symmetric interleaved mode.\n\t */\n\t} else if (peer->flip == 0) {\n\t\tif (!L_ISEQU(&p_org, &peer->aorg)) {\n\t\t\tpeer->bogusorg++;\n\t\t\tpeer->flash |= TEST2;\t/* bogus */\n\t\t\tif (!L_ISZERO(&peer->dst) && L_ISEQU(&p_org,\n\t\t\t    &peer->dst)) {\n\t\t\t\tpeer->flip = 1;\n\t\t\t\treport_event(PEVNT_XLEAVE, peer, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tL_CLR(&peer->aorg);\n\t\t}\n\n\t/*\n\t * Check for valid nonzero timestamp fields.\n\t */\n\t} else if (L_ISZERO(&p_org) || L_ISZERO(&p_rec) ||\n\t    L_ISZERO(&peer->dst)) {\n\t\tpeer->flash |= TEST3;\t\t/* unsynch */\n\n\t/*\n\t * Check for bogus packet in interleaved symmetric mode. This\n\t * can happen if a packet is lost, duplicated or crossed. If\n\t * found, flip and resynchronize.\n\t */\n\t} else if (!L_ISZERO(&peer->dst) && !L_ISEQU(&p_org,\n\t    &peer->dst)) {\n\t\tpeer->bogusorg++;\n\t\tpeer->flags |= FLAG_XBOGUS;\n\t\tpeer->flash |= TEST2;\t\t/* bogus */\n\t}\n\n\t/*\n\t * If this is a crypto_NAK, the server cannot authenticate a\n\t * client packet. The server might have just changed keys. Clear\n\t * the association and restart the protocol.\n\t */\n\tif (is_authentic == AUTH_CRYPTO) {\n\t\treport_event(PEVNT_AUTH, peer, \"crypto_NAK\");\n\t\tpeer->flash |= TEST5;\t\t/* bad auth */\n\t\tpeer->badauth++;\n\t\tif (peer->flags & FLAG_PREEMPT) {\n\t\t\tunpeer(peer);\n\t\t\treturn;\n\t\t}\n#ifdef AUTOKEY\n\t\tif (peer->crypto)\n\t\t\tpeer_clear(peer, \"AUTH\");\n#endif\t/* AUTOKEY */\n\t\treturn;\n\n\t/*\n\t * If the digest fails or it's missing for authenticated\n\t * associations, the client cannot authenticate a server\n\t * reply to a client packet previously sent. The loopback check\n\t * is designed to avoid a bait-and-switch attack, which was\n\t * possible in past versions. If symmetric modes, return a\n\t * crypto-NAK. The peer should restart the protocol.\n\t */\n\t} else if (!AUTH(peer->keyid || has_mac ||\n\t\t\t (restrict_mask & RES_DONTTRUST), is_authentic)) {\n\t\treport_event(PEVNT_AUTH, peer, \"digest\");\n\t\tpeer->flash |= TEST5;\t\t/* bad auth */\n\t\tpeer->badauth++;\n\t\tif (has_mac &&\n\t\t    (hismode == MODE_ACTIVE || hismode == MODE_PASSIVE))\n\t\t\tfast_xmit(rbufp, MODE_ACTIVE, 0, restrict_mask);\n\t\tif (peer->flags & FLAG_PREEMPT) {\n\t\t\tunpeer(peer);\n\t\t\treturn;\n\t\t}\n#ifdef AUTOKEY\n\t\tif (peer->crypto)\n\t\t\tpeer_clear(peer, \"AUTH\");\n#endif\t/* AUTOKEY */\n\t\treturn;\n\t}\n\n\t/*\n\t * Update the state variables.\n\t */\n\tif (peer->flip == 0) {\n\t\tif (hismode != MODE_BROADCAST)\n\t\t\tpeer->rec = p_xmt;\n\t\tpeer->dst = rbufp->recv_time;\n\t}\n\tpeer->xmt = p_xmt;\n\n\t/*\n\t * Set the peer ppoll to the maximum of the packet ppoll and the\n\t * peer minpoll. If a kiss-o'-death, set the peer minpoll to\n\t * this maximum and advance the headway to give the sender some\n\t * headroom. Very intricate.\n\t */\n\tpeer->ppoll = max(peer->minpoll, pkt->ppoll);\n\tif (hismode == MODE_SERVER && hisleap == LEAP_NOTINSYNC &&\n\t    hisstratum == STRATUM_UNSPEC && memcmp(&pkt->refid,\n\t    \"RATE\", 4) == 0) {\n\t\tpeer->selbroken++;\n\t\treport_event(PEVNT_RATE, peer, NULL);\n\t\tif (pkt->ppoll > peer->minpoll)\n\t\t\tpeer->minpoll = peer->ppoll;\n\t\tpeer->burst = peer->retry = 0;\n\t\tpeer->throttle = (NTP_SHIFT + 1) * (1 << peer->minpoll);\n\t\tpoll_update(peer, pkt->ppoll);\n\t\treturn;\t\t\t\t/* kiss-o'-death */\n\t}\n\n\t/*\n\t * That was hard and I am sweaty, but the packet is squeaky\n\t * clean. Get on with real work.\n\t */\n\tpeer->timereceived = current_time;\n\tif (is_authentic == AUTH_OK)\n\t\tpeer->flags |= FLAG_AUTHENTIC;\n\telse\n\t\tpeer->flags &= ~FLAG_AUTHENTIC;\n\n#ifdef AUTOKEY\n\t/*\n\t * More autokey dance. The rules of the cha-cha are as follows:\n\t *\n\t * 1. If there is no key or the key is not auto, do nothing.\n\t *\n\t * 2. If this packet is in response to the one just previously\n\t *    sent or from a broadcast server, do the extension fields.\n\t *    Otherwise, assume bogosity and bail out.\n\t *\n\t * 3. If an extension field contains a verified signature, it is\n\t *    self-authenticated and we sit the dance.\n\t *\n\t * 4. If this is a server reply, check only to see that the\n\t *    transmitted key ID matches the received key ID.\n\t *\n\t * 5. Check to see that one or more hashes of the current key ID\n\t *    matches the previous key ID or ultimate original key ID\n\t *    obtained from the broadcaster or symmetric peer. If no\n\t *    match, sit the dance and call for new autokey values.\n\t *\n\t * In case of crypto error, fire the orchestra, stop dancing and\n\t * restart the protocol.\n\t */\n\tif (peer->flags & FLAG_SKEY) {\n\t\t/*\n\t\t * Decrement remaining autokey hashes. This isn't\n\t\t * perfect if a packet is lost, but results in no harm.\n\t\t */\n\t\tap = (struct autokey *)peer->recval.ptr;\n\t\tif (ap != NULL) {\n\t\t\tif (ap->seq > 0)\n\t\t\t\tap->seq--;\n\t\t}\n\t\tpeer->flash |= TEST8;\n\t\trval = crypto_recv(peer, rbufp);\n\t\tif (rval == XEVNT_OK) {\n\t\t\tpeer->unreach = 0;\n\t\t} else {\n\t\t\tif (rval == XEVNT_ERR) {\n\t\t\t\treport_event(PEVNT_RESTART, peer,\n\t\t\t\t    \"crypto error\");\n\t\t\t\tpeer_clear(peer, \"CRYP\");\n\t\t\t\tpeer->flash |= TEST9;\t/* bad crypt */\n\t\t\t\tif (peer->flags & FLAG_PREEMPT)\n\t\t\t\t\tunpeer(peer);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If server mode, verify the receive key ID matches\n\t\t * the transmit key ID.\n\t\t */\n\t\tif (hismode == MODE_SERVER) {\n\t\t\tif (skeyid == peer->keyid)\n\t\t\t\tpeer->flash &= ~TEST8;\n\n\t\t/*\n\t\t * If an extension field is present, verify only that it\n\t\t * has been correctly signed. We don't need a sequence\n\t\t * check here, but the sequence continues.\n\t\t */\n\t\t} else if (!(peer->flash & TEST8)) {\n\t\t\tpeer->pkeyid = skeyid;\n\n\t\t/*\n\t\t * Now the fun part. Here, skeyid is the current ID in\n\t\t * the packet, pkeyid is the ID in the last packet and\n\t\t * tkeyid is the hash of skeyid. If the autokey values\n\t\t * have not been received, this is an automatic error.\n\t\t * If so, check that the tkeyid matches pkeyid. If not,\n\t\t * hash tkeyid and try again. If the number of hashes\n\t\t * exceeds the number remaining in the sequence, declare\n\t\t * a successful failure and refresh the autokey values.\n\t\t */\n\t\t} else if (ap != NULL) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; ; i++) {\n\t\t\t\tif (tkeyid == peer->pkeyid ||\n\t\t\t\t    tkeyid == ap->key) {\n\t\t\t\t\tpeer->flash &= ~TEST8;\n\t\t\t\t\tpeer->pkeyid = skeyid;\n\t\t\t\t\tap->seq -= i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i > ap->seq) {\n\t\t\t\t\tpeer->crypto &=\n\t\t\t\t\t    ~CRYPTO_FLAG_AUTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttkeyid = session_key(\n\t\t\t\t    &rbufp->recv_srcadr, dstadr_sin,\n\t\t\t\t    tkeyid, pkeyid, 0);\n\t\t\t}\n\t\t\tif (peer->flash & TEST8)\n\t\t\t\treport_event(PEVNT_AUTH, peer, \"keylist\");\n\t\t}\n\t\tif (!(peer->crypto & CRYPTO_FLAG_PROV)) /* test 9 */\n\t\t\tpeer->flash |= TEST8;\t/* bad autokey */\n\n\t\t/*\n\t\t * The maximum lifetime of the protocol is about one\n\t\t * week before restarting the Autokey protocol to\n\t\t * refresh certificates and leapseconds values.\n\t\t */\n\t\tif (current_time > peer->refresh) {\n\t\t\treport_event(PEVNT_RESTART, peer,\n\t\t\t    \"crypto refresh\");\n\t\t\tpeer_clear(peer, \"TIME\");\n\t\t\treturn;\n\t\t}\n\t}\n#endif\t/* AUTOKEY */\n\n\t/*\n\t * The dance is complete and the flash bits have been lit. Toss\n\t * the packet over the fence for processing, which may light up\n\t * more flashers.\n\t */\n\tprocess_packet(peer, pkt, rbufp->recv_length);\n\n\t/*\n\t * In interleaved mode update the state variables. Also adjust the\n\t * transmit phase to avoid crossover.\n\t */\n\tif (peer->flip != 0) {\n\t\tpeer->rec = p_rec;\n\t\tpeer->dst = rbufp->recv_time;\n\t\tif (peer->nextdate - current_time < (1U << min(peer->ppoll,\n\t\t    peer->hpoll)) / 2)\n\t\t\tpeer->nextdate++;\n\t\telse\n\t\t\tpeer->nextdate--;\n\t}\n}", "target": 1, "cwe": ["CWE-287"], "project": "ntp", "commit_id": "aa44b5835d69d8ee031736bb8ee2730a514edb7d", "hash": 246618439618565711854767182233541177176, "size": 1131, "message": "[Bug 2941] NAK to the Future: Symmetric association authentication bypass via crypto-NAK", "idx": 358}
{"func": "hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,\n                                    const unsigned char *sig,\n                                    size_t sig_len,\n                                    const unsigned char *m,\n                                    size_t m_len, void **abstract)\n{\n    const unsigned char *r, *s, *p;\n    size_t r_len, s_len;\n    libssh2_ecdsa_ctx *ctx = (libssh2_ecdsa_ctx *) (*abstract);\n\n    (void) session;\n\n    if(sig_len < 35)\n        return -1;\n\n    /* Skip past keyname_len(4) + keyname(19){\"ecdsa-sha2-nistp256\"} + signature_len(4) */\n    p = sig;\n    p += 27;\n\n    r_len = _libssh2_ntohu32(p);\n    p += 4;\n    r = p;\n    p += r_len;\n\n    s_len = _libssh2_ntohu32(p);\n    p += 4;\n    s = p;\n\n    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);\n}", "target": 1, "cwe": ["CWE-787"], "project": "libssh2", "commit_id": "dc109a7f518757741590bb993c0c8412928ccec2", "hash": 125385358157901677066678936346521164120, "size": 30, "message": "Security fixes (#315)\n\n* Bounds checks\r\n\r\nFixes for CVEs\r\nhttps://www.libssh2.org/CVE-2019-3863.html\r\nhttps://www.libssh2.org/CVE-2019-3856.html\r\n\r\n* Packet length bounds check\r\n\r\nCVE\r\nhttps://www.libssh2.org/CVE-2019-3855.html\r\n\r\n* Response length check\r\n\r\nCVE\r\nhttps://www.libssh2.org/CVE-2019-3859.html\r\n\r\n* Bounds check\r\n\r\nCVE\r\nhttps://www.libssh2.org/CVE-2019-3857.html\r\n\r\n* Bounds checking\r\n\r\nCVE\r\nhttps://www.libssh2.org/CVE-2019-3859.html\r\n\r\nand additional data validation\r\n\r\n* Check bounds before reading into buffers\r\n\r\n* Bounds checking\r\n\r\nCVE\r\nhttps://www.libssh2.org/CVE-2019-3859.html\r\n\r\n* declare SIZE_MAX and UINT_MAX if needed", "idx": 359}
{"func": "static BOOL update_read_glyph_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          GLYPH_INDEX_ORDER* glyph_index)\n{\n\tORDER_FIELD_BYTE(1, glyph_index->cacheId);\n\tORDER_FIELD_BYTE(2, glyph_index->flAccel);\n\tORDER_FIELD_BYTE(3, glyph_index->ulCharInc);\n\tORDER_FIELD_BYTE(4, glyph_index->fOpRedundant);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &glyph_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &glyph_index->foreColor);\n\tORDER_FIELD_UINT16(7, glyph_index->bkLeft);\n\tORDER_FIELD_UINT16(8, glyph_index->bkTop);\n\tORDER_FIELD_UINT16(9, glyph_index->bkRight);\n\tORDER_FIELD_UINT16(10, glyph_index->bkBottom);\n\tORDER_FIELD_UINT16(11, glyph_index->opLeft);\n\tORDER_FIELD_UINT16(12, glyph_index->opTop);\n\tORDER_FIELD_UINT16(13, glyph_index->opRight);\n\tORDER_FIELD_UINT16(14, glyph_index->opBottom);\n\n\tif (!update_read_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(20, glyph_index->x);\n\tORDER_FIELD_UINT16(21, glyph_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_22)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, glyph_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < glyph_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(glyph_index->data, Stream_Pointer(s), glyph_index->cbData);\n\t\tStream_Seek(s, glyph_index->cbData);\n\t}\n\n\treturn TRUE;\n}", "target": 0, "cwe": ["CWE-415"], "project": "FreeRDP", "commit_id": "67c2aa52b2ae0341d469071d1bc8aab91f8d2ed8", "hash": 57805938701694485431094141529811761480, "size": 40, "message": "Fixed #6013: Check new length is > 0", "idx": 360}
{"func": "static bool set_off_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, unsigned long flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\t/*\n\t * Always use on-slab management when SLAB_NOLEAKTRACE\n\t * to avoid recursive calls into kmemleak.\n\t */\n\tif (flags & SLAB_NOLEAKTRACE)\n\t\treturn false;\n\n\t/*\n\t * Size is large, assume best to place the slab management obj\n\t * off-slab (should allow better packing of objs).\n\t */\n\tleft = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\t/*\n\t * If the slab has been placed off-slab, and we have enough space then\n\t * move it on-slab. This is at the expense of any extra colouring.\n\t */\n\tif (left >= cachep->num * sizeof(freelist_idx_t))\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}", "target": 0, "cwe": ["CWE-703"], "project": "linux", "commit_id": "c4e490cf148e85ead0d1b1c2caaba833f1d5b29f", "hash": 205694770542889377653561754389290173411, "size": 33, "message": "mm/slab.c: fix SLAB freelist randomization duplicate entries\n\nThis patch fixes a bug in the freelist randomization code.  When a high\nrandom number is used, the freelist will contain duplicate entries.  It\nwill result in different allocations sharing the same chunk.\n\nIt will result in odd behaviours and crashes.  It should be uncommon but\nit depends on the machines.  We saw it happening more often on some\nmachines (every few hours of running tests).\n\nFixes: c7ce4f60ac19 (\"mm: SLAB freelist randomization\")\nLink: http://lkml.kernel.org/r/20170103181908.143178-1-thgarnie@google.com\nSigned-off-by: John Sperbeck <jsperbeck@google.com>\nSigned-off-by: Thomas Garnier <thgarnie@google.com>\nCc: Christoph Lameter <cl@linux.com>\nCc: Pekka Enberg <penberg@kernel.org>\nCc: David Rientjes <rientjes@google.com>\nCc: Joonsoo Kim <iamjoonsoo.kim@lge.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 361}
{"func": "static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tIRDA_DEBUG(2, \"%s(), Received truncated frame (%zd < %zd)!\\n\",\n\t\t\t   __func__, copied, size);\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tskb_free_datagram(sk, skb);\n\n\t/*\n\t *  Check if we have previously stopped IrTTP and we know\n\t *  have more free space in our rx_queue. If so tell IrTTP\n\t *  to start delivering frames again before our rx_queue gets\n\t *  empty\n\t */\n\tif (self->rx_flow == FLOW_STOP) {\n\t\tif ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {\n\t\t\tIRDA_DEBUG(2, \"%s(), Starting IrTTP\\n\", __func__);\n\t\t\tself->rx_flow = FLOW_START;\n\t\t\tirttp_flow_request(self->tsap, FLOW_START);\n\t\t}\n\t}\n\n\treturn copied;\n}", "target": 1, "cwe": ["CWE-200"], "project": "linux", "commit_id": "5ae94c0d2f0bed41d6718be743985d61b7f5c47d", "hash": 180474043083536314973088763820914867148, "size": 45, "message": "irda: Fix missing msg_namelen update in irda_recvmsg_dgram()\n\nThe current code does not fill the msg_name member in case it is set.\nIt also does not set the msg_namelen member to 0 and therefore makes\nnet/socket.c leak the local, uninitialized sockaddr_storage variable\nto userland -- 128 bytes of kernel stack memory.\n\nFix that by simply setting msg_namelen to 0 as obviously nobody cared\nabout irda_recvmsg_dgram() not filling the msg_name in case it was\nset.\n\nCc: Samuel Ortiz <samuel@sortiz.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 362}
{"func": "static int wc_ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curveIn,\n        ecc_point* pubOut)\n{\n    int err = MP_OKAY;\n#ifndef WOLFSSL_ATECC508A\n#ifndef WOLFSSL_SP_MATH\n    ecc_point* base = NULL;\n#endif\n    ecc_point* pub;\n    DECLARE_CURVE_SPECS(curve, ECC_CURVE_FIELD_COUNT);\n#endif /* !WOLFSSL_ATECC508A */\n\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifndef WOLFSSL_ATECC508A\n\n    /* if ecc_point passed in then use it as output for public key point */\n    if (pubOut != NULL) {\n        pub = pubOut;\n    }\n    else {\n        /* caching public key making it a ECC_PRIVATEKEY instead of\n           ECC_PRIVATEKEY_ONLY */\n        pub = &key->pubkey;\n        key->type = ECC_PRIVATEKEY_ONLY;\n    }\n\n    /* avoid loading the curve unless it is not passed in */\n    if (curveIn != NULL) {\n        curve = curveIn;\n    }\n    else {\n        /* load curve info */\n        if (err == MP_OKAY) {\n            ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);\n            err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);\n        }\n    }\n\n    if (err == MP_OKAY) {\n    #ifndef ALT_ECC_SIZE\n        err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);\n    #else\n        pub->x = (mp_int*)&pub->xyz[0];\n        pub->y = (mp_int*)&pub->xyz[1];\n        pub->z = (mp_int*)&pub->xyz[2];\n        alt_fp_init(pub->x);\n        alt_fp_init(pub->y);\n        alt_fp_init(pub->z);\n    #endif\n    }\n\n\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP256R1) {\n        if (err == MP_OKAY)\n            err = sp_ecc_mulmod_base_256(&key->k, pub, 1, key->heap);\n    }\n    else\n#endif\n#ifdef WOLFSSL_SP_384\n    if (key->idx != ECC_CUSTOM_IDX && ecc_sets[key->idx].id == ECC_SECP384R1) {\n        if (err == MP_OKAY)\n            err = sp_ecc_mulmod_base_384(&key->k, pub, 1, key->heap);\n    }\n    else\n#endif\n#endif\n#ifdef WOLFSSL_SP_MATH\n        err = WC_KEY_SIZE_E;\n#else\n    {\n        if (err == MP_OKAY) {\n            base = wc_ecc_new_point_h(key->heap);\n            if (base == NULL)\n                err = MEMORY_E;\n        }\n        /* read in the x/y for this key */\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gx, base->x);\n        if (err == MP_OKAY)\n            err = mp_copy(curve->Gy, base->y);\n        if (err == MP_OKAY)\n            err = mp_set(base->z, 1);\n\n        /* make the public key */\n        if (err == MP_OKAY) {\n            err = wc_ecc_mulmod_ex(&key->k, base, pub, curve->Af, curve->prime,\n                                                                  1, key->heap);\n            if (err == MP_MEM) {\n               err = MEMORY_E;\n            }\n        }\n\n        wc_ecc_del_point_h(base, key->heap);\n    }\n#endif\n\n#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN\n    /* validate the public key, order * pubkey = point at infinity */\n    if (err == MP_OKAY)\n        err = ecc_check_pubkey_order(key, pub, curve->Af, curve->prime,\n                curve->order);\n#endif /* WOLFSSL_VALIDATE_KEYGEN */\n\n    if (err != MP_OKAY) {\n        /* clean up if failed */\n    #ifndef ALT_ECC_SIZE\n        mp_clear(pub->x);\n        mp_clear(pub->y);\n        mp_clear(pub->z);\n    #endif\n    }\n\n    /* free up local curve */\n    if (curveIn == NULL) {\n        wc_ecc_curve_free(curve);\n        FREE_CURVE_SPECS();\n    }\n\n#else\n    (void)curveIn;\n    err = NOT_COMPILED_IN;\n#endif /* WOLFSSL_ATECC508A */\n\n    /* change key state if public part is cached */\n    if (key->type == ECC_PRIVATEKEY_ONLY && pubOut == NULL) {\n        key->type = ECC_PRIVATEKEY;\n    }\n\n    return err;\n}", "target": 1, "cwe": ["CWE-326", "CWE-203"], "project": "wolfssl", "commit_id": "1de07da61f0c8e9926dcbd68119f73230dae283f", "hash": 79542785084750004931360648285211721614, "size": 135, "message": "Constant time EC map to affine for private operations\n\nFor fast math, use a constant time modular inverse when mapping to\naffine when operation involves a private key - key gen, calc shared\nsecret, sign.", "idx": 363}
{"func": "static int read_bucket_policy(RGWRados *store,\n                              struct req_state *s,\n                              RGWBucketInfo& bucket_info,\n                              map<string, bufferlist>& bucket_attrs,\n                              RGWAccessControlPolicy *policy,\n                              rgw_bucket& bucket)\n{\n  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {\n    ldout(s->cct, 0) << \"NOTICE: bucket \" << bucket_info.bucket.name << \" is suspended\" << dendl;\n    return -ERR_USER_SUSPENDED;\n  }\n\n  if (bucket.name.empty()) {\n    return 0;\n  }\n\n  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);\n  if (ret == -ENOENT) {\n      ret = -ERR_NO_SUCH_BUCKET;\n  }\n\n  return ret;\n}", "target": 0, "cwe": ["CWE-770"], "project": "ceph", "commit_id": "ab29bed2fc9f961fe895de1086a8208e21ddaddc", "hash": 86605508150413288412937810994317070992, "size": 23, "message": "rgw: fix issues with 'enforce bounds' patch\n\nThe patch to enforce bounds on max-keys/max-uploads/max-parts had a few\nissues that would prevent us from compiling it. Instead of changing the\ncode provided by the submitter, we're addressing them in a separate\ncommit to maintain the DCO.\n\nSigned-off-by: Joao Eduardo Luis <joao@suse.de>\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>\n(cherry picked from commit 29bc434a6a81a2e5c5b8cfc4c8d5c82ca5bf538a)\nmimic specific fixes:\nAs the largeish change from master g_conf() isn't in mimic yet, use the g_conf\nglobal structure, also make rgw_op use the value from req_info ceph context as\nwe do for all the requests", "idx": 364}
{"func": "static ssize_t rebind_store(struct device_driver *dev, const char *buf,\n\t\t\t\t size_t count)\n{\n\tint ret;\n\tint len;\n\tstruct bus_id_priv *bid;\n\n\t/* buf length should be less that BUSID_SIZE */\n\tlen = strnlen(buf, BUSID_SIZE);\n\n\tif (!(len < BUSID_SIZE))\n\t\treturn -EINVAL;\n\n\tbid = get_busid_priv(buf);\n\tif (!bid)\n\t\treturn -ENODEV;\n\n\t/* mark the device for deletion so probe ignores it during rescan */\n\tbid->status = STUB_BUSID_OTHER;\n\n\tret = do_rebind((char *) buf, bid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* delete device from busid_table */\n\tdel_match_busid((char *) buf);\n\n\treturn count;\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux", "commit_id": "22076557b07c12086eeb16b8ce2b0b735f7a27e7", "hash": 305518711855992950420693132653011389298, "size": 29, "message": "usbip: usbip_host: fix NULL-ptr deref and use-after-free errors\n\nusbip_host updates device status without holding lock from stub probe,\ndisconnect and rebind code paths. When multiple requests to import a\ndevice are received, these unprotected code paths step all over each\nother and drive fails with NULL-ptr deref and use-after-free errors.\n\nThe driver uses a table lock to protect the busid array for adding and\ndeleting busids to the table. However, the probe, disconnect and rebind\npaths get the busid table entry and update the status without holding\nthe busid table lock. Add a new finer grain lock to protect the busid\nentry. This new lock will be held to search and update the busid entry\nfields from get_busid_idx(), add_match_busid() and del_match_busid().\n\nmatch_busid_show() does the same to access the busid entry fields.\n\nget_busid_priv() changed to return the pointer to the busid entry holding\nthe busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()\ncall put_busid_priv() to release the busid lock before returning. This\nchanges fixes the unprotected code paths eliminating the race conditions\nin updating the busid entries.\n\nReported-by: Jakub Jirasek\nSigned-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>\nCc: stable <stable@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 365}
{"func": "static int tvaudio_set_ctrl(struct CHIPSTATE *chip,\n\t\t\t    struct v4l2_control *ctrl)\n{\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tif (ctrl->value < 0 || ctrl->value >= 2)\n\t\t\treturn -ERANGE;\n\t\tchip->muted = ctrl->value;\n\t\tif (chip->muted)\n\t\t\tchip_write_masked(chip,desc->inputreg,desc->inputmute,desc->inputmask);\n\t\telse\n\t\t\tchip_write_masked(chip,desc->inputreg,\n\t\t\t\t\tdesc->inputmap[chip->input],desc->inputmask);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t{\n\t\tint volume,balance;\n\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\n\t\tvolume = max(chip->left,chip->right);\n\t\tif (volume)\n\t\t\tbalance=(32768*min(chip->left,chip->right))/volume;\n\t\telse\n\t\t\tbalance=32768;\n\n\t\tvolume=ctrl->value;\n\t\tchip->left = (min(65536 - balance,32768) * volume) / 32768;\n\t\tchip->right = (min(balance,volume *(__u16)32768)) / 32768;\n\n\t\tchip_write(chip,desc->leftreg,desc->volfunc(chip->left));\n\t\tchip_write(chip,desc->rightreg,desc->volfunc(chip->right));\n\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t{\n\t\tint volume, balance;\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\n\t\tvolume = max(chip->left,chip->right);\n\t\tbalance = ctrl->value;\n\n\t\tchip_write(chip,desc->leftreg,desc->volfunc(chip->left));\n\t\tchip_write(chip,desc->rightreg,desc->volfunc(chip->right));\n\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\tbreak;\n\t\tchip->bass = ctrl->value;\n\t\tchip_write(chip,desc->bassreg,desc->bassfunc(chip->bass));\n\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\treturn -EINVAL;\n\n\t\tchip->treble = ctrl->value;\n\t\tchip_write(chip,desc->treblereg,desc->treblefunc(chip->treble));\n\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "01a1a3cc1e3fbe718bd06a2a5d4d1a2d0fb4d7d9", "hash": 189088603958465909662009208721667786681, "size": 70, "message": "V4L/DVB (9624): CVE-2008-5033: fix OOPS on tvaudio when controlling bass/treble\n\nThis bug were supposed to be fixed by 5ba2f67afb02c5302b2898949ed6fc3b3d37dcf1,\nwhere a call to NULL happens.\n\nNot all tvaudio chips allow controlling bass/treble. So, the driver\nhas a table with a flag to indicate if the chip does support it.\n\nUnfortunately, the handling of this logic were broken for a very long\ntime (probably since the first module version). Due to that, an OOPS\nwere generated for devices that don't support bass/treble.\n\nThis were the resulting OOPS message before the patch, with debug messages\nenabled:\n\ntvaudio' 1-005b: VIDIOC_S_CTRL\nBUG: unable to handle kernel NULL pointer dereference at 00000000\nIP: [<00000000>]\n*pde = 22fda067 *pte = 00000000\nOops: 0000 [#1] SMP\nModules linked in: snd_hda_intel snd_seq_dummy snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device\nsnd_pcm_oss snd_mixer_oss snd_pcm snd_timer snd_hwdep snd soundcore tuner_simple tuner_types tea5767 tuner\ntvaudio bttv bridgebnep rfcomm l2cap bluetooth it87 hwmon_vid hwmon fuse sunrpc ipt_REJECT\nnf_conntrack_ipv4 iptable_filter ip_tables ip6t_REJECT xt_tcpudp nf_conntrack_ipv6 xt_state nf_conntrack\nip6table_filter ip6_tables x_tables ipv6 dm_mirrordm_multipath dm_mod configfs videodev v4l1_compat\nir_common 8139cp compat_ioctl32 v4l2_common 8139too videobuf_dma_sg videobuf_core mii btcx_risc tveeprom\ni915 button snd_page_alloc serio_raw drm pcspkr i2c_algo_bit i2c_i801 i2c_core iTCO_wdt\niTCO_vendor_support sr_mod cdrom sg ata_generic pata_acpi ata_piix libata sd_mod scsi_mod ext3 jbdmbcache\nuhci_hcd ohci_hcd ehci_hcd [last unloaded: soundcore]\n\nPid: 15413, comm: qv4l2 Not tainted (2.6.25.14-108.fc9.i686 #1)\nEIP: 0060:[<00000000>] EFLAGS: 00210246 CPU: 0\nEIP is at 0x0\nEAX: 00008000 EBX: ebd21600 ECX: e2fd9ec4 EDX: 00200046\nESI: f8c0f0c4 EDI: f8c0f0c4 EBP: e2fd9d50 ESP: e2fd9d2c\n DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068\nProcess qv4l2 (pid: 15413, ti=e2fd9000 task=ebe44000 task.ti=e2fd9000)\nStack: f8c0c6ae e2ff2a00 00000d00 e2fd9ec4 ebc4e000 e2fd9d5c f8c0c448 00000000\n       f899c12a e2fd9d5c f899c154 e2fd9d68 e2fd9d80 c0560185 e2fd9d88 f8f3e1d8\n       f8f3e1dc ebc4e034 f8f3e18c e2fd9ec4 00000000 e2fd9d90 f899c286 c008561c\nCall Trace:\n [<f8c0c6ae>] ? chip_command+0x266/0x4b6 [tvaudio]\n [<f8c0c448>] ? chip_command+0x0/0x4b6 [tvaudio]\n [<f899c12a>] ? i2c_cmd+0x0/0x2f [i2c_core]\n [<f899c154>] ? i2c_cmd+0x2a/0x2f [i2c_core]\n [<c0560185>] ? device_for_each_child+0x21/0x49\n [<f899c286>] ? i2c_clients_command+0x1c/0x1e [i2c_core]\n [<f8f283d8>] ? bttv_call_i2c_clients+0x14/0x16 [bttv]\n [<f8f23601>] ? bttv_s_ctrl+0x1bc/0x313 [bttv]\n [<f8f23445>] ? bttv_s_ctrl+0x0/0x313 [bttv]\n [<f8b6096d>] ? __video_do_ioctl+0x1f84/0x3726 [videodev]\n [<c05abb4e>] ? sock_aio_write+0x100/0x10d\n [<c041b23e>] ? kmap_atomic_prot+0x1dd/0x1df\n [<c043a0c9>] ? enqueue_hrtimer+0xc2/0xcd\n [<c04f4fa4>] ? copy_from_user+0x39/0x121\n [<f8b622b9>] ? __video_ioctl2+0x1aa/0x24a [videodev]\n [<c04054fd>] ? do_notify_resume+0x768/0x795\n [<c043c0f7>] ? getnstimeofday+0x34/0xd1\n [<c0437b77>] ? autoremove_wake_function+0x0/0x33\n [<f8b62368>] ? video_ioctl2+0xf/0x13 [videodev]\n [<c048c6f0>] ? vfs_ioctl+0x50/0x69\n [<c048c942>] ? do_vfs_ioctl+0x239/0x24c\n [<c048c995>] ? sys_ioctl+0x40/0x5b\n [<c0405bf2>] ? syscall_call+0x7/0xb\n [<c0620000>] ? cpuid4_cache_sysfs_exit+0x3d/0x69\n =======================\nCode:  Bad EIP value.\nEIP: [<00000000>] 0x0 SS:ESP 0068:e2fd9d2c\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>", "idx": 366}
{"func": "static ssize_t runtime_active_kids_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev->power.ignore_children ?\n\t\t0 : atomic_read(&dev->power.child_count));\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "aa838896d87af561a33ecefea1caa4c15a68bc47", "hash": 47597888041429709879094213599726952687, "size": 7, "message": "drivers core: Use sysfs_emit and sysfs_emit_at for show(device *...) functions\n\nConvert the various sprintf fmaily calls in sysfs device show functions\nto sysfs_emit and sysfs_emit_at for PAGE_SIZE buffer safety.\n\nDone with:\n\n$ spatch -sp-file sysfs_emit_dev.cocci --in-place --max-width=80 .\n\nAnd cocci script:\n\n$ cat sysfs_emit_dev.cocci\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tstrcpy(buf, chr);\n+\tsysfs_emit(buf, chr);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n-\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n+\tlen += sysfs_emit_at(buf, len,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t...\n-\tstrcpy(buf, chr);\n-\treturn strlen(buf);\n+\treturn sysfs_emit(buf, chr);\n}\n\nSigned-off-by: Joe Perches <joe@perches.com>\nLink: https://lore.kernel.org/r/3d033c33056d88bbe34d4ddb62afd05ee166ab9a.1600285923.git.joe@perches.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 367}
{"func": "    inline const char *stros() {\n#if defined(linux) || defined(__linux) || defined(__linux__)\n      static const char *const str = \"Linux\";\n#elif defined(sun) || defined(__sun)\n      static const char *const str = \"Sun OS\";\n#elif defined(BSD) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined (__DragonFly__)\n      static const char *const str = \"BSD\";\n#elif defined(sgi) || defined(__sgi)\n      static const char *const str = \"Irix\";\n#elif defined(__MACOSX__) || defined(__APPLE__)\n      static const char *const str = \"Mac OS\";\n#elif defined(unix) || defined(__unix) || defined(__unix__)\n      static const char *const str = \"Generic Unix\";\n#elif defined(_MSC_VER) || defined(WIN32)  || defined(_WIN32) || defined(__WIN32__) || \\\n  defined(WIN64) || defined(_WIN64) || defined(__WIN64__)\n      static const char *const str = \"Windows\";\n#else\n      const char\n        *const _str1 = std::getenv(\"OSTYPE\"),\n        *const _str2 = _str1?_str1:std::getenv(\"OS\"),\n        *const str = _str2?_str2:\"Unknown OS\";\n#endif\n      return str;\n    }", "target": 0, "cwe": ["CWE-770"], "project": "cimg", "commit_id": "619cb58dd90b4e03ac68286c70ed98acbefd1c90", "hash": 292845743394048678788537257627488989210, "size": 24, "message": "CImg<>::load_bmp() and CImg<>::load_pandore(): Check that dimensions encoded in file does not exceed file size.", "idx": 368}
{"func": "static int read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd)\n{\n    ALSSpecificConfig *sconf = &ctx->sconf;\n    AVCodecContext *avctx    = ctx->avctx;\n    GetBitContext *gb        = &ctx->gb;\n    unsigned int k;\n    unsigned int s[8];\n    unsigned int sx[8];\n    unsigned int sub_blocks, log2_sub_blocks, sb_length;\n    unsigned int start      = 0;\n    unsigned int opt_order;\n    int          sb;\n    int32_t      *quant_cof = bd->quant_cof;\n    int32_t      *current_res;\n\n\n    // ensure variable block decoding by reusing this field\n    *bd->const_block = 0;\n\n    *bd->opt_order  = 1;\n    bd->js_blocks   = get_bits1(gb);\n\n    opt_order       = *bd->opt_order;\n\n    // determine the number of subblocks for entropy decoding\n    if (!sconf->bgmc && !sconf->sb_part) {\n        log2_sub_blocks = 0;\n    } else {\n        if (sconf->bgmc && sconf->sb_part)\n            log2_sub_blocks = get_bits(gb, 2);\n        else\n            log2_sub_blocks = 2 * get_bits1(gb);\n    }\n\n    sub_blocks = 1 << log2_sub_blocks;\n\n    // do not continue in case of a damaged stream since\n    // block_length must be evenly divisible by sub_blocks\n    if (bd->block_length & (sub_blocks - 1)) {\n        av_log(avctx, AV_LOG_WARNING,\n               \"Block length is not evenly divisible by the number of subblocks.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sb_length = bd->block_length >> log2_sub_blocks;\n\n    if (sconf->bgmc) {\n        s[0] = get_bits(gb, 8 + (sconf->resolution > 1));\n        for (k = 1; k < sub_blocks; k++)\n            s[k] = s[k - 1] + decode_rice(gb, 2);\n\n        for (k = 0; k < sub_blocks; k++) {\n            sx[k]   = s[k] & 0x0F;\n            s [k] >>= 4;\n        }\n    } else {\n        s[0] = get_bits(gb, 4 + (sconf->resolution > 1));\n        for (k = 1; k < sub_blocks; k++)\n            s[k] = s[k - 1] + decode_rice(gb, 0);\n    }\n    for (k = 1; k < sub_blocks; k++)\n        if (s[k] > 32) {\n            av_log(avctx, AV_LOG_ERROR, \"k invalid for rice code.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n    if (get_bits1(gb))\n        *bd->shift_lsbs = get_bits(gb, 4) + 1;\n\n    *bd->store_prev_samples = (bd->js_blocks && bd->raw_other) || *bd->shift_lsbs;\n\n\n    if (!sconf->rlslms) {\n        if (sconf->adapt_order) {\n            int opt_order_length = av_ceil_log2(av_clip((bd->block_length >> 3) - 1,\n                                                2, sconf->max_order + 1));\n            *bd->opt_order       = get_bits(gb, opt_order_length);\n            if (*bd->opt_order > sconf->max_order) {\n                *bd->opt_order = sconf->max_order;\n                av_log(avctx, AV_LOG_ERROR, \"Predictor order too large.\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        } else {\n            *bd->opt_order = sconf->max_order;\n        }\n\n        opt_order = *bd->opt_order;\n\n        if (opt_order) {\n            int add_base;\n\n            if (sconf->coef_table == 3) {\n                add_base = 0x7F;\n\n                // read coefficient 0\n                quant_cof[0] = 32 * parcor_scaled_values[get_bits(gb, 7)];\n\n                // read coefficient 1\n                if (opt_order > 1)\n                    quant_cof[1] = -32 * parcor_scaled_values[get_bits(gb, 7)];\n\n                // read coefficients 2 to opt_order\n                for (k = 2; k < opt_order; k++)\n                    quant_cof[k] = get_bits(gb, 7);\n            } else {\n                int k_max;\n                add_base = 1;\n\n                // read coefficient 0 to 19\n                k_max = FFMIN(opt_order, 20);\n                for (k = 0; k < k_max; k++) {\n                    int rice_param = parcor_rice_table[sconf->coef_table][k][1];\n                    int offset     = parcor_rice_table[sconf->coef_table][k][0];\n                    quant_cof[k] = decode_rice(gb, rice_param) + offset;\n                    if (quant_cof[k] < -64 || quant_cof[k] > 63) {\n                        av_log(avctx, AV_LOG_ERROR, \"quant_cof %d is out of range.\\n\", quant_cof[k]);\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n\n                // read coefficients 20 to 126\n                k_max = FFMIN(opt_order, 127);\n                for (; k < k_max; k++)\n                    quant_cof[k] = decode_rice(gb, 2) + (k & 1);\n\n                // read coefficients 127 to opt_order\n                for (; k < opt_order; k++)\n                    quant_cof[k] = decode_rice(gb, 1);\n\n                quant_cof[0] = 32 * parcor_scaled_values[quant_cof[0] + 64];\n\n                if (opt_order > 1)\n                    quant_cof[1] = -32 * parcor_scaled_values[quant_cof[1] + 64];\n            }\n\n            for (k = 2; k < opt_order; k++)\n                quant_cof[k] = (quant_cof[k] << 14) + (add_base << 13);\n        }\n    }\n\n    // read LTP gain and lag values\n    if (sconf->long_term_prediction) {\n        *bd->use_ltp = get_bits1(gb);\n\n        if (*bd->use_ltp) {\n            int r, c;\n\n            bd->ltp_gain[0]   = decode_rice(gb, 1) << 3;\n            bd->ltp_gain[1]   = decode_rice(gb, 2) << 3;\n\n            r                 = get_unary(gb, 0, 3);\n            c                 = get_bits(gb, 2);\n            bd->ltp_gain[2]   = ltp_gain_values[r][c];\n\n            bd->ltp_gain[3]   = decode_rice(gb, 2) << 3;\n            bd->ltp_gain[4]   = decode_rice(gb, 1) << 3;\n\n            *bd->ltp_lag      = get_bits(gb, ctx->ltp_lag_length);\n            *bd->ltp_lag     += FFMAX(4, opt_order + 1);\n        }\n    }\n\n    // read first value and residuals in case of a random access block\n    if (bd->ra_block) {\n        if (opt_order)\n            bd->raw_samples[0] = decode_rice(gb, avctx->bits_per_raw_sample - 4);\n        if (opt_order > 1)\n            bd->raw_samples[1] = decode_rice(gb, FFMIN(s[0] + 3, ctx->s_max));\n        if (opt_order > 2)\n            bd->raw_samples[2] = decode_rice(gb, FFMIN(s[0] + 1, ctx->s_max));\n\n        start = FFMIN(opt_order, 3);\n    }\n\n    // read all residuals\n    if (sconf->bgmc) {\n        int          delta[8];\n        unsigned int k    [8];\n        unsigned int b = av_clip((av_ceil_log2(bd->block_length) - 3) >> 1, 0, 5);\n\n        // read most significant bits\n        unsigned int high;\n        unsigned int low;\n        unsigned int value;\n\n        ff_bgmc_decode_init(gb, &high, &low, &value);\n\n        current_res = bd->raw_samples + start;\n\n        for (sb = 0; sb < sub_blocks; sb++) {\n            unsigned int sb_len  = sb_length - (sb ? 0 : start);\n\n            k    [sb] = s[sb] > b ? s[sb] - b : 0;\n            delta[sb] = 5 - s[sb] + k[sb];\n\n            ff_bgmc_decode(gb, sb_len, current_res,\n                        delta[sb], sx[sb], &high, &low, &value, ctx->bgmc_lut, ctx->bgmc_lut_status);\n\n            current_res += sb_len;\n        }\n\n        ff_bgmc_decode_end(gb);\n\n\n        // read least significant bits and tails\n        current_res = bd->raw_samples + start;\n\n        for (sb = 0; sb < sub_blocks; sb++, start = 0) {\n            unsigned int cur_tail_code = tail_code[sx[sb]][delta[sb]];\n            unsigned int cur_k         = k[sb];\n            unsigned int cur_s         = s[sb];\n\n            for (; start < sb_length; start++) {\n                int32_t res = *current_res;\n\n                if (res == cur_tail_code) {\n                    unsigned int max_msb =   (2 + (sx[sb] > 2) + (sx[sb] > 10))\n                                          << (5 - delta[sb]);\n\n                    res = decode_rice(gb, cur_s);\n\n                    if (res >= 0) {\n                        res += (max_msb    ) << cur_k;\n                    } else {\n                        res -= (max_msb - 1) << cur_k;\n                    }\n                } else {\n                    if (res > cur_tail_code)\n                        res--;\n\n                    if (res & 1)\n                        res = -res;\n\n                    res >>= 1;\n\n                    if (cur_k) {\n                        res <<= cur_k;\n                        res  |= get_bits_long(gb, cur_k);\n                    }\n                }\n\n                *current_res++ = res;\n            }\n        }\n    } else {\n        current_res = bd->raw_samples + start;\n\n        for (sb = 0; sb < sub_blocks; sb++, start = 0)\n            for (; start < sb_length; start++)\n                *current_res++ = decode_rice(gb, s[sb]);\n     }\n\n    if (!sconf->mc_coding || ctx->js_switch)\n        align_get_bits(gb);\n\n    return 0;\n}", "target": 1, "cwe": ["CWE-787"], "project": "FFmpeg", "commit_id": "18f94df8af04f2c02a25a7dec512289feff6517f", "hash": 266247169717184144160101826412117545060, "size": 257, "message": "avcodec/alsdec: check predictor order against block length\n\nFixes out of array access\nFixes: abd3c041acbcb816be113455d138166b-asan_heap-oob_b11634_3707_cov_1707137151_als_05_2ch48k16b.mp4\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "idx": 369}
{"func": "char * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\n\troot_tmp = gf_strdup(szPath);\n\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\n\tstrcat(szPath, \"gpac_cache\");\n\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}", "target": 0, "cwe": ["CWE-787"], "project": "gpac", "commit_id": "f3698bb1bce62402805c3fda96551a23101a32f9", "hash": 125724920177639704522768931100506945100, "size": 29, "message": "fix buffer overrun in gf_bin128_parse\n\ncloses #1204\ncloses #1205", "idx": 370}
{"func": "CtPtr ProtocolV1::handle_client_banner_write(int r) {\n  ldout(cct, 20) << __func__ << \" r=\" << r << dendl;\n\n  if (r < 0) {\n    ldout(cct, 1) << __func__ << \" write client banner failed\" << dendl;\n    return _fault();\n  }\n  ldout(cct, 10) << __func__ << \" connect write banner done: \"\n                 << connection->get_peer_addr() << dendl;\n\n  return wait_server_banner();\n}", "target": 0, "cwe": ["CWE-294"], "project": "ceph", "commit_id": "6c14c2fb5650426285428dfe6ca1597e5ea1d07d", "hash": 225231714098416078037893638803558257795, "size": 12, "message": "mon/MonClient: bring back CEPHX_V2 authorizer challenges\n\nCommit c58c5754dfd2 (\"msg/async/ProtocolV1: use AuthServer and\nAuthClient\") introduced a backwards compatibility issue into msgr1.\nTo fix it, commit 321548010578 (\"mon/MonClient: skip CEPHX_V2\nchallenge if client doesn't support it\") set out to skip authorizer\nchallenges for peers that don't support CEPHX_V2.  However, it\nmade it so that authorizer challenges are skipped for all peers in\nboth msgr1 and msgr2 cases, effectively disabling the protection\nagainst replay attacks that was put in place in commit f80b848d3f83\n(\"auth/cephx: add authorizer challenge\", CVE-2018-1128).\n\nThis is because con->get_features() always returns 0 at that\npoint.  In msgr1 case, the peer shares its features along with the\nauthorizer, but while they are available in connect_msg.features they\naren't assigned to con until ProtocolV1::open().  In msgr2 case, the\npeer doesn't share its features until much later (in CLIENT_IDENT\nframe, i.e. after the authentication phase).  The result is that\n!CEPHX_V2 branch is taken in all cases and replay attack protection\nis lost.\n\nOnly clusters with cephx_service_require_version set to 2 on the\nservice daemons would not be silently downgraded.  But, since the\ndefault is 1 and there are no reports of looping on BADAUTHORIZER\nfaults, I'm pretty sure that no one has ever done that.  Note that\ncephx_require_version set to 2 would have no effect even though it\nis supposed to be stronger than cephx_service_require_version\nbecause MonClient::handle_auth_request() didn't check it.\n\nTo fix:\n\n- for msgr1, check connect_msg.features (as was done before commit\n  c58c5754dfd2) and challenge if CEPHX_V2 is supported.  Together\n  with two preceding patches that resurrect proper cephx_* option\n  handling in msgr1, this covers both \"I want old clients to work\"\n  and \"I wish to require better authentication\" use cases.\n\n- for msgr2, don't check anything and always challenge.  CEPHX_V2\n  predates msgr2, anyone speaking msgr2 must support it.\n\nSigned-off-by: Ilya Dryomov <idryomov@gmail.com>\n(cherry picked from commit 4a82c72e3bdddcb625933e83af8b50a444b961f1)", "idx": 371}
{"func": "static int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tschedule();\n\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tsig->notify_count = -1;\t/* for exit_notify() */\n\t\tfor (;;) {\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tschedule();\n\t\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\tdetach_pid(tsk, PIDTYPE_PID);\n\t\ttsk->pid = leader->pid;\n\t\tattach_pid(tsk, PIDTYPE_PID,  task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n\texit_itimers(sig);\n\tflush_itimer_signals();\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t/* protects against exit_notify() and __exit_signal() */\n\tread_lock(&tasklist_lock);\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}", "target": 0, "cwe": ["CWE-200"], "project": "linux-2.6", "commit_id": "b66c5984017533316fd1951770302649baf1aa33", "hash": 259860615279223083264396530397627953530, "size": 157, "message": "exec: do not leave bprm->interp on stack\n\nIf a series of scripts are executed, each triggering module loading via\nunprintable bytes in the script header, kernel stack contents can leak\ninto the command line.\n\nNormally execution of binfmt_script and binfmt_misc happens recursively.\nHowever, when modules are enabled, and unprintable bytes exist in the\nbprm->buf, execution will restart after attempting to load matching\nbinfmt modules.  Unfortunately, the logic in binfmt_script and\nbinfmt_misc does not expect to get restarted.  They leave bprm->interp\npointing to their local stack.  This means on restart bprm->interp is\nleft pointing into unused stack memory which can then be copied into the\nuserspace argv areas.\n\nAfter additional study, it seems that both recursion and restart remains\nthe desirable way to handle exec with scripts, misc, and modules.  As\nsuch, we need to protect the changes to interp.\n\nThis changes the logic to require allocation for any changes to the\nbprm->interp.  To avoid adding a new kmalloc to every exec, the default\nvalue is left as-is.  Only when passing through binfmt_script or\nbinfmt_misc does an allocation take place.\n\nFor a proof of concept, see DoTest.sh from:\n\n   http://www.halfdog.net/Security/2012/LinuxKernelBinfmtScriptStackDataDisclosure/\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: halfdog <me@halfdog.net>\nCc: P J P <ppandit@redhat.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 372}
{"func": "static int restore_fp(struct task_struct *tsk)\n{\n\tif (tsk->thread.load_fp || tm_active_with_fp(tsk)) {\n\t\tload_fp_state(&current->thread.fp_state);\n\t\tcurrent->thread.load_fp++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-662"], "project": "linux", "commit_id": "a8318c13e79badb92bc6640704a64cc022a6eb97", "hash": 172079334135325159828700269273006775870, "size": 9, "message": "powerpc/tm: Fix restoring FP/VMX facility incorrectly on interrupts\n\nWhen in userspace and MSR FP=0 the hardware FP state is unrelated to\nthe current process. This is extended for transactions where if tbegin\nis run with FP=0, the hardware checkpoint FP state will also be\nunrelated to the current process. Due to this, we need to ensure this\nhardware checkpoint is updated with the correct state before we enable\nFP for this process.\n\nUnfortunately we get this wrong when returning to a process from a\nhardware interrupt. A process that starts a transaction with FP=0 can\ntake an interrupt. When the kernel returns back to that process, we\nchange to FP=1 but with hardware checkpoint FP state not updated. If\nthis transaction is then rolled back, the FP registers now contain the\nwrong state.\n\nThe process looks like this:\n   Userspace:                      Kernel\n\n               Start userspace\n                with MSR FP=0 TM=1\n                  < -----\n   ...\n   tbegin\n   bne\n               Hardware interrupt\n                   ---- >\n                                    <do_IRQ...>\n                                    ....\n                                    ret_from_except\n                                      restore_math()\n\t\t\t\t        /* sees FP=0 */\n                                        restore_fp()\n                                          tm_active_with_fp()\n\t\t\t\t\t    /* sees FP=1 (Incorrect) */\n                                          load_fp_state()\n                                        FP = 0 -> 1\n                  < -----\n               Return to userspace\n                 with MSR TM=1 FP=1\n                 with junk in the FP TM checkpoint\n   TM rollback\n   reads FP junk\n\nWhen returning from the hardware exception, tm_active_with_fp() is\nincorrectly making restore_fp() call load_fp_state() which is setting\nFP=1.\n\nThe fix is to remove tm_active_with_fp().\n\ntm_active_with_fp() is attempting to handle the case where FP state\nhas been changed inside a transaction. In this case the checkpointed\nand transactional FP state is different and hence we must restore the\nFP state (ie. we can't do lazy FP restore inside a transaction that's\nused FP). It's safe to remove tm_active_with_fp() as this case is\nhandled by restore_tm_state(). restore_tm_state() detects if FP has\nbeen using inside a transaction and will set load_fp and call\nrestore_math() to ensure the FP state (checkpoint and transaction) is\nrestored.\n\nThis is a data integrity problem for the current process as the FP\nregisters are corrupted. It's also a security problem as the FP\nregisters from one process may be leaked to another.\n\nSimilarly for VMX.\n\nA simple testcase to replicate this will be posted to\ntools/testing/selftests/powerpc/tm/tm-poison.c\n\nThis fixes CVE-2019-15031.\n\nFixes: a7771176b439 (\"powerpc: Don't enable FP/Altivec if not checkpointed\")\nCc: stable@vger.kernel.org # 4.15+\nSigned-off-by: Gustavo Romero <gromero@linux.ibm.com>\nSigned-off-by: Michael Neuling <mikey@neuling.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20190904045529.23002-2-gromero@linux.vnet.ibm.com", "idx": 373}
{"func": "static void save_bt_to_dump_dir(const char *bt, const char *exe, const char *reason)\n{\n    time_t t = time(NULL);\n    const char *iso_date = iso_date_string(&t);\n    /* dump should be readable by all if we're run with -x */\n    uid_t my_euid = (uid_t)-1L;\n    mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH;\n    /* and readable only for the owner otherwise */\n    if (!(g_opts & OPT_x))\n    {\n        mode = DEFAULT_DUMP_DIR_MODE;\n        my_euid = geteuid();\n    }\n\n    pid_t my_pid = getpid();\n\n    char base[sizeof(\"xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu\") + 2 * sizeof(long)*3];\n    sprintf(base, \"xorg-%s-%lu-%u\", iso_date, (long)my_pid, g_bt_count);\n    char *path = concat_path_file(debug_dumps_dir, base);\n\n    struct dump_dir *dd = dd_create(path, /*uid:*/ my_euid, mode);\n    if (dd)\n    {\n        dd_create_basic_files(dd, /*uid:*/ my_euid, NULL);\n        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);\n        dd_save_text(dd, FILENAME_ANALYZER, \"xorg\");\n        dd_save_text(dd, FILENAME_TYPE, \"xorg\");\n        dd_save_text(dd, FILENAME_REASON, reason);\n        dd_save_text(dd, FILENAME_BACKTRACE, bt);\n        /*\n         * Reporters usually need component name to file a bug.\n\t * It is usually derived from executable.\n         * We _guess_ X server's executable name as a last resort.\n         * Better ideas?\n         */\n        if (!exe)\n        {\n            exe = \"/usr/bin/X\";\n            if (access(\"/usr/bin/Xorg\", X_OK) == 0)\n                exe = \"/usr/bin/Xorg\";\n        }\n        dd_save_text(dd, FILENAME_EXECUTABLE, exe);\n        dd_close(dd);\n        notify_new_path(path);\n    }\n\n    free(path);\n}", "target": 1, "cwe": ["CWE-200"], "project": "abrt", "commit_id": "8939398b82006ba1fec4ed491339fc075f43fc7c", "hash": 195329513710506002236410920847639135677, "size": 48, "message": "make the dump directories owned by root by default\n\nIt was discovered that the abrt event scripts create a user-readable\ncopy of a sosreport file in abrt problem directories, and include\nexcerpts of /var/log/messages selected by the user-controlled process\nname, leading to an information disclosure.\n\nThis issue was discovered by Florian Weimer of Red Hat Product Security.\n\nRelated: #1212868\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>", "idx": 374}
{"func": "static void InsertRow(Image *image,ssize_t depth,unsigned char *p,ssize_t y,\n  ExceptionInfo *exception)\n{\n  size_t bit; ssize_t x;\n  register Quantum *q;\n  Quantum index;\n\n  index=0;\n  switch (depth)\n  {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);\n                SetPixelIndex(image,index,q);\n                q+=GetPixelChannels(image);\n              }\n            p++;\n          }\n        (void) SyncAuthenticPixels(image,exception);\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n        {\n          index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          p++;\n        }\n        if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            if ((image->columns % 4) >= 1)\n\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                SetPixelIndex(image,index,q);\n                q+=GetPixelChannels(image);\n                if ((image->columns % 4) >= 2)\n\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                      exception);\n                    SetPixelIndex(image,index,q);\n                    q+=GetPixelChannels(image);\n                  }\n              }\n            p++;\n          }\n        (void) SyncAuthenticPixels(image,exception);\n        break;\n      }\n\n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0xf,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            p++;\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            p++;\n          }\n        (void) SyncAuthenticPixels(image,exception);\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,*p,exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        (void) SyncAuthenticPixels(image,exception);\n        break;\n      }\n    }\n}", "target": 1, "cwe": ["CWE-787"], "project": "ImageMagick", "commit_id": "cc4ac341f29fa368da6ef01c207deaf8c61f6a2e", "hash": 110780341587724055258384123179961330132, "size": 127, "message": "https://github.com/ImageMagick/ImageMagick/issues/1162", "idx": 375}
{"func": "static int device_notifier(struct notifier_block *nb,\n\t\t\t\t  unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct dmar_domain *domain;\n\n\tif (iommu_dummy(dev))\n\t\treturn 0;\n\n\tif (action != BUS_NOTIFY_REMOVED_DEVICE)\n\t\treturn 0;\n\n\tdomain = find_domain(dev);\n\tif (!domain)\n\t\treturn 0;\n\n\tdmar_remove_one_dev_info(domain, dev);\n\tif (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))\n\t\tdomain_exit(domain);\n\n\treturn 0;\n}", "target": 0, "cwe": [], "project": "linux", "commit_id": "fb58fdcd295b914ece1d829b24df00a17a9624bc", "hash": 134447663594052256088435469848904884437, "size": 22, "message": "iommu/vt-d: Do not enable ATS for untrusted devices\n\nCurrently Linux automatically enables ATS (Address Translation Service)\nfor any device that supports it (and IOMMU is turned on). ATS is used to\naccelerate DMA access as the device can cache translations locally so\nthere is no need to do full translation on IOMMU side. However, as\npointed out in [1] ATS can be used to bypass IOMMU based security\ncompletely by simply sending PCIe read/write transaction with AT\n(Address Translation) field set to \"translated\".\n\nTo mitigate this modify the Intel IOMMU code so that it does not enable\nATS for any device that is marked as being untrusted. In case this turns\nout to cause performance issues we may selectively allow ATS based on\nuser decision but currently use big hammer and disable it completely to\nbe on the safe side.\n\n[1] https://www.repository.cam.ac.uk/handle/1810/274352\n\nSigned-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>\nReviewed-by: Ashok Raj <ashok.raj@intel.com>\nReviewed-by: Joerg Roedel <jroedel@suse.de>\nAcked-by: Joerg Roedel <jroedel@suse.de>", "idx": 376}
{"func": "composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* partial re-init of the response message; the function or the\n\t * gadget might need to intercept e.g. a control-OUT completion\n\t * when we delegate to it.\n\t */\n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t/*\n\t * Don't let non-standard requests match any of the cases below\n\t * by accident.\n\t */\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t/* we handle all standard USB descriptors */\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* any number of configs can work */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t/* function drivers must handle get/set altsetting */\n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If there's no get_alt() method, we know only altsetting zero\n\t\t * works. There is no need to check if set_alt() is not NULL\n\t\t * as we check this in usb_add_function().\n\t\t */\n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t/* lots of interfaces only need altsetting zero... */\n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * USB 3.0 additions:\n\t\t * Function driver should handle get_status request. If such cb\n\t\t * wasn't supplied we respond with default value = 0\n\t\t * Note: function driver should supply such cb only for the\n\t\t * first interface of the function\n\t\t */\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t/* This is the length of the get_status reply */\n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\tstatus = f->get_status ? f->get_status(f) : 0;\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t/*\n\t * Function drivers should handle SetFeature/ClearFeature\n\t * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied\n\t * only for the first interface of the function\n\t */\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend)\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t/*\n\t\t * OS descriptors handling\n\t\t */\n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t/* Number of ext compat interfaces */\n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24; /* 24 B/ext compat desc */\n\t\t\t\tcount += 16; /* header */\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t/* functions always handle their interfaces and endpoints...\n\t\t * punt other recipients (other, WUSB, ...) to the current\n\t\t * configuration code.\n\t\t */\n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, f->endpoints))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&f->list == &cdev->config->functions)\n\t\t\t\tf = NULL;\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t/* try current config's setup */\n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* try the only function in the current config */\n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t/* respond with data transfer before status phase? */\n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t/* device either stalls (value < 0) or reports success */\n\treturn value;\n}", "target": 1, "cwe": ["CWE-476"], "project": "linux", "commit_id": "75e5b4849b81e19e9efe1654b30d7f3151c33c2c", "hash": 25039695704253028034294570945012845427, "size": 422, "message": "USB: gadget: validate interface OS descriptor requests\n\nStall the control endpoint in case provided index exceeds array size of\nMAX_CONFIG_INTERFACES or when the retrieved function pointer is null.\n\nSigned-off-by: Szymon Heidrich <szymon.heidrich@gmail.com>\nCc: stable@kernel.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 377}
{"func": "static int samldb_pwd_last_set_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tNTTIME last_set = 0;\n\tstruct ldb_message_element *el = NULL;\n\tstruct ldb_message *tmp_msg = NULL;\n\tstruct dom_sid *self_sid = NULL;\n\tint ret;\n\tstruct ldb_result *res = NULL;\n\tconst char * const attrs[] = {\n\t\t\"objectSid\",\n\t\tNULL\n\t};\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"pwdLastSet\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL || el->num_values == 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: 'pwdLastSet' can't be deleted!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Create a temporary message for fetching the \"userAccountControl\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tlast_set = samdb_result_nttime(tmp_msg, \"pwdLastSet\", 0);\n\ttalloc_free(tmp_msg);\n\n\t/*\n\t * Setting -1 (0xFFFFFFFFFFFFFFFF) requires the Unexpire-Password right\n\t */\n\tif (last_set != UINT64_MAX) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* Fetch the \"objectSid\" */\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tself_sid = samdb_result_dom_sid(res, res->msgs[0], \"objectSid\");\n\tif (self_sid == NULL) {\n\t\treturn ldb_module_operr(ac->module);\n\t}\n\n\tret = samldb_check_pwd_last_set_acl(ac, self_sid);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn LDB_SUCCESS;\n}", "target": 0, "cwe": ["CWE-200"], "project": "samba", "commit_id": "0a3aa5f908e351201dc9c4d4807b09ed9eedff77", "hash": 136614897383329977915784553105808859756, "size": 67, "message": "CVE-2022-32746 ldb: Make use of functions for appending to an ldb_message\n\nThis aims to minimise usage of the error-prone pattern of searching for\na just-added message element in order to make modifications to it (and\npotentially finding the wrong element).\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=15009\n\nSigned-off-by: Joseph Sutton <josephsutton@catalyst.net.nz>", "idx": 378}
{"func": "/* }}} */\n\nstatic void pspell_config_path(INTERNAL_FUNCTION_PARAMETERS, char *option)\n{\n\tint type;\n\tlong conf;\n\tchar *value;\n\tint value_len;\n\tPspellConfig *config;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ls\", &conf, &value, &value_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPSPELL_FETCH_CONFIG;\n\n\tif (PG(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_check_open_basedir(value TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tpspell_config_replace(config, option, value);\n", "target": 1, "cwe": [], "project": "php-src", "commit_id": "ce96fd6b0761d98353761bf78d5bfb55291179fd", "hash": 332888793498072567083141776687770856380, "size": 26, "message": "- fix #39863, do not accept paths with NULL in them. See http://news.php.net/php.internals/50191, trunk will have the patch later (adding a macro and/or changing (some) APIs. Patch by Rasmus", "idx": 379}
{"func": "static int php_zip_parse_options(zval *options, long *remove_all_path, \n\tchar **remove_path, int *remove_path_len, char **add_path, int *add_path_len TSRMLS_DC) /* {{{ */\n{\n\tzval **option;\n\tif (zend_hash_find(HASH_OF(options), \"remove_all_path\", sizeof(\"remove_all_path\"), (void **)&option) == SUCCESS) {\n\t\tlong opt;\n\t\tif (Z_TYPE_PP(option) != IS_LONG) {\n\t\t\tzval tmp = **option;\n\t\t\tzval_copy_ctor(&tmp);\n\t\t\tconvert_to_long(&tmp);\n\t\t\topt = Z_LVAL(tmp);\n\t\t} else {\n\t\t\topt = Z_LVAL_PP(option);\n\t\t}\n\t\t*remove_all_path = opt;\n\t}\n\n\t/* If I add more options, it would make sense to create a nice static struct and loop over it. */\n\tif (zend_hash_find(HASH_OF(options), \"remove_path\", sizeof(\"remove_path\"), (void **)&option) == SUCCESS) {\n\t\tif (Z_TYPE_PP(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Empty string given as remove_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path string is too long (max: %i, %i given)\", \n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_PP(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*remove_path_len = Z_STRLEN_PP(option); \n\t\t*remove_path = Z_STRVAL_PP(option);\n\t}\n\n\tif (zend_hash_find(HASH_OF(options), \"add_path\", sizeof(\"add_path\"), (void **)&option) == SUCCESS) {\n\t\tif (Z_TYPE_PP(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Empty string given as the add_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\", \n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_PP(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*add_path_len = Z_STRLEN_PP(option); \n\t\t*add_path = Z_STRVAL_PP(option);\n\t}\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-22"], "project": "php-src", "commit_id": "f9c2bf73adb2ede0a486b0db466c264f2b27e0bb", "hash": 89373143535694316131527144084817307056, "size": 59, "message": "Fixed bug #70350: ZipArchive::extractTo allows for directory traversal when creating directories", "idx": 380}
{"func": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 1, "cwe": ["CWE-476"], "project": "radare2", "commit_id": "48f0ea79f99174fb0a62cb2354e13496ce5b7c44", "hash": 238157226993888060412008928414827920796, "size": 25, "message": "Fix null deref in ne parser ##crash\n\n* Reported by @cnitlrt via huntr.dev\n* BountyID: d8b6d239-6d7b-4783-b26b-5be848c01aa1/\n* Reproducer: nenull", "idx": 381}
{"func": "static inline int get_compat_mq_attr(struct mq_attr *attr,\n\t\t\tconst struct compat_mq_attr __user *uattr)\n{\n\tstruct compat_mq_attr v;\n\n\tif (copy_from_user(&v, uattr, sizeof(*uattr)))\n\t\treturn -EFAULT;\n\n\tmemset(attr, 0, sizeof(*attr));\n\tattr->mq_flags = v.mq_flags;\n\tattr->mq_maxmsg = v.mq_maxmsg;\n\tattr->mq_msgsize = v.mq_msgsize;\n\tattr->mq_curmsgs = v.mq_curmsgs;\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-416"], "project": "linux", "commit_id": "f991af3daabaecff34684fd51fac80319d1baad1", "hash": 124905856284931523753711696886901398263, "size": 15, "message": "mqueue: fix a use-after-free in sys_mq_notify()\n\nThe retry logic for netlink_attachskb() inside sys_mq_notify()\nis nasty and vulnerable:\n\n1) The sock refcnt is already released when retry is needed\n2) The fd is controllable by user-space because we already\n   release the file refcnt\n\nso we when retry but the fd has been just closed by user-space\nduring this small window, we end up calling netlink_detachskb()\non the error path which releases the sock again, later when\nthe user-space closes this socket a use-after-free could be\ntriggered.\n\nSetting 'sock' to NULL here should be sufficient to fix it.\n\nReported-by: GeneBlue <geneblue.mail@gmail.com>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Manfred Spraul <manfred@colorfullife.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 382}
{"func": "glue(glue(cirrus_bitblt_rop_bkwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,\n\t\t\t\t\t\t\t uint8_t *dst,const uint8_t *src,\n\t\t\t\t\t\t\t int dstpitch,int srcpitch,\n\t\t\t\t\t\t\t int bltwidth,int bltheight)\n{\n    int x,y;\n    uint8_t p1, p2;\n    dstpitch += bltwidth;\n    srcpitch += bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x+=2) {\n\t    p1 = *(dst-1);\n\t    p2 = *dst;\n            ROP_OP(&p1, *(src - 1));\n            ROP_OP(&p2, *src);\n\t    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {\n\t\t*(dst-1) = p1;\n\t\t*dst = p2;\n\t    }\n            dst-=2;\n            src-=2;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}", "target": 1, "cwe": ["CWE-119"], "project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "hash": 206391556163726091334558233583917246673, "size": 26, "message": "cirrus: stop passing around dst pointers in the blitter\n\nInstead pass around the address (aka offset into vga memory).  Calculate\nthe pointer in the rop_* functions, after applying the mask to the\naddress, to make sure the address stays within the valid range.\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nMessage-id: 1489574872-8679-1-git-send-email-kraxel@redhat.com", "idx": 383}
{"func": "int lgff_init(struct hid_device* hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff_joystick;\n\tint error;\n\tint i;\n\n\t/* Check that the report looks ok */\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(devices); i++) {\n\t\tif (dev->id.vendor == devices[i].idVendor &&\n\t\t    dev->id.product == devices[i].idProduct) {\n\t\t\tff_bits = devices[i].ff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\n\terror = input_ff_create_memless(dev, NULL, hid_lgff_play);\n\tif (error)\n\t\treturn error;\n\n\tif ( test_bit(FF_AUTOCENTER, dev->ffbit) )\n\t\tdev->ff->set_autocenter = hid_lgff_set_autocenter;\n\n\tpr_info(\"Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\\n\");\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "d9d4b1e46d9543a82c23f6df03f4ad697dab361b", "hash": 154267941060945361477931256076970684717, "size": 34, "message": "HID: Fix assumption that devices have inputs\n\nThe syzbot fuzzer found a slab-out-of-bounds write bug in the hid-gaff\ndriver.  The problem is caused by the driver's assumption that the\ndevice must have an input report.  While this will be true for all\nnormal HID input devices, a suitably malicious device can violate the\nassumption.\n\nThe same assumption is present in over a dozen other HID drivers.\nThis patch fixes them by checking that the list of hid_inputs for the\nhid_device is nonempty before allowing it to be used.\n\nReported-and-tested-by: syzbot+403741a091bf41d4ae79@syzkaller.appspotmail.com\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nCC: <stable@vger.kernel.org>\nSigned-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>", "idx": 384}
{"func": "void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {\n\tif ( oldV == newV ) {\n\t\tMSG_WriteBits( msg, 0, 1 );\n\t\treturn;\n\t}\n\tMSG_WriteBits( msg, 1, 1 );\n\tMSG_WriteBits( msg, newV ^ key, bits );\n}", "target": 0, "cwe": ["CWE-119"], "project": "ioq3", "commit_id": "d2b1d124d4055c2fcbe5126863487c52fd58cca1", "hash": 199099187737725097191321564119195086747, "size": 8, "message": "Fix/improve buffer overflow in MSG_ReadBits/MSG_WriteBits\n\nPrevent reading past end of message in MSG_ReadBits. If read past\nend of msg->data buffer (16348 bytes) the engine could SEGFAULT.\nMake MSG_WriteBits use an exact buffer overflow check instead of\npossibly failing with a few bytes left.", "idx": 385}
{"func": "xmlCtxtResetPush(xmlParserCtxtPtr ctxt, const char *chunk,\n                 int size, const char *filename, const char *encoding)\n{\n    xmlParserInputPtr inputStream;\n    xmlParserInputBufferPtr buf;\n    xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;\n\n    if (ctxt == NULL)\n        return(1);\n\n    if ((encoding == NULL) && (chunk != NULL) && (size >= 4))\n        enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);\n\n    buf = xmlAllocParserInputBuffer(enc);\n    if (buf == NULL)\n        return(1);\n\n    if (ctxt == NULL) {\n        xmlFreeParserInputBuffer(buf);\n        return(1);\n    }\n\n    xmlCtxtReset(ctxt);\n\n    if (filename == NULL) {\n        ctxt->directory = NULL;\n    } else {\n        ctxt->directory = xmlParserGetDirectory(filename);\n    }\n\n    inputStream = xmlNewInputStream(ctxt);\n    if (inputStream == NULL) {\n        xmlFreeParserInputBuffer(buf);\n        return(1);\n    }\n\n    if (filename == NULL)\n        inputStream->filename = NULL;\n    else\n        inputStream->filename = (char *)\n            xmlCanonicPath((const xmlChar *) filename);\n    inputStream->buf = buf;\n    xmlBufResetInput(buf->buffer, inputStream);\n\n    inputPush(ctxt, inputStream);\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n        size_t cur = ctxt->input->cur - ctxt->input->base;\n\n        xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n\n        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n#ifdef DEBUG_PUSH\n        xmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n#endif\n    }\n\n    if (encoding != NULL) {\n        xmlCharEncodingHandlerPtr hdlr;\n\n        if (ctxt->encoding != NULL)\n\t    xmlFree((xmlChar *) ctxt->encoding);\n        ctxt->encoding = xmlStrdup((const xmlChar *) encoding);\n\n        hdlr = xmlFindCharEncodingHandler(encoding);\n        if (hdlr != NULL) {\n            xmlSwitchToEncoding(ctxt, hdlr);\n\t} else {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n\t\t\t      \"Unsupported encoding %s\\n\", BAD_CAST encoding);\n        }\n    } else if (enc != XML_CHAR_ENCODING_NONE) {\n        xmlSwitchEncoding(ctxt, enc);\n    }\n\n    return(0);\n}", "target": 0, "cwe": [], "project": "libxml2", "commit_id": "0e1a49c8907645d2e155f0d89d4d9895ac5112b5", "hash": 2823851030484647396156596565388315753, "size": 79, "message": "Fix infinite loop in xmlStringLenDecodeEntities\n\nWhen ctxt->instate == XML_PARSER_EOF,xmlParseStringEntityRef\nreturn NULL which cause a infinite loop in xmlStringLenDecodeEntities\n\nFound with libFuzzer.\n\nSigned-off-by: Zhipeng Xie <xiezhipeng1@huawei.com>", "idx": 386}
{"func": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n\n        if (rom->romsize > rom->datasize) {\n            /* If datasize is less than romsize, it means that we didn't\n             * allocate all the ROM because the trailing data are only zeros.\n             */\n\n            d += l;\n            l = rom->romsize - rom->datasize;\n\n            if ((d + l) > (dest + size)) {\n                /* Rom size doesn't fit in the destination area. Adjust to avoid\n                 * overflow.\n                 */\n                l = dest - d;\n            }\n\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n\n    return (d + l) - dest;\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "e423455c4f23a1a828901c78fe6d03b7dde79319", "hash": 3950169506491128570527434608997367423, "size": 56, "message": "hw/core/loader: Fix possible crash in rom_copy()\n\nBoth, \"rom->addr\" and \"addr\" are derived from the binary image\nthat can be loaded with the \"-kernel\" paramer. The code in\nrom_copy() then calculates:\n\n    d = dest + (rom->addr - addr);\n\nand uses \"d\" as destination in a memcpy() some lines later. Now with\nbad kernel images, it is possible that rom->addr is smaller than addr,\nthus \"rom->addr - addr\" gets negative and the memcpy() then tries to\ncopy contents from the image to a bad memory location. This could\nmaybe be used to inject code from a kernel image into the QEMU binary,\nso we better fix it with an additional sanity check here.\n\nCc: qemu-stable@nongnu.org\nReported-by: Guangming Liu\nBuglink: https://bugs.launchpad.net/qemu/+bug/1844635\nMessage-Id: <20190925130331.27825-1-thuth@redhat.com>\nReviewed-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Thomas Huth <thuth@redhat.com>", "idx": 387}
{"func": "xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,\n\t    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {\n    if ((inst->children != NULL) && (comp != NULL)) {\n\txmlNodePtr text = inst->children;\n\txmlNodePtr copy;\n\n\twhile (text != NULL) {\n\t    if ((text->type != XML_TEXT_NODE) &&\n\t         (text->type != XML_CDATA_SECTION_NODE)) {\n\t\txsltTransformError(ctxt, NULL, inst,\n\t\t\t\t \"xsl:text content problem\\n\");\n\t\tbreak;\n\t    }\n\t    copy = xmlNewDocText(ctxt->output, text->content);\n\t    if (text->type != XML_CDATA_SECTION_NODE) {\n#ifdef WITH_XSLT_DEBUG_PARSING\n\t\txsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"Disable escaping: %s\\n\", text->content);\n#endif\n\t\tcopy->name = xmlStringTextNoenc;\n\t    }\n\t    copy = xsltAddChild(ctxt->insert, copy);\n\t    text = text->next;\n\t}\n    }\n}", "target": 0, "cwe": [], "project": "libxslt", "commit_id": "937ba2a3eb42d288f53c8adc211bd1122869f0bf", "hash": 54079235543757844044119471417986985280, "size": 26, "message": "Fix default template processing on namespace nodes", "idx": 388}
{"func": "void AuthorizationSession::_refreshUserInfoAsNeeded(OperationContext* opCtx) {\n    AuthorizationManager& authMan = getAuthorizationManager();\n    UserSet::iterator it = _authenticatedUsers.begin();\n    while (it != _authenticatedUsers.end()) {\n        User* user = *it;\n\n        if (!user->isValid()) {\n            // Make a good faith effort to acquire an up-to-date user object, since the one\n            // we've cached is marked \"out-of-date.\"\n            UserName name = user->getName();\n            User* updatedUser;\n\n            Status status = authMan.acquireUser(opCtx, name, &updatedUser);\n            stdx::lock_guard<Client> lk(*opCtx->getClient());\n            switch (status.code()) {\n                case ErrorCodes::OK: {\n\n                    // Verify the updated user object's authentication restrictions.\n                    UserHolder userHolder(user, UserReleaser(&authMan, &_authenticatedUsers, it));\n                    UserHolder updatedUserHolder(updatedUser, UserReleaser(&authMan));\n                    try {\n                        const auto& restrictionSet =\n                            updatedUserHolder->getRestrictions();  // Owned by updatedUser\n                        invariant(opCtx->getClient());\n                        Status restrictionStatus = restrictionSet.validate(\n                            RestrictionEnvironment::get(*opCtx->getClient()));\n                        if (!restrictionStatus.isOK()) {\n                            log() << \"Removed user \" << name\n                                  << \" with unmet authentication restrictions from session cache of\"\n                                  << \" user information. Restriction failed because: \"\n                                  << restrictionStatus.reason();\n                            // If we remove from the UserSet, we cannot increment the iterator.\n                            continue;\n                        }\n                    } catch (...) {\n                        log() << \"Evaluating authentication restrictions for \" << name\n                              << \" resulted in an unknown exception. Removing user from the\"\n                              << \" session cache.\";\n                        continue;\n                    }\n\n                    // Success! Replace the old User object with the updated one.\n                    fassert(17067,\n                            _authenticatedUsers.replaceAt(it, updatedUserHolder.release()) ==\n                                userHolder.get());\n                    LOG(1) << \"Updated session cache of user information for \" << name;\n                    break;\n                }\n                case ErrorCodes::UserNotFound: {\n                    // User does not exist anymore; remove it from _authenticatedUsers.\n                    fassert(17068, _authenticatedUsers.removeAt(it) == user);\n                    authMan.releaseUser(user);\n                    log() << \"Removed deleted user \" << name\n                          << \" from session cache of user information.\";\n                    continue;  // No need to advance \"it\" in this case.\n                }\n                case ErrorCodes::UnsupportedFormat: {\n                    // An auth subsystem has explicitly indicated a failure.\n                    fassert(40555, _authenticatedUsers.removeAt(it) == user);\n                    authMan.releaseUser(user);\n                    log() << \"Removed user \" << name\n                          << \" from session cache of user information because of refresh failure:\"\n                          << \" '\" << status << \"'.\";\n                    continue;  // No need to advance \"it\" in this case.\n                }\n                default:\n                    // Unrecognized error; assume that it's transient, and continue working with the\n                    // out-of-date privilege data.\n                    warning() << \"Could not fetch updated user privilege information for \" << name\n                              << \"; continuing to use old information.  Reason is \"\n                              << redact(status);\n                    break;\n            }\n        }\n        ++it;\n    }\n    _buildAuthenticatedRolesVector();\n}", "target": 1, "cwe": ["CWE-613"], "project": "mongo", "commit_id": "db19e7ce84cfd702a4ba9983ee2ea5019f470f82", "hash": 156738888514310218868784802283965587030, "size": 78, "message": "SERVER-38984 Validate unique User ID on UserCache hit\n\n(cherry picked from commit e55d6e2292e5dbe2f97153251d8193d1cc89f5d7)", "idx": 389}
{"func": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "target": 1, "cwe": ["CWE-416", "CWE-362", "CWE-401"], "project": "linux", "commit_id": "9709674e68646cee5a24e3000b3558d25412203a", "hash": 26413094966573284873828451515700326119, "size": 23, "message": "ipv4: fix a race in ip4_datagram_release_cb()\n\nAlexey gave a AddressSanitizer[1] report that finally gave a good hint\nat where was the origin of various problems already reported by Dormando\nin the past [2]\n\nProblem comes from the fact that UDP can have a lockless TX path, and\nconcurrent threads can manipulate sk_dst_cache, while another thread,\nis holding socket lock and calls __sk_dst_set() in\nip4_datagram_release_cb() (this was added in linux-3.8)\n\nIt seems that all we need to do is to use sk_dst_check() and\nsk_dst_set() so that all the writers hold same spinlock\n(sk->sk_dst_lock) to prevent corruptions.\n\nTCP stack do not need this protection, as all sk_dst_cache writers hold\nthe socket lock.\n\n[1]\nhttps://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernel\n\nAddressSanitizer: heap-use-after-free in ipv4_dst_check\nRead of size 2 by thread T15453:\n [<ffffffff817daa3a>] ipv4_dst_check+0x1a/0x90 ./net/ipv4/route.c:1116\n [<ffffffff8175b789>] __sk_dst_check+0x89/0xe0 ./net/core/sock.c:531\n [<ffffffff81830a36>] ip4_datagram_release_cb+0x46/0x390 ??:0\n [<ffffffff8175eaea>] release_sock+0x17a/0x230 ./net/core/sock.c:2413\n [<ffffffff81830882>] ip4_datagram_connect+0x462/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\nFreed by thread T15455:\n [<ffffffff8178d9b8>] dst_destroy+0xa8/0x160 ./net/core/dst.c:251\n [<ffffffff8178de25>] dst_release+0x45/0x80 ./net/core/dst.c:280\n [<ffffffff818304c1>] ip4_datagram_connect+0xa1/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\nAllocated by thread T15453:\n [<ffffffff8178d291>] dst_alloc+0x81/0x2b0 ./net/core/dst.c:171\n [<ffffffff817db3b7>] rt_dst_alloc+0x47/0x50 ./net/ipv4/route.c:1406\n [<     inlined    >] __ip_route_output_key+0x3e8/0xf70\n__mkroute_output ./net/ipv4/route.c:1939\n [<ffffffff817dde08>] __ip_route_output_key+0x3e8/0xf70 ./net/ipv4/route.c:2161\n [<ffffffff817deb34>] ip_route_output_flow+0x14/0x30 ./net/ipv4/route.c:2249\n [<ffffffff81830737>] ip4_datagram_connect+0x317/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\n[2]\n<4>[196727.311203] general protection fault: 0000 [#1] SMP\n<4>[196727.311224] Modules linked in: xt_TEE xt_dscp xt_DSCP macvlan bridge coretemp crc32_pclmul ghash_clmulni_intel gpio_ich microcode ipmi_watchdog ipmi_devintf sb_edac edac_core lpc_ich mfd_core tpm_tis tpm tpm_bios ipmi_si ipmi_msghandler isci igb libsas i2c_algo_bit ixgbe ptp pps_core mdio\n<4>[196727.311333] CPU: 17 PID: 0 Comm: swapper/17 Not tainted 3.10.26 #1\n<4>[196727.311344] Hardware name: Supermicro X9DRi-LN4+/X9DR3-LN4+/X9DRi-LN4+/X9DR3-LN4+, BIOS 3.0 07/05/2013\n<4>[196727.311364] task: ffff885e6f069700 ti: ffff885e6f072000 task.ti: ffff885e6f072000\n<4>[196727.311377] RIP: 0010:[<ffffffff815f8c7f>]  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80\n<4>[196727.311399] RSP: 0018:ffff885effd23a70  EFLAGS: 00010282\n<4>[196727.311409] RAX: dead000000200200 RBX: ffff8854c398ecc0 RCX: 0000000000000040\n<4>[196727.311423] RDX: dead000000100100 RSI: dead000000100100 RDI: dead000000200200\n<4>[196727.311437] RBP: ffff885effd23a80 R08: ffffffff815fd9e0 R09: ffff885d5a590800\n<4>[196727.311451] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\n<4>[196727.311464] R13: ffffffff81c8c280 R14: 0000000000000000 R15: ffff880e85ee16ce\n<4>[196727.311510] FS:  0000000000000000(0000) GS:ffff885effd20000(0000) knlGS:0000000000000000\n<4>[196727.311554] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n<4>[196727.311581] CR2: 00007a46751eb000 CR3: 0000005e65688000 CR4: 00000000000407e0\n<4>[196727.311625] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n<4>[196727.311669] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n<4>[196727.311713] Stack:\n<4>[196727.311733]  ffff8854c398ecc0 ffff8854c398ecc0 ffff885effd23ab0 ffffffff815b7f42\n<4>[196727.311784]  ffff88be6595bc00 ffff8854c398ecc0 0000000000000000 ffff8854c398ecc0\n<4>[196727.311834]  ffff885effd23ad0 ffffffff815b86c6 ffff885d5a590800 ffff8816827821c0\n<4>[196727.311885] Call Trace:\n<4>[196727.311907]  <IRQ>\n<4>[196727.311912]  [<ffffffff815b7f42>] dst_destroy+0x32/0xe0\n<4>[196727.311959]  [<ffffffff815b86c6>] dst_release+0x56/0x80\n<4>[196727.311986]  [<ffffffff81620bd5>] tcp_v4_do_rcv+0x2a5/0x4a0\n<4>[196727.312013]  [<ffffffff81622b5a>] tcp_v4_rcv+0x7da/0x820\n<4>[196727.312041]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360\n<4>[196727.312070]  [<ffffffff815de02d>] ? nf_hook_slow+0x7d/0x150\n<4>[196727.312097]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360\n<4>[196727.312125]  [<ffffffff815fda92>] ip_local_deliver_finish+0xb2/0x230\n<4>[196727.312154]  [<ffffffff815fdd9a>] ip_local_deliver+0x4a/0x90\n<4>[196727.312183]  [<ffffffff815fd799>] ip_rcv_finish+0x119/0x360\n<4>[196727.312212]  [<ffffffff815fe00b>] ip_rcv+0x22b/0x340\n<4>[196727.312242]  [<ffffffffa0339680>] ? macvlan_broadcast+0x160/0x160 [macvlan]\n<4>[196727.312275]  [<ffffffff815b0c62>] __netif_receive_skb_core+0x512/0x640\n<4>[196727.312308]  [<ffffffff811427fb>] ? kmem_cache_alloc+0x13b/0x150\n<4>[196727.312338]  [<ffffffff815b0db1>] __netif_receive_skb+0x21/0x70\n<4>[196727.312368]  [<ffffffff815b0fa1>] netif_receive_skb+0x31/0xa0\n<4>[196727.312397]  [<ffffffff815b1ae8>] napi_gro_receive+0xe8/0x140\n<4>[196727.312433]  [<ffffffffa00274f1>] ixgbe_poll+0x551/0x11f0 [ixgbe]\n<4>[196727.312463]  [<ffffffff815fe00b>] ? ip_rcv+0x22b/0x340\n<4>[196727.312491]  [<ffffffff815b1691>] net_rx_action+0x111/0x210\n<4>[196727.312521]  [<ffffffff815b0db1>] ? __netif_receive_skb+0x21/0x70\n<4>[196727.312552]  [<ffffffff810519d0>] __do_softirq+0xd0/0x270\n<4>[196727.312583]  [<ffffffff816cef3c>] call_softirq+0x1c/0x30\n<4>[196727.312613]  [<ffffffff81004205>] do_softirq+0x55/0x90\n<4>[196727.312640]  [<ffffffff81051c85>] irq_exit+0x55/0x60\n<4>[196727.312668]  [<ffffffff816cf5c3>] do_IRQ+0x63/0xe0\n<4>[196727.312696]  [<ffffffff816c5aaa>] common_interrupt+0x6a/0x6a\n<4>[196727.312722]  <EOI>\n<1>[196727.313071] RIP  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80\n<4>[196727.313100]  RSP <ffff885effd23a70>\n<4>[196727.313377] ---[ end trace 64b3f14fae0f2e29 ]---\n<0>[196727.380908] Kernel panic - not syncing: Fatal exception in interrupt\n\nReported-by: Alexey Preobrazhensky <preobr@google.com>\nReported-by: dormando <dormando@rydia.ne>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nFixes: 8141ed9fcedb2 (\"ipv4: Add a socket release callback for datagram sockets\")\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 390}
{"func": "struct ftrace_rec_iter *ftrace_rec_iter_start(void)\n{\n\t/*\n\t * We only use a single iterator.\n\t * Protected by the ftrace_lock mutex.\n\t */\n\tstatic struct ftrace_rec_iter ftrace_rec_iter;\n\tstruct ftrace_rec_iter *iter = &ftrace_rec_iter;\n\n\titer->pg = ftrace_pages_start;\n\titer->index = 0;\n\n\t/* Could have empty pages */\n\twhile (iter->pg && !iter->pg->index)\n\t\titer->pg = iter->pg->next;\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}", "target": 0, "cwe": ["CWE-703"], "project": "linux", "commit_id": "6a76f8c0ab19f215af2a3442870eeb5f0e81998d", "hash": 229574354642085733683813760122875636163, "size": 21, "message": "tracing: Fix possible NULL pointer dereferences\n\nCurrently set_ftrace_pid and set_graph_function files use seq_lseek\nfor their fops.  However seq_open() is called only for FMODE_READ in\nthe fops->open() so that if an user tries to seek one of those file\nwhen she open it for writing, it sees NULL seq_file and then panic.\n\nIt can be easily reproduced with following command:\n\n  $ cd /sys/kernel/debug/tracing\n  $ echo 1234 | sudo tee -a set_ftrace_pid\n\nIn this example, GNU coreutils' tee opens the file with fopen(, \"a\")\nand then the fopen() internally calls lseek().\n\nLink: http://lkml.kernel.org/r/1365663302-2170-1-git-send-email-namhyung@kernel.org\n\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Ingo Molnar <mingo@kernel.org>\nCc: Namhyung Kim <namhyung.kim@lge.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Namhyung Kim <namhyung@kernel.org>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>", "idx": 391}
{"func": "  virtual const string name() { return \"put_obj_tags\"; }", "target": 0, "cwe": ["CWE-770"], "project": "ceph", "commit_id": "ab29bed2fc9f961fe895de1086a8208e21ddaddc", "hash": 270202134270276594833588695458144935266, "size": 1, "message": "rgw: fix issues with 'enforce bounds' patch\n\nThe patch to enforce bounds on max-keys/max-uploads/max-parts had a few\nissues that would prevent us from compiling it. Instead of changing the\ncode provided by the submitter, we're addressing them in a separate\ncommit to maintain the DCO.\n\nSigned-off-by: Joao Eduardo Luis <joao@suse.de>\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>\n(cherry picked from commit 29bc434a6a81a2e5c5b8cfc4c8d5c82ca5bf538a)\nmimic specific fixes:\nAs the largeish change from master g_conf() isn't in mimic yet, use the g_conf\nglobal structure, also make rgw_op use the value from req_info ceph context as\nwe do for all the requests", "idx": 392}
{"func": "int netif_receive_skb(struct sk_buff *skb)\n{\n\tif (netdev_tstamp_prequeue)\n\t\tnet_timestamp_check(skb);\n\n\tif (skb_defer_rx_timestamp(skb))\n\t\treturn NET_RX_SUCCESS;\n\n#ifdef CONFIG_RPS\n\t{\n\t\tstruct rps_dev_flow voidflow, *rflow = &voidflow;\n\t\tint cpu, ret;\n\n\t\trcu_read_lock();\n\n\t\tcpu = get_rps_cpu(skb->dev, skb, &rflow);\n\n\t\tif (cpu >= 0) {\n\t\t\tret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\trcu_read_unlock();\n\t\t\tret = __netif_receive_skb(skb);\n\t\t}\n\n\t\treturn ret;\n\t}\n#else\n\treturn __netif_receive_skb(skb);\n#endif\n}", "target": 0, "cwe": ["CWE-264"], "project": "linux", "commit_id": "8909c9ad8ff03611c9c96c9a92656213e4bb495b", "hash": 199538385787406350229725239797005810521, "size": 31, "message": "net: don't allow CAP_NET_ADMIN to load non-netdev kernel modules\n\nSince a8f80e8ff94ecba629542d9b4b5f5a8ee3eb565c any process with\nCAP_NET_ADMIN may load any module from /lib/modules/.  This doesn't mean\nthat CAP_NET_ADMIN is a superset of CAP_SYS_MODULE as modules are\nlimited to /lib/modules/**.  However, CAP_NET_ADMIN capability shouldn't\nallow anybody load any module not related to networking.\n\nThis patch restricts an ability of autoloading modules to netdev modules\nwith explicit aliases.  This fixes CVE-2011-1019.\n\nArnd Bergmann suggested to leave untouched the old pre-v2.6.32 behavior\nof loading netdev modules by name (without any prefix) for processes\nwith CAP_SYS_MODULE to maintain the compatibility with network scripts\nthat use autoloading netdev modules by aliases like \"eth0\", \"wlan0\".\n\nCurrently there are only three users of the feature in the upstream\nkernel: ipip, ip_gre and sit.\n\n    root@albatros:~# capsh --drop=$(seq -s, 0 11),$(seq -s, 13 34) --\n    root@albatros:~# grep Cap /proc/$$/status\n    CapInh:\t0000000000000000\n    CapPrm:\tfffffff800001000\n    CapEff:\tfffffff800001000\n    CapBnd:\tfffffff800001000\n    root@albatros:~# modprobe xfs\n    FATAL: Error inserting xfs\n    (/lib/modules/2.6.38-rc6-00001-g2bf4ca3/kernel/fs/xfs/xfs.ko): Operation not permitted\n    root@albatros:~# lsmod | grep xfs\n    root@albatros:~# ifconfig xfs\n    xfs: error fetching interface information: Device not found\n    root@albatros:~# lsmod | grep xfs\n    root@albatros:~# lsmod | grep sit\n    root@albatros:~# ifconfig sit\n    sit: error fetching interface information: Device not found\n    root@albatros:~# lsmod | grep sit\n    root@albatros:~# ifconfig sit0\n    sit0      Link encap:IPv6-in-IPv4\n\t      NOARP  MTU:1480  Metric:1\n\n    root@albatros:~# lsmod | grep sit\n    sit                    10457  0\n    tunnel4                 2957  1 sit\n\nFor CAP_SYS_MODULE module loading is still relaxed:\n\n    root@albatros:~# grep Cap /proc/$$/status\n    CapInh:\t0000000000000000\n    CapPrm:\tffffffffffffffff\n    CapEff:\tffffffffffffffff\n    CapBnd:\tffffffffffffffff\n    root@albatros:~# ifconfig xfs\n    xfs: error fetching interface information: Device not found\n    root@albatros:~# lsmod | grep xfs\n    xfs                   745319  0\n\nReference: https://lkml.org/lkml/2011/2/24/203\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Michael Tokarev <mjt@tls.msk.ru>\nAcked-by: David S. Miller <davem@davemloft.net>\nAcked-by: Kees Cook <kees.cook@canonical.com>\nSigned-off-by: James Morris <jmorris@namei.org>", "idx": 393}
{"func": "struct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {\n\tstruct reloc_t *relocs;\n\tint i = 0, len;\n\tulebr ur = {NULL};\n\tint wordsize = MACH0_(get_bits)(bin) / 8;\n\tif (bin->dyld_info) {\n\t\tut8 *opcodes,*end, type = 0, rel_type = 0;\n\t\tint lib_ord, seg_idx = -1, sym_ord = -1;\n\t\tsize_t j, count, skip, bind_size, lazy_size;\n\t\tst64 addend = 0;\n\t\tut64 segmentAddress = 0LL;\n\t\tut64 addr = 0LL;\n\t\tut8 done = 0;\n\n#define CASE(T) case (T / 8): rel_type = R_BIN_RELOC_ ## T; break\n\t\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return NULL;\n\t\t}\n#undef CASE\n\t\tbind_size = bin->dyld_info->bind_size;\n\t\tlazy_size = bin->dyld_info->lazy_bind_size;\n\n\t\tif (!bind_size || !lazy_size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((bind_size + lazy_size)<1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)\n\t\t\treturn NULL;\n\t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size)\n\t\t\treturn NULL;\n\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)\n\t\t\treturn NULL;\n\t\t// NOTE(eddyb) it's a waste of memory, but we don't know the actual number of relocs.\n\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))\n\t\t\treturn NULL;\n\n\t\topcodes = calloc (1, bind_size + lazy_size + 1);\n\t\tif (!opcodes) {\n\t\t\tfree (relocs);\n\t\t\treturn NULL;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);\n\t\ti = r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);\n\t\tif (len < 1 || i < 1) {\n\t\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\",\n\t\t\t(ut64)(size_t)bin->dyld_info->bind_off);\n\t\t\tfree (opcodes);\n\t\t\trelocs[i].last = 1;\n\t\t\treturn relocs;\n\t\t}\n\t\ti = 0;\n\t\t// that +2 is a minimum required for uleb128, this may be wrong,\n\t\t// the correct fix would be to make ULEB() must use rutil's\n\t\t// implementation that already checks for buffer boundaries\n\t\tfor (ur.p = opcodes, end = opcodes + bind_size + lazy_size ; (ur.p+2 < end) && !done; ) {\n\t\t\tut8 imm = *ur.p & BIND_IMMEDIATE_MASK, op = *ur.p & BIND_OPCODE_MASK;\n\t\t\t++ur.p;\n\t\t\tswitch (op) {\n#define ULEB() read_uleb128 (&ur,end)\n#define SLEB() read_sleb128 (&ur,end)\n\t\t\tcase BIND_OPCODE_DONE:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\t\t\tlib_ord = imm;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\t\tlib_ord = ULEB();\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\t\t\tlib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {\n\t\t\t\tchar *sym_name = (char*)ur.p;\n\t\t\t\t//ut8 sym_flags = imm;\n\t\t\t\twhile (*ur.p++ && ur.p<end) {\n\t\t\t\t\t/* empty loop */\n\t\t\t\t}\n\t\t\t\tsym_ord = -1;\n\t\t\t\tif (bin->symtab && bin->dysymtab.nundefsym < 0xffff)\n\t\t\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\t\t\tint stridx = 0;\n\t\t\t\t\tint iundefsym = bin->dysymtab.iundefsym;\n\t\t\t\t\tif (iundefsym>=0 && iundefsym < bin->nsymtab) {\n\t\t\t\t\t\tint sidx = iundefsym +j;\n\t\t\t\t\t\tif (sidx<0 || sidx>= bin->nsymtab)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tstridx = bin->symtab[sidx].n_strx;\n\t\t\t\t\t\tif (stridx < 0 || stridx >= bin->symstrlen)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp ((char *)bin->symstr + stridx, sym_name)) {\n\t\t\t\t\t\tsym_ord = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\t\ttype = imm;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\t\taddend = SLEB();\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\tseg_idx = imm;\n\t\t\t\tif (seg_idx < 0 || seg_idx >= bin->nsegs) {\n\t\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\t\taddr = 0LL;\n\t\t\t\t\treturn 0; // early exit to avoid future mayhem\n\t\t\t\t} else {\n\t\t\t\t\taddr = bin->segs[seg_idx].vmaddr + ULEB();\n\t\t\t\t\tsegmentAddress = bin->segs[seg_idx].vmaddr \\\n\t\t\t\t\t\t\t+ bin->segs[seg_idx].vmsize;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\taddr += ULEB();\n\t\t\t\tbreak;\n#define DO_BIND() do {\\\nif (sym_ord < 0 || seg_idx < 0 ) break;\\\nif (i >= (bind_size + lazy_size)) break;\\\nrelocs[i].addr = addr;\\\nrelocs[i].offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\\\nif (type == BIND_TYPE_TEXT_PCREL32)\\\n\trelocs[i].addend = addend - (bin->baddr + addr);\\\nelse relocs[i].addend = addend;\\\n/* library ordinal ??? */ \\\nrelocs[i].ord = lib_ord;\\\nrelocs[i].ord = sym_ord;\\\nrelocs[i].type = rel_type;\\\nrelocs[i++].last = 0;\\\n} while (0)\n\t\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed DO bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += ULEB() + wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\tcount = ULEB();\n\t\t\t\tskip = ULEB();\n\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND();\n\t\t\t\t\taddr += skip + wordsize;\n\t\t\t\t}\n\t\t\t\tbreak;\n#undef DO_BIND\n#undef ULEB\n#undef SLEB\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *ur.p);\n\t\t\t\tfree (opcodes);\n\t\t\t\trelocs[i].last = 1;\n\t\t\t\treturn relocs;\n\t\t\t}\n\t\t}\n\t\tfree (opcodes);\n\t} else {\n\t\tint j;\n\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n\t\t\treturn NULL;\n\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))\n\t\t\treturn NULL;\n\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\tif (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {\n\t\t\t\trelocs[i].ord = j;\n\t\t\t\trelocs[i++].last = 0;\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\trelocs[i].last = 1;\n\n\treturn relocs;\n}", "target": 1, "cwe": ["CWE-416"], "project": "radare2", "commit_id": "d1e8ac62c6d978d4662f69116e30230d43033c92", "hash": 39091866468573325366783849733126981098, "size": 207, "message": "Fix null deref and uaf in mach0 parser", "idx": 394}
{"func": "static void free_urlhandle(struct Curl_URL *u)\n{\n  free(u->scheme);\n  free(u->user);\n  free(u->password);\n  free(u->options);\n  free(u->host);\n  free(u->zoneid);\n  free(u->port);\n  free(u->path);\n  free(u->query);\n  free(u->fragment);\n  free(u->scratch);\n  free(u->temppath);\n}", "target": 0, "cwe": [], "project": "curl", "commit_id": "914aaab9153764ef8fa4178215b8ad89d3ac263a", "hash": 140644922196971522504021455998619043109, "size": 15, "message": "urlapi: reject percent-decoding host name into separator bytes\n\nCVE-2022-27780\n\nReported-by: Axel Chong\nBug: https://curl.se/docs/CVE-2022-27780.html\nCloses #8826", "idx": 395}
{"func": "mbed_connect_common(struct connectdata *conn,\n                    int sockindex,\n                    bool nonblocking,\n                    bool *done)\n{\n  CURLcode retcode;\n  struct SessionHandle *data = conn->data;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  long timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1==connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n    retcode = mbed_connect_step1(conn, sockindex);\n    if(retcode)\n      return retcode;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_ready(readfd, writefd, nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    retcode = mbed_connect_step2(conn, sockindex);\n    if(retcode || (nonblocking &&\n                   (ssl_connect_2 == connssl->connecting_state ||\n                    ssl_connect_2_reading == connssl->connecting_state ||\n                    ssl_connect_2_writing == connssl->connecting_state)))\n      return retcode;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3==connssl->connecting_state) {\n    retcode = mbed_connect_step3(conn, sockindex);\n    if(retcode)\n      return retcode;\n  }\n\n  if(ssl_connect_done==connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = mbed_recv;\n    conn->send[sockindex] = mbed_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}", "target": 0, "cwe": ["CWE-20"], "project": "curl", "commit_id": "6efd2fa529a189bf41736a610f6184cd8ad94b4d", "hash": 302693653666770375105462732421173527453, "size": 110, "message": "mbedtls/polarssl: set \"hostname\" unconditionally\n\n...as otherwise the TLS libs will skip the CN/SAN check and just allow\nconnection to any server. curl previously skipped this function when SNI\nwasn't used or when connecting to an IP address specified host.\n\nCVE-2016-3739\n\nBug: https://curl.haxx.se/docs/adv_20160518A.html\nReported-by: Moti Avrahami", "idx": 396}
{"func": "parse_group_prop_ntr_selection_method(struct ofpbuf *payload,\n                                      enum ofp11_group_type group_type,\n                                      enum ofp15_group_mod_command group_cmd,\n                                      struct ofputil_group_props *gp)\n{\n    struct ntr_group_prop_selection_method *prop = payload->data;\n    size_t fields_len, method_len;\n    enum ofperr error;\n\n    switch (group_type) {\n    case OFPGT11_SELECT:\n        break;\n    case OFPGT11_ALL:\n    case OFPGT11_INDIRECT:\n    case OFPGT11_FF:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                    \"only allowed for select groups\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    switch (group_cmd) {\n    case OFPGC15_ADD:\n    case OFPGC15_MODIFY:\n    case OFPGC15_ADD_OR_MOD:\n        break;\n    case OFPGC15_DELETE:\n    case OFPGC15_INSERT_BUCKET:\n    case OFPGC15_REMOVE_BUCKET:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                    \"only allowed for add and delete group modifications\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    if (payload->size < sizeof *prop) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property \"\n                    \"length %u is not valid\", payload->size);\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    method_len = strnlen(prop->selection_method, NTR_MAX_SELECTION_METHOD_LEN);\n\n    if (method_len == NTR_MAX_SELECTION_METHOD_LEN) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method is not null terminated\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    if (strcmp(\"hash\", prop->selection_method)\n        && strcmp(\"dp_hash\", prop->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method '%s' is not supported\",\n                    prop->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    /* 'method_len' is now non-zero. */\n\n    strcpy(gp->selection_method, prop->selection_method);\n    gp->selection_method_param = ntohll(prop->selection_method_param);\n\n    ofpbuf_pull(payload, sizeof *prop);\n\n    fields_len = ntohs(prop->length) - sizeof *prop;\n    if (fields_len && strcmp(\"hash\", gp->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method %s \"\n                    \"does not support fields\", gp->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    error = oxm_pull_field_array(payload->data, fields_len,\n                                 &gp->fields);\n    if (error) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method fields are invalid\");\n        return error;\n    }\n\n    return 0;\n}", "target": 1, "cwe": ["CWE-617", "CWE-703"], "project": "ovs", "commit_id": "4af6da3b275b764b1afe194df6499b33d2bf4cde", "hash": 243929399070785055737660017205489009712, "size": 82, "message": "ofp-group: Don't assert-fail decoding bad OF1.5 group mod type or command.\n\nWhen decoding a group mod, the current code validates the group type and\ncommand after the whole group mod has been decoded.  The OF1.5 decoder,\nhowever, tries to use the type and command earlier, when it might still be\ninvalid.  This caused an assertion failure (via OVS_NOT_REACHED).  This\ncommit fixes the problem.\n\novs-vswitchd does not enable support for OpenFlow 1.5 by default.\n\nReported-at: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9249\nSigned-off-by: Ben Pfaff <blp@ovn.org>\nReviewed-by: Yifeng Sun <pkusunyifeng@gmail.com>", "idx": 397}
{"func": "TfLiteRegistration* Register_UNIQUE() {\n  static TfLiteRegistration r = {unique::Init, unique::Free, unique::Prepare,\n                                 unique::Eval};\n  return &r;\n}", "target": 0, "cwe": ["CWE-125", "CWE-787"], "project": "tensorflow", "commit_id": "1970c2158b1ffa416d159d03c3370b9a462aee35", "hash": 291597820942151296690995901983644466440, "size": 5, "message": "[tflite]: Insert `nullptr` checks when obtaining tensors.\n\nAs part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.\n\nWe also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).\n\nPiperOrigin-RevId: 332521299\nChange-Id: I29af455bcb48d0b92e58132d951a3badbd772d56", "idx": 398}
{"func": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tumode_t mode;\n\tstruct inode * inode = bprm->file->f_path.dentry->d_inode;\n\tint retval;\n\n\tmode = inode->i_mode;\n\tif (bprm->file->f_op == NULL)\n\t\treturn -EACCES;\n\n\t/* clear any previous set[ug]id data from a previous binary */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !current->no_new_privs) {\n\t\t/* Set-uid? */\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\n\t\t/* Set-gid? */\n\t\t/*\n\t\t * If setgid is set but no group execute bit then this\n\t\t * is a candidate for mandatory locking, not a setgid\n\t\t * executable.\n\t\t */\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}", "target": 0, "cwe": ["CWE-264"], "project": "linux", "commit_id": "259e5e6c75a910f3b5e656151dc602f53f9d7548", "hash": 203576155179512304534802305792284855391, "size": 43, "message": "Add PR_{GET,SET}_NO_NEW_PRIVS to prevent execve from granting privs\n\nWith this change, calling\n  prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)\ndisables privilege granting operations at execve-time.  For example, a\nprocess will not be able to execute a setuid binary to change their uid\nor gid if this bit is set.  The same is true for file capabilities.\n\nAdditionally, LSM_UNSAFE_NO_NEW_PRIVS is defined to ensure that\nLSMs respect the requested behavior.\n\nTo determine if the NO_NEW_PRIVS bit is set, a task may call\n  prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0);\nIt returns 1 if set and 0 if it is not set. If any of the arguments are\nnon-zero, it will return -1 and set errno to -EINVAL.\n(PR_SET_NO_NEW_PRIVS behaves similarly.)\n\nThis functionality is desired for the proposed seccomp filter patch\nseries.  By using PR_SET_NO_NEW_PRIVS, it allows a task to modify the\nsystem call behavior for itself and its child tasks without being\nable to impact the behavior of a more privileged task.\n\nAnother potential use is making certain privileged operations\nunprivileged.  For example, chroot may be considered \"safe\" if it cannot\naffect privileged tasks.\n\nNote, this patch causes execve to fail when PR_SET_NO_NEW_PRIVS is\nset and AppArmor is in use.  It is fixed in a subsequent patch.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Will Drewry <wad@chromium.org>\nAcked-by: Eric Paris <eparis@redhat.com>\nAcked-by: Kees Cook <keescook@chromium.org>\n\nv18: updated change desc\nv17: using new define values as per 3.4\nSigned-off-by: James Morris <james.l.morris@oracle.com>", "idx": 399}
{"func": "xmlSchemaFormatNodeForError(xmlChar ** msg,\n\t\t\t    xmlSchemaAbstractCtxtPtr actxt,\n\t\t\t    xmlNodePtr node)\n{\n    xmlChar *str = NULL;\n\n    *msg = NULL;\n    if ((node != NULL) &&\n\t(node->type != XML_ELEMENT_NODE) &&\n\t(node->type != XML_ATTRIBUTE_NODE))\n    {\n\t/*\n\t* Don't try to format other nodes than element and\n\t* attribute nodes.\n\t* Play save and return an empty string.\n\t*/\n\t*msg = xmlStrdup(BAD_CAST \"\");\n\treturn(*msg);\n    }\n    if (node != NULL) {\n\t/*\n\t* Work on tree nodes.\n\t*/\n\tif (node->type == XML_ATTRIBUTE_NODE) {\n\t    xmlNodePtr elem = node->parent;\n\n\t    *msg = xmlStrdup(BAD_CAST \"Element '\");\n\t    if (elem->ns != NULL)\n\t\t*msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n\t\t    elem->ns->href, elem->name));\n\t    else\n\t\t*msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n\t\t    NULL, elem->name));\n\t    FREE_AND_NULL(str);\n\t    *msg = xmlStrcat(*msg, BAD_CAST \"', \");\n\t    *msg = xmlStrcat(*msg, BAD_CAST \"attribute '\");\n\t} else {\n\t    *msg = xmlStrdup(BAD_CAST \"Element '\");\n\t}\n\tif (node->ns != NULL)\n\t    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n\t    node->ns->href, node->name));\n\telse\n\t    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n\t    NULL, node->name));\n\tFREE_AND_NULL(str);\n\t*msg = xmlStrcat(*msg, BAD_CAST \"': \");\n    } else if (actxt->type == XML_SCHEMA_CTXT_VALIDATOR) {\n\txmlSchemaValidCtxtPtr vctxt = (xmlSchemaValidCtxtPtr) actxt;\n\t/*\n\t* Work on node infos.\n\t*/\n\tif (vctxt->inode->nodeType == XML_ATTRIBUTE_NODE) {\n\t    xmlSchemaNodeInfoPtr ielem =\n\t\tvctxt->elemInfos[vctxt->depth];\n\n\t    *msg = xmlStrdup(BAD_CAST \"Element '\");\n\t    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n\t\tielem->nsName, ielem->localName));\n\t    FREE_AND_NULL(str);\n\t    *msg = xmlStrcat(*msg, BAD_CAST \"', \");\n\t    *msg = xmlStrcat(*msg, BAD_CAST \"attribute '\");\n\t} else {\n\t    *msg = xmlStrdup(BAD_CAST \"Element '\");\n\t}\n\t*msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,\n\t    vctxt->inode->nsName, vctxt->inode->localName));\n\tFREE_AND_NULL(str);\n\t*msg = xmlStrcat(*msg, BAD_CAST \"': \");\n    } else if (actxt->type == XML_SCHEMA_CTXT_PARSER) {\n\t/*\n\t* Hmm, no node while parsing?\n\t* Return an empty string, in case NULL will break something.\n\t*/\n\t*msg = xmlStrdup(BAD_CAST \"\");\n    } else {\n\tTODO\n\treturn (NULL);\n    }\n    /*\n    * VAL TODO: The output of the given schema component is currently\n    * disabled.\n    */\n#if 0\n    if ((type != NULL) && (xmlSchemaIsGlobalItem(type))) {\n\t*msg = xmlStrcat(*msg, BAD_CAST \" [\");\n\t*msg = xmlStrcat(*msg, xmlSchemaFormatItemForReport(&str,\n\t    NULL, type, NULL, 0));\n\tFREE_AND_NULL(str)\n\t*msg = xmlStrcat(*msg, BAD_CAST \"]\");\n    }\n#endif\n    return (*msg);\n}", "target": 1, "cwe": ["CWE-134"], "project": "libxml2", "commit_id": "4472c3a5a5b516aaf59b89be602fbce52756c3e9", "hash": 232451949434367393399020973380133636638, "size": 94, "message": "Fix some format string warnings with possible format string vulnerability\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=761029\n\nDecorate every method in libxml2 with the appropriate\nLIBXML_ATTR_FORMAT(fmt,args) macro and add some cleanups\nfollowing the reports.", "idx": 400}
{"func": "void lpFree(unsigned char *lp) {\n    lp_free(lp);\n}", "target": 0, "cwe": ["CWE-190"], "project": "redis", "commit_id": "f6a40570fa63d5afdd596c78083d754081d80ae3", "hash": 118238722961445476138908197508564767474, "size": 3, "message": "Fix ziplist and listpack overflows and truncations (CVE-2021-32627, CVE-2021-32628)\n\n- fix possible heap corruption in ziplist and listpack resulting by trying to\n  allocate more than the maximum size of 4GB.\n- prevent ziplist (hash and zset) from reaching size of above 1GB, will be\n  converted to HT encoding, that's not a useful size.\n- prevent listpack (stream) from reaching size of above 1GB.\n- XADD will start a new listpack if the new record may cause the previous\n  listpack to grow over 1GB.\n- XADD will respond with an error if a single stream record is over 1GB\n- List type (ziplist in quicklist) was truncating strings that were over 4GB,\n  now it'll respond with an error.", "idx": 401}
{"func": "static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\n\t\tmutex_lock(&tu->tread_sem);\n\t\tif (tu->timeri)\t{\t/* too late */\n\t\t\tmutex_unlock(&tu->tread_sem);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (get_user(xarg, p)) {\n\t\t\tmutex_unlock(&tu->tread_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttu->tread = xarg ? 1 : 0;\n\t\tmutex_unlock(&tu->tread_sem);\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux", "commit_id": "af368027a49a751d6ff4ee9e3f9961f35bb4fede", "hash": 185842371909519137355697912773476215870, "size": 59, "message": "ALSA: timer: Fix race among timer ioctls\n\nALSA timer ioctls have an open race and this may lead to a\nuse-after-free of timer instance object.  A simplistic fix is to make\neach ioctl exclusive.  We have already tread_sem for controlling the\ntread, and extend this as a global mutex to be applied to each ioctl.\n\nThe downside is, of course, the worse concurrency.  But these ioctls\naren't to be parallel accessible, in anyway, so it should be fine to\nserialize there.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "idx": 402}
{"func": "static bool io_wq_work_match_all(struct io_wq_work *work, void *data)\n{\n\treturn true;\n}", "target": 0, "cwe": ["CWE-200"], "project": "linux", "commit_id": "713b9825a4c47897f66ad69409581e7734a8728e", "hash": 111435209642221855554498857840897729086, "size": 4, "message": "io-wq: fix cancellation on create-worker failure\n\nWARNING: CPU: 0 PID: 10392 at fs/io_uring.c:1151 req_ref_put_and_test\nfs/io_uring.c:1151 [inline]\nWARNING: CPU: 0 PID: 10392 at fs/io_uring.c:1151 req_ref_put_and_test\nfs/io_uring.c:1146 [inline]\nWARNING: CPU: 0 PID: 10392 at fs/io_uring.c:1151\nio_req_complete_post+0xf5b/0x1190 fs/io_uring.c:1794\nModules linked in:\nCall Trace:\n tctx_task_work+0x1e5/0x570 fs/io_uring.c:2158\n task_work_run+0xe0/0x1a0 kernel/task_work.c:164\n tracehook_notify_signal include/linux/tracehook.h:212 [inline]\n handle_signal_work kernel/entry/common.c:146 [inline]\n exit_to_user_mode_loop kernel/entry/common.c:172 [inline]\n exit_to_user_mode_prepare+0x232/0x2a0 kernel/entry/common.c:209\n __syscall_exit_to_user_mode_work kernel/entry/common.c:291 [inline]\n syscall_exit_to_user_mode+0x19/0x60 kernel/entry/common.c:302\n do_syscall_64+0x42/0xb0 arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nWhen io_wqe_enqueue() -> io_wqe_create_worker() fails, we can't just\ncall io_run_cancel() to clean up the request, it's already enqueued via\nio_wqe_insert_work() and will be executed either by some other worker\nduring cancellation (e.g. in io_wq_put_and_exit()).\n\nReported-by: Hao Sun <sunhao.th@gmail.com>\nFixes: 3146cba99aa28 (\"io-wq: make worker creation resilient against signals\")\nSigned-off-by: Pavel Begunkov <asml.silence@gmail.com>\nLink: https://lore.kernel.org/r/93b9de0fcf657affab0acfd675d4abcd273ee863.1631092071.git.asml.silence@gmail.com\nSigned-off-by: Jens Axboe <axboe@kernel.dk>", "idx": 403}
{"func": "  longlong val_int() { return cached_time.to_longlong(); }", "target": 0, "cwe": ["CWE-617"], "project": "server", "commit_id": "807945f2eb5fa22e6f233cc17b85a2e141efe2c8", "hash": 172712672628622373587036205631319828420, "size": 1, "message": "MDEV-26402: A SEGV in Item_field::used_tables/update_depend_map_for_order...\n\nWhen doing condition pushdown from HAVING into WHERE,\nItem_equal::create_pushable_equalities() calls\nitem->set_extraction_flag(IMMUTABLE_FL) for constant items.\nThen, Item::cleanup_excluding_immutables_processor() checks for this flag\nto see if it should call item->cleanup() or leave the item as-is.\n\nThe failure happens when a constant item has a non-constant one inside it,\nlike:\n\n   (tbl.col=0 AND impossible_cond)\n\nitem->walk(cleanup_excluding_immutables_processor) works in a bottom-up\nway so it\n1. will call Item_func_eq(tbl.col=0)->cleanup()\n2. will not call Item_cond_and->cleanup (as the AND is constant)\n\nThis creates an item tree where a fixed Item has an un-fixed Item inside\nit which eventually causes an assertion failure.\n\nFixed by introducing this rule: instead of just calling\n\n  item->set_extraction_flag(IMMUTABLE_FL);\n\nwe call Item::walk() to set the flag for all sub-items of the item.", "idx": 404}
{"func": "int wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    int ret;\n\n    /* Suppress possible unused arg if all signature types are disabled */\n    (void)rng;\n\n    /* Check arguments */\n    if (hash_data == NULL || hash_len <= 0 ||\n        sig == NULL || sig_len == NULL || *sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (needs to be at least max) */\n    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid hash type/len\");\n        return ret;\n    }\n    ret = 0;\n\n    /* Create signature using hash as data */\n    switch (sig_type) {\n        case WC_SIGNATURE_TYPE_ECC:\n#if defined(HAVE_ECC) && defined(HAVE_ECC_SIGN)\n            /* Create signature using provided ECC key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n            if (ret >= 0)\n                ret = wc_ecc_sign_hash(hash_data, hash_len, sig, sig_len,\n                    rng, (ecc_key*)key);\n            } while (ret == WC_PENDING_E);\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_RSA_W_ENC:\n        case WC_SIGNATURE_TYPE_RSA:\n#if !defined(NO_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n            /* Create signature using provided RSA key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n                if (ret >= 0)\n                    ret = wc_RsaSSL_Sign(hash_data, hash_len, sig, *sig_len,\n                        (RsaKey*)key, rng);\n            } while (ret == WC_PENDING_E);\n            if (ret >= 0) {\n                *sig_len = ret;\n                ret = 0; /* Success */\n            }\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_NONE:\n        default:\n            ret = BAD_FUNC_ARG;\n            break;\n    }\n\n    return ret;\n}", "target": 1, "cwe": ["CWE-200", "CWE-327", "CWE-347"], "project": "wolfssl", "commit_id": "23878512c65834d12811b1107d19a001478eca5d", "hash": 48744892369847927345328691286462880145, "size": 81, "message": "Change signature generation to verify by default", "idx": 405}
{"func": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\n\tadd_timer(&rose->timer);\n}", "target": 1, "cwe": ["CWE-416"], "project": "linux", "commit_id": "9cc02ede696272c5271a401e4f27c262359bc2f6", "hash": 65265638756087342113204082906080512158, "size": 11, "message": "net: rose: fix UAF bugs caused by timer handler\n\nThere are UAF bugs in rose_heartbeat_expiry(), rose_timer_expiry()\nand rose_idletimer_expiry(). The root cause is that del_timer()\ncould not stop the timer handler that is running and the refcount\nof sock is not managed properly.\n\nOne of the UAF bugs is shown below:\n\n    (thread 1)          |        (thread 2)\n                        |  rose_bind\n                        |  rose_connect\n                        |    rose_start_heartbeat\nrose_release            |    (wait a time)\n  case ROSE_STATE_0     |\n  rose_destroy_socket   |  rose_heartbeat_expiry\n    rose_stop_heartbeat |\n    sock_put(sk)        |    ...\n  sock_put(sk) // FREE  |\n                        |    bh_lock_sock(sk) // USE\n\nThe sock is deallocated by sock_put() in rose_release() and\nthen used by bh_lock_sock() in rose_heartbeat_expiry().\n\nAlthough rose_destroy_socket() calls rose_stop_heartbeat(),\nit could not stop the timer that is running.\n\nThe KASAN report triggered by POC is shown below:\n\nBUG: KASAN: use-after-free in _raw_spin_lock+0x5a/0x110\nWrite of size 4 at addr ffff88800ae59098 by task swapper/3/0\n...\nCall Trace:\n <IRQ>\n dump_stack_lvl+0xbf/0xee\n print_address_description+0x7b/0x440\n print_report+0x101/0x230\n ? irq_work_single+0xbb/0x140\n ? _raw_spin_lock+0x5a/0x110\n kasan_report+0xed/0x120\n ? _raw_spin_lock+0x5a/0x110\n kasan_check_range+0x2bd/0x2e0\n _raw_spin_lock+0x5a/0x110\n rose_heartbeat_expiry+0x39/0x370\n ? rose_start_heartbeat+0xb0/0xb0\n call_timer_fn+0x2d/0x1c0\n ? rose_start_heartbeat+0xb0/0xb0\n expire_timers+0x1f3/0x320\n __run_timers+0x3ff/0x4d0\n run_timer_softirq+0x41/0x80\n __do_softirq+0x233/0x544\n irq_exit_rcu+0x41/0xa0\n sysvec_apic_timer_interrupt+0x8c/0xb0\n </IRQ>\n <TASK>\n asm_sysvec_apic_timer_interrupt+0x1b/0x20\nRIP: 0010:default_idle+0xb/0x10\nRSP: 0018:ffffc9000012fea0 EFLAGS: 00000202\nRAX: 000000000000bcae RBX: ffff888006660f00 RCX: 000000000000bcae\nRDX: 0000000000000001 RSI: ffffffff843a11c0 RDI: ffffffff843a1180\nRBP: dffffc0000000000 R08: dffffc0000000000 R09: ffffed100da36d46\nR10: dfffe9100da36d47 R11: ffffffff83cf0950 R12: 0000000000000000\nR13: 1ffff11000ccc1e0 R14: ffffffff8542af28 R15: dffffc0000000000\n...\nAllocated by task 146:\n __kasan_kmalloc+0xc4/0xf0\n sk_prot_alloc+0xdd/0x1a0\n sk_alloc+0x2d/0x4e0\n rose_create+0x7b/0x330\n __sock_create+0x2dd/0x640\n __sys_socket+0xc7/0x270\n __x64_sys_socket+0x71/0x80\n do_syscall_64+0x43/0x90\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nFreed by task 152:\n kasan_set_track+0x4c/0x70\n kasan_set_free_info+0x1f/0x40\n ____kasan_slab_free+0x124/0x190\n kfree+0xd3/0x270\n __sk_destruct+0x314/0x460\n rose_release+0x2fa/0x3b0\n sock_close+0xcb/0x230\n __fput+0x2d9/0x650\n task_work_run+0xd6/0x160\n exit_to_user_mode_loop+0xc7/0xd0\n exit_to_user_mode_prepare+0x4e/0x80\n syscall_exit_to_user_mode+0x20/0x40\n do_syscall_64+0x4f/0x90\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThis patch adds refcount of sock when we use functions\nsuch as rose_start_heartbeat() and so on to start timer,\nand decreases the refcount of sock when timer is finished\nor deleted by functions such as rose_stop_heartbeat()\nand so on. As a result, the UAF bugs could be mitigated.\n\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nTested-by: Duoming Zhou <duoming@zju.edu.cn>\nLink: https://lore.kernel.org/r/20220629002640.5693-1-duoming@zju.edu.cn\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>", "idx": 406}
{"func": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to),\n                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)\n              / BYTES_PER_WORD,\n          arena);\n}", "target": 1, "cwe": ["CWE-20"], "project": "capnproto", "commit_id": "52bc956459a5e83d7c31be95763ff6399e064ae4", "hash": 55943391802138715209819063687788264096, "size": 9, "message": "SECURITY: Prevent compiler from eliding bounds checks.\n\nDetails: https://github.com/sandstorm-io/capnproto/blob/master/security-advisories/2017-04-17-0-apple-32bit-elides-bounds-check.md", "idx": 407}
{"func": "static void schedule_bh(void (*handler)(void))\n{\n\tWARN_ON(work_pending(&floppy_work));\n\n\tfloppy_work_fn = handler;\n\tqueue_work(floppy_wq, &floppy_work);\n}", "target": 0, "cwe": ["CWE-264", "CWE-754"], "project": "linux", "commit_id": "ef87dbe7614341c2e7bfe8d32fcb7028cc97442c", "hash": 24546007457447725362335694722370303927, "size": 7, "message": "floppy: ignore kernel-only members in FDRAWCMD ioctl input\n\nAlways clear out these floppy_raw_cmd struct members after copying the\nentire structure from userspace so that the in-kernel version is always\nvalid and never left in an interdeterminate state.\n\nSigned-off-by: Matthew Daley <mattd@bugfuzz.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 408}
{"func": "void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {\n  if (!connection_.enableTrailers()) {\n    return endEncode();\n  }\n  // Trailers only matter if it is a chunk transfer encoding\n  // https://tools.ietf.org/html/rfc7230#section-4.4\n  if (chunk_encoding_) {\n    // Finalize the body\n    connection_.buffer().add(LAST_CHUNK);\n\n    trailers.iterate(\n        [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n          static_cast<StreamEncoderImpl*>(context)->encodeFormattedHeader(\n              header.key().getStringView(), header.value().getStringView());\n          return HeaderMap::Iterate::Continue;\n        },\n        this);\n\n    connection_.flushOutput();\n    connection_.buffer().add(CRLF);\n  }\n\n  connection_.flushOutput();\n  connection_.onEncodeComplete();\n}", "target": 0, "cwe": ["CWE-770"], "project": "envoy", "commit_id": "7ca28ff7d46454ae930e193d97b7d08156b1ba59", "hash": 24386340258840793210103171342466421146, "size": 25, "message": "[http1] Include request URL in request header size computation, and reject partial headers that exceed configured limits (#145)\n\nSigned-off-by: antonio <avd@google.com>", "idx": 409}
{"func": "get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-22"], "project": "linux-pam", "commit_id": "9dcead87e6d7f66d34e7a56d11a30daca367dffb", "hash": 227818384334126316111651650155998253999, "size": 25, "message": "pam_timestamp: fix potential directory traversal issue (ticket #27)\n\npam_timestamp uses values of PAM_RUSER and PAM_TTY as components of\nthe timestamp pathname it creates, so extra care should be taken to\navoid potential directory traversal issues.\n\n* modules/pam_timestamp/pam_timestamp.c (check_tty): Treat\n\".\" and \"..\" tty values as invalid.\n(get_ruser): Treat \".\" and \"..\" ruser values, as well as any ruser\nvalue containing '/', as invalid.\n\nFixes CVE-2014-2583.\n\nReported-by: Sebastian Krahmer <krahmer@suse.de>", "idx": 410}
{"func": "evbuffer_chain_new(size_t size)\n{\n\tstruct evbuffer_chain *chain;\n\tsize_t to_alloc;\n\n\tsize += EVBUFFER_CHAIN_SIZE;\n\n\t/* get the next largest memory that can hold the buffer */\n\tto_alloc = MIN_BUFFER_SIZE;\n\twhile (to_alloc < size)\n\t\tto_alloc <<= 1;\n\n\t/* we get everything in one chunk */\n\tif ((chain = mm_malloc(to_alloc)) == NULL)\n\t\treturn (NULL);\n\n\tmemset(chain, 0, EVBUFFER_CHAIN_SIZE);\n\n\tchain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;\n\n\t/* this way we can manipulate the buffer to different addresses,\n\t * which is required for mmap for example.\n\t */\n\tchain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);\n\n\tchain->refcnt = 1;\n\n\treturn (chain);\n}", "target": 1, "cwe": ["CWE-189"], "project": "libevent", "commit_id": "841ecbd96105c84ac2e7c9594aeadbcc6fb38bc4", "hash": 236387847853101804025239563764040747780, "size": 29, "message": "Fix CVE-2014-6272 in Libevent 2.1\n\nFor this fix, we need to make sure that passing too-large inputs to\nthe evbuffer functions can't make us do bad things with the heap.\n\nAlso, lower the maximum chunk size to the lower of off_t, size_t maximum.\n\nThis is necessary since otherwise we could get into an infinite loop\nif we make a chunk that 'misalign' cannot index into.", "idx": 411}
{"func": "send_client_notifications (void)\n{\n  struct {\n    pid_t pid;\n#ifdef HAVE_W32_SYSTEM\n    HANDLE handle;\n#else\n    int signo;\n#endif\n  } killed[50];\n  int killidx = 0;\n  int kidx;\n  struct server_local_s *sl;\n\n  for (sl=session_list; sl; sl = sl->next_session)\n    {\n      if (sl->event_signal && sl->assuan_ctx)\n        {\n          pid_t pid = assuan_get_pid (sl->assuan_ctx);\n#ifdef HAVE_W32_SYSTEM\n          HANDLE handle = (void *)sl->event_signal;\n\n          for (kidx=0; kidx < killidx; kidx++)\n            if (killed[kidx].pid == pid\n                && killed[kidx].handle == handle)\n              break;\n          if (kidx < killidx)\n            log_info (\"event %lx (%p) already triggered for client %d\\n\",\n                      sl->event_signal, handle, (int)pid);\n          else\n            {\n              log_info (\"triggering event %lx (%p) for client %d\\n\",\n                        sl->event_signal, handle, (int)pid);\n              if (!SetEvent (handle))\n                log_error (\"SetEvent(%lx) failed: %s\\n\",\n                           sl->event_signal, w32_strerror (-1));\n              if (killidx < DIM (killed))\n                {\n                  killed[killidx].pid = pid;\n                  killed[killidx].handle = handle;\n                  killidx++;\n                }\n            }\n#else /*!HAVE_W32_SYSTEM*/\n          int signo = sl->event_signal;\n\n          if (pid != (pid_t)(-1) && pid && signo > 0)\n            {\n              for (kidx=0; kidx < killidx; kidx++)\n                if (killed[kidx].pid == pid\n                    && killed[kidx].signo == signo)\n                  break;\n              if (kidx < killidx)\n                log_info (\"signal %d already sent to client %d\\n\",\n                          signo, (int)pid);\n              else\n                {\n                  log_info (\"sending signal %d to client %d\\n\",\n                            signo, (int)pid);\n                  kill (pid, signo);\n                  if (killidx < DIM (killed))\n                    {\n                      killed[killidx].pid = pid;\n                      killed[killidx].signo = signo;\n                      killidx++;\n                    }\n                }\n            }\n#endif /*!HAVE_W32_SYSTEM*/\n        }\n    }\n}", "target": 0, "cwe": [], "project": "gnupg", "commit_id": "b0b3803e8c2959dd67ca96debc54b5c6464f0d41", "hash": 22671257748271259607179568130132715709, "size": 72, "message": "scd: Avoid double-free on error condition in scd\n\n* scd/command.c (cmd_readkey): avoid double-free of cert\n\n--\n\nWhen ksba_cert_new() fails, cert will be double-freed.\n\nDebian-Bug-Id: 773471\n\nOriginal patch changed by wk to do the free only at leave.", "idx": 412}
{"func": "static void on_page_prepare(GtkNotebook *assistant, GtkWidget *page, gpointer user_data)\n{\n    //int page_no = gtk_assistant_get_current_page(g_assistant);\n    //log_ready_state();\n\n    /* This suppresses [Last] button: assistant thinks that\n     * we never have this page ready unless we are on it\n     * -> therefore there is at least one non-ready page\n     * -> therefore it won't show [Last]\n     */\n    // Doesn't work: if Completeness:[++++++-+++],\n    // then [Last] btn will still be shown.\n    //gtk_assistant_set_page_complete(g_assistant,\n    //            pages[PAGENO_REVIEW_DATA].page_widget,\n    //            pages[PAGENO_REVIEW_DATA].page_widget == page\n    //);\n\n    /* If processing is finished and if it was terminated because of an error\n     * the event progress page is selected. So, it does not make sense to show\n     * the next step button and we MUST NOT clear warnings.\n     */\n    if (!is_processing_finished())\n    {\n        /* some pages hide it, so restore it to it's default */\n        show_next_step_button();\n        clear_warnings();\n    }\n\n    gtk_widget_hide(g_btn_detail);\n    gtk_widget_hide(g_btn_onfail);\n    if (!g_expert_mode)\n        gtk_widget_hide(g_btn_repeat);\n    /* Save text fields if changed */\n    /* Must be called before any GUI operation because the following two\n     * functions causes recreating of the text items tabs, thus all updates to\n     * these tabs will be lost */\n    save_items_from_notepad();\n    save_text_from_text_view(g_tv_comment, FILENAME_COMMENT);\n\n\n    if (pages[PAGENO_SUMMARY].page_widget == page)\n    {\n        if (!g_expert_mode)\n        {\n            /* Skip intro screen */\n            int n = select_next_page_no(pages[PAGENO_SUMMARY].page_no, NULL);\n            log_info(\"switching to page_no:%d\", n);\n            gtk_notebook_set_current_page(assistant, n);\n            return;\n        }\n    }\n\n    if (pages[PAGENO_EDIT_ELEMENTS].page_widget == page)\n    {\n        if (highlight_forbidden())\n        {\n            add_sensitive_data_warning();\n            show_warnings();\n            gtk_expander_set_expanded(g_exp_search, TRUE);\n        }\n        else\n            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g_rb_custom_search), TRUE);\n\n        show_warnings();\n    }\n\n    if (pages[PAGENO_REVIEW_DATA].page_widget == page)\n    {\n        update_ls_details_checkboxes(g_event_selected);\n        gtk_widget_set_sensitive(g_btn_next, gtk_toggle_button_get_active(g_tb_approve_bt));\n    }\n\n    if (pages[PAGENO_EDIT_COMMENT].page_widget == page)\n    {\n        gtk_widget_show(g_btn_detail);\n        gtk_widget_set_sensitive(g_btn_next, false);\n        on_comment_changed(gtk_text_view_get_buffer(g_tv_comment), NULL);\n    }\n    //log_ready_state();\n\n    if (pages[PAGENO_EVENT_PROGRESS].page_widget == page)\n    {\n        log_info(\"g_event_selected:'%s'\", g_event_selected);\n        if (g_event_selected\n         && g_event_selected[0]\n        ) {\n            clear_warnings();\n            start_event_run(g_event_selected);\n        }\n    }\n\n    if(pages[PAGENO_EVENT_SELECTOR].page_widget == page)\n    {\n        if (!g_expert_mode && !g_auto_event_list)\n            hide_next_step_button();\n    }\n}", "target": 1, "cwe": ["CWE-200"], "project": "libreport", "commit_id": "257578a23d1537a2d235aaa2b1488ee4f818e360", "hash": 230570117251994215930780067212704205010, "size": 97, "message": "wizard: fix save users changes after reviewing dump dir files\n\nIf the user reviewed the dump dir's files during reporting the crash, the\nchanges was thrown away and original data was passed to the bugzilla bug\nreport.\n\nreport-gtk saves the first text view buffer and then reloads data from the\nreported problem directory, which causes that the changes made to those text\nviews are thrown away.\n\nFunction save_text_if_changed(), except of saving text, also reload the files\nfrom dump dir and update gui state from the dump dir. The commit moves the\nreloading and updating gui functions away from this function.\n\nRelated to rhbz#1270235\n\nSigned-off-by: Matej Habrnal <mhabrnal@redhat.com>", "idx": 413}
{"func": "tiff_set_rgb_fields(gx_device_tiff *tfdev)\n{\n    cmm_profile_t *icc_profile;\n\n    if (tfdev->icc_struct->postren_profile != NULL)\n        icc_profile = tfdev->icc_struct->postren_profile;\n    else if (tfdev->icc_struct->oi_profile != NULL)\n        icc_profile = tfdev->icc_struct->oi_profile;\n    else\n        icc_profile = tfdev->icc_struct->device_profile[0];\n\n    switch (icc_profile->data_cs) {\n        case gsRGB:\n            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            break;\n        case gsCIELAB:\n            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB);\n            break;\n        default:\n            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            break;\n    }\n    TIFFSetField(tfdev->tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    TIFFSetField(tfdev->tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n\n    tiff_set_compression((gx_device_printer *)tfdev, tfdev->tif,\n                         tfdev->Compression, tfdev->MaxStripSize);\n}", "target": 0, "cwe": ["CWE-476"], "project": "ghostpdl", "commit_id": "aadb53eb834b3def3ef68d78865ff87a68901804", "hash": 98545606816248486332193093555425902058, "size": 28, "message": "Tiffsep and Tiffsep1 - abort on multi-page input wtithout %d OutputFile\n\nBug #701821 \"Segmentation fault at tiff//libtiff/tif_dirinfo.c:513 in TIFFFindField\"\n\nThe tiffsep and tiffsep1 only set 'code' to an error when an attempt is\nmade to write a second output file without using %d in the OutputFile\nspecification.\n\nThis causes problems later when attempting to process the files. The\ndevices should exit without trying to further process the pages under\nthese conditions and this commit returns immediately on error.\n\nThe other devices like this already return immediately on error, it\nlooks like the code here was copied between  devices without realising\nthat the tiffsep and tiffsep1 devices didn't exit when the error\ncondition was set.", "idx": 414}
{"func": "spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\n\treturn (ret);\n}", "target": 1, "cwe": ["CWE-18", "CWE-763"], "project": "krb5", "commit_id": "b51b33f2bc5d1497ddf5bd107f791c101695000d", "hash": 276788596304513117722551860970305208167, "size": 20, "message": "Fix SPNEGO context aliasing bugs [CVE-2015-2695]\n\nThe SPNEGO mechanism currently replaces its context handle with the\nmechanism context handle upon establishment, under the assumption that\nmost GSS functions are only called after context establishment.  This\nassumption is incorrect, and can lead to aliasing violations for some\nprograms.  Maintain the SPNEGO context structure after context\nestablishment and refer to it in all GSS methods.  Add initiate and\nopened flags to the SPNEGO context structure for use in\ngss_inquire_context() prior to context establishment.\n\nCVE-2015-2695:\n\nIn MIT krb5 1.5 and later, applications which call\ngss_inquire_context() on a partially-established SPNEGO context can\ncause the GSS-API library to read from a pointer using the wrong type,\ngenerally causing a process crash.  This bug may go unnoticed, because\nthe most common SPNEGO authentication scenario establishes the context\nafter just one call to gss_accept_sec_context().  Java server\napplications using the native JGSS provider are vulnerable to this\nbug.  A carefully crafted SPNEGO packet might allow the\ngss_inquire_context() call to succeed with attacker-determined\nresults, but applications should not make access control decisions\nbased on gss_inquire_context() results prior to context establishment.\n\n    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C\n\n[ghudson@mit.edu: several bugfixes, style changes, and edge-case\nbehavior changes; commit message and CVE description]\n\nticket: 8244\ntarget_version: 1.14\ntags: pullup", "idx": 415}
{"func": "int sysctl_is_seen(struct ctl_table_header *p)\n{\n\tstruct ctl_table_set *set = p->set;\n\tint res;\n\tspin_lock(&sysctl_lock);\n\tif (p->unregistering)\n\t\tres = 0;\n\telse if (!set->is_seen)\n\t\tres = 1;\n\telse\n\t\tres = set->is_seen(set);\n\tspin_unlock(&sysctl_lock);\n\treturn res;\n}", "target": 0, "cwe": ["CWE-284", "CWE-264"], "project": "linux", "commit_id": "bfdc0b497faa82a0ba2f9dddcf109231dd519fcc", "hash": 107863151602341226138275959624253029730, "size": 14, "message": "sysctl: restrict write access to dmesg_restrict\n\nWhen dmesg_restrict is set to 1 CAP_SYS_ADMIN is needed to read the kernel\nring buffer.  But a root user without CAP_SYS_ADMIN is able to reset\ndmesg_restrict to 0.\n\nThis is an issue when e.g.  LXC (Linux Containers) are used and complete\nuser space is running without CAP_SYS_ADMIN.  A unprivileged and jailed\nroot user can bypass the dmesg_restrict protection.\n\nWith this patch writing to dmesg_restrict is only allowed when root has\nCAP_SYS_ADMIN.\n\nSigned-off-by: Richard Weinberger <richard@nod.at>\nAcked-by: Dan Rosenberg <drosenberg@vsecurity.com>\nAcked-by: Serge E. Hallyn <serge@hallyn.com>\nCc: Eric Paris <eparis@redhat.com>\nCc: Kees Cook <kees.cook@canonical.com>\nCc: James Morris <jmorris@namei.org>\nCc: Eugene Teo <eugeneteo@kernel.org>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 416}
{"func": "static MagickBooleanType WriteMIFFImage(const ImageInfo *image_info,\n  Image *image)\n{\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  bz_stream\n    bzip_info;\n#endif\n\n  char\n    buffer[MaxTextExtent];\n\n  CompressionType\n    compression;\n\n  const char\n    *property,\n    *value;\n\n  IndexPacket\n    index;\n\n#if defined(MAGICKCORE_LZMA_DELEGATE)\n  lzma_allocator\n    allocator;\n\n  lzma_stream\n    initialize_lzma = LZMA_STREAM_INIT,\n    lzma_info;\n#endif\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  PixelPacket\n    pixel;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    imageListLength,\n    length,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compress_pixels,\n    *pixels,\n    *q;\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n  z_stream\n    zip_info;\n#endif\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Allocate image pixels.\n    */\n    if ((image->storage_class == PseudoClass) &&\n        (image->colors > (size_t) (GetQuantumRange(image->depth)+1)))\n      (void) SetImageStorageClass(image,DirectClass);\n    image->depth=image->depth <= 8 ? 8UL : image->depth <= 16 ? 16UL :\n      image->depth <= 32 ? 32UL : 64UL;\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 16) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          {\n            quantum_info=DestroyQuantumInfo(quantum_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    else\n      if (image->depth < 16)\n        (void) DeleteImageProperty(image,\"quantum:format\");\n    compression=UndefinedCompression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n#if !defined(MAGICKCORE_LZMA_DELEGATE)\n      case LZMACompression: compression=NoCompression; break;\n#endif\n#if !defined(MAGICKCORE_ZLIB_DELEGATE)\n      case LZWCompression:\n      case ZipCompression: compression=NoCompression; break;\n#endif\n#if !defined(MAGICKCORE_BZLIB_DELEGATE)\n      case BZipCompression: compression=NoCompression; break;\n#endif\n      case RLECompression:\n      {\n        if (quantum_info->format == FloatingPointQuantumFormat)\n          compression=NoCompression;\n        break;\n      }\n      default:\n        break;\n    }\n    packet_size=(size_t) (quantum_info->depth/8);\n    if (image->storage_class == DirectClass)\n      packet_size=(size_t) (3*quantum_info->depth/8);\n    if (IsGrayColorspace(image->colorspace) != MagickFalse)\n      packet_size=(size_t) (quantum_info->depth/8);\n    if (image->matte != MagickFalse)\n      packet_size+=quantum_info->depth/8;\n    if (image->colorspace == CMYKColorspace)\n      packet_size+=quantum_info->depth/8;\n    if (compression == RLECompression)\n      packet_size++;\n    length=MagickMax(BZipMaxExtent(packet_size*image->columns),ZipMaxExtent(\n      packet_size*image->columns));\n    if ((compression == BZipCompression) || (compression == ZipCompression))\n      if (length != (size_t) ((unsigned int) length))\n        compression=NoCompression;\n    compress_pixels=(unsigned char *) AcquireQuantumMemory(length,\n      sizeof(*compress_pixels));\n    if (compress_pixels == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    /*\n      Write MIFF header.\n    */\n    (void) WriteBlobString(image,\"id=ImageMagick  version=1.0\\n\");\n    (void) FormatLocaleString(buffer,MaxTextExtent,\n      \"class=%s  colors=%.20g  matte=%s\\n\",CommandOptionToMnemonic(\n      MagickClassOptions,image->storage_class),(double) image->colors,\n      CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t) image->matte));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MaxTextExtent,\"columns=%.20g  rows=%.20g  \"\n      \"depth=%.20g\\n\",(double) image->columns,(double) image->rows,(double)\n      image->depth);\n    (void) WriteBlobString(image,buffer);\n    if (image->type != UndefinedType)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"type=%s\\n\",\n          CommandOptionToMnemonic(MagickTypeOptions,image->type));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->colorspace != UndefinedColorspace)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"colorspace=%s\\n\",\n          CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->intensity != UndefinedPixelIntensityMethod)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"pixel-intensity=%s\\n\",\n          CommandOptionToMnemonic(MagickPixelIntensityOptions,\n          image->intensity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->endian != UndefinedEndian)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"endian=%s\\n\",\n          CommandOptionToMnemonic(MagickEndianOptions,image->endian));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (compression != UndefinedCompression)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"compression=%s  \"\n          \"quality=%.20g\\n\",CommandOptionToMnemonic(MagickCompressOptions,\n          compression),(double) image->quality);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->units != UndefinedResolution)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"units=%s\\n\",\n          CommandOptionToMnemonic(MagickResolutionOptions,image->units));\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->x_resolution != 0) || (image->y_resolution != 0))\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"resolution=%gx%g\\n\",image->x_resolution,image->y_resolution);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->page.width != 0) || (image->page.height != 0))\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"page=%.20gx%.20g%+.20g%+.20g\\n\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      if ((image->page.x != 0) || (image->page.y != 0))\n        {\n          (void) FormatLocaleString(buffer,MaxTextExtent,\"page=%+ld%+ld\\n\",\n            (long) image->page.x,(long) image->page.y);\n          (void) WriteBlobString(image,buffer);\n        }\n    if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"tile-offset=%+ld%+ld\\n\",\n          (long) image->tile_offset.x,(long) image->tile_offset.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((GetNextImageInList(image) != (Image *) NULL) ||\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      {\n        if (image->scene == 0)\n          (void) FormatLocaleString(buffer,MaxTextExtent,\"iterations=%.20g  \"\n            \"delay=%.20g  ticks-per-second=%.20g\\n\",(double) image->iterations,\n            (double) image->delay,(double) image->ticks_per_second);\n        else\n          (void) FormatLocaleString(buffer,MaxTextExtent,\"scene=%.20g  \"\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",(double)\n            image->scene,(double) image->iterations,(double) image->delay,\n            (double) image->ticks_per_second);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        if (image->scene != 0)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\"scene=%.20g\\n\",\n              (double) image->scene);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->iterations != 0)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\"iterations=%.20g\\n\",\n              (double) image->iterations);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->delay != 0)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\"delay=%.20g\\n\",\n              (double) image->delay);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->ticks_per_second != UndefinedTicksPerSecond)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\n              \"ticks-per-second=%.20g\\n\",(double) image->ticks_per_second);\n            (void) WriteBlobString(image,buffer);\n          }\n      }\n    if (image->gravity != UndefinedGravity)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"gravity=%s\\n\",\n          CommandOptionToMnemonic(MagickGravityOptions,image->gravity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->dispose != UndefinedDispose)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"dispose=%s\\n\",\n          CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->rendering_intent != UndefinedIntent)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"rendering-intent=%s\\n\",\n           CommandOptionToMnemonic(MagickIntentOptions,image->rendering_intent));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->gamma != 0.0)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"gamma=%g\\n\",\n          image->gamma);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        /*\n          Note chomaticity points.\n        */\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"red-primary=%g,\"\n          \"%g  green-primary=%g,%g  blue-primary=%g,%g\\n\",\n          image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n          image->chromaticity.green_primary.x,\n          image->chromaticity.green_primary.y,\n          image->chromaticity.blue_primary.x,\n          image->chromaticity.blue_primary.y);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"white-point=%g,%g\\n\",image->chromaticity.white_point.x,\n          image->chromaticity.white_point.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->orientation != UndefinedOrientation)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"orientation=%s\\n\",\n          CommandOptionToMnemonic(MagickOrientationOptions,image->orientation));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->profiles != (void *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profile names.\n        */\n        ResetImageProfileIterator(image);\n        for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              (void) FormatLocaleString(buffer,MagickPathExtent,\"profile=%s\\n\",\n                name);\n              (void) WriteBlobString(image,buffer);\n            }\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->montage != (char *) NULL)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"montage=%s\\n\",\n          image->montage);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (quantum_info->format == FloatingPointQuantumFormat)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      (void) FormatLocaleString(buffer,MaxTextExtent,\"%s=\",property);\n      (void) WriteBlobString(image,buffer);\n      value=GetImageProperty(image,property);\n      if (value != (const char *) NULL)\n        {\n          size_t\n            length;\n\n          length=strlen(value);\n          for (i=0; i < (ssize_t) length; i++)\n            if ((isspace((int) ((unsigned char) value[i])) != 0) ||\n                (value[i] == '}'))\n              break;\n          if ((i == (ssize_t) length) && (i != 0))\n            (void) WriteBlob(image,length,(const unsigned char *) value);\n          else\n            {\n              (void) WriteBlobByte(image,'{');\n              if (strchr(value,'}') == (char *) NULL)\n                (void) WriteBlob(image,length,(const unsigned char *) value);\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                {\n                  if (value[i] == (int) '}')\n                    (void) WriteBlobByte(image,'\\\\');\n                  (void) WriteBlobByte(image,(unsigned char) value[i]);\n                }\n              (void) WriteBlobByte(image,'}');\n            }\n        }\n      (void) WriteBlobByte(image,'\\n');\n      property=GetNextImageProperty(image);\n    }\n    (void) WriteBlobString(image,\"\\f\\n:\\032\");\n    if (image->montage != (char *) NULL)\n      {\n        /*\n          Write montage tile directory.\n        */\n        if (image->directory != (char *) NULL)\n          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)\n            image->directory);\n        (void) WriteBlobByte(image,'\\0');\n      }\n    if (image->profiles != 0)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profile blob.\n        */\n        ResetImageProfileIterator(image);\n        name=GetNextImageProfile(image);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          (void) WriteBlobMSBLong(image,(unsigned int)\n            GetStringInfoLength(profile));\n          (void) WriteBlob(image,GetStringInfoLength(profile),\n            GetStringInfoDatum(profile));\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          packet_size;\n\n        unsigned char\n          *colormap,\n          *q;\n\n        /*\n          Allocate colormap.\n        */\n        packet_size=(size_t) (3*quantum_info->depth/8);\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          packet_size*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Write colormap to file.\n        */\n        q=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          switch (quantum_info->depth)\n          {\n            default:\n              ThrowWriterException(CorruptImageError,\"ImageDepthNotSupported\");\n            case 32:\n            {\n              register unsigned int\n                pixel;\n\n              pixel=ScaleQuantumToLong(image->colormap[i].red);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].green);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].blue);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 16:\n            {\n              register unsigned short\n                pixel;\n\n              pixel=ScaleQuantumToShort(image->colormap[i].red);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].green);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].blue);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 8:\n            {\n              register unsigned char\n                pixel;\n\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(\n                image->colormap[i].green);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n              q=PopCharPixel(pixel,q);\n              break;\n            }\n          }\n        }\n        (void) WriteBlob(image,packet_size*image->colors,colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    /*\n      Write image pixels to file.\n    */\n    status=MagickTrue;\n    switch (compression)\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      case BZipCompression:\n      {\n        int\n          code;\n\n        bzip_info.bzalloc=AcquireBZIPMemory;\n        bzip_info.bzfree=RelinquishBZIPMemory;\n        bzip_info.opaque=(void *) NULL;\n        code=BZ2_bzCompressInit(&bzip_info,(int) (image->quality ==\n          UndefinedCompressionQuality ? 7 : MagickMin(image->quality/10,\n          9)),(int) image_info->verbose,0);\n        if (code != BZ_OK)\n          status=MagickFalse;\n        break;\n      }\n#endif\n#if defined(MAGICKCORE_LZMA_DELEGATE)\n      case LZMACompression:\n      {\n        int\n          code;\n\n        allocator.alloc=AcquireLZMAMemory;\n        allocator.free=RelinquishLZMAMemory;\n        allocator.opaque=(void *) NULL;\n        lzma_info=initialize_lzma;\n        lzma_info.allocator=&allocator;\n        code=lzma_easy_encoder(&lzma_info,image->quality/10,LZMA_CHECK_SHA256);\n        if (code != LZMA_OK)\n          status=MagickTrue;\n        break;\n      }\n#endif\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      case LZWCompression:\n      case ZipCompression:\n      {\n        int\n          code;\n\n        zip_info.zalloc=AcquireZIPMemory;\n        zip_info.zfree=RelinquishZIPMemory;\n        zip_info.opaque=(void *) NULL;\n        code=deflateInit(&zip_info,(int) (image->quality ==\n          UndefinedCompressionQuality ? 7 : MagickMin(image->quality/10,9)));\n        if (code != Z_OK)\n          status=MagickFalse;\n        break;\n      }\n#endif\n      default:\n        break;\n    }\n    quantum_type=GetQuantumType(image,&image->exception);\n    pixels=GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register const IndexPacket\n        *magick_restrict indexes;\n\n      register const PixelPacket\n        *magick_restrict p;\n\n      register ssize_t\n        x;\n\n      if (status == MagickFalse)\n        break;\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (const PixelPacket *) NULL)\n        break;\n      indexes=GetVirtualIndexQueue(image);\n      q=pixels;\n      switch (compression)\n      {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n        case BZipCompression:\n        {\n          bzip_info.next_in=(char *) pixels;\n          bzip_info.avail_in=(unsigned int) (packet_size*image->columns);\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          do\n          {\n            int\n              code;\n\n            bzip_info.next_out=(char *) compress_pixels;\n            bzip_info.avail_out=(unsigned int) BZipMaxExtent(packet_size*\n              image->columns);\n            code=BZ2_bzCompress(&bzip_info,BZ_FLUSH);\n            if (code != BZ_OK)\n              status=MagickFalse;\n            length=(size_t) (bzip_info.next_out-(char *) compress_pixels);\n            if (length != 0)\n              {\n                (void) WriteBlobMSBLong(image,(unsigned int) length);\n                (void) WriteBlob(image,length,compress_pixels);\n              }\n          } while (bzip_info.avail_in != 0);\n          break;\n        }\n#endif\n#if defined(MAGICKCORE_LZMA_DELEGATE)\n        case LZMACompression:\n        {\n          lzma_info.next_in=pixels;\n          lzma_info.avail_in=packet_size*image->columns;\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          do\n          {\n            int\n              code;\n\n            lzma_info.next_out=compress_pixels;\n            lzma_info.avail_out=packet_size*image->columns;\n            code=lzma_code(&lzma_info,LZMA_RUN);\n            if (code != LZMA_OK)\n              status=MagickFalse;\n            length=(size_t) (lzma_info.next_out-compress_pixels);\n            if (length != 0)\n              {\n                (void) WriteBlobMSBLong(image,(unsigned int) length);\n                (void) WriteBlob(image,length,compress_pixels);\n              }\n          } while (lzma_info.avail_in != 0);\n          break;\n        }\n#endif\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n        case LZWCompression:\n        case ZipCompression:\n        {\n          zip_info.next_in=pixels;\n          zip_info.avail_in=(uInt) (packet_size*image->columns);\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          do\n          {\n            int\n              code;\n\n            zip_info.next_out=compress_pixels;\n            zip_info.avail_out=(uInt) ZipMaxExtent(packet_size*image->columns);\n            code=deflate(&zip_info,Z_SYNC_FLUSH);\n            if (code != Z_OK)\n              status=MagickFalse;\n            length=(size_t) (zip_info.next_out-compress_pixels);\n            if (length != 0)\n              {\n                (void) WriteBlobMSBLong(image,(unsigned int) length);\n                (void) WriteBlob(image,length,compress_pixels);\n              }\n          } while (zip_info.avail_in != 0);\n          break;\n        }\n#endif\n        case RLECompression:\n        {\n          pixel=(*p);\n          index=(IndexPacket) 0;\n          if (indexes != (IndexPacket *) NULL)\n            index=(*indexes);\n          length=255;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if ((length < 255) && (x < (ssize_t) (image->columns-1)) &&\n                (IsColorEqual(p,&pixel) != MagickFalse) &&\n                ((image->matte == MagickFalse) ||\n                 (GetPixelOpacity(p) == pixel.opacity)) &&\n                ((indexes == (IndexPacket *) NULL) ||\n                 (index == GetPixelIndex(indexes+x))))\n              length++;\n            else\n              {\n                if (x > 0)\n                  q=PopRunlengthPacket(image,q,length,pixel,index);\n                length=0;\n              }\n            pixel=(*p);\n            if (indexes != (IndexPacket *) NULL)\n              index=GetPixelIndex(indexes+x);\n            p++;\n          }\n          q=PopRunlengthPacket(image,q,length,pixel,index);\n          (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n          break;\n        }\n        default:\n        {\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          (void) WriteBlob(image,packet_size*image->columns,pixels);\n          break;\n        }\n      }\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    switch (compression)\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      case BZipCompression:\n      {\n        int\n          code;\n\n        for ( ; ; )\n        {\n          if (status == MagickFalse)\n            break;\n          bzip_info.next_out=(char *) compress_pixels;\n          bzip_info.avail_out=(unsigned int) BZipMaxExtent(packet_size*\n            image->columns);\n          code=BZ2_bzCompress(&bzip_info,BZ_FINISH);\n          length=(size_t) (bzip_info.next_out-(char *) compress_pixels);\n          if (length != 0)\n            {\n              (void) WriteBlobMSBLong(image,(unsigned int) length);\n              (void) WriteBlob(image,length,compress_pixels);\n            }\n          if (code == BZ_STREAM_END)\n            break;\n        }\n        code=BZ2_bzCompressEnd(&bzip_info);\n        if (code != BZ_OK)\n          status=MagickFalse;\n        break;\n      }\n#endif\n#if defined(MAGICKCORE_LZMA_DELEGATE)\n      case LZMACompression:\n      {\n        int\n          code;\n\n        for ( ; ; )\n        {\n          if (status == MagickFalse)\n            break;\n          lzma_info.next_out=compress_pixels;\n          lzma_info.avail_out=packet_size*image->columns;\n          code=lzma_code(&lzma_info,LZMA_FINISH);\n          length=(size_t) (lzma_info.next_out-compress_pixels);\n          if (length > 6)\n            {\n              (void) WriteBlobMSBLong(image,(unsigned int) length);\n              (void) WriteBlob(image,length,compress_pixels);\n            }\n          if (code == LZMA_STREAM_END)\n            break;\n        }\n        lzma_end(&lzma_info);\n        break;\n      }\n#endif\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      case LZWCompression:\n      case ZipCompression:\n      {\n        int\n          code;\n\n        for ( ; ; )\n        {\n          if (status == MagickFalse)\n            break;\n          zip_info.next_out=compress_pixels;\n          zip_info.avail_out=(uInt) ZipMaxExtent(packet_size*image->columns);\n          code=deflate(&zip_info,Z_FINISH);\n          length=(size_t) (zip_info.next_out-compress_pixels);\n          if (length > 6)\n            {\n              (void) WriteBlobMSBLong(image,(unsigned int) length);\n              (void) WriteBlob(image,length,compress_pixels);\n            }\n          if (code == Z_STREAM_END)\n            break;\n        }\n        code=deflateEnd(&zip_info);\n        if (code != Z_OK)\n          status=MagickFalse;\n        break;\n      }\n#endif\n      default:\n        break;\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    compress_pixels=(unsigned char *) RelinquishMagickMemory(compress_pixels);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(status);\n}", "target": 1, "cwe": ["CWE-772"], "project": "ImageMagick6", "commit_id": "ae3eecad2f59e27123c1a6c891be75d06fc03656", "hash": 132166287416284296396695747866398978457, "size": 806, "message": "https://github.com/ImageMagick/ImageMagick/issues/1191", "idx": 417}
{"func": "NOEXPORT void save_log() {\n    TCHAR file_name[MAX_PATH];\n    OPENFILENAME ofn;\n    LPTSTR txt;\n    LPSTR str;\n\n    ZeroMemory(&ofn, sizeof ofn);\n    file_name[0]='\\0';\n\n    ofn.lStructSize=sizeof ofn;\n    ofn.hwndOwner=hwnd;\n    ofn.lpstrFilter=TEXT(\"Log Files (*.log)\\0*.log\\0All Files (*.*)\\0*.*\\0\\0\");\n    ofn.lpstrFile=file_name;\n    ofn.nMaxFile=MAX_PATH;\n    ofn.lpstrDefExt=TEXT(\"LOG\");\n    ofn.lpstrInitialDir=TEXT(\".\");\n\n    ofn.lpstrTitle=TEXT(\"Save Log\");\n    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|\n        OFN_OVERWRITEPROMPT;\n    if(!GetSaveFileName(&ofn))\n        return;\n\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);\n    txt=log_txt(); /* need to convert the result to UTF-8 */\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);\n    str=tstr2str(txt);\n    str_free(txt);\n    save_text_file(file_name, str);\n    str_free(str);\n}", "target": 0, "cwe": ["CWE-295"], "project": "stunnel", "commit_id": "ebad9ddc4efb2635f37174c9d800d06206f1edf9", "hash": 137418274406360145885430214239673392893, "size": 31, "message": "stunnel-5.57", "idx": 418}
{"func": "MOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    opf->metadata = calloc(1, sizeof(OPFmetadata));\n    if (opf->metadata == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* initialize metadata sub-elements */\n    opf->metadata->meta = calloc(OPF_META_MAX_TAGS, sizeof(OPFmeta*));\n    if (opf->metadata->meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->dc_meta = calloc(1, sizeof(OPFdcmeta));\n    if (opf->metadata->dc_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->x_meta = calloc(1, sizeof(OPFxmeta));\n    if (opf->metadata->x_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (m->eh) {\n        MOBI_RET ret = mobi_get_opf_from_exth(opf->metadata, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    /* check for required elements */\n    if (opf->metadata->dc_meta->identifier == NULL) {\n        /* default id will be \"0\" */\n        char uid_string[11] = \"0\";\n        if (m->mh && m->mh->uid) {\n            snprintf(uid_string, 11, \"%u\", *m->mh->uid);\n        }\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, value, uid_string);\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, id, \"uid\");\n    } else {\n        opf->metadata->dc_meta->identifier[0]->id = strdup(\"uid\");\n    }\n    if (opf->metadata->dc_meta->title == NULL) {\n        opf->metadata->dc_meta->title = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->title == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        char *title = mobi_meta_get_title(m);\n        if (title == NULL) {\n            title = strdup(\"Unknown\");\n        }\n        opf->metadata->dc_meta->title[0] = title;\n    }\n    if (opf->metadata->dc_meta->language == NULL) {\n        opf->metadata->dc_meta->language = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->language == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const char *lang_string = NULL;\n        if (m->mh && m->mh->locale) {\n            uint32_t lang_code = *m->mh->locale;\n            lang_string = mobi_get_locale_string(lang_code);\n        }\n        if (lang_string) {\n            opf->metadata->dc_meta->language[0] = strdup(lang_string);\n        } else {\n            opf->metadata->dc_meta->language[0] = strdup(\"en\");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_in);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_in_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                uint32_t dict_lang_out = *m->mh->dict_output_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_out);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_out_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf->metadata->x_meta->default_lookup_index[0] = strdup(rawml->orth->orth_index_name);\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 0, "cwe": ["CWE-476"], "project": "libmobi", "commit_id": "c0699c8693c47f14a2e57dec7292e862ac7adf9c", "hash": 101487152111615522237369492665847708842, "size": 114, "message": "Fix undefined behavior when passing null to strdup", "idx": 419}
{"func": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1 || nsops > SEMOPM)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\t/* copy this as well before changing domain protection */\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-264"], "project": "linux", "commit_id": "7de249964f5578e67b99699c5f0b405738d820a2", "hash": 282427497170046699936789849109425242536, "size": 38, "message": "arm: oabi compat: add missing access checks\n\nAdd access checks to sys_oabi_epoll_wait() and sys_oabi_semtimedop().\nThis fixes CVE-2016-3857, a local privilege escalation under\nCONFIG_OABI_COMPAT.\n\nCc: stable@vger.kernel.org\nReported-by: Chiachih Wu <wuchiachih@gmail.com>\nReviewed-by: Kees Cook <keescook@chromium.org>\nReviewed-by: Nicolas Pitre <nico@linaro.org>\nSigned-off-by: Dave Weinstein <olorin@google.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 420}
{"func": "fr_window_set_batch__extract_here (FrWindow *window,\n\t\t\t\t   GFile    *archive)\n{\n\tg_return_if_fail (window != NULL);\n\tg_return_if_fail (archive != NULL);\n\n\tfr_window_append_batch_action (window,\n\t\t\t\t       FR_BATCH_ACTION_LOAD,\n\t\t\t\t       g_object_ref (archive),\n\t\t\t\t       (GFreeFunc) g_object_unref);\n\tfr_window_append_batch_action (window,\n\t\t\t\t       FR_BATCH_ACTION_EXTRACT_HERE,\n\t\t\t\t       extract_to_data_new (window, NULL),\n\t\t\t\t       (GFreeFunc) extract_data_free);\n\tfr_window_append_batch_action (window,\n\t\t\t\t       FR_BATCH_ACTION_CLOSE,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n}", "target": 0, "cwe": ["CWE-22"], "project": "file-roller", "commit_id": "b147281293a8307808475e102a14857055f81631", "hash": 289090484896300066550909931880777747974, "size": 19, "message": "libarchive: sanitize filenames before extracting", "idx": 421}
{"func": "TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n\n    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1), multikeyPaths);\n    runQuery(fromjson(\"{a: {$ne: 3}, b: 2}\"));\n\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, \"\n        \"bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], \"\n        \"b: [[2, 2, true, true]]}}}}}\");\n}", "target": 0, "cwe": ["CWE-834"], "project": "mongo", "commit_id": "94d0e046baa64d1aa1a6af97e2d19bb466cc1ff5", "hash": 249439463765224595536672694939289357527, "size": 13, "message": "SERVER-38164 $or pushdown optimization does not correctly handle $not within an $elemMatch", "idx": 422}
{"func": "const char *SSL_state_string_long(const SSL *s)\n\t{\n\tconst char *str;\n\n\tswitch (s->state)\n\t\t{\ncase SSL_ST_BEFORE: str=\"before SSL initialization\"; break;\ncase SSL_ST_ACCEPT: str=\"before accept initialization\"; break;\ncase SSL_ST_CONNECT: str=\"before connect initialization\"; break;\ncase SSL_ST_OK: str=\"SSL negotiation finished successfully\"; break;\ncase SSL_ST_RENEGOTIATE:\tstr=\"SSL renegotiate ciphers\"; break;\ncase SSL_ST_BEFORE|SSL_ST_CONNECT: str=\"before/connect initialization\"; break;\ncase SSL_ST_OK|SSL_ST_CONNECT: str=\"ok/connect SSL initialization\"; break;\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT: str=\"before/accept initialization\"; break;\ncase SSL_ST_OK|SSL_ST_ACCEPT: str=\"ok/accept SSL initialization\"; break;\n#ifndef OPENSSL_NO_SSL2\ncase SSL2_ST_CLIENT_START_ENCRYPTION: str=\"SSLv2 client start encryption\"; break;\ncase SSL2_ST_SERVER_START_ENCRYPTION: str=\"SSLv2 server start encryption\"; break;\ncase SSL2_ST_SEND_CLIENT_HELLO_A: str=\"SSLv2 write client hello A\"; break;\ncase SSL2_ST_SEND_CLIENT_HELLO_B: str=\"SSLv2 write client hello B\"; break;\ncase SSL2_ST_GET_SERVER_HELLO_A: str=\"SSLv2 read server hello A\"; break;\ncase SSL2_ST_GET_SERVER_HELLO_B: str=\"SSLv2 read server hello B\"; break;\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A: str=\"SSLv2 write client master key A\"; break;\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B: str=\"SSLv2 write client master key B\"; break;\ncase SSL2_ST_SEND_CLIENT_FINISHED_A: str=\"SSLv2 write client finished A\"; break;\ncase SSL2_ST_SEND_CLIENT_FINISHED_B: str=\"SSLv2 write client finished B\"; break;\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A: str=\"SSLv2 write client certificate A\"; break;\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B: str=\"SSLv2 write client certificate B\"; break;\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C: str=\"SSLv2 write client certificate C\"; break;\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D: str=\"SSLv2 write client certificate D\"; break;\ncase SSL2_ST_GET_SERVER_VERIFY_A: str=\"SSLv2 read server verify A\"; break;\ncase SSL2_ST_GET_SERVER_VERIFY_B: str=\"SSLv2 read server verify B\"; break;\ncase SSL2_ST_GET_SERVER_FINISHED_A: str=\"SSLv2 read server finished A\"; break;\ncase SSL2_ST_GET_SERVER_FINISHED_B: str=\"SSLv2 read server finished B\"; break;\ncase SSL2_ST_GET_CLIENT_HELLO_A: str=\"SSLv2 read client hello A\"; break;\ncase SSL2_ST_GET_CLIENT_HELLO_B: str=\"SSLv2 read client hello B\"; break;\ncase SSL2_ST_GET_CLIENT_HELLO_C: str=\"SSLv2 read client hello C\"; break;\ncase SSL2_ST_SEND_SERVER_HELLO_A: str=\"SSLv2 write server hello A\"; break;\ncase SSL2_ST_SEND_SERVER_HELLO_B: str=\"SSLv2 write server hello B\"; break;\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_A: str=\"SSLv2 read client master key A\"; break;\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_B: str=\"SSLv2 read client master key B\"; break;\ncase SSL2_ST_SEND_SERVER_VERIFY_A: str=\"SSLv2 write server verify A\"; break;\ncase SSL2_ST_SEND_SERVER_VERIFY_B: str=\"SSLv2 write server verify B\"; break;\ncase SSL2_ST_SEND_SERVER_VERIFY_C: str=\"SSLv2 write server verify C\"; break;\ncase SSL2_ST_GET_CLIENT_FINISHED_A: str=\"SSLv2 read client finished A\"; break;\ncase SSL2_ST_GET_CLIENT_FINISHED_B: str=\"SSLv2 read client finished B\"; break;\ncase SSL2_ST_SEND_SERVER_FINISHED_A: str=\"SSLv2 write server finished A\"; break;\ncase SSL2_ST_SEND_SERVER_FINISHED_B: str=\"SSLv2 write server finished B\"; break;\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_A: str=\"SSLv2 write request certificate A\"; break;\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_B: str=\"SSLv2 write request certificate B\"; break;\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_C: str=\"SSLv2 write request certificate C\"; break;\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_D: str=\"SSLv2 write request certificate D\"; break;\ncase SSL2_ST_X509_GET_SERVER_CERTIFICATE: str=\"SSLv2 X509 read server certificate\"; break;\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE: str=\"SSLv2 X509 read client certificate\"; break;\n#endif\n\n#ifndef OPENSSL_NO_SSL3\n/* SSLv3 additions */\ncase SSL3_ST_CW_CLNT_HELLO_A:\tstr=\"SSLv3 write client hello A\"; break;\ncase SSL3_ST_CW_CLNT_HELLO_B:\tstr=\"SSLv3 write client hello B\"; break;\ncase SSL3_ST_CR_SRVR_HELLO_A:\tstr=\"SSLv3 read server hello A\"; break;\ncase SSL3_ST_CR_SRVR_HELLO_B:\tstr=\"SSLv3 read server hello B\"; break;\ncase SSL3_ST_CR_CERT_A:\t\tstr=\"SSLv3 read server certificate A\"; break;\ncase SSL3_ST_CR_CERT_B:\t\tstr=\"SSLv3 read server certificate B\"; break;\ncase SSL3_ST_CR_KEY_EXCH_A:\tstr=\"SSLv3 read server key exchange A\"; break;\ncase SSL3_ST_CR_KEY_EXCH_B:\tstr=\"SSLv3 read server key exchange B\"; break;\ncase SSL3_ST_CR_CERT_REQ_A:\tstr=\"SSLv3 read server certificate request A\"; break;\ncase SSL3_ST_CR_CERT_REQ_B:\tstr=\"SSLv3 read server certificate request B\"; break;\ncase SSL3_ST_CR_SESSION_TICKET_A: str=\"SSLv3 read server session ticket A\";break;\ncase SSL3_ST_CR_SESSION_TICKET_B: str=\"SSLv3 read server session ticket B\";break;\ncase SSL3_ST_CR_SRVR_DONE_A:\tstr=\"SSLv3 read server done A\"; break;\ncase SSL3_ST_CR_SRVR_DONE_B:\tstr=\"SSLv3 read server done B\"; break;\ncase SSL3_ST_CW_CERT_A:\t\tstr=\"SSLv3 write client certificate A\"; break;\ncase SSL3_ST_CW_CERT_B:\t\tstr=\"SSLv3 write client certificate B\"; break;\ncase SSL3_ST_CW_CERT_C:\t\tstr=\"SSLv3 write client certificate C\"; break;\ncase SSL3_ST_CW_CERT_D:\t\tstr=\"SSLv3 write client certificate D\"; break;\ncase SSL3_ST_CW_KEY_EXCH_A:\tstr=\"SSLv3 write client key exchange A\"; break;\ncase SSL3_ST_CW_KEY_EXCH_B:\tstr=\"SSLv3 write client key exchange B\"; break;\ncase SSL3_ST_CW_CERT_VRFY_A:\tstr=\"SSLv3 write certificate verify A\"; break;\ncase SSL3_ST_CW_CERT_VRFY_B:\tstr=\"SSLv3 write certificate verify B\"; break;\n\ncase SSL3_ST_CW_CHANGE_A:\ncase SSL3_ST_SW_CHANGE_A:\tstr=\"SSLv3 write change cipher spec A\"; break;\ncase SSL3_ST_CW_CHANGE_B:\t\ncase SSL3_ST_SW_CHANGE_B:\tstr=\"SSLv3 write change cipher spec B\"; break;\ncase SSL3_ST_CW_FINISHED_A:\t\ncase SSL3_ST_SW_FINISHED_A:\tstr=\"SSLv3 write finished A\"; break;\ncase SSL3_ST_CW_FINISHED_B:\t\ncase SSL3_ST_SW_FINISHED_B:\tstr=\"SSLv3 write finished B\"; break;\ncase SSL3_ST_CR_CHANGE_A:\t\ncase SSL3_ST_SR_CHANGE_A:\tstr=\"SSLv3 read change cipher spec A\"; break;\ncase SSL3_ST_CR_CHANGE_B:\t\ncase SSL3_ST_SR_CHANGE_B:\tstr=\"SSLv3 read change cipher spec B\"; break;\ncase SSL3_ST_CR_FINISHED_A:\t\ncase SSL3_ST_SR_FINISHED_A:\tstr=\"SSLv3 read finished A\"; break;\ncase SSL3_ST_CR_FINISHED_B:\t\ncase SSL3_ST_SR_FINISHED_B:\tstr=\"SSLv3 read finished B\"; break;\n\ncase SSL3_ST_CW_FLUSH:\ncase SSL3_ST_SW_FLUSH:\t\tstr=\"SSLv3 flush data\"; break;\n\ncase SSL3_ST_SR_CLNT_HELLO_A:\tstr=\"SSLv3 read client hello A\"; break;\ncase SSL3_ST_SR_CLNT_HELLO_B:\tstr=\"SSLv3 read client hello B\"; break;\ncase SSL3_ST_SR_CLNT_HELLO_C:\tstr=\"SSLv3 read client hello C\"; break;\ncase SSL3_ST_SW_HELLO_REQ_A:\tstr=\"SSLv3 write hello request A\"; break;\ncase SSL3_ST_SW_HELLO_REQ_B:\tstr=\"SSLv3 write hello request B\"; break;\ncase SSL3_ST_SW_HELLO_REQ_C:\tstr=\"SSLv3 write hello request C\"; break;\ncase SSL3_ST_SW_SRVR_HELLO_A:\tstr=\"SSLv3 write server hello A\"; break;\ncase SSL3_ST_SW_SRVR_HELLO_B:\tstr=\"SSLv3 write server hello B\"; break;\ncase SSL3_ST_SW_CERT_A:\t\tstr=\"SSLv3 write certificate A\"; break;\ncase SSL3_ST_SW_CERT_B:\t\tstr=\"SSLv3 write certificate B\"; break;\ncase SSL3_ST_SW_KEY_EXCH_A:\tstr=\"SSLv3 write key exchange A\"; break;\ncase SSL3_ST_SW_KEY_EXCH_B:\tstr=\"SSLv3 write key exchange B\"; break;\ncase SSL3_ST_SW_CERT_REQ_A:\tstr=\"SSLv3 write certificate request A\"; break;\ncase SSL3_ST_SW_CERT_REQ_B:\tstr=\"SSLv3 write certificate request B\"; break;\ncase SSL3_ST_SW_SESSION_TICKET_A: str=\"SSLv3 write session ticket A\"; break;\ncase SSL3_ST_SW_SESSION_TICKET_B: str=\"SSLv3 write session ticket B\"; break;\ncase SSL3_ST_SW_SRVR_DONE_A:\tstr=\"SSLv3 write server done A\"; break;\ncase SSL3_ST_SW_SRVR_DONE_B:\tstr=\"SSLv3 write server done B\"; break;\ncase SSL3_ST_SR_CERT_A:\t\tstr=\"SSLv3 read client certificate A\"; break;\ncase SSL3_ST_SR_CERT_B:\t\tstr=\"SSLv3 read client certificate B\"; break;\ncase SSL3_ST_SR_KEY_EXCH_A:\tstr=\"SSLv3 read client key exchange A\"; break;\ncase SSL3_ST_SR_KEY_EXCH_B:\tstr=\"SSLv3 read client key exchange B\"; break;\ncase SSL3_ST_SR_CERT_VRFY_A:\tstr=\"SSLv3 read certificate verify A\"; break;\ncase SSL3_ST_SR_CERT_VRFY_B:\tstr=\"SSLv3 read certificate verify B\"; break;\n#endif\n\n#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)\n/* SSLv2/v3 compatibility states */\n/* client */\ncase SSL23_ST_CW_CLNT_HELLO_A:\tstr=\"SSLv2/v3 write client hello A\"; break;\ncase SSL23_ST_CW_CLNT_HELLO_B:\tstr=\"SSLv2/v3 write client hello B\"; break;\ncase SSL23_ST_CR_SRVR_HELLO_A:\tstr=\"SSLv2/v3 read server hello A\"; break;\ncase SSL23_ST_CR_SRVR_HELLO_B:\tstr=\"SSLv2/v3 read server hello B\"; break;\n/* server */\ncase SSL23_ST_SR_CLNT_HELLO_A:\tstr=\"SSLv2/v3 read client hello A\"; break;\ncase SSL23_ST_SR_CLNT_HELLO_B:\tstr=\"SSLv2/v3 read client hello B\"; break;\n#endif\n\n/* DTLS */\ncase DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A: str=\"DTLS1 read hello verify request A\"; break;\ncase DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B: str=\"DTLS1 read hello verify request B\"; break;\ncase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A: str=\"DTLS1 write hello verify request A\"; break;\ncase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B: str=\"DTLS1 write hello verify request B\"; break;\n\ndefault:\tstr=\"unknown state\"; break;\n\t\t}\n\treturn(str);\n\t}", "target": 1, "cwe": [], "project": "openssl", "commit_id": "edc032b5e3f3ebb1006a9c89e0ae00504f47966f", "hash": 300019564404195272197720253784397983025, "size": 149, "message": "Add SRP support.", "idx": 423}
{"func": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_value_t key_arg, /**< key argument */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */", "target": 1, "cwe": ["CWE-119", "CWE-125", "CWE-703"], "project": "jerryscript", "commit_id": "c2b662170245a16f46ce02eae68815c325d99821", "hash": 289394230641505307974784830249750953781, "size": 16, "message": "Fix adding entries to the internal buffer of a Map object (#3805)\n\nWhen appending the key/value pair separately, garbage collection could be\r\ntriggered before the value is added, which could cause problems during\r\nmarking. This patch changes insertion to add both values at the same\r\ntime, which prevents partial entries from being present in the internal\r\nbuffer.\r\n\r\nFixes #3804.\r\n\r\nJerryScript-DCO-1.0-Signed-off-by: Dániel Bátyai dbatyai@inf.u-szeged.hu", "idx": 424}
{"func": "static char *ask_new_shell(char *question, char *oldshell)\n{\n\tint len;\n\tchar *ans = NULL;\n\tsize_t dummy = 0;\n\n\tif (!oldshell)\n\t\toldshell = \"\";\n\tprintf(\"%s [%s]:\", question, oldshell);\n\tputchar(' ');\n\n\tif (getline(&ans, &dummy, stdin) < 0)\n\t\treturn NULL;\n\n\t/* remove the newline at the end of ans. */\n\tltrim_whitespace((unsigned char *) ans);\n\tlen = rtrim_whitespace((unsigned char *) ans);\n\tif (len == 0)\n\t\treturn NULL;\n\treturn ans;\n}", "target": 0, "cwe": [], "project": "util-linux", "commit_id": "39a81981ac4b8a1f521db550afc117ccab9548cb", "hash": 126504633856378577575156784639556251897, "size": 21, "message": "chsh, chfn: remove readline support [CVE-2022-0563]\n\nThe readline library uses INPUTRC= environment variable to get a path\nto the library config file. When the library cannot parse the\nspecified file, it prints an error message containing data from the\nfile.\n\nUnfortunately, the library does not use secure_getenv() (or a similar\nconcept) to avoid vulnerabilities that could occur if set-user-ID or\nset-group-ID programs.\n\nReported-by: Rory Mackie <rory.mackie@trailofbits.com>\nSigned-off-by: Karel Zak <kzak@redhat.com>", "idx": 425}
{"func": "modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1, "cwe": ["CWE-119", "CWE-772", "CWE-401"], "project": "krb5", "commit_id": "83ed75feba32e46f736fcce0d96a0445f29b96c2", "hash": 282942358279907932591032746132436329740, "size": 51, "message": "Fix leaks in kadmin server stubs [CVE-2015-8631]\n\nIn each kadmind server stub, initialize the client_name and\nserver_name variables, and release them in the cleanup handler.  Many\nof the stubs will otherwise leak the client and server name if\nkrb5_unparse_name() fails.  Also make sure to free the prime_arg\nvariables in rename_principal_2_svc(), or we can leak the first one if\nunparsing the second one fails.  Discovered by Simo Sorce.\n\nCVE-2015-8631:\n\nIn all versions of MIT krb5, an authenticated attacker can cause\nkadmind to leak memory by supplying a null principal name in a request\nwhich uses one.  Repeating these requests will eventually cause\nkadmind to exhaust all available memory.\n\n    CVSSv2 Vector: AV:N/AC:L/Au:S/C:N/I:N/A:C/E:POC/RL:OF/RC:C\n\nticket: 8343 (new)\ntarget_version: 1.14-next\ntarget_version: 1.13-next\ntags: pullup", "idx": 426}
{"func": "void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)\n{\n  ciss_url_t url;\n\n  mutt_account_tourl (&mx->account, &url);\n  url.path = path;\n\n  url_ciss_tobuffer (&url, dest, 0);\n}", "target": 0, "cwe": ["CWE-125"], "project": "mutt", "commit_id": "7c4779ac24d2fb68a2a47b58c7904118f40965d5", "hash": 11658775699842230470777180367319465914, "size": 9, "message": "Fix seqset iterator when it ends in a comma.\n\nIf the seqset ended with a comma, the substr_end marker would be just\nbefore the trailing nul.  In the next call, the loop to skip the\nmarker would iterate right past the end of string too.\n\nThe fix is simple: place the substr_end marker and skip past it\nimmediately.", "idx": 427}
{"func": "static void __net_exit xfrm6_tunnel_net_exit(struct net *net)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tunsigned int i;\n\n\txfrm_flush_gc();\n\txfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byaddr[i]));\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byspi[i]));\n}", "target": 1, "cwe": ["CWE-416"], "project": "linux", "commit_id": "dbb2483b2a46fbaf833cfb5deb5ed9cace9c7399", "hash": 186777866420089452455540907130300501852, "size": 14, "message": "xfrm: clean up xfrm protocol checks\n\nIn commit 6a53b7593233 (\"xfrm: check id proto in validate_tmpl()\")\nI introduced a check for xfrm protocol, but according to Herbert\nIPSEC_PROTO_ANY should only be used as a wildcard for lookup, so\nit should be removed from validate_tmpl().\n\nAnd, IPSEC_PROTO_ANY is expected to only match 3 IPSec-specific\nprotocols, this is why xfrm_state_flush() could still miss\nIPPROTO_ROUTING, which leads that those entries are left in\nnet->xfrm.state_all before exit net. Fix this by replacing\nIPSEC_PROTO_ANY with zero.\n\nThis patch also extracts the check from validate_tmpl() to\nxfrm_id_proto_valid() and uses it in parse_ipsecrequest().\nWith this, no other protocols should be added into xfrm.\n\nFixes: 6a53b7593233 (\"xfrm: check id proto in validate_tmpl()\")\nReported-by: syzbot+0bf0519d6e0de15914fe@syzkaller.appspotmail.com\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nAcked-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>", "idx": 428}
{"func": "void LEX::start(THD *thd_arg)\n{\n  DBUG_ENTER(\"LEX::start\");\n  DBUG_PRINT(\"info\", (\"This: %p thd_arg->lex: %p\", this, thd_arg->lex));\n\n  thd= unit.thd= thd_arg;\n  stmt_lex= this; // default, should be rewritten for VIEWs And CTEs\n\n  DBUG_ASSERT(!explain);\n\n  builtin_select.lex_start(this);\n  lex_options= 0;\n  context_stack.empty();\n  //empty select_stack\n  select_stack_top= 0;\n  unit.init_query();\n  current_select_number= 0;\n  curr_with_clause= 0;\n  with_clauses_list= 0;\n  with_clauses_list_last_next= &with_clauses_list;\n  clone_spec_offset= 0;\n  create_view= NULL;\n  field_list.empty();\n  value_list.empty();\n  update_list.empty();\n  set_var_list.empty();\n  param_list.empty();\n  view_list.empty();\n  with_column_list.empty();\n  with_persistent_for_clause= FALSE;\n  column_list= NULL;\n  index_list= NULL;\n  prepared_stmt.lex_start();\n  auxiliary_table_list.empty();\n  unit.next= unit.master= unit.link_next= unit.return_to= 0;\n  unit.prev= unit.link_prev= 0;\n  unit.slave= current_select= all_selects_list= &builtin_select;\n  sql_cache= LEX::SQL_CACHE_UNSPECIFIED;\n  describe= 0;\n  analyze_stmt= 0;\n  explain_json= false;\n  context_analysis_only= 0;\n  derived_tables= 0;\n  with_cte_resolution= false;\n  only_cte_resolution= false;\n  safe_to_cache_query= 1;\n  parsing_options.reset();\n  empty_field_list_on_rset= 0;\n  part_info= 0;\n  m_sql_cmd= NULL;\n  duplicates= DUP_ERROR;\n  ignore= 0;\n  spname= NULL;\n  spcont= NULL;\n  proc_list.first= 0;\n  escape_used= FALSE;\n  default_used= FALSE;\n  query_tables= 0;\n  reset_query_tables_list(FALSE);\n  clause_that_disallows_subselect= NULL;\n  selects_allow_into= FALSE;\n  selects_allow_procedure= FALSE;\n  use_only_table_context= FALSE;\n  parse_vcol_expr= FALSE;\n  check_exists= FALSE;\n  create_info.lex_start();\n  verbose= 0;\n\n  name= null_clex_str;\n  event_parse_data= NULL;\n  profile_options= PROFILE_NONE;\n  nest_level= 0;\n  builtin_select.nest_level_base= &unit;\n  allow_sum_func.clear_all();\n  in_sum_func= NULL;\n\n  used_tables= 0;\n  table_type= TABLE_TYPE_UNKNOWN;\n  reset_slave_info.all= false;\n  limit_rows_examined= 0;\n  limit_rows_examined_cnt= ULONGLONG_MAX;\n  var_list.empty();\n  stmt_var_list.empty();\n  proc_list.elements=0;\n\n  save_group_list.empty();\n  save_order_list.empty();\n  win_ref= NULL;\n  win_frame= NULL;\n  frame_top_bound= NULL;\n  frame_bottom_bound= NULL;\n  win_spec= NULL;\n\n  vers_conditions.empty();\n  period_conditions.empty();\n\n  is_lex_started= TRUE;\n\n  next_is_main= FALSE;\n  next_is_down= FALSE;\n\n  wild= 0;\n  exchange= 0;\n\n  DBUG_VOID_RETURN;\n}", "target": 1, "cwe": ["CWE-703"], "project": "server", "commit_id": "39feab3cd31b5414aa9b428eaba915c251ac34a2", "hash": 26699921584460092807999602188958188903, "size": 106, "message": "MDEV-26412 Server crash in Item_field::fix_outer_field for INSERT SELECT\n\nIF an INSERT/REPLACE SELECT statement contained an ON expression in the top\nlevel select and this expression used a subquery with a column reference\nthat could not be resolved then an attempt to resolve this reference as\nan outer reference caused a crash of the server. This happened because the\nouter context field in the Name_resolution_context structure was not set\nto NULL for such references. Rather it pointed to the first element in\nthe select_stack.\n\nNote that starting from 10.4 we cannot use the SELECT_LEX::outer_select()\nmethod when parsing a SELECT construct.\n\nApproved by Oleksandr Byelkin <sanja@mariadb.com>", "idx": 429}
{"func": "EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)\n{\n    return &vq->guest_notifier;\n}", "target": 0, "cwe": ["CWE-94"], "project": "qemu", "commit_id": "cc45995294b92d95319b4782750a3580cabdbc0c", "hash": 309863051885191023013323798241609917599, "size": 4, "message": "virtio: out-of-bounds buffer write on invalid state load\n\nCVE-2013-4151 QEMU 1.0 out-of-bounds buffer write in\nvirtio_load@hw/virtio/virtio.c\n\nSo we have this code since way back when:\n\n    num = qemu_get_be32(f);\n\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n\narray of vqs has size VIRTIO_PCI_QUEUE_MAX, so\non invalid input this will write beyond end of buffer.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Michael Roth <mdroth@linux.vnet.ibm.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>", "idx": 430}
{"func": "static ASS_Style *handle_selective_style_overrides(ASS_Renderer *render_priv,\n                                                   ASS_Style *rstyle)\n{\n    // The script style is the one the event was declared with.\n    ASS_Style *script = render_priv->track->styles +\n                        render_priv->state.event->Style;\n    // The user style was set with ass_set_selective_style_override().\n    ASS_Style *user = &render_priv->user_override_style;\n    ASS_Style *new = &render_priv->state.override_style_temp_storage;\n    int explicit = event_has_hard_overrides(render_priv->state.event->Text) ||\n                   render_priv->state.evt_type != EVENT_NORMAL;\n    int requested = render_priv->settings.selective_style_overrides;\n    double scale;\n\n    user->Name = \"OverrideStyle\"; // name insignificant\n\n    // Either the event's style, or the style forced with a \\r tag.\n    if (!rstyle)\n        rstyle = script;\n\n    // Create a new style that contains a mix of the original style and\n    // user_style (the user's override style). Copy only fields from the\n    // script's style that are deemed necessary.\n    *new = *rstyle;\n\n    render_priv->state.explicit = explicit;\n\n    render_priv->state.apply_font_scale =\n        !explicit || !(requested & ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE);\n\n    // On positioned events, do not apply most overrides.\n    if (explicit)\n        requested = 0;\n\n    if (requested & ASS_OVERRIDE_BIT_STYLE)\n        requested |= ASS_OVERRIDE_BIT_FONT_NAME |\n                     ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS |\n                     ASS_OVERRIDE_BIT_COLORS |\n                     ASS_OVERRIDE_BIT_BORDER |\n                     ASS_OVERRIDE_BIT_ATTRIBUTES;\n\n    // Copies fields even not covered by any of the other bits.\n    if (requested & ASS_OVERRIDE_FULL_STYLE)\n        *new = *user;\n\n    // The user style is supposed to be independent of the script resolution.\n    // Treat the user style's values as if they were specified for a script with\n    // PlayResY=288, and rescale the values to the current script.\n    scale = render_priv->track->PlayResY / 288.0;\n\n    if (requested & ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS) {\n        new->FontSize = user->FontSize * scale;\n        new->Spacing = user->Spacing * scale;\n        new->ScaleX = user->ScaleX;\n        new->ScaleY = user->ScaleY;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_FONT_NAME) {\n        new->FontName = user->FontName;\n        new->treat_fontname_as_pattern = user->treat_fontname_as_pattern;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_COLORS) {\n        new->PrimaryColour = user->PrimaryColour;\n        new->SecondaryColour = user->SecondaryColour;\n        new->OutlineColour = user->OutlineColour;\n        new->BackColour = user->BackColour;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_ATTRIBUTES) {\n        new->Bold = user->Bold;\n        new->Italic = user->Italic;\n        new->Underline = user->Underline;\n        new->StrikeOut = user->StrikeOut;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_BORDER) {\n        new->BorderStyle = user->BorderStyle;\n        new->Outline = user->Outline * scale;\n        new->Shadow = user->Shadow * scale;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_ALIGNMENT)\n        new->Alignment = user->Alignment;\n\n    if (requested & ASS_OVERRIDE_BIT_MARGINS) {\n        new->MarginL = user->MarginL;\n        new->MarginR = user->MarginR;\n        new->MarginV = user->MarginV;\n    }\n\n    if (!new->FontName)\n        new->FontName = rstyle->FontName;\n\n    render_priv->state.style = new;\n    render_priv->state.overrides = requested;\n\n    return new;\n}", "target": 0, "cwe": ["CWE-125"], "project": "libass", "commit_id": "f4f48950788b91c6a30029cc28a240b834713ea7", "hash": 197465056128687936596294785927514631004, "size": 99, "message": "Fix line wrapping mode 0/3 bugs\n\nThis fixes two separate bugs:\n\na) Don't move a linebreak into the first symbol. This results in a empty\n   line at the front, which does not help to equalize line lengths at all.\n   Instead, merge line with the second one.\nb) When moving a linebreak into a symbol that already is a break, the\n   number of lines must be decremented. Otherwise, uninitialized memory\n   is possibly used for later layout operations.\n\nFound by fuzzer test case\nid:000085,sig:11,src:003377+003350,op:splice,rep:8.\n\nThis might also affect and hopefully fix libass#229.\n\nv2: change semantics according to review", "idx": 431}
{"func": "bool Item_equal::count_sargable_conds(void *arg)\n{\n  SELECT_LEX *sel= (SELECT_LEX *) arg;\n  uint m= equal_items.elements;\n  sel->cond_count+= m*(m-1);\n  return 0;\n}", "target": 0, "cwe": ["CWE-617"], "project": "server", "commit_id": "807945f2eb5fa22e6f233cc17b85a2e141efe2c8", "hash": 295061225295492338357443027699698122718, "size": 7, "message": "MDEV-26402: A SEGV in Item_field::used_tables/update_depend_map_for_order...\n\nWhen doing condition pushdown from HAVING into WHERE,\nItem_equal::create_pushable_equalities() calls\nitem->set_extraction_flag(IMMUTABLE_FL) for constant items.\nThen, Item::cleanup_excluding_immutables_processor() checks for this flag\nto see if it should call item->cleanup() or leave the item as-is.\n\nThe failure happens when a constant item has a non-constant one inside it,\nlike:\n\n   (tbl.col=0 AND impossible_cond)\n\nitem->walk(cleanup_excluding_immutables_processor) works in a bottom-up\nway so it\n1. will call Item_func_eq(tbl.col=0)->cleanup()\n2. will not call Item_cond_and->cleanup (as the AND is constant)\n\nThis creates an item tree where a fixed Item has an un-fixed Item inside\nit which eventually causes an assertion failure.\n\nFixed by introducing this rule: instead of just calling\n\n  item->set_extraction_flag(IMMUTABLE_FL);\n\nwe call Item::walk() to set the flag for all sub-items of the item.", "idx": 432}
{"func": "R_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output, int *len, char **sterr) {\n\tchar *mysterr = NULL;\n\tif (!sterr) {\n\t\tsterr = &mysterr;\n\t}\n\tchar buffer[1024], *outputptr = NULL;\n\tchar *inputptr = (char *)input;\n\tint pid, bytes = 0, status;\n\tint sh_in[2], sh_out[2], sh_err[2];\n\n\tif (len) {\n\t\t*len = 0;\n\t}\n\tif (pipe (sh_in)) {\n\t\treturn false;\n\t}\n\tif (output) {\n\t\tif (pipe (sh_out)) {\n\t\t\tclose (sh_in[0]);\n\t\t\tclose (sh_in[1]);\n\t\t\tclose (sh_out[0]);\n\t\t\tclose (sh_out[1]);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (pipe (sh_err)) {\n\t\tclose (sh_in[0]);\n\t\tclose (sh_in[1]);\n\t\treturn false;\n\t}\n\n\tswitch ((pid = r_sys_fork ())) {\n\tcase -1:\n\t\treturn false;\n\tcase 0:\n\t\tdup2 (sh_in[0], 0);\n\t\tclose (sh_in[0]);\n\t\tclose (sh_in[1]);\n\t\tif (output) {\n\t\t\tdup2 (sh_out[1], 1);\n\t\t\tclose (sh_out[0]);\n\t\t\tclose (sh_out[1]);\n\t\t}\n\t\tif (sterr) {\n\t\t\tdup2 (sh_err[1], 2);\n\t\t} else {\n\t\t\tclose (2);\n\t\t}\n\t\tclose (sh_err[0]);\n\t\tclose (sh_err[1]);\n\t\texit (r_sandbox_system (cmd, 0));\n\tdefault:\n\t\toutputptr = strdup (\"\");\n\t\tif (!outputptr) {\n\t\t\treturn false;\n\t\t}\n\t\tif (sterr) {\n\t\t\t*sterr = strdup (\"\");\n\t\t\tif (!*sterr) {\n\t\t\t\tfree (outputptr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (output) {\n\t\t\tclose (sh_out[1]);\n\t\t}\n\t\tclose (sh_err[1]);\n\t\tclose (sh_in[0]);\n\t\tif (!inputptr || !*inputptr) {\n\t\t\tclose (sh_in[1]);\n\t\t}\n\t\t// we should handle broken pipes somehow better\n\t\tr_sys_signal (SIGPIPE, SIG_IGN);\n\t\tfor (;;) {\n\t\t\tfd_set rfds, wfds;\n\t\t\tint nfd;\n\t\t\tFD_ZERO (&rfds);\n\t\t\tFD_ZERO (&wfds);\n\t\t\tif (output) {\n\t\t\t\tFD_SET (sh_out[0], &rfds);\n\t\t\t}\n\t\t\tif (sterr) {\n\t\t\t\tFD_SET (sh_err[0], &rfds);\n\t\t\t}\n\t\t\tif (inputptr && *inputptr) {\n\t\t\t\tFD_SET (sh_in[1], &wfds);\n\t\t\t}\n\t\t\tmemset (buffer, 0, sizeof (buffer));\n\t\t\tnfd = select (sh_err[0] + 1, &rfds, &wfds, NULL, NULL);\n\t\t\tif (nfd < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (output && FD_ISSET (sh_out[0], &rfds)) {\n\t\t\t\tif (!(bytes = read (sh_out[0], buffer, sizeof (buffer)-1))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuffer[sizeof (buffer) - 1] = '\\0';\n\t\t\t\tif (len) {\n\t\t\t\t\t*len += bytes;\n\t\t\t\t}\n\t\t\t\toutputptr = r_str_append (outputptr, buffer);\n\t\t\t} else if (FD_ISSET (sh_err[0], &rfds) && sterr) {\n\t\t\t\tif (!read (sh_err[0], buffer, sizeof (buffer)-1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuffer[sizeof (buffer) - 1] = '\\0';\n\t\t\t\t*sterr = r_str_append (*sterr, buffer);\n\t\t\t} else if (FD_ISSET (sh_in[1], &wfds) && inputptr && *inputptr) {\n\t\t\t\tint inputptr_len = strlen (inputptr);\n\t\t\t\tbytes = write (sh_in[1], inputptr, inputptr_len);\n\t\t\t\tif (bytes != inputptr_len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinputptr += bytes;\n\t\t\t\tif (!*inputptr) {\n\t\t\t\t\tclose (sh_in[1]);\n\t\t\t\t\t/* If neither stdout nor stderr should be captured,\n\t\t\t\t\t * abort now - nothing more to do for select(). */\n\t\t\t\t\tif (!output && !sterr) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (output) {\n\t\t\tclose (sh_out[0]);\n\t\t}\n\t\tclose (sh_err[0]);\n\t\tclose (sh_in[1]);\n\t\twaitpid (pid, &status, 0);\n\t\tbool ret = true;\n\t\tif (status) {\n\t\t\t// char *escmd = r_str_escape (cmd);\n\t\t\t// eprintf (\"error code %d (%s): %s\\n\", WEXITSTATUS (status), escmd, *sterr);\n\t\t\t// eprintf (\"(%s)\\n\", output);\n\t\t\t// eprintf (\"%s: failed command '%s'\\n\", __func__, escmd);\n\t\t\t// free (escmd);\n\t\t\tret = false;\n\t\t}\n\n\t\tif (output) {\n\t\t\t*output = outputptr;\n\t\t} else {\n\t\t\tfree (outputptr);\n\t\t}\n\t\treturn ret;\n\t}\n\treturn false;\n}", "target": 1, "cwe": ["CWE-78"], "project": "radare2", "commit_id": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9", "hash": 3065531955394962198812316435056623916, "size": 149, "message": "Fix command injection on PDB download (#16966)\n\n* Fix r_sys_mkdirp with absolute path on Windows\r\n* Fix build with --with-openssl\r\n* Use RBuffer in r_socket_http_answer()\r\n* r_socket_http_answer: Fix read for big responses\r\n* Implement r_str_escape_sh()\r\n* Cleanup r_socket_connect() on Windows\r\n* Fix socket being created without a protocol\r\n* Fix socket connect with SSL ##socket\r\n* Use select() in r_socket_ready()\r\n* Fix read failing if received only protocol answer\r\n* Fix double-free\r\n* r_socket_http_get: Fail if req. SSL with no support\r\n* Follow redirects in r_socket_http_answer()\r\n* Fix r_socket_http_get result length with R2_CURL=1\r\n* Also follow redirects\r\n* Avoid using curl for downloading PDBs\r\n* Use r_socket_http_get() on UNIXs\r\n* Use WinINet API on Windows for r_socket_http_get()\r\n* Fix command injection\r\n* Fix r_sys_cmd_str_full output for binary data\r\n* Validate GUID on PDB download\r\n* Pass depth to socket_http_get_recursive()\r\n* Remove 'r_' and '__' from static function names\r\n* Fix is_valid_guid\r\n* Fix for comments", "idx": 433}
{"func": "static bool ldb_kv_index_unique(struct ldb_context *ldb,\n\t\t\t\tstruct ldb_kv_private *ldb_kv,\n\t\t\t\tconst char *attr)\n{\n\tconst struct ldb_schema_attribute *a;\n\tif (ldb_kv->cache->GUID_index_attribute != NULL) {\n\t\tif (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==\n\t\t    0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (ldb_attr_dn(attr) == 0) {\n\t\treturn true;\n\t}\n\n\ta = ldb_schema_attribute_by_name(ldb, attr);\n\tif (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0, "cwe": ["CWE-20"], "project": "samba", "commit_id": "0998f2f1bced019db4000ef4b55887abcb65f6d2", "hash": 154379200547168106260667823031421176573, "size": 21, "message": "CVE-2018-1140 Add NULL check for ldb_dn_get_casefold() in ltdb_index_dn_attr()\n\nSigned-off-by: Andrej Gessel <Andrej.Gessel@janztec.com>\nReviewed-by: Douglas Bagnall <douglas.bagnall@catalyst.net.nz>\nReviewed-by: Andrew Bartlett <abartlet@samba.org>\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=13374", "idx": 434}
{"func": "PHP_FUNCTION(oci_lob_export)\n{\t\n\tzval **tmp, *z_descriptor = getThis();\n\tphp_oci_descriptor *descriptor;\n\tchar *filename;\n\tchar *buffer;\n\tint filename_len;\n\tlong start = -1, length = -1, block_length;\n\tphp_stream *stream;\n\tub4 lob_length;\n\n\tif (getThis()) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ll\", &filename, &filename_len, &start, &length) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tif (ZEND_NUM_ARGS() > 1 && start < 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Start parameter must be greater than or equal to 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (ZEND_NUM_ARGS() > 2 && length < 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than or equal to 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\telse {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Os|ll\", &z_descriptor, oci_lob_class_entry_ptr, &filename, &filename_len, &start, &length) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\t\t\n\t\tif (ZEND_NUM_ARGS() > 2 && start < 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Start parameter must be greater than or equal to 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (ZEND_NUM_ARGS() > 3 && length < 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than or equal to 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tif (strlen(filename) != filename_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Filename cannot contain null bytes\");\n\t\tRETURN_FALSE;  \n\t}\n\n\tif (zend_hash_find(Z_OBJPROP_P(z_descriptor), \"descriptor\", sizeof(\"descriptor\"), (void **)&tmp) == FAILURE) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to find descriptor property\");\n\t\tRETURN_FALSE;\n\t}\n\t\n\tPHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);\n\t\n\tif (php_oci_lob_get_length(descriptor, &lob_length TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\t\t\n\t\n\tif (start == -1) {\n\t\tstart = 0;\n\t}\n\n\tif (length == -1) {\n\t\tlength = lob_length - descriptor->lob_current_position;\n\t}\n\t\n\tif (length == 0) {\n\t\t/* nothing to write, fail silently */\n\t\tRETURN_FALSE;\n\t}\n\t\n\tif (PG(safe_mode) && (!php_checkuid(filename, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_check_open_basedir(filename TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tstream = php_stream_open_wrapper_ex(filename, \"w\", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL, NULL);\n\n\tblock_length = PHP_OCI_LOB_BUFFER_SIZE;\n\tif (block_length > length) {\n\t\tblock_length = length;\n\t}\n\n\twhile(length > 0) {\n\t\tub4 tmp_bytes_read = 0;\n\t\tif (php_oci_lob_read(descriptor, block_length, start, &buffer, &tmp_bytes_read TSRMLS_CC)) {\n\t\t\tphp_stream_close(stream);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (tmp_bytes_read && !php_stream_write(stream, buffer, tmp_bytes_read)) {\n\t\t\tphp_stream_close(stream);\n\t\t\tefree(buffer);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (buffer) {\n\t\t\tefree(buffer);\n\t\t}\n\t\t\n\t\tlength -= tmp_bytes_read;\n\t\tdescriptor->lob_current_position += tmp_bytes_read;\n\t\tstart += tmp_bytes_read;\n\n\t\tif (block_length > length) {\n\t\t\tblock_length = length;\n\t\t}\n\t}\n\n\tphp_stream_close(stream);\n\tRETURN_TRUE;\n}", "target": 1, "cwe": [], "project": "php-src", "commit_id": "ce96fd6b0761d98353761bf78d5bfb55291179fd", "hash": 108146027541918929504105239593112999478, "size": 111, "message": "- fix #39863, do not accept paths with NULL in them. See http://news.php.net/php.internals/50191, trunk will have the patch later (adding a macro and/or changing (some) APIs. Patch by Rasmus", "idx": 435}
{"func": "uniquefy_paths(garray_T *gap, char_u *pattern)\n{\n    int\t\ti;\n    int\t\tlen;\n    char_u\t**fnames = (char_u **)gap->ga_data;\n    int\t\tsort_again = FALSE;\n    char_u\t*pat;\n    char_u      *file_pattern;\n    char_u\t*curdir;\n    regmatch_T\tregmatch;\n    garray_T\tpath_ga;\n    char_u\t**in_curdir = NULL;\n    char_u\t*short_name;\n\n    remove_duplicates(gap);\n    ga_init2(&path_ga, (int)sizeof(char_u *), 1);\n\n    /*\n     * We need to prepend a '*' at the beginning of file_pattern so that the\n     * regex matches anywhere in the path. FIXME: is this valid for all\n     * possible patterns?\n     */\n    len = (int)STRLEN(pattern);\n    file_pattern = alloc(len + 2);\n    if (file_pattern == NULL)\n\treturn;\n    file_pattern[0] = '*';\n    file_pattern[1] = NUL;\n    STRCAT(file_pattern, pattern);\n    pat = file_pat_to_reg_pat(file_pattern, NULL, NULL, TRUE);\n    vim_free(file_pattern);\n    if (pat == NULL)\n\treturn;\n\n    regmatch.rm_ic = TRUE;\t\t// always ignore case\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    vim_free(pat);\n    if (regmatch.regprog == NULL)\n\treturn;\n\n    if ((curdir = alloc(MAXPATHL)) == NULL)\n\tgoto theend;\n    mch_dirname(curdir, MAXPATHL);\n    expand_path_option(curdir, &path_ga);\n\n    in_curdir = ALLOC_CLEAR_MULT(char_u *, gap->ga_len);\n    if (in_curdir == NULL)\n\tgoto theend;\n\n    for (i = 0; i < gap->ga_len && !got_int; i++)\n    {\n\tchar_u\t    *path = fnames[i];\n\tint\t    is_in_curdir;\n\tchar_u\t    *dir_end = gettail_dir(path);\n\tchar_u\t    *pathsep_p;\n\tchar_u\t    *path_cutoff;\n\n\tlen = (int)STRLEN(path);\n\tis_in_curdir = fnamencmp(curdir, path, dir_end - path) == 0\n\t\t\t\t\t     && curdir[dir_end - path] == NUL;\n\tif (is_in_curdir)\n\t    in_curdir[i] = vim_strsave(path);\n\n\t// Shorten the filename while maintaining its uniqueness\n\tpath_cutoff = get_path_cutoff(path, &path_ga);\n\n\t// Don't assume all files can be reached without path when search\n\t// pattern starts with star star slash, so only remove path_cutoff\n\t// when possible.\n\tif (pattern[0] == '*' && pattern[1] == '*'\n\t\t&& vim_ispathsep_nocolon(pattern[2])\n\t\t&& path_cutoff != NULL\n\t\t&& vim_regexec(&regmatch, path_cutoff, (colnr_T)0)\n\t\t&& is_unique(path_cutoff, gap, i))\n\t{\n\t    sort_again = TRUE;\n\t    mch_memmove(path, path_cutoff, STRLEN(path_cutoff) + 1);\n\t}\n\telse\n\t{\n\t    // Here all files can be reached without path, so get shortest\n\t    // unique path.  We start at the end of the path.\n\t    pathsep_p = path + len - 1;\n\n\t    while (find_previous_pathsep(path, &pathsep_p))\n\t\tif (vim_regexec(&regmatch, pathsep_p + 1, (colnr_T)0)\n\t\t\t&& is_unique(pathsep_p + 1, gap, i)\n\t\t\t&& path_cutoff != NULL && pathsep_p + 1 >= path_cutoff)\n\t\t{\n\t\t    sort_again = TRUE;\n\t\t    mch_memmove(path, pathsep_p + 1, STRLEN(pathsep_p));\n\t\t    break;\n\t\t}\n\t}\n\n\tif (mch_isFullName(path))\n\t{\n\t    /*\n\t     * Last resort: shorten relative to curdir if possible.\n\t     * 'possible' means:\n\t     * 1. It is under the current directory.\n\t     * 2. The result is actually shorter than the original.\n\t     *\n\t     *\t    Before\t\t  curdir\tAfter\n\t     *\t    /foo/bar/file.txt\t  /foo/bar\t./file.txt\n\t     *\t    c:\\foo\\bar\\file.txt   c:\\foo\\bar\t.\\file.txt\n\t     *\t    /file.txt\t\t  /\t\t/file.txt\n\t     *\t    c:\\file.txt\t\t  c:\\\t\t.\\file.txt\n\t     */\n\t    short_name = shorten_fname(path, curdir);\n\t    if (short_name != NULL && short_name > path + 1\n# if defined(MSWIN)\n\t\t    // On windows,\n\t\t    //\t    shorten_fname(\"c:\\a\\a.txt\", \"c:\\a\\b\")\n\t\t    // returns \"\\a\\a.txt\", which is not really the short\n\t\t    // name, hence:\n\t\t    && !vim_ispathsep(*short_name)\n# endif\n\t\t)\n\t    {\n\t\tSTRCPY(path, \".\");\n\t\tadd_pathsep(path);\n\t\tSTRMOVE(path + STRLEN(path), short_name);\n\t    }\n\t}\n\tui_breakcheck();\n    }\n\n    // Shorten filenames in /in/current/directory/{filename}\n    for (i = 0; i < gap->ga_len && !got_int; i++)\n    {\n\tchar_u *rel_path;\n\tchar_u *path = in_curdir[i];\n\n\tif (path == NULL)\n\t    continue;\n\n\t// If the {filename} is not unique, change it to ./{filename}.\n\t// Else reduce it to {filename}\n\tshort_name = shorten_fname(path, curdir);\n\tif (short_name == NULL)\n\t    short_name = path;\n\tif (is_unique(short_name, gap, i))\n\t{\n\t    STRCPY(fnames[i], short_name);\n\t    continue;\n\t}\n\n\trel_path = alloc(STRLEN(short_name) + STRLEN(PATHSEPSTR) + 2);\n\tif (rel_path == NULL)\n\t    goto theend;\n\tSTRCPY(rel_path, \".\");\n\tadd_pathsep(rel_path);\n\tSTRCAT(rel_path, short_name);\n\n\tvim_free(fnames[i]);\n\tfnames[i] = rel_path;\n\tsort_again = TRUE;\n\tui_breakcheck();\n    }\n\ntheend:\n    vim_free(curdir);\n    if (in_curdir != NULL)\n    {\n\tfor (i = 0; i < gap->ga_len; i++)\n\t    vim_free(in_curdir[i]);\n\tvim_free(in_curdir);\n    }\n    ga_clear_strings(&path_ga);\n    vim_regfree(regmatch.regprog);\n\n    if (sort_again)\n\tremove_duplicates(gap);\n}", "target": 0, "cwe": ["CWE-122"], "project": "vim", "commit_id": "615ddd5342b50a6878a907062aa471740bd9a847", "hash": 125369603072129542171942984978614712719, "size": 175, "message": "patch 8.2.3611: crash when using CTRL-W f without finding a file name\n\nProblem:    Crash when using CTRL-W f without finding a file name.\nSolution:   Bail out when the file name length is zero.", "idx": 436}
{"func": "PHP_FUNCTION(locale_get_display_language) \n{\n    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}", "target": 1, "cwe": ["CWE-125"], "project": "php-src", "commit_id": "97eff7eb57fc2320c267a949cffd622c38712484", "hash": 226787271916824066872465354677338710463, "size": 4, "message": "Fix bug #72241: get_icu_value_internal out-of-bounds read", "idx": 437}
{"func": "static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)\n{\n\treturn __htab_lru_map_lookup_elem(map, key, false);\n}", "target": 0, "cwe": ["CWE-787"], "project": "bpf", "commit_id": "c4eb1f403243fc7bbb7de644db8587c03de36da6", "hash": 223310460622647660482945984217044538089, "size": 4, "message": "bpf: Fix integer overflow involving bucket_size\n\nIn __htab_map_lookup_and_delete_batch(), hash buckets are iterated\nover to count the number of elements in each bucket (bucket_size).\nIf bucket_size is large enough, the multiplication to calculate\nkvmalloc() size could overflow, resulting in out-of-bounds write\nas reported by KASAN:\n\n  [...]\n  [  104.986052] BUG: KASAN: vmalloc-out-of-bounds in __htab_map_lookup_and_delete_batch+0x5ce/0xb60\n  [  104.986489] Write of size 4194224 at addr ffffc9010503be70 by task crash/112\n  [  104.986889]\n  [  104.987193] CPU: 0 PID: 112 Comm: crash Not tainted 5.14.0-rc4 #13\n  [  104.987552] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\n  [  104.988104] Call Trace:\n  [  104.988410]  dump_stack_lvl+0x34/0x44\n  [  104.988706]  print_address_description.constprop.0+0x21/0x140\n  [  104.988991]  ? __htab_map_lookup_and_delete_batch+0x5ce/0xb60\n  [  104.989327]  ? __htab_map_lookup_and_delete_batch+0x5ce/0xb60\n  [  104.989622]  kasan_report.cold+0x7f/0x11b\n  [  104.989881]  ? __htab_map_lookup_and_delete_batch+0x5ce/0xb60\n  [  104.990239]  kasan_check_range+0x17c/0x1e0\n  [  104.990467]  memcpy+0x39/0x60\n  [  104.990670]  __htab_map_lookup_and_delete_batch+0x5ce/0xb60\n  [  104.990982]  ? __wake_up_common+0x4d/0x230\n  [  104.991256]  ? htab_of_map_free+0x130/0x130\n  [  104.991541]  bpf_map_do_batch+0x1fb/0x220\n  [...]\n\nIn hashtable, if the elements' keys have the same jhash() value, the\nelements will be put into the same bucket. By putting a lot of elements\ninto a single bucket, the value of bucket_size can be increased to\ntrigger the integer overflow.\n\nTriggering the overflow is possible for both callers with CAP_SYS_ADMIN\nand callers without CAP_SYS_ADMIN.\n\nIt will be trivial for a caller with CAP_SYS_ADMIN to intentionally\nreach this overflow by enabling BPF_F_ZERO_SEED. As this flag will set\nthe random seed passed to jhash() to 0, it will be easy for the caller\nto prepare keys which will be hashed into the same value, and thus put\nall the elements into the same bucket.\n\nIf the caller does not have CAP_SYS_ADMIN, BPF_F_ZERO_SEED cannot be\nused. However, it will be still technically possible to trigger the\noverflow, by guessing the random seed value passed to jhash() (32bit)\nand repeating the attempt to trigger the overflow. In this case,\nthe probability to trigger the overflow will be low and will take\na very long time.\n\nFix the integer overflow by calling kvmalloc_array() instead of\nkvmalloc() to allocate memory.\n\nFixes: 057996380a42 (\"bpf: Add batch ops to all htab bpf map\")\nSigned-off-by: Tatsuhiko Yasumatsu <th.yasumatsu@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nLink: https://lore.kernel.org/bpf/20210806150419.109658-1-th.yasumatsu@gmail.com", "idx": 438}
{"func": "static void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}", "target": 0, "cwe": ["CWE-20"], "project": "linux", "commit_id": "8d0c2d10dd72c5292eda7a06231056a4c972e4cc", "hash": 168188570541055847218480397174125158658, "size": 27, "message": "ext3: Fix format string issues\n\next3_msg() takes the printk prefix as the second parameter and the\nformat string as the third parameter. Two callers of ext3_msg omit the\nprefix and pass the format string as the second parameter and the first\nparameter to the format string as the third parameter. In both cases\nthis string comes from an arbitrary source. Which means the string may\ncontain format string characters, which will\nlead to undefined and potentially harmful behavior.\n\nThe issue was introduced in commit 4cf46b67eb(\"ext3: Unify log messages\nin ext3\") and is fixed by this patch.\n\nCC: stable@vger.kernel.org\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nSigned-off-by: Jan Kara <jack@suse.cz>", "idx": 439}
{"func": "static int display_sync(void *handle, void *device)\n{\n    IMAGE *img = image_find(handle, device);\n    int color;\n    int depth;\n    int endian;\n    int native555;\n    int alpha;\n    if (img == NULL)\n        return -1;\n\n    color = img->format & DISPLAY_COLORS_MASK;\n    depth = img->format & DISPLAY_DEPTH_MASK;\n    endian = img->format & DISPLAY_ENDIAN_MASK;\n    native555 = img->format & DISPLAY_555_MASK;\n    alpha = img->format & DISPLAY_ALPHA_MASK;\n\n    if ((color == DISPLAY_COLORS_CMYK) ||\n        (color == DISPLAY_COLORS_SEPARATION)) {\n        /* check if separations have changed */\n        int i;\n        gchar *str;\n        for (i=0; i<IMAGE_DEVICEN_MAX; i++) {\n            gtk_label_get(\n                GTK_LABEL(GTK_BIN(img->separation[i])->child), &str);\n            if (!img->devicen[i].used)\n                gtk_widget_hide(img->separation[i]);\n            else if (strcmp(img->devicen[i].name, str) != 0) {\n                /* text has changed, update it */\n                gtk_label_set_text(\n                    GTK_LABEL(GTK_BIN(img->separation[i])->child),\n                    img->devicen[i].name);\n                gtk_widget_show(img->separation[i]);\n            }\n        }\n    }\n\n    /* some formats need to be converted for use by GdkRgb */\n    switch (color) {\n        case DISPLAY_COLORS_NATIVE:\n            if (depth == DISPLAY_DEPTH_16) {\n              if (endian == DISPLAY_LITTLEENDIAN) {\n                if (native555 == DISPLAY_NATIVE_555) {\n                    /* BGR555 */\n                    int x, y;\n                    unsigned short w;\n                    unsigned char value;\n                    unsigned char *s, *d;\n                    for (y = 0; y<img->height; y++) {\n                        s = img->buf + y * img->rowstride;\n                        d = img->rgbbuf + y * img->width * 3;\n                        for (x=0; x<img->width; x++) {\n                            w = s[0] + (s[1] << 8);\n                            value = (w >> 10) & 0x1f;\t/* red */\n                            *d++ = (value << 3) + (value >> 2);\n                            value = (w >> 5) & 0x1f;\t/* green */\n                            *d++ = (value << 3) + (value >> 2);\n                            value = w & 0x1f;\t\t/* blue */\n                            *d++ = (value << 3) + (value >> 2);\n                            s += 2;\n                        }\n                    }\n                }\n                else {\n                    /* BGR565 */\n                    int x, y;\n                    unsigned short w;\n                    unsigned char value;\n                    unsigned char *s, *d;\n                    for (y = 0; y<img->height; y++) {\n                        s = img->buf + y * img->rowstride;\n                        d = img->rgbbuf + y * img->width * 3;\n                        for (x=0; x<img->width; x++) {\n                            w = s[0] + (s[1] << 8);\n                            value = (w >> 11) & 0x1f;\t/* red */\n                            *d++ = (value << 3) + (value >> 2);\n                            value = (w >> 5) & 0x3f;\t/* green */\n                            *d++ = (value << 2) + (value >> 4);\n                            value = w & 0x1f;\t\t/* blue */\n                            *d++ = (value << 3) + (value >> 2);\n                            s += 2;\n                        }\n                    }\n                }\n              }\n              else {\n                if (native555 == DISPLAY_NATIVE_555) {\n                    /* RGB555 */\n                    int x, y;\n                    unsigned short w;\n                    unsigned char value;\n                    unsigned char *s, *d;\n                    for (y = 0; y<img->height; y++) {\n                        s = img->buf + y * img->rowstride;\n                        d = img->rgbbuf + y * img->width * 3;\n                        for (x=0; x<img->width; x++) {\n                            w = s[1] + (s[0] << 8);\n                            value = (w >> 10) & 0x1f;\t/* red */\n                            *d++ = (value << 3) + (value >> 2);\n                            value = (w >> 5) & 0x1f;\t/* green */\n                            *d++ = (value << 3) + (value >> 2);\n                            value = w & 0x1f;\t\t/* blue */\n                            *d++ = (value << 3) + (value >> 2);\n                            s += 2;\n                        }\n                    }\n                }\n                else {\n                    /* RGB565 */\n                    int x, y;\n                    unsigned short w;\n                    unsigned char value;\n                    unsigned char *s, *d;\n                    for (y = 0; y<img->height; y++) {\n                        s = img->buf + y * img->rowstride;\n                        d = img->rgbbuf + y * img->width * 3;\n                        for (x=0; x<img->width; x++) {\n                            w = s[1] + (s[0] << 8);\n                            value = (w >> 11) & 0x1f;\t/* red */\n                            *d++ = (value << 3) + (value >> 2);\n                            value = (w >> 5) & 0x3f;\t/* green */\n                            *d++ = (value << 2) + (value >> 4);\n                            value = w & 0x1f;\t\t/* blue */\n                            *d++ = (value << 3) + (value >> 2);\n                            s += 2;\n                        }\n                    }\n                }\n              }\n            }\n            break;\n        case DISPLAY_COLORS_RGB:\n            if ( (depth == DISPLAY_DEPTH_8) &&\n                 ((alpha == DISPLAY_ALPHA_FIRST) ||\n                  (alpha == DISPLAY_UNUSED_FIRST)) &&\n                 (endian == DISPLAY_BIGENDIAN) ) {\n                /* Mac format */\n                int x, y;\n                unsigned char *s, *d;\n                for (y = 0; y<img->height; y++) {\n                    s = img->buf + y * img->rowstride;\n                    d = img->rgbbuf + y * img->width * 3;\n                    for (x=0; x<img->width; x++) {\n                        s++;\t\t/* x = filler */\n                        *d++ = *s++;\t/* r */\n                        *d++ = *s++;\t/* g */\n                        *d++ = *s++;\t/* b */\n                    }\n                }\n            }\n            else if ( (depth == DISPLAY_DEPTH_8) &&\n                      (endian == DISPLAY_LITTLEENDIAN) ) {\n                if ((alpha == DISPLAY_UNUSED_LAST) ||\n                    (alpha == DISPLAY_ALPHA_LAST)) {\n                    /* Windows format + alpha = BGRx */\n                    int x, y;\n                    unsigned char *s, *d;\n                    for (y = 0; y<img->height; y++) {\n                        s = img->buf + y * img->rowstride;\n                        d = img->rgbbuf + y * img->width * 3;\n                        for (x=0; x<img->width; x++) {\n                            *d++ = s[2];\t/* r */\n                            *d++ = s[1];\t/* g */\n                            *d++ = s[0];\t/* b */\n                            s += 4;\n                        }\n                    }\n                }\n                else if ((alpha == DISPLAY_UNUSED_FIRST) ||\n                    (alpha == DISPLAY_ALPHA_FIRST)) {\n                    /* xBGR */\n                    int x, y;\n                    unsigned char *s, *d;\n                    for (y = 0; y<img->height; y++) {\n                        s = img->buf + y * img->rowstride;\n                        d = img->rgbbuf + y * img->width * 3;\n                        for (x=0; x<img->width; x++) {\n                            *d++ = s[3];\t/* r */\n                            *d++ = s[2];\t/* g */\n                            *d++ = s[1];\t/* b */\n                            s += 4;\n                        }\n                    }\n                }\n                else {\n                    /* Windows BGR24 */\n                    int x, y;\n                    unsigned char *s, *d;\n                    for (y = 0; y<img->height; y++) {\n                        s = img->buf + y * img->rowstride;\n                        d = img->rgbbuf + y * img->width * 3;\n                        for (x=0; x<img->width; x++) {\n                            *d++ = s[2];\t/* r */\n                            *d++ = s[1];\t/* g */\n                            *d++ = s[0];\t/* b */\n                            s += 3;\n                        }\n                    }\n                }\n            }\n            break;\n        case DISPLAY_COLORS_CMYK:\n            if (depth == DISPLAY_DEPTH_8) {\n                /* Separations */\n                int x, y;\n                int cyan, magenta, yellow, black;\n                unsigned char *s, *d;\n                int vc = img->devicen[0].visible;\n                int vm = img->devicen[1].visible;\n                int vy = img->devicen[2].visible;\n                int vk = img->devicen[3].visible;\n                int vall = vc && vm && vy && vk;\n                int show_gray = (vc + vm + vy + vk == 1) && img->devicen_gray;\n                for (y = 0; y<img->height; y++) {\n                    s = img->buf + y * img->rowstride;\n                    d = img->rgbbuf + y * img->width * 3;\n                    for (x=0; x<img->width; x++) {\n                        cyan = *s++;\n                        magenta = *s++;\n                        yellow = *s++;\n                        black = *s++;\n                        if (!vall) {\n                            if (!vc)\n                                cyan = 0;\n                            if (!vm)\n                                magenta = 0;\n                            if (!vy)\n                                yellow = 0;\n                            if (!vk)\n                                black = 0;\n                            if (show_gray) {\n                                black += cyan + magenta + yellow;\n                                cyan = magenta = yellow = 0;\n                            }\n                        }\n                        *d++ = (255-cyan)    * (255-black) / 255; /* r */\n                        *d++ = (255-magenta) * (255-black) / 255; /* g */\n                        *d++ = (255-yellow)  * (255-black) / 255; /* b */\n                    }\n                }\n            }\n            else if (depth == DISPLAY_DEPTH_1) {\n                /* Separations */\n                int x, y;\n                int cyan, magenta, yellow, black;\n                unsigned char *s, *d;\n                int vc = img->devicen[0].visible;\n                int vm = img->devicen[1].visible;\n                int vy = img->devicen[2].visible;\n                int vk = img->devicen[3].visible;\n                int vall = vc && vm && vy && vk;\n                int show_gray = (vc + vm + vy + vk == 1) && img->devicen_gray;\n                int value;\n                for (y = 0; y<img->height; y++) {\n                    s = img->buf + y * img->rowstride;\n                    d = img->rgbbuf + y * img->width * 3;\n                    for (x=0; x<img->width; x++) {\n                        value = s[x/2];\n                        if (x & 0)\n                            value >>= 4;\n                        cyan = ((value >> 3) & 1) * 255;\n                        magenta = ((value >> 2) & 1) * 255;\n                        yellow = ((value >> 1) & 1) * 255;\n                        black = (value & 1) * 255;\n                        if (!vall) {\n                            if (!vc)\n                                cyan = 0;\n                            if (!vm)\n                                magenta = 0;\n                            if (!vy)\n                                yellow = 0;\n                            if (!vk)\n                                black = 0;\n                            if (show_gray) {\n                                black += cyan + magenta + yellow;\n                                cyan = magenta = yellow = 0;\n                            }\n                        }\n                        *d++ = (255-cyan)    * (255-black) / 255; /* r */\n                        *d++ = (255-magenta) * (255-black) / 255; /* g */\n                        *d++ = (255-yellow)  * (255-black) / 255; /* b */\n                    }\n                }\n            }\n            break;\n        case DISPLAY_COLORS_SEPARATION:\n            if (depth == DISPLAY_DEPTH_8) {\n                int j;\n                int x, y;\n                unsigned char *s, *d;\n                int cyan, magenta, yellow, black;\n                int num_comp = 0;\n                int value;\n                int num_visible = 0;\n                int show_gray = 0;\n                IMAGE_DEVICEN *devicen = img->devicen;\n                for (j=0; j<IMAGE_DEVICEN_MAX; j++) {\n                    if (img->devicen[j].used) {\n                       num_comp = j+1;\n                       if (img->devicen[j].visible)\n                            num_visible++;\n                    }\n                }\n                if ((num_visible == 1) && img->devicen_gray)\n                    show_gray = 1;\n\n                for (y = 0; y<img->height; y++) {\n                    s = img->buf + y * img->rowstride;\n                    d = img->rgbbuf + y * img->width * 3;\n                    for (x=0; x<img->width; x++) {\n                        cyan = magenta = yellow = black = 0;\n                        if (show_gray) {\n                            for (j=0; j<num_comp; j++) {\n                                devicen = &img->devicen[j];\n                                if (devicen->visible && devicen->used)\n                                    black += s[j];\n                            }\n                        }\n                        else {\n                            for (j=0; j<num_comp; j++) {\n                                devicen = &img->devicen[j];\n                                if (devicen->visible && devicen->used) {\n                                    value = s[j];\n                                    cyan    += value*devicen->cyan   /65535;\n                                    magenta += value*devicen->magenta/65535;\n                                    yellow  += value*devicen->yellow /65535;\n                                    black   += value*devicen->black  /65535;\n                                }\n                            }\n                        }\n                        if (cyan > 255)\n                           cyan = 255;\n                        if (magenta > 255)\n                           magenta = 255;\n                        if (yellow > 255)\n                           yellow = 255;\n                        if (black > 255)\n                           black = 255;\n                        *d++ = (255-cyan)    * (255-black) / 255; /* r */\n                        *d++ = (255-magenta) * (255-black) / 255; /* g */\n                        *d++ = (255-yellow)  * (255-black) / 255; /* b */\n                        s += 8;\n                    }\n                }\n            }\n            break;\n    }\n\n    if (img->window == NULL) {\n        window_create(img);\n        window_resize(img);\n    }\n    if (!(GTK_WIDGET_FLAGS(img->window) & GTK_VISIBLE))\n        gtk_widget_show_all(img->window);\n\n    gtk_widget_draw(img->darea, NULL);\n    gtk_main_iteration_do(FALSE);\n    return 0;\n}", "target": 1, "cwe": [], "project": "ghostpdl", "commit_id": "514595fc2cc84f51efdef563cf7a35a0050902e5", "hash": 7456660978652416369151146220649255638, "size": 359, "message": "Bug 693038 - allow gsx to build against GTK+ 3.x\n\nPatch from galtgendo@gmail.com applied with changes to maintain compatibility\nwith GTK+ 2.x, and replace a function deprecated in GTK+ 3.x.\n\nThis patch drops GTK+ 1.x support.\n\nNo cluster differences.", "idx": 440}
{"func": "choose_windows(s)\nconst char *s;\n{\n    register int i;\n\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        /* early config file error processing routines call this */\n        windowprocs.win_wait_synch = def_wait_synch;\n\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}", "target": 1, "cwe": ["CWE-120", "CWE-269"], "project": "NetHack", "commit_id": "f3def5c0b999478da2d0a8f0b6a7c370a2065f77", "hash": 320921142868955803794641399394460182772, "size": 58, "message": "command line triggered buffer overruns\n\nPrevent extremely long command line arguments from overflowing local\nbuffers in raw_printf or config_error_add.  The increased buffer\nsizes they recently got to deal with long configuration file values\naren't sufficient to handle command line induced overflows.\n\nchoose_windows(core): copy and truncate the window_type argument in\ncase it gets passed to config_error_add().\n\nprocess_options(unix): report bad values with \"%.60s\" so that vsprintf\nwill implicitly truncate when formatted by raw_printf().", "idx": 441}
{"func": "static int read_pack_info_file(const char *infofile)\n{\n\tFILE *fp;\n\tchar line[1000];\n\tint old_cnt = 0;\n\n\tfp = fopen(infofile, \"r\");\n\tif (!fp)\n\t\treturn 1; /* nonexistent is not an error. */\n\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tint len = strlen(line);\n\t\tif (len && line[len-1] == '\\n')\n\t\t\tline[--len] = 0;\n\n\t\tif (!len)\n\t\t\tcontinue;\n\n\t\tswitch (line[0]) {\n\t\tcase 'P': /* P name */\n\t\t\tif (parse_pack_def(line, old_cnt++))\n\t\t\t\tgoto out_stale;\n\t\t\tbreak;\n\t\tcase 'D': /* we used to emit D but that was misguided. */\n\t\t\tgoto out_stale;\n\t\t\tbreak;\n\t\tcase 'T': /* we used to emit T but nobody uses it. */\n\t\t\tgoto out_stale;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"unrecognized: %s\", line);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\treturn 0;\n out_stale:\n\tfclose(fp);\n\treturn 1;\n}", "target": 1, "cwe": [], "project": "git", "commit_id": "c173dad58787a7f11a526dbcdaa5a2fe9ff1c87f", "hash": 58635535560331124079362957806519639232, "size": 40, "message": "update-server-info: Shorten read_pack_info_file()\n\nThe correct responses to a D and a T line in .git/objects/info/packs\nare the same, so combine their case arms.  In both cases we already\n‘goto’ out of the switch so while at it, remove a redundant ‘break’\nto avoid yet another line of code.\n\nSigned-off-by: Ralf Thielow <ralf.thielow@googlemail.com>\nReviewed-by: Jonathan Nieder <jrnieder <at> gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>", "idx": 442}
{"func": "static void wake_futex(struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\t/*\n\t * We set q->lock_ptr = NULL _before_ we wake up the task. If\n\t * a non futex wake up happens on another CPU then the task\n\t * might exit and p would dereference a non existing task\n\t * struct. Prevent this by holding a reference on p across the\n\t * wake up.\n\t */\n\tget_task_struct(p);\n\n\tplist_del(&q->list, &q->list.plist);\n\t/*\n\t * The waiting task can free the futex_q as soon as\n\t * q->lock_ptr = NULL is written, without taking any locks. A\n\t * memory barrier is required here to prevent the following\n\t * store to lock_ptr from getting ahead of the plist_del.\n\t */\n\tsmp_wmb();\n\tq->lock_ptr = NULL;\n\n\twake_up_state(p, TASK_NORMAL);\n\tput_task_struct(p);\n}", "target": 0, "cwe": [], "project": "linux-2.6", "commit_id": "5ecb01cfdf96c5f465192bdb2a4fd4a61a24c6cc", "hash": 326625725873245469593807385295285218560, "size": 26, "message": "futex_lock_pi() key refcnt fix\n\nThis fixes a futex key reference count bug in futex_lock_pi(),\nwhere a key's reference count is incremented twice but decremented\nonly once, causing the backing object to not be released.\n\nIf the futex is created in a temporary file in an ext3 file system,\nthis bug causes the file's inode to become an \"undead\" orphan,\nwhich causes an oops from a BUG_ON() in ext3_put_super() when the\nfile system is unmounted. glibc's test suite is known to trigger this,\nsee <http://bugzilla.kernel.org/show_bug.cgi?id=14256>.\n\nThe bug is a regression from 2.6.28-git3, namely Peter Zijlstra's\n38d47c1b7075bd7ec3881141bb3629da58f88dab \"[PATCH] futex: rely on\nget_user_pages() for shared futexes\". That commit made get_futex_key()\nalso increment the reference count of the futex key, and updated its\ncallers to decrement the key's reference count before returning.\nUnfortunately the normal exit path in futex_lock_pi() wasn't corrected:\nthe reference count is incremented by get_futex_key() and queue_lock(),\nbut the normal exit path only decrements once, via unqueue_me_pi().\nThe fix is to put_futex_key() after unqueue_me_pi(), since 2.6.31\nthis is easily done by 'goto out_put_key' rather than 'goto out'.\n\nSigned-off-by: Mikael Pettersson <mikpe@it.uu.se>\nAcked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nAcked-by: Darren Hart <dvhltc@us.ibm.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: <stable@kernel.org>", "idx": 443}
{"func": "static int duplicate_search_and_fix(e2fsck_t ctx, ext2_filsys fs,\n\t\t\t\t    ext2_ino_t ino,\n\t\t\t\t    struct fill_dir_struct *fd)\n{\n\tstruct problem_context\tpctx;\n\tstruct hash_entry \t*ent, *prev;\n\tint\t\t\ti, j;\n\tint\t\t\tfixed = 0;\n\tchar\t\t\tnew_name[256];\n\tunsigned int\t\tnew_len;\n\tint\t\t\thash_alg;\n\tint hash_flags = fd->inode->i_flags & EXT4_CASEFOLD_FL;\n\n\tclear_problem_context(&pctx);\n\tpctx.ino = ino;\n\n\thash_alg = fs->super->s_def_hash_version;\n\tif ((hash_alg <= EXT2_HASH_TEA) &&\n\t    (fs->super->s_flags & EXT2_FLAGS_UNSIGNED_HASH))\n\t\thash_alg += 3;\n\n\tfor (i=1; i < fd->num_array; i++) {\n\t\tent = fd->harray + i;\n\t\tprev = ent - 1;\n\t\tif (!ent->dir->inode ||\n\t\t    (ext2fs_dirent_name_len(ent->dir) !=\n\t\t     ext2fs_dirent_name_len(prev->dir)) ||\n\t\t    memcmp(ent->dir->name, prev->dir->name,\n\t\t\t     ext2fs_dirent_name_len(ent->dir)))\n\t\t\tcontinue;\n\t\tpctx.dirent = ent->dir;\n\t\tif ((ent->dir->inode == prev->dir->inode) &&\n\t\t    fix_problem(ctx, PR_2_DUPLICATE_DIRENT, &pctx)) {\n\t\t\te2fsck_adjust_inode_count(ctx, ent->dir->inode, -1);\n\t\t\tent->dir->inode = 0;\n\t\t\tfixed++;\n\t\t\tcontinue;\n\t\t}\n\t\tnew_len = ext2fs_dirent_name_len(ent->dir);\n\t\tmemcpy(new_name, ent->dir->name, new_len);\n\t\tmutate_name(new_name, &new_len);\n\t\tfor (j=0; j < fd->num_array; j++) {\n\t\t\tif ((i==j) ||\n\t\t\t    (new_len !=\n\t\t\t     (unsigned) ext2fs_dirent_name_len(fd->harray[j].dir)) ||\n\t\t\t    memcmp(new_name, fd->harray[j].dir->name, new_len))\n\t\t\t\tcontinue;\n\t\t\tmutate_name(new_name, &new_len);\n\n\t\t\tj = -1;\n\t\t}\n\t\tnew_name[new_len] = 0;\n\t\tpctx.str = new_name;\n\t\tif (fix_problem(ctx, PR_2_NON_UNIQUE_FILE, &pctx)) {\n\t\t\tmemcpy(ent->dir->name, new_name, new_len);\n\t\t\text2fs_dirent_set_name_len(ent->dir, new_len);\n\t\t\text2fs_dirhash2(hash_alg, new_name, new_len,\n\t\t\t\t\tfs->encoding, hash_flags,\n\t\t\t\t\tfs->super->s_hash_seed,\n\t\t\t\t\t&ent->hash, &ent->minor_hash);\n\t\t\tfixed++;\n\t\t}\n\t}\n\treturn fixed;\n}", "target": 1, "cwe": ["CWE-787"], "project": "e2fsprogs", "commit_id": "8dd73c149f418238f19791f9d666089ef9734dff", "hash": 290741365850892730453380515669535617439, "size": 65, "message": "e2fsck: abort if there is a corrupted directory block when rehashing\n\nIn e2fsck pass 3a, when we are rehashing directories, at least in\ntheory, all of the directories should have had corruptions with\nrespect to directory entry structure fixed.  However, it's possible\n(for example, if the user declined a fix) that we can reach this stage\nof processing with a corrupted directory entries.\n\nSo check for that case and don't try to process a corrupted directory\nblock so we don't run into trouble in mutate_name() if there is a\nzero-length file name.\n\nAddresses: TALOS-2019-0973\nAddresses: CVE-2019-5188\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>", "idx": 444}
{"func": "static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif (svm->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\t/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))\n\t\treturn -EBUSY;\n\n\treturn !svm_smi_blocked(vcpu);\n}", "target": 0, "cwe": ["CWE-862"], "project": "kvm", "commit_id": "0f923e07124df069ba68d8bb12324398f4b6b709", "hash": 328376124574643090870620956517979785010, "size": 12, "message": "KVM: nSVM: avoid picking up unsupported bits from L2 in int_ctl (CVE-2021-3653)\n\n* Invert the mask of bits that we pick from L2 in\n  nested_vmcb02_prepare_control\n\n* Invert and explicitly use VIRQ related bits bitmask in svm_clear_vintr\n\nThis fixes a security issue that allowed a malicious L1 to run L2 with\nAVIC enabled, which allowed the L2 to exploit the uninitialized and enabled\nAVIC to read/write the host physical memory at some offsets.\n\nFixes: 3d6368ef580a (\"KVM: SVM: Add VMRUN handler\")\nSigned-off-by: Maxim Levitsky <mlevitsk@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 445}
{"func": "int __init early_fixup_exception(unsigned long *ip)\n{\n\tconst struct exception_table_entry *fixup;\n\tunsigned long new_ip;\n\n\tfixup = search_exception_tables(*ip);\n\tif (fixup) {\n\t\tnew_ip = ex_fixup_addr(fixup);\n\n\t\tif (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {\n\t\t\t/* uaccess handling not supported during early boot */\n\t\t\treturn 0;\n\t\t}\n\n\t\t*ip = new_ip;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "project": "linux", "commit_id": "548acf19234dbda5a52d5a8e7e205af46e9da840", "hash": 134239428251173976933826690804855208675, "size": 20, "message": "x86/mm: Expand the exception table logic to allow new handling options\n\nHuge amounts of help from  Andy Lutomirski and Borislav Petkov to\nproduce this. Andy provided the inspiration to add classes to the\nexception table with a clever bit-squeezing trick, Boris pointed\nout how much cleaner it would all be if we just had a new field.\n\nLinus Torvalds blessed the expansion with:\n\n  ' I'd rather not be clever in order to save just a tiny amount of space\n    in the exception table, which isn't really criticial for anybody. '\n\nThe third field is another relative function pointer, this one to a\nhandler that executes the actions.\n\nWe start out with three handlers:\n\n 1: Legacy - just jumps the to fixup IP\n 2: Fault - provide the trap number in %ax to the fixup code\n 3: Cleaned up legacy for the uaccess error hack\n\nSigned-off-by: Tony Luck <tony.luck@intel.com>\nReviewed-by: Borislav Petkov <bp@suse.de>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nLink: http://lkml.kernel.org/r/f6af78fcbd348cf4939875cfda9c19689b5e50b8.1455732970.git.tony.luck@intel.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>", "idx": 446}
{"func": "tty_try_colour(struct tty *tty, int colour, const char *type)\n{\n\tu_char\tr, g, b;\n\tchar\ts[32];\n\n\tif (colour & COLOUR_FLAG_256) {\n\t\t/*\n\t\t * If the user has specified -2 to the client (meaning\n\t\t * TERM_256COLOURS is set), setaf and setab may not work (or\n\t\t * they may not want to use them), so send the usual sequence.\n\t\t *\n\t\t * Also if RGB is set, setaf and setab do not support the 256\n\t\t * colour palette so use the sequences directly there too.\n\t\t */\n\t\tif ((tty->term_flags & TERM_256COLOURS) ||\n\t\t    tty_term_has(tty->term, TTYC_RGB))\n\t\t\tgoto fallback_256;\n\n\t\t/*\n\t\t * If the terminfo entry has 256 colours and setaf and setab\n\t\t * exist, assume that they work correctly.\n\t\t */\n\t\tif (tty->term->flags & TERM_256COLOURS) {\n\t\t\tif (*type == '3') {\n\t\t\t\tif (!tty_term_has(tty->term, TTYC_SETAF))\n\t\t\t\t\tgoto fallback_256;\n\t\t\t\ttty_putcode1(tty, TTYC_SETAF, colour & 0xff);\n\t\t\t} else {\n\t\t\t\tif (!tty_term_has(tty->term, TTYC_SETAB))\n\t\t\t\t\tgoto fallback_256;\n\t\t\t\ttty_putcode1(tty, TTYC_SETAB, colour & 0xff);\n\t\t\t}\n\t\t\treturn (0);\n\t\t}\n\t\tgoto fallback_256;\n\t}\n\n\tif (colour & COLOUR_FLAG_RGB) {\n\t\tif (*type == '3') {\n\t\t\tif (!tty_term_has(tty->term, TTYC_SETRGBF))\n\t\t\t\treturn (-1);\n\t\t\tcolour_split_rgb(colour & 0xffffff, &r, &g, &b);\n\t\t\ttty_putcode3(tty, TTYC_SETRGBF, r, g, b);\n\t\t} else {\n\t\t\tif (!tty_term_has(tty->term, TTYC_SETRGBB))\n\t\t\t\treturn (-1);\n\t\t\tcolour_split_rgb(colour & 0xffffff, &r, &g, &b);\n\t\t\ttty_putcode3(tty, TTYC_SETRGBB, r, g, b);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n\nfallback_256:\n\txsnprintf(s, sizeof s, \"\\033[%s;5;%dm\", type, colour & 0xff);\n\tlog_debug(\"%s: 256 colour fallback: %s\", tty->client->name, s);\n\ttty_puts(tty, s);\n\treturn (0);\n}", "target": 0, "cwe": [], "project": "src", "commit_id": "b32e1d34e10a0da806823f57f02a4ae6e93d756e", "hash": 50699095897234665421401497521185692732, "size": 60, "message": "evbuffer_new and bufferevent_new can both fail (when malloc fails) and\nreturn NULL. GitHub issue 1547.", "idx": 447}
{"func": "PackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = NULL;\n        shstrtab = NULL;\n        if (e_shnum) {\n            unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);\n            if (e_shstrndx) {\n                if (e_shnum <= e_shstrndx) {\n                    char msg[40]; snprintf(msg, sizeof(msg),\n                        \"bad e_shstrndx %#x >= e_shnum %d\", e_shstrndx, e_shnum);\n                    throwCantPack(msg);\n                }\n                sec_strndx = &shdri[e_shstrndx];\n                upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset);\n                if ((u64_t)file_size <= sh_offset) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad .e_shstrndx->sh_offset %#lx\", (long unsigned)sh_offset);\n                    throwCantPack(msg);\n                }\n                shstrtab = (char const *)(sh_offset + file_image);\n            }\n            sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n            if (sec_dynsym) {\n                upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link);\n                if (e_shnum <= sh_link) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad SHT_DYNSYM.sh_link %#lx\", (long unsigned)sh_link);\n                }\n                sec_dynstr = &shdri[sh_link];\n            }\n\n            if (sec_strndx) {\n                unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n                || (u32_t)file_size <= (sizeof(\".shstrtab\")\n                    + sh_name + (shstrtab - (const char *)&file_image[0]))\n                || (sh_name\n                  && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n                ) {\n                    throwCantPack(\"bad e_shstrtab\");\n                }\n            }\n        }\n\n        Elf64_Phdr const *pload_x0(0);  // first eXecutable PT_LOAD\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n        }\n        else if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            if (!pload_x0\n            &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)\n            ) {\n                pload_x0 = phdr;\n            }\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");\n                goto abandon;\n            }\n            if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) {\n                // not explicitly PIE main program\n                if (Elf64_Ehdr::EM_AARCH64 == e_machine  // Android is common\n                &&  !opt->o_unix.android_shlib  // but not explicit\n                ) {\n                    opt->info_mode++;\n                    info(\"note: use --android-shlib if appropriate\");\n                    opt->info_mode--;\n                }\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        unsigned user_init_ava = get_te32(&shdr->sh_addr);\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        if ((u64_t)file_size <= user_init_off) {\n                            char msg[70]; snprintf(msg, sizeof(msg),\n                                \"bad Elf64_Shdr[%d].sh_offset %#x\",\n                                -1+ e_shnum - j, user_init_off);\n                            throwCantPack(msg);\n                        }\n                        // Check that &file_image[user_init_off] has\n                        // *_RELATIVE relocation, and fetch user_init_va.\n                        // If Elf64_Rela then the actual value is in Rela.r_addend.\n                        int z_rel = dt_table[Elf64_Dyn::DT_RELA];\n                        int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ];\n                        if (z_rel && z_rsz) {\n                            unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val);\n                            Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off];\n                            unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val);\n                            Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp);\n                            for (; rp < last; ++rp) {\n                                unsigned r_va = get_te64(&rp->r_offset);\n                                if (r_va == user_init_ava) { // found the Elf64_Rela\n                                    unsigned r_info = get_te64(&rp->r_info);\n                                    unsigned r_type = ELF64_R_TYPE(r_info);\n                                    if (Elf64_Ehdr::EM_AARCH64 == e_machine\n                                    &&  R_AARCH64_RELATIVE == r_type) {\n                                        user_init_va = get_te64(&rp->r_addend);\n                                    }\n                                    else if (Elf64_Ehdr::EM_AARCH64 == e_machine\n                                    &&  R_AARCH64_ABS64 == r_type) {\n                                        user_init_va = get_te64(&file_image[user_init_off]);\n                                    }\n                                    else {\n                                        char msg[50]; snprintf(msg, sizeof(msg),\n                                            \"bad relocation %#x DT_INIT_ARRAY[0]\",\n                                            r_info);\n                                        throwCantPack(msg);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        unsigned const p_filesz = get_te64(&pload_x0->p_filesz);\n                        if (!((user_init_va - xct_va) < p_filesz)) {\n                            // Not in executable portion of first executable PT_LOAD.\n                            if (0==user_init_va && opt->o_unix.android_shlib) {\n                                // Android allows (0 ==> skip) ?\n                                upx_dt_init = 0;  // force steal of 'extra' DT_NULL\n                                // XXX: FIXME: depends on SHT_DYNAMIC coming later\n                            }\n                            else {\n                                char msg[70]; snprintf(msg, sizeof(msg),\n                                    \"bad init address %#x in Elf64_Shdr[%d].%#x\\n\",\n                                    (unsigned)user_init_va, -1+ e_shnum - j, user_init_off);\n                                throwCantPack(msg);\n                            }\n                        }\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            unsigned y = 0;\n            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))\n            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))\n            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))\n            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))\n            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))\n            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))\n            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))\n            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) {\n                static char const *which[] = {\n                    \"unknown\",\n                    \"DT_GNU_HASH\",\n                    \"DT_HASH\",\n                    \"DT_STRTAB\",\n                    \"DT_SYMTAB\",\n                    \"DT_REL\",\n                    \"DT_RELA\",\n                    \"DT_JMPREL\",\n                    \"DT_VERDEF\",\n                    \"DT_VERSYM\",\n                    \"DT_VERNEEDED\",\n                };\n                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);\n                throwCantPack(buf);\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \"PT_NOTE %#lx above stub\", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%#lx\\n\",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}", "target": 1, "cwe": ["CWE-787"], "project": "upx", "commit_id": "4e2fdb464a885c694408552c31739cb04b77bdcf", "hash": 124963385580122857101681011773478449093, "size": 343, "message": "Defend against bad PT_DYNAMIC\n\nhttps://github.com/upx/upx/issues/391\n\tmodified:   p_lx_elf.cpp\n\tmodified:   p_lx_elf.h", "idx": 448}
{"func": "static int parse_uac_endpoint_attributes(struct snd_usb_audio *chip,\n\t\t\t\t\t struct usb_host_interface *alts,\n\t\t\t\t\t int protocol, int iface_no)\n{\n\t/* parsed with a v1 header here. that's ok as we only look at the\n\t * header first which is the same for both versions */\n\tstruct uac_iso_endpoint_descriptor *csep;\n\tstruct usb_interface_descriptor *altsd = get_iface_desc(alts);\n\tint attributes = 0;\n\n\tcsep = snd_usb_find_desc(alts->endpoint[0].extra, alts->endpoint[0].extralen, NULL, USB_DT_CS_ENDPOINT);\n\n\t/* Creamware Noah has this descriptor after the 2nd endpoint */\n\tif (!csep && altsd->bNumEndpoints >= 2)\n\t\tcsep = snd_usb_find_desc(alts->endpoint[1].extra, alts->endpoint[1].extralen, NULL, USB_DT_CS_ENDPOINT);\n\n\t/*\n\t * If we can't locate the USB_DT_CS_ENDPOINT descriptor in the extra\n\t * bytes after the first endpoint, go search the entire interface.\n\t * Some devices have it directly *before* the standard endpoint.\n\t */\n\tif (!csep)\n\t\tcsep = snd_usb_find_desc(alts->extra, alts->extralen, NULL, USB_DT_CS_ENDPOINT);\n\n\tif (!csep || csep->bLength < 7 ||\n\t    csep->bDescriptorSubtype != UAC_EP_GENERAL) {\n\t\tusb_audio_warn(chip,\n\t\t\t       \"%u:%d : no or invalid class specific endpoint descriptor\\n\",\n\t\t\t       iface_no, altsd->bAlternateSetting);\n\t\treturn 0;\n\t}\n\n\tif (protocol == UAC_VERSION_1) {\n\t\tattributes = csep->bmAttributes;\n\t} else {\n\t\tstruct uac2_iso_endpoint_descriptor *csep2 =\n\t\t\t(struct uac2_iso_endpoint_descriptor *) csep;\n\n\t\tattributes = csep->bmAttributes & UAC_EP_CS_ATTR_FILL_MAX;\n\n\t\t/* emulate the endpoint attributes of a v1 device */\n\t\tif (csep2->bmControls & UAC2_CONTROL_PITCH)\n\t\t\tattributes |= UAC_EP_CS_ATTR_PITCH_CONTROL;\n\t}\n\n\treturn attributes;\n}", "target": 0, "cwe": [], "project": "linux", "commit_id": "836b34a935abc91e13e63053d0a83b24dfb5ea78", "hash": 310930664381204961996778090992463405532, "size": 47, "message": "ALSA: usb-audio: Fix double-free in error paths after snd_usb_add_audio_stream() call\n\ncreate_fixed_stream_quirk(), snd_usb_parse_audio_interface() and\ncreate_uaxx_quirk() functions allocate the audioformat object by themselves\nand free it upon error before returning. However, once the object is linked\nto a stream, it's freed again in snd_usb_audio_pcm_free(), thus it'll be\ndouble-freed, eventually resulting in a memory corruption.\n\nThis patch fixes these failures in the error paths by unlinking the audioformat\nobject before freeing it.\n\nBased on a patch by Takashi Iwai <tiwai@suse.de>\n\n[Note for stable backports:\n this patch requires the commit 902eb7fd1e4a ('ALSA: usb-audio: Minor\n code cleanup in create_fixed_stream_quirk()')]\n\nBugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1283358\nReported-by: Ralf Spenneberg <ralf@spenneberg.net>\nCc: <stable@vger.kernel.org> # see the note above\nSigned-off-by: Vladis Dronov <vdronov@redhat.com>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "idx": 449}
{"func": "kadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_int32                  now;\n    krb5_tl_data                *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (entry == NULL)\n        return EINVAL;\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(kdb, 0, sizeof(*kdb));\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &polent, &have_polent);\n        if (ret)\n            goto cleanup;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = now + polent.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    if ((ret = kadm5_copy_principal(handle->context,\n                                    entry->principal, &(kdb->princ))))\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /*\n     * We need to have setup the TL data, so we have strings, so we can\n     * check enctype policy, which is why we check/initialize ks_tuple\n     * this late.\n     */\n    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto cleanup;\n\n    /* initialize the keys */\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (mask & KADM5_KEY_DATA) {\n        /* The client requested no keys for this principal. */\n        assert(entry->n_key_data == 0);\n    } else if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,\n                           new_n_ks_tuple, password,\n                           (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (mask & KADM5_POLICY) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                new_n_ks_tuple, new_ks_tuple, password);\n\ncleanup:\n    free(new_ks_tuple);\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}", "target": 1, "cwe": ["CWE-703"], "project": "krb5", "commit_id": "b863de7fbf080b15e347a736fdda0a82d42f4f6b", "hash": 292626093835870422312355520803032724139, "size": 221, "message": "Check for null kadm5 policy name [CVE-2015-8630]\n\nIn kadm5_create_principal_3() and kadm5_modify_principal(), check for\nentry->policy being null when KADM5_POLICY is included in the mask.\n\nCVE-2015-8630:\n\nIn MIT krb5 1.12 and later, an authenticated attacker with permission\nto modify a principal entry can cause kadmind to dereference a null\npointer by supplying a null policy value but including KADM5_POLICY in\nthe mask.\n\n    CVSSv2 Vector: AV:N/AC:H/Au:S/C:N/I:N/A:C/E:POC/RL:OF/RC:C\n\nticket: 8342 (new)\ntarget_version: 1.14-next\ntarget_version: 1.13-next\ntags: pullup", "idx": 450}
{"func": "OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t * p_j2k,\n                                  OPJ_UINT32 * p_tile_index,\n                                  OPJ_UINT32 * p_data_size,\n                                  OPJ_INT32 * p_tile_x0, OPJ_INT32 * p_tile_y0,\n                                  OPJ_INT32 * p_tile_x1, OPJ_INT32 * p_tile_y1,\n                                  OPJ_UINT32 * p_nb_comps,\n                                  OPJ_BOOL * p_go_on,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_current_marker = J2K_MS_SOT;\n    OPJ_UINT32 l_marker_size;\n    const opj_dec_memory_marker_handler_t * l_marker_handler = 00;\n    opj_tcp_t * l_tcp = NULL;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /* Reach the End Of Codestream ?*/\n    if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC) {\n        l_current_marker = J2K_MS_EOC;\n    }\n    /* We need to encounter a SOT marker (a new tile-part header) */\n    else if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) {\n        return OPJ_FALSE;\n    }\n\n    /* Read into the codestream until reach the EOC or ! can_decode ??? FIXME */\n    while ((!p_j2k->m_specific_param.m_decoder.m_can_decode) &&\n            (l_current_marker != J2K_MS_EOC)) {\n\n        /* Try to read until the Start Of Data is detected */\n        while (l_current_marker != J2K_MS_SOD) {\n\n            if (opj_stream_get_number_byte_left(p_stream) == 0) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                break;\n            }\n\n            /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n            if (opj_stream_read_data(p_stream,\n                                     p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Read 2 bytes from the buffer as the marker size */\n            opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data, &l_marker_size,\n                           2);\n\n            /* Check marker size (does not include marker ID but includes marker size) */\n            if (l_marker_size < 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Inconsistent marker size\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* cf. https://code.google.com/p/openjpeg/issues/detail?id=226 */\n            if (l_current_marker == 0x8080 &&\n                    opj_stream_get_number_byte_left(p_stream) == 0) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                break;\n            }\n\n            /* Why this condition? FIXME */\n            if (p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_TPH) {\n                p_j2k->m_specific_param.m_decoder.m_sot_length -= (l_marker_size + 2);\n            }\n            l_marker_size -= 2; /* Subtract the size of the marker ID already read */\n\n            /* Get the marker handler from the marker ID */\n            l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n\n            /* Check if the marker is known and if it is the right place to find it */\n            if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Marker is not compliant with its position\\n\");\n                return OPJ_FALSE;\n            }\n            /* FIXME manage case of unknown marker as in the main header ? */\n\n            /* Check if the marker size is compatible with the header data size */\n            if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {\n                OPJ_BYTE *new_header_data = NULL;\n                /* If we are here, this means we consider this marker as known & we will read it */\n                /* Check enough bytes left in stream before allocation */\n                if ((OPJ_OFF_T)l_marker_size >  opj_stream_get_number_byte_left(p_stream)) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Marker size inconsistent with stream length\\n\");\n                    return OPJ_FALSE;\n                }\n                new_header_data = (OPJ_BYTE *) opj_realloc(\n                                      p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);\n                if (! new_header_data) {\n                    opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                    p_j2k->m_specific_param.m_decoder.m_header_data = NULL;\n                    p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                    opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read header\\n\");\n                    return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;\n                p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;\n            }\n\n            /* Try to read the rest of the marker segment from stream and copy them into the buffer */\n            if (opj_stream_read_data(p_stream,\n                                     p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size,\n                                     p_manager) != l_marker_size) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n            }\n\n            if (!l_marker_handler->handler) {\n                /* See issue #175 */\n                opj_event_msg(p_manager, EVT_ERROR, \"Not sure how that happened.\\n\");\n                return OPJ_FALSE;\n            }\n            /* Read the marker segment with the correct marker handler */\n            if (!(*(l_marker_handler->handler))(p_j2k,\n                                                p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Fail to read the current marker segment (%#x)\\n\", l_current_marker);\n                return OPJ_FALSE;\n            }\n\n            /* Add the marker to the codestream index*/\n            if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,\n                                                  p_j2k->cstr_index,\n                                                  l_marker_handler->id,\n                                                  (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,\n                                                  l_marker_size + 4)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Keep the position of the last SOT marker read */\n            if (l_marker_handler->id == J2K_MS_SOT) {\n                OPJ_UINT32 sot_pos = (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4\n                                     ;\n                if (sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {\n                    p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = sot_pos;\n                }\n            }\n\n            if (p_j2k->m_specific_param.m_decoder.m_skip_data) {\n                /* Skip the rest of the tile part header*/\n                if (opj_stream_skip(p_stream, p_j2k->m_specific_param.m_decoder.m_sot_length,\n                                    p_manager) != p_j2k->m_specific_param.m_decoder.m_sot_length) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                    return OPJ_FALSE;\n                }\n                l_current_marker = J2K_MS_SOD; /* Normally we reached a SOD */\n            } else {\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/\n                if (opj_stream_read_data(p_stream,\n                                         p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                    return OPJ_FALSE;\n                }\n                /* Read 2 bytes from the buffer as the new marker ID */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                               &l_current_marker, 2);\n            }\n        }\n        if (opj_stream_get_number_byte_left(p_stream) == 0\n                && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {\n            break;\n        }\n\n        /* If we didn't skip data before, we need to read the SOD marker*/\n        if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {\n            /* Try to read the SOD marker and skip data ? FIXME */\n            if (! opj_j2k_read_sod(p_j2k, p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n            if (p_j2k->m_specific_param.m_decoder.m_can_decode &&\n                    !p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {\n                /* Issue 254 */\n                OPJ_BOOL l_correction_needed;\n\n                p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;\n                if (!opj_j2k_need_nb_tile_parts_correction(p_stream,\n                        p_j2k->m_current_tile_number, &l_correction_needed, p_manager)) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"opj_j2k_apply_nb_tile_parts_correction error\\n\");\n                    return OPJ_FALSE;\n                }\n                if (l_correction_needed) {\n                    OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n                    OPJ_UINT32 l_tile_no;\n\n                    p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n                    p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction = 1;\n                    /* correct tiles */\n                    for (l_tile_no = 0U; l_tile_no < l_nb_tiles; ++l_tile_no) {\n                        if (p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts != 0U) {\n                            p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts += 1;\n                        }\n                    }\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"Non conformant codestream TPsot==TNsot.\\n\");\n                }\n            }\n            if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n                if (opj_stream_read_data(p_stream,\n                                         p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                    return OPJ_FALSE;\n                }\n\n                /* Read 2 bytes from buffer as the new marker ID */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                               &l_current_marker, 2);\n            }\n        } else {\n            /* Indicate we will try to read a new tile-part header*/\n            p_j2k->m_specific_param.m_decoder.m_skip_data = 0;\n            p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n\n            /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n            if (opj_stream_read_data(p_stream,\n                                     p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Read 2 bytes from buffer as the new marker ID */\n            opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                           &l_current_marker, 2);\n        }\n    }\n\n    /* Current marker is the EOC marker ?*/\n    if (l_current_marker == J2K_MS_EOC) {\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;\n    }\n\n    /* FIXME DOC ???*/\n    if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {\n        OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;\n\n        while ((p_j2k->m_current_tile_number < l_nb_tiles) && (l_tcp->m_data == 00)) {\n            ++p_j2k->m_current_tile_number;\n            ++l_tcp;\n        }\n\n        if (p_j2k->m_current_tile_number == l_nb_tiles) {\n            *p_go_on = OPJ_FALSE;\n            return OPJ_TRUE;\n        }\n    }\n\n    if (! opj_j2k_merge_ppt(p_j2k->m_cp.tcps + p_j2k->m_current_tile_number,\n                            p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Failed to merge PPT data\\n\");\n        return OPJ_FALSE;\n    }\n    /*FIXME ???*/\n    if (! opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,\n                                   p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_event_msg(p_manager, EVT_INFO, \"Header of tile %d / %d has been read.\\n\",\n                  p_j2k->m_current_tile_number + 1, (p_j2k->m_cp.th * p_j2k->m_cp.tw));\n\n    *p_tile_index = p_j2k->m_current_tile_number;\n    *p_go_on = OPJ_TRUE;\n    *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);\n    if (*p_data_size == UINT_MAX) {\n        return OPJ_FALSE;\n    }\n    *p_tile_x0 = p_j2k->m_tcd->tcd_image->tiles->x0;\n    *p_tile_y0 = p_j2k->m_tcd->tcd_image->tiles->y0;\n    *p_tile_x1 = p_j2k->m_tcd->tcd_image->tiles->x1;\n    *p_tile_y1 = p_j2k->m_tcd->tcd_image->tiles->y1;\n    *p_nb_comps = p_j2k->m_tcd->tcd_image->tiles->numcomps;\n\n    p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_DATA;\n\n    return OPJ_TRUE;\n}", "target": 0, "cwe": ["CWE-416", "CWE-787"], "project": "openjpeg", "commit_id": "4241ae6fbbf1de9658764a80944dc8108f2b4154", "hash": 218209143537604198564213558214740042544, "size": 287, "message": "Fix assertion in debug mode / heap-based buffer overflow in opj_write_bytes_LE for Cinema profiles with numresolutions = 1 (#985)", "idx": 451}
{"func": "add_layers (const gint32  image_id,\n            PSDimage     *img_a,\n            PSDlayer    **lyr_a,\n            FILE         *f,\n            GError      **error)\n{\n  PSDchannel          **lyr_chn;\n  guchar               *pixels;\n  guint16               alpha_chn;\n  guint16               user_mask_chn;\n  guint16               layer_channels;\n  guint16               channel_idx[MAX_CHANNELS];\n  guint16              *rle_pack_len;\n  gint32                l_x;                   /* Layer x */\n  gint32                l_y;                   /* Layer y */\n  gint32                l_w;                   /* Layer width */\n  gint32                l_h;                   /* Layer height */\n  gint32                lm_x;                  /* Layer mask x */\n  gint32                lm_y;                  /* Layer mask y */\n  gint32                lm_w;                  /* Layer mask width */\n  gint32                lm_h;                  /* Layer mask height */\n  gint32                layer_size;\n  gint32                layer_id = -1;\n  gint32                mask_id = -1;\n  gint                  lidx;                  /* Layer index */\n  gint                  cidx;                  /* Channel index */\n  gint                  rowi;                  /* Row index */\n  gint                  coli;                  /* Column index */\n  gint                  i;\n  gboolean              alpha;\n  gboolean              user_mask;\n  gboolean              empty;\n  gboolean              empty_mask;\n  GimpDrawable         *drawable;\n  GimpPixelRgn          pixel_rgn;\n  GimpImageType         image_type;\n  GimpLayerModeEffects  layer_mode;\n\n\n  IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n  if (img_a->num_layers == 0)\n    {\n      IFDBG(2) g_debug (\"No layers to process\");\n      return 0;\n    }\n\n  /* Layered image - Photoshop 3 style */\n  if (fseek (f, img_a->layer_data_start, SEEK_SET) < 0)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n\n  for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n    {\n      IFDBG(2) g_debug (\"Process Layer No %d.\", lidx);\n\n      if (lyr_a[lidx]->drop)\n        {\n          IFDBG(2) g_debug (\"Drop layer %d\", lidx);\n\n          /* Step past layer data */\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (fseek (f, lyr_a[lidx]->chn_info[cidx].data_len, SEEK_CUR) < 0)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return -1;\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n          g_free (lyr_a[lidx]->name);\n        }\n\n      else\n        {\n          /* Empty layer */\n          if (lyr_a[lidx]->bottom - lyr_a[lidx]->top == 0\n              || lyr_a[lidx]->right - lyr_a[lidx]->left == 0)\n              empty = TRUE;\n          else\n              empty = FALSE;\n\n          /* Empty mask */\n          if (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top == 0\n              || lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left == 0)\n              empty_mask = TRUE;\n          else\n              empty_mask = FALSE;\n\n          IFDBG(3) g_debug (\"Empty mask %d, size %d %d\", empty_mask,\n                            lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top,\n                            lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);\n\n          /* Load layer channel data */\n          IFDBG(2) g_debug (\"Number of channels: %d\", lyr_a[lidx]->num_channels);\n          /* Create pointer array for the channel records */\n          lyr_chn = g_new (PSDchannel *, lyr_a[lidx]->num_channels);\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              guint16 comp_mode = PSD_COMP_RAW;\n\n              /* Allocate channel record */\n              lyr_chn[cidx] = g_malloc (sizeof (PSDchannel) );\n\n              lyr_chn[cidx]->id = lyr_a[lidx]->chn_info[cidx].channel_id;\n              lyr_chn[cidx]->rows = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n              lyr_chn[cidx]->columns = lyr_a[lidx]->right - lyr_a[lidx]->left;\n\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  /* Works around a bug in panotools psd files where the layer mask\n                     size is given as 0 but data exists. Set mask size to layer size.\n                  */\n                  if (empty_mask && lyr_a[lidx]->chn_info[cidx].data_len - 2 > 0)\n                    {\n                      empty_mask = FALSE;\n                      if (lyr_a[lidx]->layer_mask.top == lyr_a[lidx]->layer_mask.bottom)\n                        {\n                          lyr_a[lidx]->layer_mask.top = lyr_a[lidx]->top;\n                          lyr_a[lidx]->layer_mask.bottom = lyr_a[lidx]->bottom;\n                        }\n                      if (lyr_a[lidx]->layer_mask.right == lyr_a[lidx]->layer_mask.left)\n                        {\n                          lyr_a[lidx]->layer_mask.right = lyr_a[lidx]->right;\n                          lyr_a[lidx]->layer_mask.left = lyr_a[lidx]->left;\n                        }\n                    }\n                  lyr_chn[cidx]->rows = (lyr_a[lidx]->layer_mask.bottom -\n                                        lyr_a[lidx]->layer_mask.top);\n                  lyr_chn[cidx]->columns = (lyr_a[lidx]->layer_mask.right -\n                                           lyr_a[lidx]->layer_mask.left);\n                }\n\n              IFDBG(3) g_debug (\"Channel id %d, %dx%d\",\n                                lyr_chn[cidx]->id,\n                                lyr_chn[cidx]->columns,\n                                lyr_chn[cidx]->rows);\n\n              /* Only read channel data if there is any channel\n               * data. Note that the channel data can contain a\n               * compression method but no actual data.\n               */\n              if (lyr_a[lidx]->chn_info[cidx].data_len >= COMP_MODE_SIZE)\n                {\n                  if (fread (&comp_mode, COMP_MODE_SIZE, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return -1;\n                    }\n                  comp_mode = GUINT16_FROM_BE (comp_mode);\n                  IFDBG(3) g_debug (\"Compression mode: %d\", comp_mode);\n                }\n              if (lyr_a[lidx]->chn_info[cidx].data_len > COMP_MODE_SIZE)\n                {\n                  switch (comp_mode)\n                    {\n                      case PSD_COMP_RAW:        /* Planar raw data */\n                        IFDBG(3) g_debug (\"Raw data length: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2);\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RAW, NULL, f, error) < 1)\n                          return -1;\n                        break;\n\n                      case PSD_COMP_RLE:        /* Packbits */\n                        IFDBG(3) g_debug (\"RLE channel length %d, RLE length data: %d, \"\n                                          \"RLE data block: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2,\n                                          lyr_chn[cidx]->rows * 2,\n                                          (lyr_a[lidx]->chn_info[cidx].data_len - 2 -\n                                           lyr_chn[cidx]->rows * 2));\n                        rle_pack_len = g_malloc (lyr_chn[cidx]->rows * 2);\n                        for (rowi = 0; rowi < lyr_chn[cidx]->rows; ++rowi)\n                          {\n                            if (fread (&rle_pack_len[rowi], 2, 1, f) < 1)\n                              {\n                                psd_set_error (feof (f), errno, error);\n                                return -1;\n                              }\n                                rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);\n                          }\n\n                        IFDBG(3) g_debug (\"RLE decode - data\");\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RLE, rle_pack_len, f, error) < 1)\n                          return -1;\n\n                        g_free (rle_pack_len);\n                        break;\n\n                      case PSD_COMP_ZIP:                 /* ? */\n                      case PSD_COMP_ZIP_PRED:\n                      default:\n                        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                    _(\"Unsupported compression mode: %d\"), comp_mode);\n                        return -1;\n                        break;\n                    }\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n\n          /* Draw layer */\n\n          alpha = FALSE;\n          alpha_chn = -1;\n          user_mask = FALSE;\n          user_mask_chn = -1;\n          layer_channels = 0;\n          l_x = 0;\n          l_y = 0;\n          l_w = img_a->columns;\n          l_h = img_a->rows;\n\n          IFDBG(3) g_debug (\"Re-hash channel indices\");\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  user_mask = TRUE;\n                  user_mask_chn = cidx;\n                }\n              else if (lyr_chn[cidx]->id == PSD_CHANNEL_ALPHA)\n                {\n                  alpha = TRUE;\n                  alpha_chn = cidx;\n                }\n              else\n                {\n                  channel_idx[layer_channels] = cidx;   /* Assumes in sane order */\n                  layer_channels++;                     /* RGB, Lab, CMYK etc.   */\n                }\n            }\n          if (alpha)\n            {\n              channel_idx[layer_channels] = alpha_chn;\n              layer_channels++;\n            }\n\n          if (empty)\n            {\n              IFDBG(2) g_debug (\"Create blank layer\");\n              image_type = get_gimp_image_type (img_a->base_type, TRUE);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name,\n                                         img_a->columns, img_a->rows,\n                                         image_type, 0, GIMP_NORMAL_MODE);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_drawable_fill (drawable->drawable_id, GIMP_TRANSPARENT_FILL);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              if (lyr_a[lidx]->layer_flags.irrelevant)\n                gimp_drawable_set_visible (drawable->drawable_id, FALSE);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n            }\n          else\n            {\n              l_x = lyr_a[lidx]->left;\n              l_y = lyr_a[lidx]->top;\n              l_w = lyr_a[lidx]->right - lyr_a[lidx]->left;\n              l_h = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n\n              IFDBG(3) g_debug (\"Draw layer\");\n              image_type = get_gimp_image_type (img_a->base_type, alpha);\n              IFDBG(3) g_debug (\"Layer type %d\", image_type);\n              layer_size = l_w * l_h;\n              pixels = g_malloc (layer_size * layer_channels);\n              for (cidx = 0; cidx < layer_channels; ++cidx)\n                {\n                  IFDBG(3) g_debug (\"Start channel %d\", channel_idx[cidx]);\n                  for (i = 0; i < layer_size; ++i)\n                    pixels[(i * layer_channels) + cidx] = lyr_chn[channel_idx[cidx]]->data[i];\n                  g_free (lyr_chn[channel_idx[cidx]]->data);\n                }\n\n              layer_mode = psd_to_gimp_blend_mode (lyr_a[lidx]->blend_mode);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name, l_w, l_h,\n                                         image_type, lyr_a[lidx]->opacity * 100 / 255,\n                                         layer_mode);\n              IFDBG(3) g_debug (\"Layer tattoo: %d\", layer_id);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              gimp_layer_set_offsets (layer_id, l_x, l_y);\n              gimp_layer_set_lock_alpha  (layer_id, lyr_a[lidx]->layer_flags.trans_prot);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0,\n                                   drawable->width, drawable->height, TRUE, FALSE);\n              gimp_pixel_rgn_set_rect (&pixel_rgn, pixels,\n                                       0, 0, drawable->width, drawable->height);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n              g_free (pixels);\n            }\n\n          /* Layer mask */\n          if (user_mask)\n            {\n              if (empty_mask)\n                {\n                  IFDBG(3) g_debug (\"Create empty mask\");\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                }\n              else\n                {\n                  /* Load layer mask data */\n                  if (lyr_a[lidx]->layer_mask.mask_flags.relative_pos)\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left;\n                      lm_y = lyr_a[lidx]->layer_mask.top;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  else\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left - l_x;\n                      lm_y = lyr_a[lidx]->layer_mask.top - l_y;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  IFDBG(3) g_debug (\"Mask channel index %d\", user_mask_chn);\n                  IFDBG(3) g_debug (\"Relative pos %d\",\n                                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n                  layer_size = lm_w * lm_h;\n                  pixels = g_malloc (layer_size);\n                  IFDBG(3) g_debug (\"Allocate Pixels %d\", layer_size);\n                  /* Crop mask at layer boundry */\n                  IFDBG(3) g_debug (\"Original Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n                  if (lm_x < 0\n                      || lm_y < 0\n                      || lm_w + lm_x > l_w\n                      || lm_h + lm_y > l_h)\n                    {\n                      if (CONVERSION_WARNINGS)\n                        g_message (\"Warning\\n\"\n                                   \"The layer mask is partly outside the \"\n                                   \"layer boundary. The mask will be \"\n                                   \"cropped which may result in data loss.\");\n                      i = 0;\n                      for (rowi = 0; rowi < lm_h; ++rowi)\n                        {\n                          if (rowi + lm_y >= 0 && rowi + lm_y < l_h)\n                            {\n                              for (coli = 0; coli < lm_w; ++coli)\n                                {\n                                  if (coli + lm_x >= 0 && coli + lm_x < l_w)\n                                    {\n                                      pixels[i] =\n                                        lyr_chn[user_mask_chn]->data[(rowi * lm_w) + coli];\n                                      i++;\n                                    }\n                                }\n                            }\n                        }\n                      if (lm_x < 0)\n                        {\n                          lm_w += lm_x;\n                          lm_x = 0;\n                        }\n                      if (lm_y < 0)\n                        {\n                          lm_h += lm_y;\n                          lm_y = 0;\n                        }\n                      if (lm_w + lm_x > l_w)\n                        lm_w = l_w - lm_x;\n                      if (lm_h + lm_y > l_h)\n                        lm_h = l_h - lm_y;\n                    }\n                  else\n                    memcpy (pixels, lyr_chn[user_mask_chn]->data, layer_size);\n                  g_free (lyr_chn[user_mask_chn]->data);\n                  /* Draw layer mask data */\n                  IFDBG(3) g_debug (\"Layer %d %d %d %d\", l_x, l_y, l_w, l_h);\n                  IFDBG(3) g_debug (\"Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n\n                  IFDBG(3) g_debug (\"New layer mask %d\", mask_id);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  drawable = gimp_drawable_get (mask_id);\n                  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0 , 0,\n                                       drawable->width, drawable->height, TRUE, FALSE);\n                  gimp_pixel_rgn_set_rect (&pixel_rgn, pixels, lm_x, lm_y, lm_w, lm_h);\n                  gimp_drawable_flush (drawable);\n                  gimp_drawable_detach (drawable);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                  g_free (pixels);\n                }\n            }\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            if (lyr_chn[cidx])\n              g_free (lyr_chn[cidx]);\n          g_free (lyr_chn);\n        }\n      g_free (lyr_a[lidx]);\n    }\n  g_free (lyr_a);\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-190"], "project": "gimp", "commit_id": "88eccea84aa375197cc04a2a0e2e29debb56bfa5", "hash": 100548926281788437485573729336082276267, "size": 418, "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)", "idx": 452}
{"func": "static CURLcode file_setup_connection(struct connectdata *conn)\n{\n  /* allocate the FILE specific struct */\n  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));\n  if(!conn->data->req.protop)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}", "target": 0, "cwe": [], "project": "curl", "commit_id": "1b71bc532bde8621fd3260843f8197182a467ff2", "hash": 85575103811279784293753945988649675141, "size": 9, "message": "file: on Windows, refuse paths that start with \\\\\n\n... as that might cause an unexpected SMB connection to a given host\nname.\n\nReported-by: Fernando Muñoz\nCVE-2019-15601\nBug: https://curl.haxx.se/docs/CVE-2019-15601.html", "idx": 453}
{"func": "static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)\n{\n\treturn vmx_pt_mode_is_host_guest() &&\n\t       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n}", "target": 0, "cwe": ["CWE-787"], "project": "linux", "commit_id": "04c4f2ee3f68c9a4bf1653d15f1a9a435ae33f7a", "hash": 210887018282951560190035216057000377524, "size": 5, "message": "KVM: VMX: Don't use vcpu->run->internal.ndata as an array index\n\n__vmx_handle_exit() uses vcpu->run->internal.ndata as an index for\nan array access.  Since vcpu->run is (can be) mapped to a user address\nspace with a writer permission, the 'ndata' could be updated by the\nuser process at anytime (the user process can set it to outside the\nbounds of the array).\nSo, it is not safe that __vmx_handle_exit() uses the 'ndata' that way.\n\nFixes: 1aa561b1a4c0 (\"kvm: x86: Add \"last CPU\" to some KVM_EXIT information\")\nSigned-off-by: Reiji Watanabe <reijiw@google.com>\nReviewed-by: Jim Mattson <jmattson@google.com>\nMessage-Id: <20210413154739.490299-1-reijiw@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 454}
{"func": "static void automount_trigger_notify(Unit *u, Unit *other) {\n        Automount *a = AUTOMOUNT(u);\n        int r;\n\n        assert(a);\n        assert(other);\n\n        /* Filter out invocations with bogus state */\n        if (other->load_state != UNIT_LOADED || other->type != UNIT_MOUNT)\n                return;\n\n        /* Don't propagate state changes from the mount if we are already down */\n        if (!IN_SET(a->state, AUTOMOUNT_WAITING, AUTOMOUNT_RUNNING))\n                return;\n\n        /* Propagate start limit hit state */\n        if (other->start_limit_hit) {\n                automount_enter_dead(a, AUTOMOUNT_FAILURE_MOUNT_START_LIMIT_HIT);\n                return;\n        }\n\n        /* Don't propagate anything if there's still a job queued */\n        if (other->job)\n                return;\n\n        /* The mount is successfully established */\n        if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {\n                (void) automount_send_ready(a, a->tokens, 0);\n\n                r = automount_start_expire(a);\n                if (r < 0)\n                        log_unit_warning_errno(UNIT(a), r, \"Failed to start expiration timer, ignoring: %m\");\n\n                automount_set_state(a, AUTOMOUNT_RUNNING);\n        }\n\n        if (IN_SET(MOUNT(other)->state,\n                   MOUNT_MOUNTING, MOUNT_MOUNTING_DONE,\n                   MOUNT_MOUNTED, MOUNT_REMOUNTING,\n                   MOUNT_MOUNTING_SIGTERM, MOUNT_MOUNTING_SIGKILL,\n                   MOUNT_REMOUNTING_SIGTERM, MOUNT_REMOUNTING_SIGKILL,\n                   MOUNT_UNMOUNTING_SIGTERM, MOUNT_UNMOUNTING_SIGKILL,\n                   MOUNT_FAILED)) {\n\n                (void) automount_send_ready(a, a->expire_tokens, -ENODEV);\n        }\n\n        if (MOUNT(other)->state == MOUNT_DEAD)\n                (void) automount_send_ready(a, a->expire_tokens, 0);\n\n        /* The mount is in some unhappy state now, let's unfreeze any waiting clients */\n        if (IN_SET(MOUNT(other)->state,\n                   MOUNT_DEAD, MOUNT_UNMOUNTING,\n                   MOUNT_MOUNTING_SIGTERM, MOUNT_MOUNTING_SIGKILL,\n                   MOUNT_REMOUNTING_SIGTERM, MOUNT_REMOUNTING_SIGKILL,\n                   MOUNT_UNMOUNTING_SIGTERM, MOUNT_UNMOUNTING_SIGKILL,\n                   MOUNT_FAILED)) {\n\n                (void) automount_send_ready(a, a->tokens, -ENODEV);\n\n                automount_set_state(a, AUTOMOUNT_WAITING);\n        }\n}", "target": 0, "cwe": ["CWE-362"], "project": "systemd", "commit_id": "e7d54bf58789545a9eb0b3964233defa0b007318", "hash": 57065042018702371395730651834260291470, "size": 63, "message": "automount: ack automount requests even when already mounted (#5916)\n\nIf a process accesses an autofs filesystem while systemd is in the\r\nmiddle of starting the mount unit on top of it, it is possible for the\r\nautofs_ptype_missing_direct request from the kernel to be received after\r\nthe mount unit has been fully started:\r\n\r\n  systemd forks and execs mount             ...\r\n            ...                     access autofs, blocks\r\n  mount exits                               ...\r\n  systemd receives SIGCHLD                  ...\r\n            ...                     kernel sends request\r\n  systemd receives request                  ...\r\n\r\nsystemd needs to respond to this request, otherwise the kernel will\r\ncontinue to block access to the mount point.", "idx": 455}
{"func": "int cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t/* call only for station! */\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\tdata->flags = 0;\n\n\twdev_lock(wdev);\n\tif (wdev->current_bss) {\n\t\tconst u8 *ie;\n\n\t\trcu_read_lock();\n\t\tie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t  WLAN_EID_SSID);\n\t\tif (ie) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ie[1];\n\t\t\tmemcpy(ssid, ie + 2, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-120"], "project": "linux", "commit_id": "4ac2813cc867ae563a1ba5a9414bfb554e5796fa", "hash": 302922082424490386927957829512942197604, "size": 34, "message": "cfg80211: wext: avoid copying malformed SSIDs\n\nEnsure the SSID element is bounds-checked prior to invoking memcpy()\nwith its length field, when copying to userspace.\n\nCc: <stable@vger.kernel.org>\nCc: Kees Cook <keescook@chromium.org>\nReported-by: Nicolas Waisman <nico@semmle.com>\nSigned-off-by: Will Deacon <will@kernel.org>\nLink: https://lore.kernel.org/r/20191004095132.15777-2-will@kernel.org\n[adjust commit log a bit]\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>", "idx": 456}
{"func": "int has_handler(pid_t pid, int signal) {\n\tif (signal > 0 && signal <= SIGRTMAX) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tEUID_ROOT();\n\t\tFILE *fp = fopen(fname, \"re\");\n\t\tEUID_USER();\n\t\tfree(fname);\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\twhile (fgets(buf, BUFLEN, fp)) {\n\t\t\t\tif (strncmp(buf, \"SigCgt:\", 7) == 0) {\n\t\t\t\t\tunsigned long long val;\n\t\t\t\t\tif (sscanf(buf + 7, \"%llx\", &val) != 1) {\n\t\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tval >>= (signal - 1);\n\t\t\t\t\tval &= 1ULL;\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\treturn val;  // 1 if process has a handler for the signal, else 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-269", "CWE-94"], "project": "firejail", "commit_id": "27cde3d7d1e4e16d4190932347c7151dc2a84c50", "hash": 238880155121929652994830603112026591232, "size": 29, "message": "fixing CVE-2022-31214", "idx": 457}
{"func": "has_server_privilege_name_name(PG_FUNCTION_ARGS)\n{\n\tName\t\tusername = PG_GETARG_NAME(0);\n\ttext\t   *servername = PG_GETARG_TEXT_P(1);\n\ttext\t   *priv_type_text = PG_GETARG_TEXT_P(2);\n\tOid\t\t\troleid;\n\tOid\t\t\tserverid;\n\tAclMode\t\tmode;\n\tAclResult\taclresult;\n\n\troleid = get_role_oid_or_public(NameStr(*username));\n\tserverid = convert_server_name(servername);\n\tmode = convert_server_priv_string(priv_type_text);\n\n\taclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);\n\n\tPG_RETURN_BOOL(aclresult == ACLCHECK_OK);\n}", "target": 0, "cwe": ["CWE-264"], "project": "postgres", "commit_id": "fea164a72a7bfd50d77ba5fb418d357f8f2bb7d0", "hash": 255220773977080379685159912458310955301, "size": 18, "message": "Shore up ADMIN OPTION restrictions.\n\nGranting a role without ADMIN OPTION is supposed to prevent the grantee\nfrom adding or removing members from the granted role.  Issuing SET ROLE\nbefore the GRANT bypassed that, because the role itself had an implicit\nright to add or remove members.  Plug that hole by recognizing that\nimplicit right only when the session user matches the current role.\nAdditionally, do not recognize it during a security-restricted operation\nor during execution of a SECURITY DEFINER function.  The restriction on\nSECURITY DEFINER is not security-critical.  However, it seems best for a\nuser testing his own SECURITY DEFINER function to see the same behavior\nothers will see.  Back-patch to 8.4 (all supported versions).\n\nThe SQL standards do not conflate roles and users as PostgreSQL does;\nonly SQL roles have members, and only SQL users initiate sessions.  An\napplication using PostgreSQL users and roles as SQL users and roles will\nnever attempt to grant membership in the role that is the session user,\nso the implicit right to add or remove members will never arise.\n\nThe security impact was mostly that a role member could revoke access\nfrom others, contrary to the wishes of his own grantor.  Unapproved role\nmember additions are less notable, because the member can still largely\nachieve that by creating a view or a SECURITY DEFINER function.\n\nReviewed by Andres Freund and Tom Lane.  Reported, independently, by\nJonas Sundman and Noah Misch.\n\nSecurity: CVE-2014-0060", "idx": 458}
{"func": "nextvar(\n\tint *datalen,\n\tconst char **datap,\n\tchar **vname,\n\tchar **vvalue\n\t)\n{\n\tconst char *cp;\n\tconst char *np;\n\tconst char *cpend;\n\tsize_t srclen;\n\tsize_t len;\n\tstatic char name[MAXVARLEN];\n\tstatic char value[MAXVALLEN];\n\n\tcp = *datap;\n\tcpend = cp + *datalen;\n\n\t/*\n\t * Space past commas and white space\n\t */\n\twhile (cp < cpend && (*cp == ',' || isspace((int)*cp)))\n\t\tcp++;\n\tif (cp >= cpend)\n\t\treturn 0;\n\n\t/*\n\t * Copy name until we hit a ',', an '=', a '\\r' or a '\\n'.  Backspace\n\t * over any white space and terminate it.\n\t */\n\tsrclen = strcspn(cp, \",=\\r\\n\");\n\tsrclen = min(srclen, (size_t)(cpend - cp));\n\tlen = srclen;\n\twhile (len > 0 && isspace((unsigned char)cp[len - 1]))\n\t\tlen--;\n\tif (len >= sizeof(name))\n\t    return 0;\n\tif (len > 0)\n\t\tmemcpy(name, cp, len);\n\tname[len] = '\\0';\n\t*vname = name;\n\tcp += srclen;\n\n\t/*\n\t * Check if we hit the end of the buffer or a ','.  If so we are done.\n\t */\n\tif (cp >= cpend || *cp == ',' || *cp == '\\r' || *cp == '\\n') {\n\t\tif (cp < cpend)\n\t\t\tcp++;\n\t\t*datap = cp;\n\t\t*datalen = cpend - cp;\n\t\t*vvalue = NULL;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * So far, so good.  Copy out the value\n\t */\n\tcp++;\t/* past '=' */\n\twhile (cp < cpend && (isspace((unsigned char)*cp) && *cp != '\\r' && *cp != '\\n'))\n\t\tcp++;\n\tnp = cp;\n\tif ('\"' == *np) {\n\t\tdo {\n\t\t\tnp++;\n\t\t} while (np < cpend && '\"' != *np);\n\t\tif (np < cpend && '\"' == *np)\n\t\t\tnp++;\n\t} else {\n\t\twhile (np < cpend && ',' != *np && '\\r' != *np)\n\t\t\tnp++;\n\t}\n\tlen = np - cp;\n\tif (np > cpend || len >= sizeof(value) ||\n\t    (np < cpend && ',' != *np && '\\r' != *np))\n\t\treturn 0;\n\tmemcpy(value, cp, len);\n\t/*\n\t * Trim off any trailing whitespace\n\t */\n\twhile (len > 0 && isspace((unsigned char)value[len - 1]))\n\t\tlen--;\n\tvalue[len] = '\\0';\n\n\t/*\n\t * Return this.  All done.\n\t */\n\tif (np < cpend && ',' == *np)\n\t\tnp++;\n\t*datap = np;\n\t*datalen = cpend - np;\n\t*vvalue = value;\n\treturn 1;\n}", "target": 0, "cwe": ["CWE-119"], "project": "ntp", "commit_id": "12f1323d18c8d74eb14fb5ac5574183d779794c5", "hash": 8086799462052261946244657599082828583, "size": 94, "message": "[Bug 2937] (NTPQ) nextvar() missing length check", "idx": 459}
{"func": "\n    Tfloat _cubic_atXYZ_p(const float fx, const float fy, const float fz, const int c=0) const {\n      const float\n        nfx = cimg::type<float>::is_nan(fx)?0:cimg::mod(fx,(float)_width),\n        nfy = cimg::type<float>::is_nan(fy)?0:cimg::mod(fy,(float)_height),\n        nfz = cimg::type<float>::is_nan(fz)?0:cimg::mod(fz,(float)_depth);\n      const int x = (int)nfx, y = (int)nfy, z = (int)nfz;\n      const float dx = nfx - x, dy = nfy - y, dz = nfz - z;\n      const int\n        px = cimg::mod(x - 1,width()), nx = cimg::mod(x + 1,width()), ax = cimg::mod(x + 2,width()),\n        py = cimg::mod(y - 1,height()), ny = cimg::mod(y + 1,height()), ay = cimg::mod(y + 2,height()),\n        pz = cimg::mod(z - 1,depth()), nz = cimg::mod(z + 1,depth()), az = cimg::mod(z + 2,depth());\n      const Tfloat\n        Ippp = (Tfloat)(*this)(px,py,pz,c), Icpp = (Tfloat)(*this)(x,py,pz,c),\n        Inpp = (Tfloat)(*this)(nx,py,pz,c), Iapp = (Tfloat)(*this)(ax,py,pz,c),\n        Ipp = Icpp + 0.5f*(dx*(-Ippp + Inpp) + dx*dx*(2*Ippp - 5*Icpp + 4*Inpp - Iapp) +\n                           dx*dx*dx*(-Ippp + 3*Icpp - 3*Inpp + Iapp)),\n        Ipcp = (Tfloat)(*this)(px,y,pz,c),  Iccp = (Tfloat)(*this)(x, y,pz,c),\n        Incp = (Tfloat)(*this)(nx,y,pz,c),  Iacp = (Tfloat)(*this)(ax,y,pz,c),\n        Icp = Iccp + 0.5f*(dx*(-Ipcp + Incp) + dx*dx*(2*Ipcp - 5*Iccp + 4*Incp - Iacp) +\n                           dx*dx*dx*(-Ipcp + 3*Iccp - 3*Incp + Iacp)),\n        Ipnp = (Tfloat)(*this)(px,ny,pz,c), Icnp = (Tfloat)(*this)(x,ny,pz,c),\n        Innp = (Tfloat)(*this)(nx,ny,pz,c), Ianp = (Tfloat)(*this)(ax,ny,pz,c),\n        Inp = Icnp + 0.5f*(dx*(-Ipnp + Innp) + dx*dx*(2*Ipnp - 5*Icnp + 4*Innp - Ianp) +\n                           dx*dx*dx*(-Ipnp + 3*Icnp - 3*Innp + Ianp)),\n        Ipap = (Tfloat)(*this)(px,ay,pz,c), Icap = (Tfloat)(*this)(x,ay,pz,c),\n        Inap = (Tfloat)(*this)(nx,ay,pz,c), Iaap = (Tfloat)(*this)(ax,ay,pz,c),\n        Iap = Icap + 0.5f*(dx*(-Ipap + Inap) + dx*dx*(2*Ipap - 5*Icap + 4*Inap - Iaap) +\n                           dx*dx*dx*(-Ipap + 3*Icap - 3*Inap + Iaap)),\n        Ip = Icp + 0.5f*(dy*(-Ipp + Inp) + dy*dy*(2*Ipp - 5*Icp + 4*Inp - Iap) +\n                         dy*dy*dy*(-Ipp + 3*Icp - 3*Inp + Iap)),\n        Ippc = (Tfloat)(*this)(px,py,z,c), Icpc = (Tfloat)(*this)(x,py,z,c),\n        Inpc = (Tfloat)(*this)(nx,py,z,c), Iapc = (Tfloat)(*this)(ax,py,z,c),\n        Ipc = Icpc + 0.5f*(dx*(-Ippc + Inpc) + dx*dx*(2*Ippc - 5*Icpc + 4*Inpc - Iapc) +\n                           dx*dx*dx*(-Ippc + 3*Icpc - 3*Inpc + Iapc)),\n        Ipcc = (Tfloat)(*this)(px,y,z,c),  Iccc = (Tfloat)(*this)(x, y,z,c),\n        Incc = (Tfloat)(*this)(nx,y,z,c),  Iacc = (Tfloat)(*this)(ax,y,z,c),\n        Icc = Iccc + 0.5f*(dx*(-Ipcc + Incc) + dx*dx*(2*Ipcc - 5*Iccc + 4*Incc - Iacc) +\n                           dx*dx*dx*(-Ipcc + 3*Iccc - 3*Incc + Iacc)),\n        Ipnc = (Tfloat)(*this)(px,ny,z,c), Icnc = (Tfloat)(*this)(x,ny,z,c),\n        Innc = (Tfloat)(*this)(nx,ny,z,c), Ianc = (Tfloat)(*this)(ax,ny,z,c),\n        Inc = Icnc + 0.5f*(dx*(-Ipnc + Innc) + dx*dx*(2*Ipnc - 5*Icnc + 4*Innc - Ianc) +\n                           dx*dx*dx*(-Ipnc + 3*Icnc - 3*Innc + Ianc)),\n        Ipac = (Tfloat)(*this)(px,ay,z,c), Icac = (Tfloat)(*this)(x,ay,z,c),\n        Inac = (Tfloat)(*this)(nx,ay,z,c), Iaac = (Tfloat)(*this)(ax,ay,z,c),\n        Iac = Icac + 0.5f*(dx*(-Ipac + Inac) + dx*dx*(2*Ipac - 5*Icac + 4*Inac - Iaac) +\n                           dx*dx*dx*(-Ipac + 3*Icac - 3*Inac + Iaac)),\n        Ic = Icc + 0.5f*(dy*(-Ipc + Inc) + dy*dy*(2*Ipc - 5*Icc + 4*Inc - Iac) +\n                         dy*dy*dy*(-Ipc + 3*Icc - 3*Inc + Iac)),\n        Ippn = (Tfloat)(*this)(px,py,nz,c), Icpn = (Tfloat)(*this)(x,py,nz,c),\n        Inpn = (Tfloat)(*this)(nx,py,nz,c), Iapn = (Tfloat)(*this)(ax,py,nz,c),\n        Ipn = Icpn + 0.5f*(dx*(-Ippn + Inpn) + dx*dx*(2*Ippn - 5*Icpn + 4*Inpn - Iapn) +\n                           dx*dx*dx*(-Ippn + 3*Icpn - 3*Inpn + Iapn)),\n        Ipcn = (Tfloat)(*this)(px,y,nz,c),  Iccn = (Tfloat)(*this)(x, y,nz,c),\n        Incn = (Tfloat)(*this)(nx,y,nz,c),  Iacn = (Tfloat)(*this)(ax,y,nz,c),\n        Icn = Iccn + 0.5f*(dx*(-Ipcn + Incn) + dx*dx*(2*Ipcn - 5*Iccn + 4*Incn - Iacn) +\n                           dx*dx*dx*(-Ipcn + 3*Iccn - 3*Incn + Iacn)),\n        Ipnn = (Tfloat)(*this)(px,ny,nz,c), Icnn = (Tfloat)(*this)(x,ny,nz,c),\n        Innn = (Tfloat)(*this)(nx,ny,nz,c), Iann = (Tfloat)(*this)(ax,ny,nz,c),\n        Inn = Icnn + 0.5f*(dx*(-Ipnn + Innn) + dx*dx*(2*Ipnn - 5*Icnn + 4*Innn - Iann) +\n                           dx*dx*dx*(-Ipnn + 3*Icnn - 3*Innn + Iann)),\n        Ipan = (Tfloat)(*this)(px,ay,nz,c), Ican = (Tfloat)(*this)(x,ay,nz,c),\n        Inan = (Tfloat)(*this)(nx,ay,nz,c), Iaan = (Tfloat)(*this)(ax,ay,nz,c),\n        Ian = Ican + 0.5f*(dx*(-Ipan + Inan) + dx*dx*(2*Ipan - 5*Ican + 4*Inan - Iaan) +\n                           dx*dx*dx*(-Ipan + 3*Ican - 3*Inan + Iaan)),\n        In = Icn + 0.5f*(dy*(-Ipn + Inn) + dy*dy*(2*Ipn - 5*Icn + 4*Inn - Ian) +\n                         dy*dy*dy*(-Ipn + 3*Icn - 3*Inn + Ian)),\n        Ippa = (Tfloat)(*this)(px,py,az,c), Icpa = (Tfloat)(*this)(x,py,az,c),\n        Inpa = (Tfloat)(*this)(nx,py,az,c), Iapa = (Tfloat)(*this)(ax,py,az,c),\n        Ipa = Icpa + 0.5f*(dx*(-Ippa + Inpa) + dx*dx*(2*Ippa - 5*Icpa + 4*Inpa - Iapa) +\n                           dx*dx*dx*(-Ippa + 3*Icpa - 3*Inpa + Iapa)),\n        Ipca = (Tfloat)(*this)(px,y,az,c),  Icca = (Tfloat)(*this)(x, y,az,c),\n        Inca = (Tfloat)(*this)(nx,y,az,c),  Iaca = (Tfloat)(*this)(ax,y,az,c),\n        Ica = Icca + 0.5f*(dx*(-Ipca + Inca) + dx*dx*(2*Ipca - 5*Icca + 4*Inca - Iaca) +\n                           dx*dx*dx*(-Ipca + 3*Icca - 3*Inca + Iaca)),\n        Ipna = (Tfloat)(*this)(px,ny,az,c), Icna = (Tfloat)(*this)(x,ny,az,c),\n        Inna = (Tfloat)(*this)(nx,ny,az,c), Iana = (Tfloat)(*this)(ax,ny,az,c),\n        Ina = Icna + 0.5f*(dx*(-Ipna + Inna) + dx*dx*(2*Ipna - 5*Icna + 4*Inna - Iana) +\n                           dx*dx*dx*(-Ipna + 3*Icna - 3*Inna + Iana)),\n        Ipaa = (Tfloat)(*this)(px,ay,az,c), Icaa = (Tfloat)(*this)(x,ay,az,c),\n        Inaa = (Tfloat)(*this)(nx,ay,az,c), Iaaa = (Tfloat)(*this)(ax,ay,az,c),\n        Iaa = Icaa + 0.5f*(dx*(-Ipaa + Inaa) + dx*dx*(2*Ipaa - 5*Icaa + 4*Inaa - Iaaa) +\n                           dx*dx*dx*(-Ipaa + 3*Icaa - 3*Inaa + Iaaa)),\n        Ia = Ica + 0.5f*(dy*(-Ipa + Ina) + dy*dy*(2*Ipa - 5*Ica + 4*Ina - Iaa) +\n                         dy*dy*dy*(-Ipa + 3*Ica - 3*Ina + Iaa));\n      return Ic + 0.5f*(dz*(-Ip + In) + dz*dz*(2*Ip - 5*Ic + 4*In - Ia) + dz*dz*dz*(-Ip + 3*Ic - 3*In + Ia));", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "CImg", "commit_id": "ac8003393569aba51048c9d67e1491559877b1d1", "hash": 98603352314497805622950401846048051889, "size": 86, "message": ".", "idx": 460}
{"func": "armpmu_event_set_period(struct perf_event *event,\n\t\t\tstruct hw_perf_event *hwc,\n\t\t\tint idx)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\ts64 left = local64_read(&hwc->period_left);\n\ts64 period = hwc->sample_period;\n\tint ret = 0;\n\n\tif (unlikely(left <= -period)) {\n\t\tleft = period;\n\t\tlocal64_set(&hwc->period_left, left);\n\t\thwc->last_period = period;\n\t\tret = 1;\n\t}\n\n\tif (unlikely(left <= 0)) {\n\t\tleft += period;\n\t\tlocal64_set(&hwc->period_left, left);\n\t\thwc->last_period = period;\n\t\tret = 1;\n\t}\n\n\t/*\n\t * Limit the maximum period to prevent the counter value\n\t * from overtaking the one we are about to program. In\n\t * effect we are reducing max_period to account for\n\t * interrupt latency (and we are being very conservative).\n\t */\n\tif (left > (armpmu->max_period >> 1))\n\t\tleft = armpmu->max_period >> 1;\n\n\tlocal64_set(&hwc->prev_count, (u64)-left);\n\n\tarmpmu->write_counter(idx, (u64)(-left) & 0xffffffff);\n\n\tperf_event_update_userpage(event);\n\n\treturn ret;\n}", "target": 0, "cwe": ["CWE-284", "CWE-264"], "project": "linux", "commit_id": "8fff105e13041e49b82f92eef034f363a6b1c071", "hash": 272469116586084277187681876812353850427, "size": 40, "message": "arm64: perf: reject groups spanning multiple HW PMUs\n\nThe perf core implicitly rejects events spanning multiple HW PMUs, as in\nthese cases the event->ctx will differ. However this validation is\nperformed after pmu::event_init() is called in perf_init_event(), and\nthus pmu::event_init() may be called with a group leader from a\ndifferent HW PMU.\n\nThe ARM64 PMU driver does not take this fact into account, and when\nvalidating groups assumes that it can call to_arm_pmu(event->pmu) for\nany HW event. When the event in question is from another HW PMU this is\nwrong, and results in dereferencing garbage.\n\nThis patch updates the ARM64 PMU driver to first test for and reject\nevents from other PMUs, moving the to_arm_pmu and related logic after\nthis test. Fixes a crash triggered by perf_fuzzer on Linux-4.0-rc2, with\na CCI PMU present:\n\nBad mode in Synchronous Abort handler detected, code 0x86000006 -- IABT (current EL)\nCPU: 0 PID: 1371 Comm: perf_fuzzer Not tainted 3.19.0+ #249\nHardware name: V2F-1XV7 Cortex-A53x2 SMM (DT)\ntask: ffffffc07c73a280 ti: ffffffc07b0a0000 task.ti: ffffffc07b0a0000\nPC is at 0x0\nLR is at validate_event+0x90/0xa8\npc : [<0000000000000000>] lr : [<ffffffc000090228>] pstate: 00000145\nsp : ffffffc07b0a3ba0\n\n[<          (null)>]           (null)\n[<ffffffc0000907d8>] armpmu_event_init+0x174/0x3cc\n[<ffffffc00015d870>] perf_try_init_event+0x34/0x70\n[<ffffffc000164094>] perf_init_event+0xe0/0x10c\n[<ffffffc000164348>] perf_event_alloc+0x288/0x358\n[<ffffffc000164c5c>] SyS_perf_event_open+0x464/0x98c\nCode: bad PC value\n\nAlso cleans up the code to use the arm_pmu only when we know\nthat we are dealing with an arm pmu event.\n\nCc: Will Deacon <will.deacon@arm.com>\nAcked-by: Mark Rutland <mark.rutland@arm.com>\nAcked-by: Peter Ziljstra (Intel) <peterz@infradead.org>\nSigned-off-by: Suzuki K. Poulose <suzuki.poulose@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>", "idx": 461}
{"func": "int yr_object_set_string(\n    const char* value,\n    size_t len,\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT_STRING* string_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(\n        object, OBJECT_CREATE, field, args);\n  else\n    string_obj = (YR_OBJECT_STRING*) object;\n\n  va_end(args);\n\n  assert(string_obj != NULL);\n  assert(string_obj->type == OBJECT_TYPE_STRING);\n\n  if (string_obj->value != NULL)\n    yr_free(string_obj->value);\n\n  if (value != NULL)\n  {\n    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));\n\n    if (string_obj->value == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    string_obj->value->length = (uint32_t) len;\n    string_obj->value->flags = 0;\n\n    memcpy(string_obj->value->c_string, value, len);\n    string_obj->value->c_string[len] = '\\0';\n  }\n  else\n  {\n    string_obj->value = NULL;\n  }\n\n  return ERROR_SUCCESS;\n}", "target": 0, "cwe": ["CWE-416"], "project": "yara", "commit_id": "053e67e3ec81cc9268ce30eaf0d6663d8639ed1e", "hash": 5252967529422827230107307355879707472, "size": 46, "message": "Fix issue #658", "idx": 462}
{"func": "parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\n\tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\",\n\t\t  level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\t\t\t  \"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 2,\n\t\t\t\t\t     \"      |  Attr | A -->%3d \"\n\t\t\t\t\t     \"| SWITCH_PAGE (Attr code page)    |\",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| ENTITY                          \"\n\t\t\t\t\t     \"|     %s'&#%u;'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| STR_I (Inline string)           \"\n\t\t\t\t\t     \"|     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tattr_save_known = 0;\n\t\t\tattr_save_literal = tvb_format_text (tvb,\n\t\t\t\t\t\t\t     str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| LITERAL (Literal Attribute)     \"\n\t\t\t\t\t     \"|   %s<%s />\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level),\n\t\t\t\t\t     attr_save_literal);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"|     %s(%s: \\'%s\\')\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     map_token (map->global, 0, peek),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\t{   char *s;\n\n\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\telse\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"\n\t\t\t\t\t\t     \"| %s%s)\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| STR_T (Tableref string)         \"\n\t\t\t\t\t     \"|     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"\n\t\t\t\t\t     \"|     %s(%s)\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     map_token (map->global, 0, peek));\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tchar *str;\n\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\tstr = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len);\n\t\t\t\t\t}\n\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\tstr = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"\n\t\t\t\t\t\t     \"|       %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\t\toff += 1 + len;\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"\n\t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| %-10s     (Invalid Token!) \"\n\t\t\t\t\t     \"| WBXML parsing stops here.\",\n\t\t\t\t\t     level, *codepage_attr,\n\t\t\t\t\t     val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"|   Known attrValue 0x%02X          \"\n\t\t\t\t\t\t     \"|       %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     map_token (map->attrValue, *codepage_attr, peek));\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tattr_save_known = peek & 0x7f;\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"|   Known attrStart 0x%02X          \"\n\t\t\t\t\t\t     \"|   %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, attr_save_known, Indent (level),\n\t\t\t\t\t\t     map_token (map->attrStart, *codepage_attr, peek));\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}", "target": 1, "cwe": ["CWE-399", "CWE-119", "CWE-787"], "project": "wireshark", "commit_id": "b8e0d416898bb975a02c1b55883342edc5b4c9c0", "hash": 225865519203365650485743419730107518245, "size": 214, "message": "WBXML: add a basic sanity check for offset overflow\n\nThis is a naive approach allowing to detact that something went wrong,\nwithout the need to replace all proto_tree_add_text() calls as what was\ndone in master-2.0 branch.\n\nBug: 12408\nChange-Id: Ia14905005e17ae322c2fc639ad5e491fa08b0108\nReviewed-on: https://code.wireshark.org/review/15310\nReviewed-by: Michael Mann <mmann78@netscape.net>\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>", "idx": 463}
{"func": "TfLiteStatus PrepareImpl(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteFullyConnectedParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE(context, node->inputs->size == 2 || node->inputs->size == 3);\n  // Shuffled formats need a workspace to store the shuffled input activations.\n  const int expected_outputs_count =\n      params->weights_format == kTfLiteFullyConnectedWeightsFormatDefault ? 1\n                                                                          : 2;\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, expected_outputs_count);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* filter = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* bias =\n      (node->inputs->size == 3)\n          ? GetOptionalInputTensor(context, node, kBiasTensor)\n          : nullptr;\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // Check proper datatype match among all Input Tensors\n  TF_LITE_ENSURE_STATUS(\n      CheckTypes(context, input, filter, bias, output, params));\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  int input_size = 1;\n  for (int i = 0; i < input->dims->size; i++) {\n    input_size *= input->dims->data[i];\n  }\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 2);\n  const int batch_size = input_size / filter->dims->data[1];\n  const int num_units = filter->dims->data[0];\n\n  if (bias) {\n    TF_LITE_ENSURE_EQ(context, NumElements(bias), SizeOfDimension(filter, 0));\n  }\n\n  // Note that quantized inference requires that all tensors have their\n  // parameters set. This is usually done during quantized training.\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8 ||\n      input->type == kTfLiteInt16) {\n    double real_multiplier = 0.0;\n    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(\n        context, input, filter, bias, output, &real_multiplier));\n    int exponent;\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier, &exponent);\n    data->output_shift = exponent;\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n  }\n\n  if (input->type == kTfLiteInt16 && output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n  }\n\n  // If we have to perform on-the-fly quantization (with quantized weights and\n  // float inputs) first we need to quantize the inputs. Allocate a temporary\n  // buffer to store the intermediate quantized values.\n  // Additionally, we allocate a temporary buffer to store the accumulated\n  // quantized values prior to multiplication by the scaling factor.\n  if (input->type == kTfLiteFloat32 &&\n      (filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8)) {\n    TfLiteIntArrayFree(node->temporaries);\n    data->compute_row_sums = true;\n    node->temporaries = TfLiteIntArrayCreate(5);\n    node->temporaries->data[0] = data->scratch_tensor_index;\n\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/0);\n    input_quantized->type = filter->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n\n    TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                     input_quantized_size));\n\n    node->temporaries->data[1] = data->scratch_tensor_index + 1;\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/1);\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n\n    node->temporaries->data[2] = data->scratch_tensor_index + 2;\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/2);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {num_units, batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_size = TfLiteIntArrayCreate(2);\n      accum_size->data[0] = num_units;\n      accum_size->data[1] = batch_size;\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, accum_scratch, accum_size));\n    }\n\n    node->temporaries->data[3] = data->scratch_tensor_index + 3;\n    TfLiteTensor* input_offsets = GetTemporary(context, node, /*index=*/3);\n    input_offsets->type = kTfLiteInt32;\n    input_offsets->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {\n      TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);\n      input_offsets_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,\n                                                       input_offsets_size));\n    }\n    node->temporaries->data[4] = data->scratch_tensor_index + 4;\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/4);\n    row_sums->type = kTfLiteInt32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[1] = {num_units};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n      row_sums_size->data[0] = row_sums_dims[0];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = nullptr;\n  if (params->keep_num_dims) {\n    // When number of dimensions are kept the filter operates along the last\n    // dimensions. In other words, for an input tensor with shape\n    // [batch_size, ..., n_inputs] and a filter of shape [n_inputs, n_units]\n    // this Op produces an output of shape [batch_size, ..., n_units].\n    TF_LITE_ENSURE_EQ(context, input->dims->data[input->dims->size - 1],\n                      SizeOfDimension(filter, 1));\n    output_size_array = TfLiteIntArrayCopy(input->dims);\n    output_size_array->data[output_size_array->size - 1] = num_units;\n  } else {\n    // Otherwise, the output is (potentially flattened to) a 2-D matrix.\n    output_size_array = TfLiteIntArrayCreate(2);\n    output_size_array->data[0] = batch_size;\n    output_size_array->data[1] = num_units;\n  }\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  return kTfLiteOk;\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tensorflow", "commit_id": "1970c2158b1ffa416d159d03c3370b9a462aee35", "hash": 96726292187125983860711574454166812954, "size": 151, "message": "[tflite]: Insert `nullptr` checks when obtaining tensors.\n\nAs part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.\n\nWe also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).\n\nPiperOrigin-RevId: 332521299\nChange-Id: I29af455bcb48d0b92e58132d951a3badbd772d56", "idx": 464}
{"func": "static CURLcode setup_connection_internals(struct connectdata *conn)\n{\n  const struct Curl_handler * p;\n  CURLcode result;\n  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */\n\n  /* Perform setup complement if some. */\n  p = conn->handler;\n\n  if(p->setup_connection) {\n    result = (*p->setup_connection)(conn);\n\n    if(result)\n      return result;\n\n    p = conn->handler;              /* May have changed. */\n  }\n\n  if(conn->port < 0)\n    /* we check for -1 here since if proxy was detected already, this\n       was very likely already set to the proxy port */\n    conn->port = p->defport;\n\n  return CURLE_OK;\n}", "target": 0, "cwe": ["CWE-416"], "project": "curl", "commit_id": "81d135d67155c5295b1033679c606165d4e28f3f", "hash": 139819021971162897660767094909652481404, "size": 25, "message": "Curl_close: clear data->multi_easy on free to avoid use-after-free\n\nRegression from b46cfbc068 (7.59.0)\nCVE-2018-16840\nReported-by: Brian Carpenter (Geeknik Labs)\n\nBug: https://curl.haxx.se/docs/CVE-2018-16840.html", "idx": 465}
{"func": "static enum entity_charset determine_charset(char *charset_hint TSRMLS_DC)\n{\n\tint i;\n\tenum entity_charset charset = cs_utf_8;\n\tint len = 0;\n\tconst zend_encoding *zenc;\n\n\t/* Default is now UTF-8 */\n\tif (charset_hint == NULL)\n\t\treturn cs_utf_8;\n\n\tif ((len = strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\tzenc = zend_multibyte_get_internal_encoding(TSRMLS_C);\n\tif (zenc != NULL) {\n\t\tcharset_hint = (char *)zend_multibyte_get_encoding_name(zenc);\n\t\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\t\tif ((len == 4) /* sizeof (none|auto|pass) */ &&\n\t\t\t\t\t(!memcmp(\"pass\", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\"auto\", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\"auto\", charset_hint, 4))) {\n\t\t\t\tcharset_hint = NULL;\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tgoto det_charset;\n\t\t\t}\n\t\t}\n\t}\n\n\tcharset_hint = SG(default_charset);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\t/* try to detect the charset for the locale */\n#if HAVE_NL_LANGINFO && HAVE_LOCALE_H && defined(CODESET)\n\tcharset_hint = nl_langinfo(CODESET);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n#endif\n\n#if HAVE_LOCALE_H\n\t/* try to figure out the charset from the locale */\n\t{\n\t\tchar *localename;\n\t\tchar *dot, *at;\n\n\t\t/* lang[_territory][.codeset][@modifier] */\n\t\tlocalename = setlocale(LC_CTYPE, NULL);\n\n\t\tdot = strchr(localename, '.');\n\t\tif (dot) {\n\t\t\tdot++;\n\t\t\t/* locale specifies a codeset */\n\t\t\tat = strchr(dot, '@');\n\t\t\tif (at)\n\t\t\t\tlen = at - dot;\n\t\t\telse\n\t\t\t\tlen = strlen(dot);\n\t\t\tcharset_hint = dot;\n\t\t} else {\n\t\t\t/* no explicit name; see if the name itself\n\t\t\t * is the charset */\n\t\t\tcharset_hint = localename;\n\t\t\tlen = strlen(charset_hint);\n\t\t}\n\t}\n#endif\n\ndet_charset:\n\n\tif (charset_hint) {\n\t\tint found = 0;\n\t\t\n\t\t/* now walk the charset map and look for the codeset */\n\t\tfor (i = 0; charset_map[i].codeset; i++) {\n\t\t\tif (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) {\n\t\t\t\tcharset = charset_map[i].charset;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"charset `%s' not supported, assuming utf-8\",\n\t\t\t\t\tcharset_hint);\n\t\t}\n\t}\n\treturn charset;\n}", "target": 1, "cwe": ["CWE-190"], "project": "php-src", "commit_id": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "hash": 109367742216453416553903426985865913500, "size": 92, "message": "Fix bug #72135 - don't create strings with lengths outside int range", "idx": 466}
{"func": "SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)\n{\n\tint i, errno;\n\tstruct new_utsname *u;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tdown_read(&uts_sem);\n\tu = utsname();\n\ti = 1 + strlen(u->nodename);\n\tif (i > len)\n\t\ti = len;\n\terrno = 0;\n\tif (copy_to_user(name, u->nodename, i))\n\t\terrno = -EFAULT;\n\tup_read(&uts_sem);\n\treturn errno;\n}", "target": 0, "cwe": ["CWE-264"], "project": "linux", "commit_id": "259e5e6c75a910f3b5e656151dc602f53f9d7548", "hash": 148077518503738497863408682988833343247, "size": 18, "message": "Add PR_{GET,SET}_NO_NEW_PRIVS to prevent execve from granting privs\n\nWith this change, calling\n  prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)\ndisables privilege granting operations at execve-time.  For example, a\nprocess will not be able to execute a setuid binary to change their uid\nor gid if this bit is set.  The same is true for file capabilities.\n\nAdditionally, LSM_UNSAFE_NO_NEW_PRIVS is defined to ensure that\nLSMs respect the requested behavior.\n\nTo determine if the NO_NEW_PRIVS bit is set, a task may call\n  prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0);\nIt returns 1 if set and 0 if it is not set. If any of the arguments are\nnon-zero, it will return -1 and set errno to -EINVAL.\n(PR_SET_NO_NEW_PRIVS behaves similarly.)\n\nThis functionality is desired for the proposed seccomp filter patch\nseries.  By using PR_SET_NO_NEW_PRIVS, it allows a task to modify the\nsystem call behavior for itself and its child tasks without being\nable to impact the behavior of a more privileged task.\n\nAnother potential use is making certain privileged operations\nunprivileged.  For example, chroot may be considered \"safe\" if it cannot\naffect privileged tasks.\n\nNote, this patch causes execve to fail when PR_SET_NO_NEW_PRIVS is\nset and AppArmor is in use.  It is fixed in a subsequent patch.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Will Drewry <wad@chromium.org>\nAcked-by: Eric Paris <eparis@redhat.com>\nAcked-by: Kees Cook <keescook@chromium.org>\n\nv18: updated change desc\nv17: using new define values as per 3.4\nSigned-off-by: James Morris <james.l.morris@oracle.com>", "idx": 467}
{"func": "PHP_FUNCTION(openssl_open)\n{\n\tzval *privkey, *opendata;\n\tEVP_PKEY *pkey;\n\tint len1, len2, cipher_iv_len;\n\tunsigned char *buf, *iv_buf;\n\tzend_resource *keyresource = NULL;\n\tEVP_CIPHER_CTX *ctx;\n\tchar * data;\n\tsize_t data_len;\n\tchar * ekey;\n\tsize_t ekey_len;\n\tchar *method = NULL, *iv = NULL;\n\tsize_t method_len = 0, iv_len = 0;\n\tconst EVP_CIPHER *cipher;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/sz|ss\", &data, &data_len, &opendata,\n\t\t\t\t&ekey, &ekey_len, &privkey, &method, &method_len, &iv, &iv_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpkey = php_openssl_evp_from_zval(privkey, 0, \"\", 0, 0, &keyresource);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL, E_WARNING, \"unable to coerce parameter 4 into a private key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_OPENSSL_CHECK_SIZE_T_TO_INT(ekey_len, ekey);\n\tPHP_OPENSSL_CHECK_SIZE_T_TO_INT(data_len, data);\n\n\tif (method) {\n\t\tcipher = EVP_get_cipherbyname(method);\n\t\tif (!cipher) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Unknown signature algorithm.\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tcipher = EVP_rc4();\n\t}\n\n\tcipher_iv_len = EVP_CIPHER_iv_length(cipher);\n\tif (cipher_iv_len > 0) {\n\t\tif (!iv) {\n\t\t\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\t\t\"Cipher algorithm requires an IV to be supplied as a sixth parameter\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif ((size_t)cipher_iv_len != iv_len) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"IV length is invalid\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tiv_buf = (unsigned char *)iv;\n\t} else {\n\t\tiv_buf = NULL;\n\t}\n\n\tbuf = emalloc(data_len + 1);\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx != NULL && EVP_OpenInit(ctx, cipher, (unsigned char *)ekey, (int)ekey_len, iv_buf, pkey) &&\n\t\t\tEVP_OpenUpdate(ctx, buf, &len1, (unsigned char *)data, (int)data_len) &&\n\t\t\tEVP_OpenFinal(ctx, buf + len1, &len2) && (len1 + len2 > 0)) {\n\t\tzval_dtor(opendata);\n\t\tbuf[len1 + len2] = '\\0';\n\t\tZVAL_NEW_STR(opendata, zend_string_init((char*)buf, len1 + len2, 0));\n\t\tRETVAL_TRUE;\n\t} else {\n\t\tphp_openssl_store_errors();\n\t\tRETVAL_FALSE;\n\t}\n\n\tefree(buf);\n\tif (keyresource == NULL) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tEVP_CIPHER_CTX_free(ctx);\n}", "target": 0, "cwe": ["CWE-326"], "project": "php-src", "commit_id": "0216630ea2815a5789a24279a1211ac398d4de79", "hash": 128685431399380189582377845485904966612, "size": 77, "message": "Fix bug #79601 (Wrong ciphertext/tag in AES-CCM encryption for a 12 bytes IV)", "idx": 468}
{"func": "mbfl_strlen(mbfl_string *string)\n{\n\tint len, n, m, k;\n\tunsigned char *p;\n\tconst unsigned char *mbtab;\n\tconst mbfl_encoding *encoding;\n\n\tencoding = mbfl_no2encoding(string->no_encoding);\n\tif (encoding == NULL || string == NULL) {\n\t\treturn -1;\n\t}\n\n\tlen = 0;\n\tif (encoding->flag & MBFL_ENCTYPE_SBCS) {\n\t\tlen = string->len;\n\t} else if (encoding->flag & (MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE)) {\n\t\tlen = string->len/2;\n\t} else if (encoding->flag & (MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE)) {\n\t\tlen = string->len/4;\n\t} else if (encoding->mblen_table != NULL) {\n\t\tmbtab = encoding->mblen_table;\n\t\tn = 0;\n\t\tp = string->val;\n\t\tk = string->len;\n\t\t/* count */\n\t\tif (p != NULL) {\n\t\t\twhile (n < k) {\n\t\t\t\tm = mbtab[*p];\n\t\t\t\tn += m;\n\t\t\t\tp += m;\n\t\t\t\tlen++;\n\t\t\t};\n\t\t}\n\t} else {\n\t\t/* wchar filter */\n\t\tmbfl_convert_filter *filter = mbfl_convert_filter_new(\n\t\t  string->no_encoding, \n\t\t  mbfl_no_encoding_wchar,\n\t\t  filter_count_output, 0, &len);\n\t\tif (filter == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\t/* count */\n\t\tn = string->len;\n\t\tp = string->val;\n\t\tif (p != NULL) {\n\t\t\twhile (n > 0) {\n\t\t\t\t(*filter->filter_function)(*p++, filter);\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tmbfl_convert_filter_delete(filter);\n\t}\n\n\treturn len;\n}", "target": 1, "cwe": ["CWE-119"], "project": "php-src", "commit_id": "64f42c73efc58e88671ad76b6b6bc8e2b62713e1", "hash": 39715137855146439594534419197989386056, "size": 56, "message": "Fixed bug #71906: AddressSanitizer: negative-size-param (-1) in mbfl_strcut", "idx": 469}
{"func": "static int ct_list_items(struct media_player *mp, const char *name,\n\t\t\t\tuint32_t start, uint32_t end, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\tstruct avrcp *session;\n\tstruct pending_list_items *p;\n\n\tif (player->p != NULL)\n\t\treturn -EBUSY;\n\n\tsession = player->sessions->data;\n\n\tset_ct_player(session, player);\n\n\tif (g_str_has_prefix(name, \"/NowPlaying\"))\n\t\tplayer->scope = 0x03;\n\telse if (g_str_has_suffix(name, \"/search\"))\n\t\tplayer->scope = 0x02;\n\telse\n\t\tplayer->scope = 0x01;\n\n\tavrcp_list_items(session, start, end);\n\n\tp = g_new0(struct pending_list_items, 1);\n\tp->start = start;\n\tp->end = end;\n\tp->total = (uint64_t) (p->end - p->start) + 1;\n\tplayer->p = p;\n\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-200"], "project": "bluez", "commit_id": "e2b0f0d8d63e1223bb714a9efb37e2257818268b", "hash": 185488829652412781980630543197193222687, "size": 31, "message": "avrcp: Fix not checking if params_len match number of received bytes\n\nThis makes sure the number of bytes in the params_len matches the\nremaining bytes received so the code don't end up accessing invalid\nmemory.", "idx": 470}
{"func": "isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,\n    struct idr *idr)\n{\n\tstruct iso9660 *iso9660;\n\tstruct isoent *np;\n\tunsigned char *p;\n\tsize_t l;\n\tint r;\n\tsize_t ffmax, parent_len;\n\tstatic const struct archive_rb_tree_ops rb_ops = {\n\t\tisoent_cmp_node_joliet, isoent_cmp_key_joliet\n\t};\n\n\tif (isoent->children.cnt == 0)\n\t\treturn (0);\n\n\tiso9660 = a->format_data;\n\tif (iso9660->opt.joliet == OPT_JOLIET_LONGNAME)\n\t\tffmax = 206;\n\telse\n\t\tffmax = 128;\n\n\tr = idr_start(a, idr, isoent->children.cnt, (int)ffmax, 6, 2, &rb_ops);\n\tif (r < 0)\n\t\treturn (r);\n\n\tparent_len = 1;\n\tfor (np = isoent; np->parent != np; np = np->parent)\n\t\tparent_len += np->mb_len + 1;\n\n\tfor (np = isoent->children.first; np != NULL; np = np->chnext) {\n\t\tunsigned char *dot;\n\t\tint ext_off, noff, weight;\n\t\tsize_t lt;\n\n\t\tif ((l = np->file->basename_utf16.length) > ffmax)\n\t\t\tl = ffmax;\n\n\t\tp = malloc((l+1)*2);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tmemcpy(p, np->file->basename_utf16.s, l);\n\t\tp[l] = 0;\n\t\tp[l+1] = 0;\n\n\t\tnp->identifier = (char *)p;\n\t\tlt = l;\n\t\tdot = p + l;\n\t\tweight = 0;\n\t\twhile (lt > 0) {\n\t\t\tif (!joliet_allowed_char(p[0], p[1]))\n\t\t\t\tarchive_be16enc(p, 0x005F); /* '_' */\n\t\t\telse if (p[0] == 0 && p[1] == 0x2E) /* '.' */\n\t\t\t\tdot = p;\n\t\t\tp += 2;\n\t\t\tlt -= 2;\n\t\t}\n\t\text_off = (int)(dot - (unsigned char *)np->identifier);\n\t\tnp->ext_off = ext_off;\n\t\tnp->ext_len = (int)l - ext_off;\n\t\tnp->id_len = (int)l;\n\n\t\t/*\n\t\t * Get a length of MBS of a full-pathname.\n\t\t */\n\t\tif (np->file->basename_utf16.length > ffmax) {\n\t\t\tif (archive_strncpy_l(&iso9660->mbs,\n\t\t\t    (const char *)np->identifier, l,\n\t\t\t\tiso9660->sconv_from_utf16be) != 0 &&\n\t\t\t    errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tnp->mb_len = (int)iso9660->mbs.length;\n\t\t\tif (np->mb_len != (int)np->file->basename.length)\n\t\t\t\tweight = np->mb_len;\n\t\t} else\n\t\t\tnp->mb_len = (int)np->file->basename.length;\n\n\t\t/* If a length of full-pathname is longer than 240 bytes,\n\t\t * it violates Joliet extensions regulation. */\n\t\tif (parent_len > 240\n\t\t    || np->mb_len > 240\n\t\t    || parent_len + np->mb_len > 240) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"The regulation of Joliet extensions;\"\n\t\t\t    \" A length of a full-pathname of `%s' is \"\n\t\t\t    \"longer than 240 bytes, (p=%d, b=%d)\",\n\t\t\t    archive_entry_pathname(np->file->entry),\n\t\t\t    (int)parent_len, (int)np->mb_len);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/* Make an offset of the number which is used to be set\n\t\t * hexadecimal number to avoid duplicate identifier. */\n\t\tif (l == ffmax)\n\t\t\tnoff = ext_off - 6;\n\t\telse if (l == ffmax-2)\n\t\t\tnoff = ext_off - 4;\n\t\telse if (l == ffmax-4)\n\t\t\tnoff = ext_off - 2;\n\t\telse\n\t\t\tnoff = ext_off;\n\t\t/* Register entry to the identifier resolver. */\n\t\tidr_register(idr, np, weight, noff);\n\t}\n\n\t/* Resolve duplicate identifier with Joliet Volume. */\n\tidr_resolve(idr, idr_set_num_beutf16);\n\n\treturn (ARCHIVE_OK);\n}", "target": 0, "cwe": ["CWE-190"], "project": "libarchive", "commit_id": "3014e19820ea53c15c90f9d447ca3e668a0b76c6", "hash": 185070314551950515012538718766283660778, "size": 116, "message": "Issue 711:  Be more careful about verifying filename lengths when writing ISO9660 archives\n\n* Don't cast size_t to int, since this can lead to overflow\n  on machines where sizeof(int) < sizeof(size_t)\n* Check a + b > limit by writing it as\n    a > limit || b > limit || a + b > limit\n  to avoid problems when a + b wraps around.", "idx": 471}
{"func": "msg_t* MsgDup(msg_t* pOld)\n{\n\tmsg_t* pNew;\n\trsRetVal localRet;\n\n\tassert(pOld != NULL);\n\n\tBEGINfunc\n\tif(msgConstructWithTime(&pNew, &pOld->tTIMESTAMP, pOld->ttGenTime) != RS_RET_OK) {\n\t\treturn NULL;\n\t}\n\n\t/* now copy the message properties */\n\tpNew->iRefCount = 1;\n\tpNew->iSeverity = pOld->iSeverity;\n\tpNew->iFacility = pOld->iFacility;\n\tpNew->msgFlags = pOld->msgFlags;\n\tpNew->iProtocolVersion = pOld->iProtocolVersion;\n\tpNew->ttGenTime = pOld->ttGenTime;\n\tpNew->offMSG = pOld->offMSG;\n\tpNew->iLenRawMsg = pOld->iLenRawMsg;\n\tpNew->iLenMSG = pOld->iLenMSG;\n\tpNew->iLenTAG = pOld->iLenTAG;\n\tpNew->iLenHOSTNAME = pOld->iLenHOSTNAME;\n\tif((pOld->msgFlags & NEEDS_DNSRESOL) == 1) {\n\t\t\tlocalRet = msgSetFromSockinfo(pNew, pOld->rcvFrom.pfrominet);\n\t\t\tif(localRet != RS_RET_OK) {\n\t\t\t\t/* if something fails, we accept loss of this property, it is\n\t\t\t\t * better than losing the whole message.\n\t\t\t\t */\n\t\t\t\tpNew->msgFlags &= ~NEEDS_DNSRESOL;\n\t\t\t}\n\t} else {\n\t\tif(pOld->rcvFrom.pRcvFrom != NULL) {\n\t\t\tpNew->rcvFrom.pRcvFrom = pOld->rcvFrom.pRcvFrom;\n\t\t\tprop.AddRef(pNew->rcvFrom.pRcvFrom);\n\t\t}\n\t}\n\tif(pOld->pRcvFromIP != NULL) {\n\t\tpNew->pRcvFromIP = pOld->pRcvFromIP;\n\t\tprop.AddRef(pNew->pRcvFromIP);\n\t}\n\tif(pOld->pInputName != NULL) {\n\t\tpNew->pInputName = pOld->pInputName;\n\t\tprop.AddRef(pNew->pInputName);\n\t}\n\t/* enable this, if someone actually uses UxTradMsg, delete after some time has\n\t * passed and nobody complained -- rgerhards, 2009-06-16\n\tpNew->offAfterPRI = pOld->offAfterPRI;\n\t*/\n\tif(pOld->iLenTAG > 0) {\n\t\tif(pOld->iLenTAG < CONF_TAG_BUFSIZE) {\n\t\t\tmemcpy(pNew->TAG.szBuf, pOld->TAG.szBuf, pOld->iLenTAG);\n\t\t} else {\n\t\t\tif((pNew->TAG.pszTAG = srUtilStrDup(pOld->TAG.pszTAG, pOld->iLenTAG)) == NULL) {\n\t\t\t\tmsgDestruct(&pNew);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpNew->iLenTAG = pOld->iLenTAG;\n\t\t}\n\t}\n\tif(pOld->iLenRawMsg < CONF_RAWMSG_BUFSIZE) {\n\t\tmemcpy(pNew->szRawMsg, pOld->szRawMsg, pOld->iLenRawMsg + 1);\n\t\tpNew->pszRawMsg = pNew->szRawMsg;\n\t} else {\n\t\ttmpCOPYSZ(RawMsg);\n\t}\n\tif(pOld->iLenHOSTNAME < CONF_HOSTNAME_BUFSIZE) {\n\t\tmemcpy(pNew->szHOSTNAME, pOld->szHOSTNAME, pOld->iLenHOSTNAME + 1);\n\t\tpNew->pszHOSTNAME = pNew->szHOSTNAME;\n\t} else {\n\t\ttmpCOPYSZ(HOSTNAME);\n\t}\n\n\ttmpCOPYCSTR(ProgName);\n\ttmpCOPYCSTR(StrucData);\n\ttmpCOPYCSTR(APPNAME);\n\ttmpCOPYCSTR(PROCID);\n\ttmpCOPYCSTR(MSGID);\n\n\t/* we do not copy all other cache properties, as we do not even know\n\t * if they are needed once again. So we let them re-create if needed.\n\t */\n\n\tENDfunc\n\treturn pNew;\n}", "target": 1, "cwe": ["CWE-772"], "project": "rsyslog", "commit_id": "8083bd1433449fd2b1b79bf759f782e0f64c0cd2", "hash": 27485991043503753802405176455964332842, "size": 87, "message": "backporting abort condition fix from 5.7.7", "idx": 472}
{"func": "static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)\n{\n\treturn fsetxattr(fsp->fh->fd, name, value, size, flags);\n}", "target": 0, "cwe": ["CWE-665"], "project": "samba", "commit_id": "30e724cbff1ecd90e5a676831902d1e41ec1b347", "hash": 260556560360808191597131810677665480759, "size": 4, "message": "FSCTL_GET_SHADOW_COPY_DATA: Initialize output array to zero\n\nOtherwise num_volumes and the end marker can return uninitialized data\nto the client.\n\nSigned-off-by: Christof Schmitt <christof.schmitt@us.ibm.com>\nReviewed-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Simo Sorce <idra@samba.org>", "idx": 473}
{"func": "static int credential_config_callback(const char *var, const char *value,\n\t\t\t\t      void *data)\n{\n\tstruct credential *c = data;\n\tconst char *key, *dot;\n\n\tif (!skip_prefix(var, \"credential.\", &key))\n\t\treturn 0;\n\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\n\tdot = strrchr(key, '.');\n\tif (dot) {\n\t\tstruct credential want = CREDENTIAL_INIT;\n\t\tchar *url = xmemdupz(key, dot - key);\n\t\tint matched;\n\n\t\tcredential_from_url(&want, url);\n\t\tmatched = credential_match(&want, c);\n\n\t\tcredential_clear(&want);\n\t\tfree(url);\n\n\t\tif (!matched)\n\t\t\treturn 0;\n\t\tkey = dot + 1;\n\t}\n\n\tif (!strcmp(key, \"helper\")) {\n\t\tif (*value)\n\t\t\tstring_list_append(&c->helpers, value);\n\t\telse\n\t\t\tstring_list_clear(&c->helpers, 0);\n\t} else if (!strcmp(key, \"username\")) {\n\t\tif (!c->username)\n\t\t\tc->username = xstrdup(value);\n\t}\n\telse if (!strcmp(key, \"usehttppath\"))\n\t\tc->use_http_path = git_config_bool(var, value);\n\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-522"], "project": "git", "commit_id": "c44088ecc4b0722636e0a305f9608d3047197282", "hash": 17691044077870558404202051305754798828, "size": 43, "message": "credential: treat URL without scheme as invalid\n\nlibcurl permits making requests without a URL scheme specified.  In\nthis case, it guesses the URL from the hostname, so I can run\n\n\tgit ls-remote http::ftp.example.com/path/to/repo\n\nand it would make an FTP request.\n\nAny user intentionally using such a URL is likely to have made a typo.\nUnfortunately, credential_from_url is not able to determine the host and\nprotocol in order to determine appropriate credentials to send, and\nuntil \"credential: refuse to operate when missing host or protocol\",\nthis resulted in another host's credentials being leaked to the named\nhost.\n\nTeach credential_from_url_gently to consider such a URL to be invalid\nso that fsck can detect and block gitmodules files with such URLs,\nallowing server operators to avoid serving them to downstream users\nrunning older versions of Git.\n\nThis also means that when such URLs are passed on the command line, Git\nwill print a clearer error so affected users can switch to the simpler\nURL that explicitly specifies the host and protocol they intend.\n\nOne subtlety: .gitmodules files can contain relative URLs, representing\na URL relative to the URL they were cloned from.  The relative URL\nresolver used for .gitmodules can follow \"..\" components out of the path\npart and past the host part of a URL, meaning that such a relative URL\ncan be used to traverse from a https://foo.example.com/innocent\nsuperproject to a https::attacker.example.com/exploit submodule.\nFortunately a leading ':' in the first path component after a series of\nleading './' and '../' components is unlikely to show up in other\ncontexts, so we can catch this by detecting that pattern.\n\nReported-by: Jeff King <peff@peff.net>\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>\nReviewed-by: Jeff King <peff@peff.net>", "idx": 474}
{"func": "loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n  {\n  uint32   i;\n  float    xres = 0.0, yres = 0.0;\n  uint32   nstrips = 0, ntiles = 0;\n  uint16   planar = 0;\n  uint16   bps = 0, spp = 0, res_unit = 0;\n  uint16   orientation = 0;\n  uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n  /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n  /* outside buffer */\n  if (!read_buff)\n  {\n    if( buffsize > 0xFFFFFFFFU - 3 )\n    {\n        TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n        return (-1);\n    }\n    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n  }\n  else\n    {\n    if (prev_readsize < buffsize)\n    {\n      if( buffsize > 0xFFFFFFFFU - 3 )\n      {\n          TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n          return (-1);\n      }\n      new_buff = _TIFFrealloc(read_buff, buffsize+3);\n      if (!new_buff)\n        {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }   /* end loadImage */", "target": 0, "cwe": ["CWE-125"], "project": "libtiff", "commit_id": "21d39de1002a5e69caa0574b2cc05d795d6fbfad", "hash": 307197030595691420054690917067740033843, "size": 413, "message": "* tools/tiffcrop.c: fix multiple uint32 overflows in\nwriteBufferToSeparateStrips(), writeBufferToContigTiles() and\nwriteBufferToSeparateTiles() that could cause heap buffer overflows.\nReported by Henri Salo from Nixu Corporation.\nFixes http://bugzilla.maptools.org/show_bug.cgi?id=2592", "idx": 475}
{"func": "static char *dex_method_signature(RBinDexObj *bin, int method_idx) {\n\tut32 proto_id, params_off, type_id, list_size;\n\tchar *r, *return_type = NULL, *signature = NULL, *buff = NULL; \n\tut8 *bufptr;\n\tut16 type_idx;\n\tint pos = 0, i, size = 1;\n\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tproto_id = bin->methods[method_idx].proto_id;\n\tif (proto_id >= bin->header.prototypes_size) {\n\t\treturn NULL;\n\t}\n\tparams_off = bin->protos[proto_id].parameters_off;\n\tif (params_off  >= bin->size) {\n\t\treturn NULL;\n\t}\n\ttype_id = bin->protos[proto_id].return_type_id;\n\tif (type_id >= bin->header.types_size ) {\n\t\treturn NULL;\n\t}\n\treturn_type = getstr (bin, bin->types[type_id].descriptor_id);\n\tif (!return_type) {\n\t\treturn NULL;\n\t}\n\tif (!params_off) {\n\t\treturn r_str_newf (\"()%s\", return_type);;\n\t}\n\tbufptr = bin->b->buf;\n\t// size of the list, in entries\n\tlist_size = r_read_le32 (bufptr + params_off); \n\t//XXX again list_size is user controlled huge loop\n\tfor (i = 0; i < list_size; i++) {\n\t\tint buff_len = 0;\n\t\tif (params_off + 4 + (i * 2) >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\ttype_idx = r_read_le16 (bufptr + params_off + 4 + (i * 2));\n\t\tif (type_idx < 0 ||\n\t\t    type_idx >=\n\t\t\t    bin->header.types_size || type_idx >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff = getstr (bin, bin->types[type_idx].descriptor_id);\n\t\tif (!buff) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff_len = strlen (buff);\n\t\tsize += buff_len + 1;\n\t\tsignature = realloc (signature, size);\n\t\tstrcpy (signature + pos, buff);\n\t\tpos += buff_len;\n\t\tsignature[pos] = '\\0';\n\t}\n\tr = r_str_newf (\"(%s)%s\", signature, return_type);\n\tfree (buff);\n\tfree (signature);\n\treturn r;\n}", "target": 0, "cwe": ["CWE-125"], "project": "radare2", "commit_id": "ead645853a63bf83d8386702cad0cf23b31d7eeb", "hash": 35815464249932800643821868903089278129, "size": 60, "message": "fix #6857", "idx": 476}
{"func": "static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,\n\t\t\t\t\tstruct ath10k_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\n\tpipe->urb_cnt++;\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}", "target": 1, "cwe": ["CWE-476"], "project": "linux", "commit_id": "bfd6e6e6c5d2ee43a3d9902b36e01fc7527ebb27", "hash": 65597966255144004256683126721395567132, "size": 12, "message": "ath10k: Fix a NULL-ptr-deref bug in ath10k_usb_alloc_urb_from_pipe\n\nThe `ar_usb` field of `ath10k_usb_pipe_usb_pipe` objects\nare initialized to point to the containing `ath10k_usb` object\naccording to endpoint descriptors read from the device side, as shown\nbelow in `ath10k_usb_setup_pipe_resources`:\n\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n        endpoint = &iface_desc->endpoint[i].desc;\n\n        // get the address from endpoint descriptor\n        pipe_num = ath10k_usb_get_logical_pipe_num(ar_usb,\n                                                endpoint->bEndpointAddress,\n                                                &urbcount);\n        ......\n        // select the pipe object\n        pipe = &ar_usb->pipes[pipe_num];\n\n        // initialize the ar_usb field\n        pipe->ar_usb = ar_usb;\n}\n\nThe driver assumes that the addresses reported in endpoint\ndescriptors from device side  to be complete. If a device is\nmalicious and does not report complete addresses, it may trigger\nNULL-ptr-deref `ath10k_usb_alloc_urb_from_pipe` and\n`ath10k_usb_free_urb_to_pipe`.\n\nThis patch fixes the bug by preventing potential NULL-ptr-deref.\n\nSigned-off-by: Hui Peng <benquike@gmail.com>\nReported-by: Hui Peng <benquike@gmail.com>\nReported-by: Mathias Payer <mathias.payer@nebelwelt.net>\nReviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n[groeck: Add driver tag to subject, fix build warning]\nSigned-off-by: Guenter Roeck <linux@roeck-us.net>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>", "idx": 477}
{"func": "Status V2UserDocumentParser::checkValidUserDocument(const BSONObj& doc) const {\n    BSONElement userElement = doc[AuthorizationManager::USER_NAME_FIELD_NAME];\n    BSONElement userDBElement = doc[AuthorizationManager::USER_DB_FIELD_NAME];\n    BSONElement credentialsElement = doc[CREDENTIALS_FIELD_NAME];\n    BSONElement rolesElement = doc[ROLES_FIELD_NAME];\n\n    // Validate the \"user\" element.\n    if (userElement.type() != String)\n        return _badValue(\"User document needs 'user' field to be a string\");\n    if (userElement.valueStringData().empty())\n        return _badValue(\"User document needs 'user' field to be non-empty\");\n\n    // Validate the \"db\" element\n    if (userDBElement.type() != String || userDBElement.valueStringData().empty()) {\n        return _badValue(\"User document needs 'db' field to be a non-empty string\");\n    }\n    StringData userDBStr = userDBElement.valueStringData();\n    if (!NamespaceString::validDBName(userDBStr, NamespaceString::DollarInDbNameBehavior::Allow) &&\n        userDBStr != \"$external\") {\n        return _badValue(mongoutils::str::stream() << \"'\" << userDBStr\n                                                   << \"' is not a valid value for the db field.\");\n    }\n\n    // Validate the \"credentials\" element\n    if (credentialsElement.eoo()) {\n        return _badValue(\"User document needs 'credentials' object\");\n    }\n    if (credentialsElement.type() != Object) {\n        return _badValue(\"User document needs 'credentials' field to be an object\");\n    }\n\n    BSONObj credentialsObj = credentialsElement.Obj();\n    if (credentialsObj.isEmpty()) {\n        return _badValue(\"User document needs 'credentials' field to be a non-empty object\");\n    }\n    if (userDBStr == \"$external\") {\n        BSONElement externalElement = credentialsObj[MONGODB_EXTERNAL_CREDENTIAL_FIELD_NAME];\n        if (externalElement.eoo() || externalElement.type() != Bool || !externalElement.Bool()) {\n            return _badValue(\n                \"User documents for users defined on '$external' must have \"\n                \"'credentials' field set to {external: true}\");\n        }\n    } else {\n        const auto validateScram = [&credentialsObj](const auto& fieldName) {\n            auto scramElement = credentialsObj[fieldName];\n\n            if (scramElement.eoo()) {\n                return Status(ErrorCodes::NoSuchKey,\n                              str::stream() << fieldName << \" does not exist\");\n            }\n            if (scramElement.type() != Object) {\n                return _badValue(str::stream() << fieldName\n                                               << \" credential must be an object, if present\");\n            }\n            return Status::OK();\n        };\n\n        const auto sha1status = validateScram(SCRAMSHA1_CREDENTIAL_FIELD_NAME);\n        if (!sha1status.isOK() && (sha1status.code() != ErrorCodes::NoSuchKey)) {\n            return sha1status;\n        }\n        const auto sha256status = validateScram(SCRAMSHA256_CREDENTIAL_FIELD_NAME);\n        if (!sha256status.isOK() && (sha256status.code() != ErrorCodes::NoSuchKey)) {\n            return sha256status;\n        }\n\n        if (!sha1status.isOK() && !sha256status.isOK()) {\n            return _badValue(\n                \"User document must provide credentials for all \"\n                \"non-external users\");\n        }\n    }\n\n    // Validate the \"roles\" element.\n    Status status = _checkV2RolesArray(rolesElement);\n    if (!status.isOK())\n        return status;\n\n    // Validate the \"authenticationRestrictions\" element.\n    status = initializeAuthenticationRestrictionsFromUserDocument(doc, nullptr);\n    if (!status.isOK()) {\n        return status;\n    }\n\n    return Status::OK();\n}", "target": 1, "cwe": ["CWE-613"], "project": "mongo", "commit_id": "e55d6e2292e5dbe2f97153251d8193d1cc89f5d7", "hash": 124961908175795967556638678838268842861, "size": 86, "message": "SERVER-38984 Validate unique User ID on UserCache hit", "idx": 478}
{"func": "Item *Item_decimal::neg(THD *thd)\n{\n  my_decimal_neg(&decimal_value);\n  unsigned_flag= 0;\n  name= 0;\n  max_length= my_decimal_precision_to_length_no_truncation(\n                      decimal_value.intg + decimals, decimals, unsigned_flag);\n  return this;\n}", "target": 0, "cwe": ["CWE-89"], "project": "server", "commit_id": "b5e16a6e0381b28b598da80b414168ce9a5016e5", "hash": 244358935165926897553188970765634706754, "size": 9, "message": "MDEV-26061 MariaDB server crash at Field::set_default\n\n* Item_default_value::fix_fields creates a copy of its argument's field.\n* Field::default_value is changed when its expression is prepared in\n  unpack_vcol_info_from_frm()\n\nThis means we must unpack any vcol expression that includes DEFAULT(x)\nstrictly after unpacking x->default_value.\n\nTo avoid building and solving this dependency graph on every table open,\nwe update Item_default_value::field->default_value after all vcols\nare unpacked and fixed.", "idx": 479}
{"func": "static int _snd_timer_stop(struct snd_timer_instance * timeri,\n\t\t\t   int keep_flag, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\tif (!keep_flag) {\n\t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n\t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\t\t}\n\t\tgoto __end;\n\t}\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\tif (!keep_flag)\n\t\ttimeri->flags &=\n\t\t\t~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n      __end:\n\tif (event != SNDRV_TIMER_EVENT_RESOLUTION)\n\t\tsnd_timer_notify1(timeri, event);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20", "CWE-200", "CWE-362"], "project": "linux", "commit_id": "b5a663aa426f4884c71cd8580adae73f33570f0d", "hash": 245085130623588060194087430417348968581, "size": 44, "message": "ALSA: timer: Harden slave timer list handling\n\nA slave timer instance might be still accessible in a racy way while\noperating the master instance as it lacks of locking.  Since the\nmaster operation is mostly protected with timer->lock, we should cope\nwith it while changing the slave instance, too.  Also, some linked\nlists (active_list and ack_list) of slave instances aren't unlinked\nimmediately at stopping or closing, and this may lead to unexpected\naccesses.\n\nThis patch tries to address these issues.  It adds spin lock of\ntimer->lock (either from master or slave, which is equivalent) in a\nfew places.  For avoiding a deadlock, we ensure that the global\nslave_active_lock is always locked at first before each timer lock.\n\nAlso, ack and active_list of slave instances are properly unlinked at\nsnd_timer_stop() and snd_timer_close().\n\nLast but not least, remove the superfluous call of _snd_timer_stop()\nat removing slave links.  This is a noop, and calling it may confuse\nreaders wrt locking.  Further cleanup will follow in a later patch.\n\nActually we've got reports of use-after-free by syzkaller fuzzer, and\nthis hopefully fixes these issues.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "idx": 480}
{"func": "SMB2_sess_sendreceive(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb2_sess_setup_req *req = sess_data->iov[0].iov_base;\n\tstruct kvec rsp_iov = { NULL, 0 };\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->SecurityBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_sess_setup_req) -\n\t\t\t1 /* pad */ - 4 /* rfc1001 len */);\n\treq->SecurityBufferLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tinc_rfc1001_len(req, sess_data->iov[1].iov_len - 1 /* pad */);\n\n\t/* BB add code to build os and lm fields */\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t\tsess_data->iov, 2,\n\t\t\t\t&sess_data->buf0_type,\n\t\t\t\tCIFS_LOG_ERROR | CIFS_NEG_OP, &rsp_iov);\n\tcifs_small_buf_release(sess_data->iov[0].iov_base);\n\tmemcpy(&sess_data->iov[0], &rsp_iov, sizeof(struct kvec));\n\n\treturn rc;\n}", "target": 0, "cwe": ["CWE-476"], "project": "linux", "commit_id": "cabfb3680f78981d26c078a26e5c748531257ebb", "hash": 267576629939701376450427138671593612849, "size": 25, "message": "CIFS: Enable encryption during session setup phase\n\nIn order to allow encryption on SMB connection we need to exchange\na session key and generate encryption and decryption keys.\n\nSigned-off-by: Pavel Shilovsky <pshilov@microsoft.com>", "idx": 481}
{"func": "int zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_group_stop_pending(t);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}", "target": 0, "cwe": ["CWE-400"], "project": "linux-stable-rt", "commit_id": "bcf6b1d78c0bde228929c388978ed3af9a623463", "hash": 190162549136944278041473075336968750619, "size": 20, "message": "signal/x86: Delay calling signals in atomic\n\nOn x86_64 we must disable preemption before we enable interrupts\nfor stack faults, int3 and debugging, because the current task is using\na per CPU debug stack defined by the IST. If we schedule out, another task\ncan come in and use the same stack and cause the stack to be corrupted\nand crash the kernel on return.\n\nWhen CONFIG_PREEMPT_RT_FULL is enabled, spin_locks become mutexes, and\none of these is the spin lock used in signal handling.\n\nSome of the debug code (int3) causes do_trap() to send a signal.\nThis function calls a spin lock that has been converted to a mutex\nand has the possibility to sleep. If this happens, the above issues with\nthe corrupted stack is possible.\n\nInstead of calling the signal right away, for PREEMPT_RT and x86_64,\nthe signal information is stored on the stacks task_struct and\nTIF_NOTIFY_RESUME is set. Then on exit of the trap, the signal resume\ncode will send the signal when preemption is enabled.\n\n[ rostedt: Switched from #ifdef CONFIG_PREEMPT_RT_FULL to\n  ARCH_RT_DELAYS_SIGNAL_SEND and added comments to the code. ]\n\nCc: stable-rt@vger.kernel.org\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>", "idx": 482}
{"func": "static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\tfuse_link_write_file(file);\n\n\tfile_accessed(file);\n\tvma->vm_ops = &fuse_file_vm_ops;\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-399", "CWE-835"], "project": "linux", "commit_id": "3ca8138f014a913f98e6ef40e939868e1e9ea876", "hash": 58356454354151595553679511274125564061, "size": 9, "message": "fuse: break infinite loop in fuse_fill_write_pages()\n\nI got a report about unkillable task eating CPU. Further\ninvestigation shows, that the problem is in the fuse_fill_write_pages()\nfunction. If iov's first segment has zero length, we get an infinite\nloop, because we never reach iov_iter_advance() call.\n\nFix this by calling iov_iter_advance() before repeating an attempt to\ncopy data from userspace.\n\nA similar problem is described in 124d3b7041f (\"fix writev regression:\npan hanging unkillable and un-straceable\"). If zero-length segmend\nis followed by segment with invalid address,\niov_iter_fault_in_readable() checks only first segment (zero-length),\niov_iter_copy_from_user_atomic() skips it, fails at second and\nreturns zero -> goto again without skipping zero-length segment.\n\nPatch calls iov_iter_advance() before goto again: we'll skip zero-length\nsegment at second iteraction and iov_iter_fault_in_readable() will detect\ninvalid address.\n\nSpecial thanks to Konstantin Khlebnikov, who helped a lot with the commit\ndescription.\n\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Maxim Patlasov <mpatlasov@parallels.com>\nCc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nSigned-off-by: Roman Gushchin <klamm@yandex-team.ru>\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nFixes: ea9b9907b82a (\"fuse: implement perform_write\")\nCc: <stable@vger.kernel.org>", "idx": 483}
{"func": "parse_suse_release (guestfs_h *g, struct inspect_fs *fs, const char *filename)\n{\n  int64_t size;\n  char *major, *minor;\n  CLEANUP_FREE_STRING_LIST char **lines = NULL;\n  int r = -1;\n\n  /* Don't trust guestfs_head_n not to break with very large files.\n   * Check the file size is something reasonable first.\n   */\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    /* guestfs_filesize failed and has already set error in handle */\n    return -1;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return -1;\n  }\n\n  lines = guestfs_head_n (g, 10, filename);\n  if (lines == NULL)\n    return -1;\n\n  if (lines[0] != NULL)\n    goto out;\n\n  /* First line is dist release name */\n  fs->product_name = safe_strdup (g, lines[0]);\n\n  /* Match SLES first because openSuSE regex overlaps some SLES release strings */\n  if (match (g, fs->product_name, re_sles) || match (g, fs->product_name, re_nld)) {\n    fs->distro = OS_DISTRO_SLES;\n\n    /* Second line contains version string */\n    if (lines[1] == NULL)\n      goto out;\n    major = match1 (g, lines[1], re_sles_version);\n    if (major == NULL)\n      goto out;\n    fs->major_version = guestfs___parse_unsigned_int (g, major);\n    free (major);\n    if (fs->major_version == -1)\n      goto out;\n\n    /* Third line contains service pack string */\n    if (lines[2] == NULL)\n      goto out;\n    minor = match1 (g, lines[2], re_sles_patchlevel);\n    if (minor == NULL)\n      goto out;\n    fs->minor_version = guestfs___parse_unsigned_int (g, minor);\n    free (minor);\n    if (fs->minor_version == -1)\n      goto out;\n  }\n  else if (match (g, fs->product_name, re_opensuse)) {\n    fs->distro = OS_DISTRO_OPENSUSE;\n\n    /* Second line contains version string */\n    if (lines[1] == NULL)\n      goto out;\n    if (match2 (g, lines[1], re_opensuse_version, &major, &minor)) {\n      fs->major_version = guestfs___parse_unsigned_int (g, major);\n      fs->minor_version = guestfs___parse_unsigned_int (g, minor);\n      free (major);\n      free (minor);\n      if (fs->major_version == -1 || fs->minor_version == -1)\n        goto out;\n    }\n  }\n\n  r = 0;\n\nout:\n  return r;\n}", "target": 1, "cwe": [], "project": "libguestfs", "commit_id": "1c9dfd079aa6d7893f72c5fd17656c847f72c8d6", "hash": 275588231035828068184347555721900796111, "size": 77, "message": "inspection: Correct fix for segfault if /etc/SuSE-release is an empty file.\n\nThe test was the wrong way round.\n\nSee: CVE-2013-2124.\n\nThis fixes commit ae8bb84ecd46d7b6ef557a87725923ac8d09dce0.", "idx": 484}
{"func": "int cap_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective, has_cap = false;\n\tint ret;\n\n\teffective = false;\n\tret = get_file_caps(bprm, &effective, &has_cap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!issecure(SECURE_NOROOT)) {\n\t\t/*\n\t\t * If the legacy file capability is set, then don't set privs\n\t\t * for a setuid root binary run by a non-root user.  Do set it\n\t\t * for a root user just to cause least surprise to an admin.\n\t\t */\n\t\tif (has_cap && new->uid != 0 && new->euid == 0) {\n\t\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\t\tgoto skip;\n\t\t}\n\t\t/*\n\t\t * To support inheritance of root-permissions and suid-root\n\t\t * executables under compatibility mode, we override the\n\t\t * capability sets for the file.\n\t\t *\n\t\t * If only the real uid is 0, we do not set the effective bit.\n\t\t */\n\t\tif (new->euid == 0 || new->uid == 0) {\n\t\t\t/* pP' = (cap_bset & ~0) | (pI & ~0) */\n\t\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t\t old->cap_inheritable);\n\t\t}\n\t\tif (new->euid == 0)\n\t\t\teffective = true;\n\t}\nskip:\n\n\t/* Don't let someone trace a set[ug]id/setpcap binary with the revised\n\t * credentials unless they have the appropriate permit\n\t */\n\tif ((new->euid != old->uid ||\n\t     new->egid != old->gid ||\n\t     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&\n\t    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {\n\t\t/* downgrade; they get no more than they had, and maybe less */\n\t\tif (!capable(CAP_SETUID)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tcap_clear(new->cap_effective);\n\tbprm->cap_effective = effective;\n\n\t/*\n\t * Audit candidate if current->cap_effective is set\n\t *\n\t * We do not bother to audit if 3 things are true:\n\t *   1) cap_effective has all caps\n\t *   2) we are root\n\t *   3) root is supposed to have all caps (SECURE_NOROOT)\n\t * Since this is just a normal root execing a process.\n\t *\n\t * Number 1 above might fail if you don't have a full bset, but I think\n\t * that is interesting information to audit.\n\t */\n\tif (!cap_isclear(new->cap_effective)) {\n\t\tif (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||\n\t\t    new->euid != 0 || new->uid != 0 ||\n\t\t    issecure(SECURE_NOROOT)) {\n\t\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "project": "linux", "commit_id": "259e5e6c75a910f3b5e656151dc602f53f9d7548", "hash": 143428732372556511451766388619475196179, "size": 89, "message": "Add PR_{GET,SET}_NO_NEW_PRIVS to prevent execve from granting privs\n\nWith this change, calling\n  prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)\ndisables privilege granting operations at execve-time.  For example, a\nprocess will not be able to execute a setuid binary to change their uid\nor gid if this bit is set.  The same is true for file capabilities.\n\nAdditionally, LSM_UNSAFE_NO_NEW_PRIVS is defined to ensure that\nLSMs respect the requested behavior.\n\nTo determine if the NO_NEW_PRIVS bit is set, a task may call\n  prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0);\nIt returns 1 if set and 0 if it is not set. If any of the arguments are\nnon-zero, it will return -1 and set errno to -EINVAL.\n(PR_SET_NO_NEW_PRIVS behaves similarly.)\n\nThis functionality is desired for the proposed seccomp filter patch\nseries.  By using PR_SET_NO_NEW_PRIVS, it allows a task to modify the\nsystem call behavior for itself and its child tasks without being\nable to impact the behavior of a more privileged task.\n\nAnother potential use is making certain privileged operations\nunprivileged.  For example, chroot may be considered \"safe\" if it cannot\naffect privileged tasks.\n\nNote, this patch causes execve to fail when PR_SET_NO_NEW_PRIVS is\nset and AppArmor is in use.  It is fixed in a subsequent patch.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Will Drewry <wad@chromium.org>\nAcked-by: Eric Paris <eparis@redhat.com>\nAcked-by: Kees Cook <keescook@chromium.org>\n\nv18: updated change desc\nv17: using new define values as per 3.4\nSigned-off-by: James Morris <james.l.morris@oracle.com>", "idx": 485}
{"func": "static void libxsmm_sparse_csr_reader( const char*    i_csr_file_in,\n                                unsigned int**        o_row_idx,\n                                unsigned int**        o_column_idx,\n                                REALTYPE**            o_values,\n                                unsigned int*         o_row_count,\n                                unsigned int*         o_column_count,\n                                unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC datastructure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL )    ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        /* read a line of content */\n#if defined(__EDGE_EXECUTE_F32__)\n        if ( sscanf(l_line, \"%u %u %f\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#else\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#endif\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "libxsmm", "commit_id": "151481489192e6d1997f8bde52c5c425ea41741d", "hash": 77053777986773891513119324761063395896, "size": 116, "message": "Issue #287: made CSR/CSC readers more robust against invalid input (case #1).", "idx": 486}
{"func": "static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)\n{\n\text4_fsblk_t block = ext4_ext_pblock(ext);\n\tint len = ext4_ext_get_actual_len(ext);\n\text4_lblk_t lblock = le32_to_cpu(ext->ee_block);\n\n\t/*\n\t * We allow neither:\n\t *  - zero length\n\t *  - overflow/wrap-around\n\t */\n\tif (lblock + len <= lblock)\n\t\treturn 0;\n\treturn ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);\n}", "target": 1, "cwe": ["CWE-703"], "project": "linux", "commit_id": "ce9f24cccdc019229b70a5c15e2b09ad9c0ab5d1", "hash": 65166371645133437238844289351234583946, "size": 15, "message": "ext4: check journal inode extents more carefully\n\nCurrently, system zones just track ranges of block, that are \"important\"\nfs metadata (bitmaps, group descriptors, journal blocks, etc.). This\nhowever complicates how extent tree (or indirect blocks) can be checked\nfor inodes that actually track such metadata - currently the journal\ninode but arguably we should be treating quota files or resize inode\nsimilarly. We cannot run __ext4_ext_check() on such metadata inodes when\nloading their extents as that would immediately trigger the validity\nchecks and so we just hack around that and special-case the journal\ninode. This however leads to a situation that a journal inode which has\nextent tree of depth at least one can have invalid extent tree that gets\nunnoticed until ext4_cache_extents() crashes.\n\nTo overcome this limitation, track inode number each system zone belongs\nto (0 is used for zones not belonging to any inode). We can then verify\ninode number matches the expected one when verifying extent tree and\nthus avoid the false errors. With this there's no need to to\nspecial-case journal inode during extent tree checking anymore so remove\nit.\n\nFixes: 0a944e8a6c66 (\"ext4: don't perform block validity checks on the journal inode\")\nReported-by: Wolfgang Frisch <wolfgang.frisch@suse.com>\nReviewed-by: Lukas Czerner <lczerner@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nLink: https://lore.kernel.org/r/20200728130437.7804-4-jack@suse.cz\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>", "idx": 487}
{"func": "loop_info(\n\tsockaddr_u *srcadr,\n\tendpt *inter,\n\tstruct req_pkt *inpkt\n\t)\n{\n\tstruct info_loop *li;\n\tl_fp ltmp;\n\n\tli = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,\n\t    sizeof(struct info_loop));\n\n\tDTOLFP(last_offset, &ltmp);\n\tHTONL_FP(&ltmp, &li->last_offset);\n\tDTOLFP(drift_comp * 1e6, &ltmp);\n\tHTONL_FP(&ltmp, &li->drift_comp);\n\tli->compliance = htonl((u_int32)(tc_counter));\n\tli->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));\n\n\tmore_pkt();\n\tflush_pkt();\n}", "target": 1, "cwe": ["CWE-476"], "project": "ntp", "commit_id": "8a0c765f3c47633fa262356b0818788d1cf249b1", "hash": 278865170698893876574084696501963977751, "size": 22, "message": "[Bug 2939] reslist NULL pointer dereference\n[Bug 2940] Stack exhaustion in recursive traversal of restriction list\n  -- these two where fixed together --", "idx": 488}
{"func": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tif (num_clips && clips_ptr) {\n\t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n\t\tif (!clips) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-190", "CWE-189"], "project": "linux", "commit_id": "a5cd335165e31db9dbab636fd29895d41da55dd2", "hash": 109243860856175263518481386548619218089, "size": 69, "message": "drm: integer overflow in drm_mode_dirtyfb_ioctl()\n\nThere is a potential integer overflow in drm_mode_dirtyfb_ioctl()\nif userspace passes in a large num_clips.  The call to kmalloc would\nallocate a small buffer, and the call to fb->funcs->dirty may result\nin a memory corruption.\n\nReported-by: Haogang Chen <haogangchen@gmail.com>\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nCc: stable@kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "idx": 489}
{"func": "int ssl3_connect(SSL *s)\n\t{\n\tBUF_MEM *buf=NULL;\n\tunsigned long Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\t\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); \n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch(s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\ts->state=SSL_ST_CONNECT;\n\t\t\ts->ctx->stats.sess_connect_renegotiate++;\n\t\t\t/* break */\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_CONNECT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_CONNECT:\n\t\tcase SSL_ST_OK|SSL_ST_CONNECT:\n\n\t\t\ts->server=0;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version & 0xff00 ) != 0x0300)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t/* s->version=SSL3_VERSION; */\n\t\t\ts->type=SSL_ST_CONNECT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\tbuf=NULL;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s)) { ret= -1; goto end; }\n\n\t\t\t/* setup buffing BIO */\n\t\t\tif (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }\n\n\t\t\t/* don't push the buffering BIO quite yet */\n\n\t\t\tssl3_init_finished_mac(s);\n\n\t\t\ts->state=SSL3_ST_CW_CLNT_HELLO_A;\n\t\t\ts->ctx->stats.sess_connect++;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CLNT_HELLO_A:\n\t\tcase SSL3_ST_CW_CLNT_HELLO_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_client_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\n\t\t\t/* turn on buffering for the next lot of output */\n\t\t\tif (s->bbio != s->wbio)\n\t\t\t\ts->wbio=BIO_push(s->bbio,s->wbio);\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_SRVR_HELLO_A:\n\t\tcase SSL3_ST_CR_SRVR_HELLO_B:\n\t\t\tret=ssl3_get_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CR_FINISHED_A;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\t{\n\t\t\t\t\t/* receive renewed session ticket */\n\t\t\t\t\ts->state=SSL3_ST_CR_SESSION_TICKET_A;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_CR_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_CERT_A:\n\t\tcase SSL3_ST_CR_CERT_B:\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tret=ssl3_check_finished(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\ts->hit = 1;\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_CR_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_CR_FINISHED_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t/* Check if it is anon DH/ECDH */\n\t\t\t/* or PSK */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\tret=ssl3_get_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_CR_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_KEY_EXCH_A:\n\t\tcase SSL3_ST_CR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\n\t\t\t/* at this point we check that we have the\n\t\t\t * required stuff from the server */\n\t\t\tif (!ssl3_check_cert_and_algorithm(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_CERT_REQ_A:\n\t\tcase SSL3_ST_CR_CERT_REQ_B:\n\t\t\tret=ssl3_get_certificate_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_SRVR_DONE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_SRVR_DONE_A:\n\t\tcase SSL3_ST_CR_SRVR_DONE_B:\n\t\t\tret=ssl3_get_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_SRP\n\t\t\tif (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP)\n\t\t\t\t{\n\t\t\t\tif ((ret = SRP_Calc_A_param(s))<=0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_CONNECT,SSL_R_SRP_A_CALC);\n\t\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_INTERNAL_ERROR);\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\tif (s->s3->tmp.cert_req)\n\t\t\t\ts->state=SSL3_ST_CW_CERT_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_CW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CERT_A:\n\t\tcase SSL3_ST_CW_CERT_B:\n\t\tcase SSL3_ST_CW_CERT_C:\n\t\tcase SSL3_ST_CW_CERT_D:\n\t\t\tret=ssl3_send_client_certificate(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_KEY_EXCH_A:\n\t\tcase SSL3_ST_CW_KEY_EXCH_B:\n\t\t\tret=ssl3_send_client_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\t/* EAY EAY EAY need to check for DH fix cert\n\t\t\t * sent back */\n\t\t\t/* For TLS, cert_req is set to 2, so a cert chain\n\t\t\t * of nothing is sent, but no verify packet is sent */\n\t\t\t/* XXX: For now, we do not support client \n\t\t\t * authentication in ECDH cipher suites with\n\t\t\t * ECDH (rather than ECDSA) certificates.\n\t\t\t * We need to skip the certificate verify \n\t\t\t * message when client's ECDH public key is sent \n\t\t\t * inside the client certificate.\n\t\t\t */\n\t\t\tif (s->s3->tmp.cert_req == 1)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CW_CERT_VRFY_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\t\ts->s3->change_cipher_spec=0;\n\t\t\t\t}\n\t\t\tif (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\t\ts->s3->change_cipher_spec=0;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CERT_VRFY_A:\n\t\tcase SSL3_ST_CW_CERT_VRFY_B:\n\t\t\tret=ssl3_send_client_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\ts->s3->change_cipher_spec=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CHANGE_A:\n\t\tcase SSL3_ST_CW_CHANGE_B:\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_CW_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_CW_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_CW_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n#ifdef OPENSSL_NO_COMP\n\t\t\ts->session->compress_meth=0;\n#else\n\t\t\tif (s->s3->tmp.new_compression == NULL)\n\t\t\t\ts->session->compress_meth=0;\n\t\t\telse\n\t\t\t\ts->session->compress_meth=\n\t\t\t\t\ts->s3->tmp.new_compression->id;\n#endif\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_CLIENT_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_CW_NEXT_PROTO_A:\n\t\tcase SSL3_ST_CW_NEXT_PROTO_B:\n\t\t\tret=ssl3_send_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_CW_FINISHED_A:\n\t\tcase SSL3_ST_CW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->client_finished_label,\n\t\t\t\ts->method->ssl3_enc->client_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_FLUSH;\n\n\t\t\t/* clear flags */\n\t\t\ts->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\t\tif (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)\n\t\t\t\t\t{\n\t\t\t\t\ts->state=SSL_ST_OK;\n\t\t\t\t\ts->s3->flags|=SSL3_FLAGS_POP_BUFFER;\n\t\t\t\t\ts->s3->delay_buf_pop_ret=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\t/* Allow NewSessionTicket if ticket expected */\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;\n\t\t\t\telse\n#endif\n\t\t\t\t\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;\n\t\t\t\t}\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_CR_SESSION_TICKET_A:\n\t\tcase SSL3_ST_CR_SESSION_TICKET_B:\n\t\t\tret=ssl3_get_new_session_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_FINISHED_A;\n\t\t\ts->init_num=0;\n\t\tbreak;\n\n\t\tcase SSL3_ST_CR_CERT_STATUS_A:\n\t\tcase SSL3_ST_CR_CERT_STATUS_B:\n\t\t\tret=ssl3_get_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_CR_FINISHED_A:\n\t\tcase SSL3_ST_CR_FINISHED_B:\n\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,\n\t\t\t\tSSL3_ST_CR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\telse\n\t\t\t\ts->state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_FLUSH:\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tif (s->init_buf != NULL)\n\t\t\t\t{\n\t\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\t\ts->init_buf=NULL;\n\t\t\t\t}\n\n\t\t\t/* If we are not 'joining' the last two packets,\n\t\t\t * remove the buffering now */\n\t\t\tif (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))\n\t\t\t\tssl_free_wbio_buffer(s);\n\t\t\t/* else do it later in ssl3_write */\n\n\t\t\ts->init_num=0;\n\t\t\ts->renegotiate=0;\n\t\t\ts->new_session=0;\n\n\t\t\tssl_update_cache(s,SSL_SESS_CACHE_CLIENT);\n\t\t\tif (s->hit) s->ctx->stats.sess_hit++;\n\n\t\t\tret=1;\n\t\t\t/* s->server=0; */\n\t\t\ts->handshake_func=ssl3_connect;\n\t\t\ts->ctx->stats.sess_connect_good++;\n\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\n\t\t/* did we do anything */\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_CONNECT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}", "target": 1, "cwe": [], "project": "openssl", "commit_id": "4817504d069b4c5082161b02a22116ad75f822b1", "hash": 42281343868361665192015196465478016974, "size": 445, "message": "PR: 2658\nSubmitted by: Robin Seggelmann <seggelmann@fh-muenster.de>\nReviewed by: steve\n\nSupport for TLS/DTLS heartbeats.", "idx": 490}
{"func": "static inline void xenvif_grant_handle_reset(struct xenvif *vif,\n\t\t\t\t\t     u16 pending_idx)\n{\n\tif (unlikely(vif->grant_tx_handle[pending_idx] ==\n\t\t     NETBACK_INVALID_HANDLE)) {\n\t\tnetdev_err(vif->dev,\n\t\t\t   \"Trying to unmap invalid handle! pending_idx: %x\\n\",\n\t\t\t   pending_idx);\n\t\tBUG();\n\t}\n\tvif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;\n}", "target": 0, "cwe": ["CWE-399"], "project": "net-next", "commit_id": "e9d8b2c2968499c1f96563e6522c56958d5a1d0d", "hash": 112163441676021595508735982292777476753, "size": 12, "message": "xen-netback: disable rogue vif in kthread context\n\nWhen netback discovers frontend is sending malformed packet it will\ndisables the interface which serves that frontend.\n\nHowever disabling a network interface involving taking a mutex which\ncannot be done in softirq context, so we need to defer this process to\nkthread context.\n\nThis patch does the following:\n1. introduce a flag to indicate the interface is disabled.\n2. check that flag in TX path, don't do any work if it's true.\n3. check that flag in RX path, turn off that interface if it's true.\n\nThe reason to disable it in RX path is because RX uses kthread. After\nthis change the behavior of netback is still consistent -- it won't do\nany TX work for a rogue frontend, and the interface will be eventually\nturned off.\n\nAlso change a \"continue\" to \"break\" after xenvif_fatal_tx_err, as it\ndoesn't make sense to continue processing packets if frontend is rogue.\n\nThis is a fix for XSA-90.\n\nReported-by: Török Edwin <edwin@etorok.net>\nSigned-off-by: Wei Liu <wei.liu2@citrix.com>\nCc: Ian Campbell <ian.campbell@citrix.com>\nReviewed-by: David Vrabel <david.vrabel@citrix.com>\nAcked-by: Ian Campbell <ian.campbell@citrix.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 491}
{"func": "void setupSigSegvAction(void) {\n    struct sigaction act;\n\n    sigemptyset (&act.sa_mask);\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction\n     * is used. Otherwise, sa_handler is used */\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;\n    act.sa_sigaction = segvHandler;\n    sigaction (SIGSEGV, &act, NULL);\n    sigaction (SIGBUS, &act, NULL);\n    sigaction (SIGFPE, &act, NULL);\n    sigaction (SIGILL, &act, NULL);\n    sigaction (SIGBUS, &act, NULL);\n\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;\n    act.sa_handler = sigtermHandler;\n    sigaction (SIGTERM, &act, NULL);\n    return;\n}", "target": 0, "cwe": ["CWE-20"], "project": "redis", "commit_id": "697af434fbeb2e3ba2ba9687cd283ed1a2734fa5", "hash": 88608552871127928602934710395805279145, "size": 19, "message": "initial changes needed to turn the current VM code into a cache system. Tons of work to do still.", "idx": 492}
{"func": "const char *SSL_get_cipher_list(const SSL *s, int n)\n{\n    SSL_CIPHER *c;\n    STACK_OF(SSL_CIPHER) *sk;\n\n    if (s == NULL)\n        return (NULL);\n    sk = SSL_get_ciphers(s);\n    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))\n        return (NULL);\n    c = sk_SSL_CIPHER_value(sk, n);\n    if (c == NULL)\n        return (NULL);\n    return (c->name);\n}", "target": 0, "cwe": ["CWE-310"], "project": "openssl", "commit_id": "56f1acf5ef8a432992497a04792ff4b3b2c6f286", "hash": 329378722469058105775853109267888853448, "size": 15, "message": "Disable SSLv2 default build, default negotiation and weak ciphers.\n\nSSLv2 is by default disabled at build-time.  Builds that are not\nconfigured with \"enable-ssl2\" will not support SSLv2.  Even if\n\"enable-ssl2\" is used, users who want to negotiate SSLv2 via the\nversion-flexible SSLv23_method() will need to explicitly call either\nof:\n\n    SSL_CTX_clear_options(ctx, SSL_OP_NO_SSLv2);\nor\n    SSL_clear_options(ssl, SSL_OP_NO_SSLv2);\n\nas appropriate.  Even if either of those is used, or the application\nexplicitly uses the version-specific SSLv2_method() or its client\nor server variants, SSLv2 ciphers vulnerable to exhaustive search\nkey recovery have been removed.  Specifically, the SSLv2 40-bit\nEXPORT ciphers, and SSLv2 56-bit DES are no longer available.\n\nMitigation for CVE-2016-0800\n\nReviewed-by: Emilia Käsper <emilia@openssl.org>", "idx": 493}
{"func": "gx_image_enum_begin(gx_device * dev, const gs_gstate * pgs,\n                    const gs_matrix *pmat, const gs_image_common_t * pic,\n                const gx_drawing_color * pdcolor, const gx_clip_path * pcpath,\n                gs_memory_t * mem, gx_image_enum *penum)\n{\n    const gs_pixel_image_t *pim = (const gs_pixel_image_t *)pic;\n    gs_image_format_t format = pim->format;\n    const int width = pim->Width;\n    const int height = pim->Height;\n    const int bps = pim->BitsPerComponent;\n    bool masked = penum->masked;\n    const float *decode = pim->Decode;\n    gs_matrix_double mat;\n    int index_bps;\n    const gs_color_space *pcs = pim->ColorSpace;\n    gs_logical_operation_t lop = (pgs ? pgs->log_op : lop_default);\n    int code;\n    int log2_xbytes = (bps <= 8 ? 0 : arch_log2_sizeof_frac);\n    int spp, nplanes, spread;\n    uint bsize;\n    byte *buffer;\n    fixed mtx, mty;\n    gs_fixed_point row_extent, col_extent, x_extent, y_extent;\n    bool device_color = true;\n    gs_fixed_rect obox, cbox;\n    bool gridfitimages = 0;\n    bool in_pattern_accumulator = 0;\n    int orthogonal;\n    int force_interpolation = 0;\n\n    penum->clues = NULL;\n    penum->icc_setup.has_transfer = false;\n    penum->icc_setup.is_lab = false;\n    penum->icc_setup.must_halftone = false;\n    penum->icc_setup.need_decode = false;\n    penum->Width = width;\n    penum->Height = height;\n\n    if ((code = gx_image_compute_mat(pgs, pmat, &(pim->ImageMatrix), &mat)) < 0) {\n        return code;\n    }\n    /* Grid fit: A common construction in postscript/PDF files is for images\n     * to be constructed as a series of 'stacked' 1 pixel high images.\n     * Furthermore, many of these are implemented as an imagemask plotted on\n     * top of thin rectangles. The different fill rules for images and line\n     * art produces problems; line art fills a pixel if any part of it is\n     * touched - images only fill a pixel if the centre of the pixel is\n     * covered. Bug 692666 is such a problem.\n     *\n     * As a workaround for this problem, the code below was introduced. The\n     * concept is that orthogonal images can be 'grid fitted' (or 'stretch')\n     * to entirely cover pixels that they touch. Initially I had this working\n     * for all images regardless of type, but as testing has proceeded, this\n     * showed more and more regressions, so I've cut the cases back in which\n     * this code is used until it now only triggers on imagemasks that are\n     * either 1 pixel high, or wide, and then not if we are rendering a\n     * glyph (such as from a type3 font).\n     */\n\n    /* Ask the device if we are in a pattern accumulator */\n    in_pattern_accumulator = (dev_proc(dev, dev_spec_op)(dev, gxdso_in_pattern_accumulator, NULL, 0));\n    if (in_pattern_accumulator < 0)\n        in_pattern_accumulator = 0;\n\n    /* Figure out if we are orthogonal */\n    if (mat.xy == 0 && mat.yx == 0)\n        orthogonal = 1;\n    else if (mat.xx == 0 && mat.yy == 0)\n        orthogonal = 2;\n    else\n        orthogonal = 0;\n\n    /* If we are in a pattern accumulator, we choose to always grid fit\n     * orthogonal images. We do this by asking the device whether we\n     * should grid fit. This allows us to avoid nasty blank lines around\n     * the edges of cells.\n     */\n    gridfitimages = in_pattern_accumulator && orthogonal;\n\n    if (pgs != NULL && pgs->show_gstate != NULL) {\n        /* If we're a graphics state, and we're in a text object, then we\n         * must be in a type3 font. Don't fiddle with it. */\n    } else if (!gridfitimages &&\n               (!penum->masked || penum->image_parent_type != 0)) {\n        /* Other than for images we are specifically looking to grid fit (such as\n         * ones in a pattern device), we only grid fit imagemasks */\n    } else if (gridfitimages && (penum->masked && penum->image_parent_type == 0)) {\n        /* We don't gridfit imagemasks in a pattern accumulator */\n    } else if (pgs != NULL && pgs->fill_adjust.x == 0 && pgs->fill_adjust.y == 0) {\n        /* If fill adjust is disabled, so is grid fitting */\n    } else if (orthogonal == 1) {\n        if (width == 1 || gridfitimages) {\n            if (mat.xx > 0) {\n                fixed ix0 = int2fixed(fixed2int(float2fixed(mat.tx)));\n                double x1 = mat.tx + mat.xx * width;\n                fixed ix1 = int2fixed(fixed2int_ceiling(float2fixed(x1)));\n                mat.tx = (double)fixed2float(ix0);\n                mat.xx = (double)(fixed2float(ix1 - ix0)/width);\n            } else if (mat.xx < 0) {\n                fixed ix0 = int2fixed(fixed2int_ceiling(float2fixed(mat.tx)));\n                double x1 = mat.tx + mat.xx * width;\n                fixed ix1 = int2fixed(fixed2int(float2fixed(x1)));\n                mat.tx = (double)fixed2float(ix0);\n                mat.xx = (double)(fixed2float(ix1 - ix0)/width);\n            }\n        }\n        if (height == 1 || gridfitimages) {\n            if (mat.yy > 0) {\n                fixed iy0 = int2fixed(fixed2int(float2fixed(mat.ty)));\n                double y1 = mat.ty + mat.yy * height;\n                fixed iy1 = int2fixed(fixed2int_ceiling(float2fixed(y1)));\n                mat.ty = (double)fixed2float(iy0);\n                mat.yy = (double)(fixed2float(iy1 - iy0)/height);\n            } else if (mat.yy < 0) {\n                fixed iy0 = int2fixed(fixed2int_ceiling(float2fixed(mat.ty)));\n                double y1 = mat.ty + mat.yy * height;\n                fixed iy1 = int2fixed(fixed2int(float2fixed(y1)));\n                mat.ty = (double)fixed2float(iy0);\n                mat.yy = ((double)fixed2float(iy1 - iy0)/height);\n            }\n        }\n    } else if (orthogonal == 2) {\n        if (height == 1 || gridfitimages) {\n            if (mat.yx > 0) {\n                fixed ix0 = int2fixed(fixed2int(float2fixed(mat.tx)));\n                double x1 = mat.tx + mat.yx * height;\n                fixed ix1 = int2fixed(fixed2int_ceiling(float2fixed(x1)));\n                mat.tx = (double)fixed2float(ix0);\n                mat.yx = (double)(fixed2float(ix1 - ix0)/height);\n            } else if (mat.yx < 0) {\n                fixed ix0 = int2fixed(fixed2int_ceiling(float2fixed(mat.tx)));\n                double x1 = mat.tx + mat.yx * height;\n                fixed ix1 = int2fixed(fixed2int(float2fixed(x1)));\n                mat.tx = (double)fixed2float(ix0);\n                mat.yx = (double)(fixed2float(ix1 - ix0)/height);\n            }\n        }\n        if (width == 1 || gridfitimages) {\n            if (mat.xy > 0) {\n                fixed iy0 = int2fixed(fixed2int(float2fixed(mat.ty)));\n                double y1 = mat.ty + mat.xy * width;\n                fixed iy1 = int2fixed(fixed2int_ceiling(float2fixed(y1)));\n                mat.ty = (double)fixed2float(iy0);\n                mat.xy = (double)(fixed2float(iy1 - iy0)/width);\n            } else if (mat.xy < 0) {\n                fixed iy0 = int2fixed(fixed2int_ceiling(float2fixed(mat.ty)));\n                double y1 = mat.ty + mat.xy * width;\n                fixed iy1 = int2fixed(fixed2int(float2fixed(y1)));\n                mat.ty = (double)fixed2float(iy0);\n                mat.xy = ((double)fixed2float(iy1 - iy0)/width);\n            }\n        }\n    }\n\n    /* When rendering to a pattern accumulator, if we are downscaling\n     * then enable interpolation, as otherwise dropouts can cause\n     * serious problems. */\n    if (in_pattern_accumulator) {\n        double ome = ((double)(fixed_1 - fixed_epsilon)) / (double)fixed_1; /* One Minus Epsilon */\n\n        if (orthogonal == 1) {\n            if ((mat.xx > -ome && mat.xx < ome) || (mat.yy > -ome && mat.yy < ome)) {\n                force_interpolation = true;\n            }\n        } else if (orthogonal == 2) {\n            if ((mat.xy > -ome && mat.xy < ome) || (mat.yx > -ome && mat.yx < ome)) {\n                force_interpolation = true;\n            }\n        }\n    }\n\n    /* Can we restrict the amount of image we need? */\n    while (pcpath) /* So we can break out of it */\n    {\n        gs_rect rect, rect_out;\n        gs_matrix mi;\n        const gs_matrix *m = pgs != NULL ? &ctm_only(pgs) : NULL;\n        gs_fixed_rect obox;\n        gs_int_rect irect;\n        if (m == NULL || (code = gs_matrix_invert(m, &mi)) < 0 ||\n            (code = gs_matrix_multiply(&mi, &pic->ImageMatrix, &mi)) < 0) {\n            /* Give up trying to shrink the render box, but continue processing */\n            break;\n        }\n        gx_cpath_outer_box(pcpath, &obox);\n        rect.p.x = fixed2float(obox.p.x);\n        rect.p.y = fixed2float(obox.p.y);\n        rect.q.x = fixed2float(obox.q.x);\n        rect.q.y = fixed2float(obox.q.y);\n        code = gs_bbox_transform(&rect, &mi, &rect_out);\n        if (code < 0) {\n            /* Give up trying to shrink the render box, but continue processing */\n            break;\n        }\n        irect.p.x = (int)(rect_out.p.x-1.0);\n        irect.p.y = (int)(rect_out.p.y-1.0);\n        irect.q.x = (int)(rect_out.q.x+1.0);\n        irect.q.y = (int)(rect_out.q.y+1.0);\n        /* Need to expand the region to allow for the fact that the mitchell\n         * scaler reads multiple pixels in. This calculation can probably be\n         * improved. */\n        /* If mi.{xx,yy} > 1 then we are downscaling. During downscaling,\n         * the support increases to ensure that we don't lose pixels contributions\n         * entirely. */\n        /* I do not understand the need for the +/- 1 fudge factors,\n         * but they seem to be required. Increasing the render rectangle can\n         * never be bad at least... RJW */\n        {\n            float support = any_abs(mi.xx);\n            int isupport;\n            if (any_abs(mi.yy) > support)\n                support = any_abs(mi.yy);\n            if (any_abs(mi.xy) > support)\n                support = any_abs(mi.xy);\n            if (any_abs(mi.yx) > support)\n                support = any_abs(mi.yx);\n            isupport = (int)(MAX_ISCALE_SUPPORT * (support+1)) + 1;\n            irect.p.x -= isupport;\n            irect.p.y -= isupport;\n            irect.q.x += isupport;\n            irect.q.y += isupport;\n        }\n        if (penum->rrect.x < irect.p.x) {\n            penum->rrect.w -= irect.p.x - penum->rrect.x;\n            if (penum->rrect.w < 0)\n               penum->rrect.w = 0;\n            penum->rrect.x = irect.p.x;\n        }\n        if (penum->rrect.x + penum->rrect.w > irect.q.x) {\n            penum->rrect.w = irect.q.x - penum->rrect.x;\n            if (penum->rrect.w < 0)\n                penum->rrect.w = 0;\n        }\n        if (penum->rrect.y < irect.p.y) {\n            penum->rrect.h -= irect.p.y - penum->rrect.y;\n            if (penum->rrect.h < 0)\n                penum->rrect.h = 0;\n            penum->rrect.y = irect.p.y;\n        }\n        if (penum->rrect.y + penum->rrect.h > irect.q.y) {\n            penum->rrect.h = irect.q.y - penum->rrect.y;\n            if (penum->rrect.h < 0)\n                penum->rrect.h = 0;\n        }\n        break; /* Out of the while */\n    }\n    /* Check for the intersection being null */\n    if (penum->rrect.x + penum->rrect.w <= penum->rect.x  ||\n        penum->rect.x  + penum->rect.w  <= penum->rrect.x ||\n        penum->rrect.y + penum->rrect.h <= penum->rect.y  ||\n        penum->rect.y  + penum->rect.h  <= penum->rrect.y)\n    {\n          /* Something may have gone wrong with the floating point above.\n           * set the region to something sane. */\n        penum->rrect.x = penum->rect.x;\n        penum->rrect.y = penum->rect.y;\n        penum->rrect.w = 0;\n        penum->rrect.h = 0;\n    }\n\n    /*penum->matrix = mat;*/\n    penum->matrix.xx = mat.xx;\n    penum->matrix.xy = mat.xy;\n    penum->matrix.yx = mat.yx;\n    penum->matrix.yy = mat.yy;\n    penum->matrix.tx = mat.tx;\n    penum->matrix.ty = mat.ty;\n    if_debug6m('b', mem, \" [%g %g %g %g %g %g]\\n\",\n              mat.xx, mat.xy, mat.yx, mat.yy, mat.tx, mat.ty);\n    /* following works for 1, 2, 4, 8, 12, 16 */\n    index_bps = (bps < 8 ? bps >> 1 : (bps >> 2) + 1);\n    /*\n     * Compute extents with distance transformation.\n     */\n    if (mat.tx > 0)\n        mtx = float2fixed(mat.tx);\n    else { /* Use positive values to ensure round down. */\n        int f = (int)-mat.tx + 1;\n\n        mtx = float2fixed(mat.tx + f) - int2fixed(f);\n    }\n    if (mat.ty > 0)\n        mty = float2fixed(mat.ty);\n    else {  /* Use positive values to ensure round down. */\n        int f = (int)-mat.ty + 1;\n\n        mty = float2fixed(mat.ty + f) - int2fixed(f);\n    }\n\n    row_extent.x = float2fixed_rounded_boxed(width * mat.xx);\n    row_extent.y =\n        (is_fzero(mat.xy) ? fixed_0 :\n         float2fixed_rounded_boxed(width * mat.xy));\n    col_extent.x =\n        (is_fzero(mat.yx) ? fixed_0 :\n         float2fixed_rounded_boxed(height * mat.yx));\n    col_extent.y = float2fixed_rounded_boxed(height * mat.yy);\n    gx_image_enum_common_init((gx_image_enum_common_t *)penum,\n                              (const gs_data_image_t *)pim,\n                              &image1_enum_procs, dev,\n                              (masked ? 1 : (penum->alpha ? cs_num_components(pcs)+1 : cs_num_components(pcs))),\n                              format);\n    if (penum->rect.w == width && penum->rect.h == height) {\n        x_extent = row_extent;\n        y_extent = col_extent;\n    } else {\n        int rw = penum->rect.w, rh = penum->rect.h;\n\n        x_extent.x = float2fixed_rounded_boxed(rw * mat.xx);\n        x_extent.y =\n            (is_fzero(mat.xy) ? fixed_0 :\n             float2fixed_rounded_boxed(rw * mat.xy));\n        y_extent.x =\n            (is_fzero(mat.yx) ? fixed_0 :\n             float2fixed_rounded_boxed(rh * mat.yx));\n        y_extent.y = float2fixed_rounded_boxed(rh * mat.yy);\n    }\n    /* Set icolor0 and icolor1 to point to image clues locations if we have\n       1spp or an imagemask, otherwise image clues is not used and\n       we have these values point to other member variables */\n    if (masked || cs_num_components(pcs) == 1) {\n        /* Go ahead and allocate now if not already done.  For a mask\n           we really should only do 2 values. For now, the goal is to\n           eliminate the 256 bytes for the >8bpp image enumerator */\n        penum->clues = (gx_image_clue*) gs_alloc_bytes(mem, sizeof(gx_image_clue)*256,\n                             \"gx_image_enum_begin\");\n        if (penum->clues == NULL)\n            return_error(gs_error_VMerror);\n        penum->icolor0 = &(penum->clues[0].dev_color);\n        penum->icolor1 = &(penum->clues[255].dev_color);\n    } else {\n        penum->icolor0 = &(penum->icolor0_val);\n        penum->icolor1 = &(penum->icolor1_val);\n    }\n    if (masked) {       /* This is imagemask. */\n        if (bps != 1 || pcs != NULL || penum->alpha || decode[0] == decode[1]) {\n            return_error(gs_error_rangecheck);\n        }\n        /* Initialize color entries 0 and 255. */\n        set_nonclient_dev_color(penum->icolor0, gx_no_color_index);\n        set_nonclient_dev_color(penum->icolor1, gx_no_color_index);\n        *(penum->icolor1) = *pdcolor;\n        memcpy(&penum->map[0].table.lookup4x1to32[0],\n               (decode[0] < decode[1] ? lookup4x1to32_inverted :\n                lookup4x1to32_identity),\n               16 * 4);\n        penum->map[0].decoding = sd_none;\n        spp = 1;\n        lop = rop3_know_S_0(lop);\n    } else {                    /* This is image, not imagemask. */\n        const gs_color_space_type *pcst = pcs->type;\n        int b_w_color;\n\n        spp = cs_num_components(pcs);\n        if (spp < 0) {          /* Pattern not allowed */\n            return_error(gs_error_rangecheck);\n        }\n        if (penum->alpha)\n            ++spp;\n        /* Use a less expensive format if possible. */\n        switch (format) {\n        case gs_image_format_bit_planar:\n            if (bps > 1)\n                break;\n            format = gs_image_format_component_planar;\n        case gs_image_format_component_planar:\n            if (spp == 1)\n                format = gs_image_format_chunky;\n        default:                /* chunky */\n            break;\n        }\n\n        if (pcs->cmm_icc_profile_data != NULL) {\n            device_color = false;\n        } else {\n            device_color = (*pcst->concrete_space) (pcs, pgs) == pcs;\n        }\n\n        code = image_init_colors(penum, bps, spp, format, decode, pgs, dev,\n                          pcs, &device_color);\n        if (code < 0) \n            return gs_throw(code, \"Image colors initialization failed\");\n        /* If we have a CIE based color space and the icc equivalent profile\n           is not yet set, go ahead and handle that now.  It may already\n           be done due to the above init_colors which may go through remap. */\n        if (gs_color_space_is_PSCIE(pcs) && pcs->icc_equivalent == NULL) {\n            code = gs_colorspace_set_icc_equivalent((gs_color_space *)pcs, &(penum->icc_setup.is_lab),\n                                                pgs->memory);\n            if (code < 0)\n                return code;\n            if (penum->icc_setup.is_lab) {\n                /* Free what ever profile was created and use the icc manager's\n                   cielab profile */\n                gs_color_space *curr_pcs = (gs_color_space *)pcs;\n                rc_decrement(curr_pcs->icc_equivalent,\"gx_image_enum_begin\");\n                rc_decrement(curr_pcs->cmm_icc_profile_data,\"gx_image_enum_begin\");\n                curr_pcs->cmm_icc_profile_data = pgs->icc_manager->lab_profile;\n                rc_increment(curr_pcs->cmm_icc_profile_data);\n            }\n        }\n        /* Try to transform non-default RasterOps to something */\n        /* that we implement less expensively. */\n        if (!pim->CombineWithColor)\n            lop = rop3_know_T_0(lop) & ~lop_T_transparent;\n        else if ((rop3_uses_T(lop) && color_draws_b_w(dev, pdcolor) == 0))\n            lop = rop3_know_T_0(lop);\n\n        if (lop != rop3_S &&    /* if best case, no more work needed */\n            !rop3_uses_T(lop) && bps == 1 && spp == 1 &&\n            (b_w_color =\n             color_draws_b_w(dev, penum->icolor0)) >= 0 &&\n            color_draws_b_w(dev, penum->icolor1) == (b_w_color ^ 1)\n            ) {\n            if (b_w_color) {    /* Swap the colors and invert the RasterOp source. */\n                gx_device_color dcolor;\n\n                dcolor = *(penum->icolor0);\n                *(penum->icolor0) = *(penum->icolor1);\n                *(penum->icolor1) = dcolor;\n                lop = rop3_invert_S(lop);\n            }\n            /*\n             * At this point, we know that the source pixels\n             * correspond directly to the S input for the raster op,\n             * i.e., icolor0 is black and icolor1 is white.\n             */\n            switch (lop) {\n                case rop3_D & rop3_S:\n                    /* Implement this as an inverted mask writing 0s. */\n                    *(penum->icolor1) = *(penum->icolor0);\n                    /* (falls through) */\n                case rop3_D | rop3_not(rop3_S):\n                    /* Implement this as an inverted mask writing 1s. */\n                    memcpy(&penum->map[0].table.lookup4x1to32[0],\n                           lookup4x1to32_inverted, 16 * 4);\n                  rmask:        /* Fill in the remaining parameters for a mask. */\n                    penum->masked = masked = true;\n                    set_nonclient_dev_color(penum->icolor0, gx_no_color_index);\n                    penum->map[0].decoding = sd_none;\n                    lop = rop3_T;\n                    break;\n                case rop3_D & rop3_not(rop3_S):\n                    /* Implement this as a mask writing 0s. */\n                    *(penum->icolor1) = *(penum->icolor0);\n                    /* (falls through) */\n                case rop3_D | rop3_S:\n                    /* Implement this as a mask writing 1s. */\n                    memcpy(&penum->map[0].table.lookup4x1to32[0],\n                           lookup4x1to32_identity, 16 * 4);\n                    goto rmask;\n                default:\n                    ;\n            }\n        }\n    }\n    penum->device_color = device_color;\n    /*\n     * Adjust width upward for unpacking up to 7 trailing bits in\n     * the row, plus 1 byte for end-of-run, plus up to 7 leading\n     * bits for data_x offset within a packed byte.\n     */\n    bsize = ((bps > 8 ? width * 2 : width) + 15) * spp;\n    buffer = gs_alloc_bytes(mem, bsize, \"image buffer\");\n    if (buffer == 0) {\n        return_error(gs_error_VMerror);\n    }\n    penum->bps = bps;\n    penum->unpack_bps = bps;\n    penum->log2_xbytes = log2_xbytes;\n    penum->spp = spp;\n    switch (format) {\n    case gs_image_format_chunky:\n        nplanes = 1;\n        spread = 1 << log2_xbytes;\n        break;\n    case gs_image_format_component_planar:\n        nplanes = spp;\n        spread = spp << log2_xbytes;\n        break;\n    case gs_image_format_bit_planar:\n        nplanes = spp * bps;\n        spread = spp << log2_xbytes;\n        break;\n    default:\n        /* No other cases are possible (checked by gx_image_enum_alloc). */\n        return_error(gs_error_Fatal);\n    }\n    penum->num_planes = nplanes;\n    penum->spread = spread;\n    /*\n     * If we're asked to interpolate in a partial image, we have to\n     * assume that the client either really only is interested in\n     * the given sub-image, or else is constructing output out of\n     * overlapping pieces.\n     */\n    penum->interpolate = force_interpolation ? interp_force : pim->Interpolate ? interp_on : interp_off;\n    penum->x_extent = x_extent;\n    penum->y_extent = y_extent;\n    penum->posture =\n        ((x_extent.y | y_extent.x) == 0 ? image_portrait :\n         (x_extent.x | y_extent.y) == 0 ? image_landscape :\n         image_skewed);\n    penum->pgs = pgs;\n    penum->pcs = pcs;\n    penum->memory = mem;\n    penum->buffer = buffer;\n    penum->buffer_size = bsize;\n    penum->line = 0;\n    penum->icc_link = NULL;\n    penum->color_cache = NULL;\n    penum->ht_buffer = NULL;\n    penum->thresh_buffer = NULL;\n    penum->use_cie_range = false;\n    penum->line_size = 0;\n    penum->use_rop = lop != (masked ? rop3_T : rop3_S);\n#ifdef DEBUG\n    if (gs_debug_c('*')) {\n        if (penum->use_rop)\n            dmprintf1(mem, \"[%03x]\", lop);\n        dmprintf5(mem, \"%c%d%c%dx%d \",\n                 (masked ? (color_is_pure(pdcolor) ? 'm' : 'h') : 'i'),\n                 bps,\n                 (penum->posture == image_portrait ? ' ' :\n                  penum->posture == image_landscape ? 'L' : 'T'),\n                 width, height);\n    }\n#endif\n    penum->slow_loop = 0;\n    if (pcpath == 0) {\n        (*dev_proc(dev, get_clipping_box)) (dev, &obox);\n        cbox = obox;\n        penum->clip_image = 0;\n    } else\n        penum->clip_image =\n            (gx_cpath_outer_box(pcpath, &obox) |        /* not || */\n             gx_cpath_inner_box(pcpath, &cbox) ?\n             0 : image_clip_region);\n    penum->clip_outer = obox;\n    penum->clip_inner = cbox;\n    penum->log_op = rop3_T;     /* rop device takes care of this */\n    penum->clip_dev = 0;        /* in case we bail out */\n    penum->rop_dev = 0;         /* ditto */\n    penum->scaler = 0;          /* ditto */\n    /*\n     * If all four extrema of the image fall within the clipping\n     * rectangle, clipping is never required.  When making this check,\n     * we must carefully take into account the fact that we only care\n     * about pixel centers.\n     */\n    {\n        fixed\n            epx = min(row_extent.x, 0) + min(col_extent.x, 0),\n            eqx = max(row_extent.x, 0) + max(col_extent.x, 0),\n            epy = min(row_extent.y, 0) + min(col_extent.y, 0),\n            eqy = max(row_extent.y, 0) + max(col_extent.y, 0);\n\n        {\n            int hwx, hwy;\n\n            switch (penum->posture) {\n                case image_portrait:\n                    hwx = width, hwy = height;\n                    break;\n                case image_landscape:\n                    hwx = height, hwy = width;\n                    break;\n                default:\n                    hwx = hwy = 0;\n            }\n            /*\n             * If the image is only 1 sample wide or high,\n             * and is less than 1 device pixel wide or high,\n             * move it slightly so that it covers pixel centers.\n             * This is a hack to work around a bug in some old\n             * versions of TeX/dvips, which use 1-bit-high images\n             * to draw horizontal and vertical lines without\n             * positioning them properly.\n             */\n            if (hwx == 1 && eqx - epx < fixed_1) {\n                fixed diff =\n                arith_rshift_1(row_extent.x + col_extent.x);\n\n                mtx = (((mtx + diff) | fixed_half) & -fixed_half) - diff;\n            }\n            if (hwy == 1 && eqy - epy < fixed_1) {\n                fixed diff =\n                arith_rshift_1(row_extent.y + col_extent.y);\n\n                mty = (((mty + diff) | fixed_half) & -fixed_half) - diff;\n            }\n        }\n        if_debug5m('b', mem, \"[b]Image: %sspp=%d, bps=%d, mt=(%g,%g)\\n\",\n                   (masked? \"masked, \" : \"\"), spp, bps,\n                   fixed2float(mtx), fixed2float(mty));\n        if_debug9m('b', mem,\n                   \"[b]   cbox=(%g,%g),(%g,%g), obox=(%g,%g),(%g,%g), clip_image=0x%x\\n\",\n                   fixed2float(cbox.p.x), fixed2float(cbox.p.y),\n                   fixed2float(cbox.q.x), fixed2float(cbox.q.y),\n                   fixed2float(obox.p.x), fixed2float(obox.p.y),\n                   fixed2float(obox.q.x), fixed2float(obox.q.y),\n                   penum->clip_image);\n        /* These DDAs enumerate the starting position of each source pixel\n         * row in device space. */\n        dda_init(penum->dda.row.x, mtx, col_extent.x, height);\n        dda_init(penum->dda.row.y, mty, col_extent.y, height);\n        if (penum->posture == image_portrait) {\n            penum->dst_width = row_extent.x;\n            penum->dst_height = col_extent.y;\n        } else {\n            penum->dst_width = col_extent.x;\n            penum->dst_height = row_extent.y;\n        }\n        /* For gs_image_class_0_interpolate. */\n        penum->yi0 = fixed2int_pixround_perfect(dda_current(penum->dda.row.y)); /* For gs_image_class_0_interpolate. */\n        if (penum->rect.y) {\n            int y = penum->rect.y;\n\n            while (y--) {\n                dda_next(penum->dda.row.x);\n                dda_next(penum->dda.row.y);\n            }\n        }\n        penum->cur.x = penum->prev.x = dda_current(penum->dda.row.x);\n        penum->cur.y = penum->prev.y = dda_current(penum->dda.row.y);\n        /* These DDAs enumerate the starting positions of each row of our\n         * source pixel data, in the subrectangle ('strip') that we are\n         * actually rendering. */\n        dda_init(penum->dda.strip.x, penum->cur.x, row_extent.x, width);\n        dda_init(penum->dda.strip.y, penum->cur.y, row_extent.y, width);\n        if (penum->rect.x) {\n            dda_advance(penum->dda.strip.x, penum->rect.x);\n            dda_advance(penum->dda.strip.y, penum->rect.x);\n        }\n        {\n            fixed ox = dda_current(penum->dda.strip.x);\n            fixed oy = dda_current(penum->dda.strip.y);\n\n            if (!penum->clip_image)     /* i.e., not clip region */\n                penum->clip_image =\n                    (fixed_pixround(ox + epx) < fixed_pixround(cbox.p.x) ?\n                     image_clip_xmin : 0) +\n                    (fixed_pixround(ox + eqx) >= fixed_pixround(cbox.q.x) ?\n                     image_clip_xmax : 0) +\n                    (fixed_pixround(oy + epy) < fixed_pixround(cbox.p.y) ?\n                     image_clip_ymin : 0) +\n                    (fixed_pixround(oy + eqy) >= fixed_pixround(cbox.q.y) ?\n                     image_clip_ymax : 0);\n        }\n    }\n    penum->y = 0;\n    penum->used.x = 0;\n    penum->used.y = 0;\n    {\n        static sample_unpack_proc_t procs[2][6] = {\n        {   sample_unpack_1, sample_unpack_2,\n            sample_unpack_4, sample_unpack_8,\n            sample_unpack_12, sample_unpack_16\n        },\n        {   sample_unpack_1_interleaved, sample_unpack_2_interleaved,\n            sample_unpack_4_interleaved, sample_unpack_8_interleaved,\n            sample_unpack_12, sample_unpack_16\n        }};\n        int num_planes = penum->num_planes;\n        bool interleaved = (num_planes == 1 && penum->plane_depths[0] != penum->bps);\n        int i;\n\n        if (interleaved) {\n            int num_components = penum->plane_depths[0] / penum->bps;\n\n            for (i = 1; i < num_components; i++) {\n                if (decode[0] != decode[i * 2 + 0] ||\n                    decode[1] != decode[i * 2 + 1])\n                    break;\n            }\n            if (i == num_components)\n                interleaved = false; /* Use single table. */\n        }\n        penum->unpack = procs[interleaved][index_bps];\n\n        if_debug1m('b', mem, \"[b]unpack=%d\\n\", bps);\n        /* Set up pixel0 for image class procedures. */\n        penum->dda.pixel0 = penum->dda.strip;\n        for (i = 0; i < gx_image_class_table_count; ++i)\n            if ((penum->render = gx_image_class_table[i](penum)) != 0)\n                break;\n        if (i == gx_image_class_table_count) {\n            /* No available class can handle this image. */\n            gx_default_end_image(dev, (gx_image_enum_common_t *) penum,\n                                 false);\n            return_error(gs_error_rangecheck);\n        }\n    }\n    if (penum->clip_image && pcpath) {  /* Set up the clipping device. */\n        gx_device_clip *cdev =\n            gs_alloc_struct(mem, gx_device_clip,\n                            &st_device_clip, \"image clipper\");\n\n        if (cdev == 0) {\n            gx_default_end_image(dev,\n                                 (gx_image_enum_common_t *) penum,\n                                 false);\n            return_error(gs_error_VMerror);\n        }\n        gx_make_clip_device_in_heap(cdev, pcpath, dev, mem);\n        penum->clip_dev = cdev;\n    }\n    if (penum->use_rop) {       /* Set up the RasterOp source device. */\n        gx_device_rop_texture *rtdev;\n\n        code = gx_alloc_rop_texture_device(&rtdev, mem,\n                                           \"image RasterOp\");\n        if (code < 0) {\n            gx_default_end_image(dev, (gx_image_enum_common_t *) penum,\n                                 false);\n            return code;\n        }\n        /* The 'target' must not be NULL for gx_make_rop_texture_device */\n        if (!penum->clip_dev && !dev)\n            return_error(gs_error_undefined);\n\n        gx_make_rop_texture_device(rtdev,\n                                   (penum->clip_dev != 0 ?\n                                    (gx_device *) penum->clip_dev :\n                                    dev), lop, pdcolor);\n        gx_device_retain((gx_device *)rtdev, true);\n        penum->rop_dev = rtdev;\n    }\n    return 0;\n}", "target": 1, "cwe": ["CWE-119"], "project": "ghostpdl", "commit_id": "362ec9daadb9992b0def3520cd1dc6fa52edd1c4", "hash": 68955368015213854950682915010627252123, "size": 729, "message": "Fix bug 697459 Buffer overflow in fill_threshold_buffer\n\nThere was an overflow check for ht_buffer size, but none for the larger\nthreshold_buffer. Note that this file didn't fail on Windows because the\ncombination of the ht_buffer and the size of the (miscalculated due to\noverflow) threshold_buffer would have exceeded the 2Gb limit.", "idx": 494}
{"func": "static NTSTATUS dcesrv_lsa_QuerySecurity(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx,\n\t\t\t\t\t struct lsa_QuerySecurity *r)\n{\n\tstruct auth_session_info *session_info =\n\t\tdcesrv_call_session_info(dce_call);\n\tstruct dcesrv_handle *h;\n\tconst struct security_descriptor *sd = NULL;\n\tuint32_t access_granted = 0;\n\tstruct sec_desc_buf *sdbuf = NULL;\n\tNTSTATUS status;\n\tstruct dom_sid *sid;\n\n\tDCESRV_PULL_HANDLE(h, r->in.handle, DCESRV_HANDLE_ANY);\n\n\tsid = &session_info->security_token->sids[PRIMARY_USER_SID_INDEX];\n\n\tif (h->wire_handle.handle_type == LSA_HANDLE_POLICY) {\n\t\tstruct lsa_policy_state *pstate = h->data;\n\n\t\tsd = pstate->sd;\n\t\taccess_granted = pstate->access_mask;\n\n\t} else if (h->wire_handle.handle_type == LSA_HANDLE_ACCOUNT) {\n\t\tstruct lsa_account_state *astate = h->data;\n\t\tstruct security_descriptor *_sd = NULL;\n\n\t\tstatus = dcesrv_build_lsa_sd(mem_ctx, &_sd, sid,\n\t\t\t\t\t     LSA_ACCOUNT_ALL_ACCESS);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t\tsd = _sd;\n\t\taccess_granted = astate->access_mask;\n\t} else {\n\t\treturn NT_STATUS_INVALID_HANDLE;\n\t}\n\n\tsdbuf = talloc_zero(mem_ctx, struct sec_desc_buf);\n\tif (sdbuf == NULL) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\n\tstatus = security_descriptor_for_client(sdbuf, sd, r->in.sec_info,\n\t\t\t\t\t\taccess_granted, &sdbuf->sd);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\n\t*r->out.sdbuf = sdbuf;\n\n\treturn NT_STATUS_OK;\n}", "target": 0, "cwe": ["CWE-200"], "project": "samba", "commit_id": "0a3aa5f908e351201dc9c4d4807b09ed9eedff77", "hash": 81283674452663080678479056994117407309, "size": 52, "message": "CVE-2022-32746 ldb: Make use of functions for appending to an ldb_message\n\nThis aims to minimise usage of the error-prone pattern of searching for\na just-added message element in order to make modifications to it (and\npotentially finding the wrong element).\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=15009\n\nSigned-off-by: Joseph Sutton <josephsutton@catalyst.net.nz>", "idx": 495}
{"func": "brcmf_wowl_nd_results(struct brcmf_if *ifp, const struct brcmf_event_msg *e,\n\t\t      void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tif (le32_to_cpu(pfn_result->count) < 1) {\n\t\tbphy_err(wiphy, \"Invalid result count, expected 1 (%d)\\n\",\n\t\t\t le32_to_cpu(pfn_result->count));\n\t\treturn -EINVAL;\n\t}\n\n\tnetinfo = brcmf_get_netinfo_array(pfn_result);\n\tmemcpy(cfg->wowl.nd->ssid.ssid, netinfo->SSID, netinfo->SSID_len);\n\tcfg->wowl.nd->ssid.ssid_len = netinfo->SSID_len;\n\tcfg->wowl.nd->n_channels = 1;\n\tcfg->wowl.nd->channels[0] =\n\t\tieee80211_channel_to_frequency(netinfo->channel,\n\t\t\tnetinfo->channel <= CH_MAX_2G_CHANNEL ?\n\t\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ);\n\tcfg->wowl.nd_info->n_matches = 1;\n\tcfg->wowl.nd_info->matches[0] = cfg->wowl.nd;\n\n\t/* Inform (the resume task) that the net detect information was recvd */\n\tcfg->wowl.nd_data_completed = true;\n\twake_up(&cfg->wowl.nd_data_wait);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "1b5e2423164b3670e8bc9174e4762d297990deff", "hash": 15191570896957004687107928484416514568, "size": 45, "message": "brcmfmac: assure SSID length from firmware is limited\n\nThe SSID length as received from firmware should not exceed\nIEEE80211_MAX_SSID_LEN as that would result in heap overflow.\n\nReviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>\nReviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>\nReviewed-by: Franky Lin <franky.lin@broadcom.com>\nSigned-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>", "idx": 496}
{"func": "S3BootScriptSavePciCfgWrite (\r\n  IN  S3_BOOT_SCRIPT_LIB_WIDTH         Width,\r\n  IN  UINT64                           Address,\r\n  IN  UINTN                            Count,\r\n  IN  VOID                            *Buffer\r\n  )\r\n{\r\n  UINT8                 Length;\r\n  UINT8                *Script;\r\n  UINT8                 WidthInByte;\r\n  EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE  ScriptPciWrite;\r\n\r\n  if (Width == S3BootScriptWidthUint64 ||\r\n      Width == S3BootScriptWidthFifoUint64 ||\r\n      Width == S3BootScriptWidthFillUint64) {\r\n    return EFI_INVALID_PARAMETER;\r\n  }\r\n\r\n  WidthInByte = (UINT8) (0x01 << (Width & 0x03));\r\n  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE) + (WidthInByte * Count));\r\n\r\n  Script = S3BootScriptGetEntryAddAddress (Length);\r\n  if (Script == NULL) {\r\n    return RETURN_OUT_OF_RESOURCES;\r\n  }\r\n  //\r\n  // Build script data\r\n  //\r\n  ScriptPciWrite.OpCode   = EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE;\r\n  ScriptPciWrite.Length   = Length;\r\n  ScriptPciWrite.Width    = Width;\r\n  ScriptPciWrite.Address  = Address;\r\n  ScriptPciWrite.Count    = (UINT32) Count;\r\n\r\n  CopyMem ((VOID*)Script, (VOID*)&ScriptPciWrite,  sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE));\r\n  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE)), Buffer, WidthInByte * Count);\r\n\r\n  SyncBootScript (Script);\r\n\r\n  return RETURN_SUCCESS;\r\n}\r", "target": 1, "cwe": ["CWE-787"], "project": "edk2", "commit_id": "322ac05f8bbc1bce066af1dabd1b70ccdbe28891", "hash": 190307843381579061780824500375515687559, "size": 41, "message": "MdeModulePkg/PiDxeS3BootScriptLib: Fix potential numeric truncation (CVE-2019-14563)\n\nREF:https://bugzilla.tianocore.org/show_bug.cgi?id=2001\n\nFor S3BootScriptLib APIs:\n\nS3BootScriptSaveIoWrite\nS3BootScriptSaveMemWrite\nS3BootScriptSavePciCfgWrite\nS3BootScriptSavePciCfg2Write\nS3BootScriptSaveSmbusExecute\nS3BootScriptSaveInformation\nS3BootScriptSaveInformationAsciiString\nS3BootScriptLabel (happen in S3BootScriptLabelInternal())\n\npossible numeric truncations will happen that may lead to S3 boot script\nentry with improper size being returned to store the boot script data.\nThis commit will add checks to prevent this kind of issue.\n\nPlease note that the remaining S3BootScriptLib APIs:\n\nS3BootScriptSaveIoReadWrite\nS3BootScriptSaveMemReadWrite\nS3BootScriptSavePciCfgReadWrite\nS3BootScriptSavePciCfg2ReadWrite\nS3BootScriptSaveStall\nS3BootScriptSaveDispatch2\nS3BootScriptSaveDispatch\nS3BootScriptSaveMemPoll\nS3BootScriptSaveIoPoll\nS3BootScriptSavePciPoll\nS3BootScriptSavePci2Poll\nS3BootScriptCloseTable\nS3BootScriptExecute\nS3BootScriptMoveLastOpcode\nS3BootScriptCompare\n\nare not affected by such numeric truncation.\n\nSigned-off-by: Hao A Wu <hao.a.wu@intel.com>\nReviewed-by: Laszlo Ersek <lersek@redhat.com>\nReviewed-by: Eric Dong <eric.dong@intel.com>\nAcked-by: Jian J Wang <jian.j.wang@intel.com>", "idx": 497}
{"func": "static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */\n  /* Always catch error here. */\n  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);\n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}", "target": 1, "cwe": ["CWE-125"], "project": "LuaJIT", "commit_id": "e296f56b825c688c3530a981dc6b495d972f3d01", "hash": 172174871306683658029369871156120752086, "size": 10, "message": "Call error function on rethrow after trace exit.", "idx": 498}
{"func": "TfLiteStatus SigmoidEval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      if (kernel_type == kReference) {\n        reference_ops::Logistic(\n            GetTensorShape(input), GetTensorData<float>(input),\n            GetTensorShape(output), GetTensorData<float>(output));\n      } else {\n        optimized_ops::Logistic(\n            GetTensorShape(input), GetTensorData<float>(input),\n            GetTensorShape(output), GetTensorData<float>(output));\n      }\n      break;\n    }\n    case kTfLiteInt16: {\n      LogisticParams params;\n      if (kernel_type == kReference || (data->input_multiplier > 0)) {\n        const int size =\n            MatchingFlatSize(GetTensorShape(input), GetTensorShape(output));\n\n        reference_integer_ops::Logistic(data->input_multiplier, size,\n                                        GetTensorData<int16_t>(input),\n                                        GetTensorData<int16_t>(output));\n      } else {\n        optimized_ops::Logistic(\n            params, GetTensorShape(input), GetTensorData<int16_t>(input),\n            GetTensorShape(output), GetTensorData<int16_t>(output));\n      }\n      break;\n    }\n    case kTfLiteUInt8: {\n      if (kernel_type == kFixedPointOptimized) {\n        LogisticParams params;\n        params.input_zero_point = input->params.zero_point;\n        params.input_range_radius = data->input_range_radius;\n        params.input_multiplier = data->input_multiplier;\n        params.input_left_shift = data->input_left_shift;\n        optimized_ops::Logistic16bitPrecision(\n            params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n            GetTensorShape(output), GetTensorData<uint8_t>(output));\n      } else {\n        EvalUsingLookupTable(data, input, output);\n      }\n      break;\n    }\n    case kTfLiteInt8: {\n      if (kernel_type == kFixedPointOptimized) {\n        LogisticParams params;\n        params.input_zero_point = input->params.zero_point;\n        params.input_range_radius = data->input_range_radius;\n        params.input_multiplier = data->input_multiplier;\n        params.input_left_shift = data->input_left_shift;\n        optimized_ops::Logistic16bitPrecision(\n            params, GetTensorShape(input), GetTensorData<int8_t>(input),\n            GetTensorShape(output), GetTensorData<int8_t>(output));\n      } else {\n        EvalUsingLookupTable(data, input, output);\n      }\n      break;\n    }\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Only float32, uint8, int16 and int8 are supported \"\n                         \"currently, got %s.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tensorflow", "commit_id": "1970c2158b1ffa416d159d03c3370b9a462aee35", "hash": 68281329575580998305056408879021899400, "size": 73, "message": "[tflite]: Insert `nullptr` checks when obtaining tensors.\n\nAs part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.\n\nWe also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).\n\nPiperOrigin-RevId: 332521299\nChange-Id: I29af455bcb48d0b92e58132d951a3badbd772d56", "idx": 499}
{"func": "static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)\n{\n  if (!input.empty()) {\n    char *endptr;\n    *output = strtol(input.c_str(), &endptr, 10);\n    if (endptr) {\n      if (endptr == input.c_str()) return -EINVAL;\n      while (*endptr && isspace(*endptr)) // ignore white space\n        endptr++;\n      if (*endptr) {\n        return -EINVAL;\n      }\n    }\n    if(*output > upper_bound) {\n      *output = upper_bound;\n    }\n    if(*output < lower_bound) {\n      *output = lower_bound;\n    }\n  } else {\n    *output = default_val;\n  }\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-770"], "project": "ceph", "commit_id": "ab29bed2fc9f961fe895de1086a8208e21ddaddc", "hash": 251944757709071582065097622310028086799, "size": 25, "message": "rgw: fix issues with 'enforce bounds' patch\n\nThe patch to enforce bounds on max-keys/max-uploads/max-parts had a few\nissues that would prevent us from compiling it. Instead of changing the\ncode provided by the submitter, we're addressing them in a separate\ncommit to maintain the DCO.\n\nSigned-off-by: Joao Eduardo Luis <joao@suse.de>\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>\n(cherry picked from commit 29bc434a6a81a2e5c5b8cfc4c8d5c82ca5bf538a)\nmimic specific fixes:\nAs the largeish change from master g_conf() isn't in mimic yet, use the g_conf\nglobal structure, also make rgw_op use the value from req_info ceph context as\nwe do for all the requests", "idx": 500}
{"func": "Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {\n    return authorizationManagerPinnedUsers.setFromString(str);\n}", "target": 0, "cwe": ["CWE-613"], "project": "mongo", "commit_id": "e55d6e2292e5dbe2f97153251d8193d1cc89f5d7", "hash": 197528871674844208185245167454436118180, "size": 3, "message": "SERVER-38984 Validate unique User ID on UserCache hit", "idx": 501}
{"func": "int __scm_send(struct socket *sock, struct msghdr *msg, struct scm_cookie *p)\n{\n\tstruct cmsghdr *cmsg;\n\tint err;\n\n\tfor (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg))\n\t{\n\t\terr = -EINVAL;\n\n\t\t/* Verify that cmsg_len is at least sizeof(struct cmsghdr) */\n\t\t/* The first check was omitted in <= 2.2.5. The reasoning was\n\t\t   that parser checks cmsg_len in any case, so that\n\t\t   additional check would be work duplication.\n\t\t   But if cmsg_level is not SOL_SOCKET, we do not check\n\t\t   for too short ancillary data object at all! Oops.\n\t\t   OK, let's add it...\n\t\t */\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\tgoto error;\n\n\t\tif (cmsg->cmsg_level != SOL_SOCKET)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type)\n\t\t{\n\t\tcase SCM_RIGHTS:\n\t\t\tif (!sock->ops || sock->ops->family != PF_UNIX)\n\t\t\t\tgoto error;\n\t\t\terr=scm_fp_copy(cmsg, &p->fp);\n\t\t\tif (err<0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SCM_CREDENTIALS:\n\t\t{\n\t\t\tstruct ucred creds;\n\t\t\tkuid_t uid;\n\t\t\tkgid_t gid;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct ucred)))\n\t\t\t\tgoto error;\n\t\t\tmemcpy(&creds, CMSG_DATA(cmsg), sizeof(struct ucred));\n\t\t\terr = scm_check_creds(&creds);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\tp->creds.pid = creds.pid;\n\t\t\tif (!p->pid || pid_vnr(p->pid) != creds.pid) {\n\t\t\t\tstruct pid *pid;\n\t\t\t\terr = -ESRCH;\n\t\t\t\tpid = find_get_pid(creds.pid);\n\t\t\t\tif (!pid)\n\t\t\t\t\tgoto error;\n\t\t\t\tput_pid(p->pid);\n\t\t\t\tp->pid = pid;\n\t\t\t}\n\n\t\t\terr = -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), creds.uid);\n\t\t\tgid = make_kgid(current_user_ns(), creds.gid);\n\t\t\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\t\t\tgoto error;\n\n\t\t\tp->creds.uid = uid;\n\t\t\tp->creds.gid = gid;\n\n\t\t\tif (!p->cred ||\n\t\t\t    !uid_eq(p->cred->euid, uid) ||\n\t\t\t    !gid_eq(p->cred->egid, gid)) {\n\t\t\t\tstruct cred *cred;\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tcred = prepare_creds();\n\t\t\t\tif (!cred)\n\t\t\t\t\tgoto error;\n\n\t\t\t\tcred->uid = cred->euid = uid;\n\t\t\t\tcred->gid = cred->egid = gid;\n\t\t\t\tif (p->cred)\n\t\t\t\t\tput_cred(p->cred);\n\t\t\t\tp->cred = cred;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (p->fp && !p->fp->count)\n\t{\n\t\tkfree(p->fp);\n\t\tp->fp = NULL;\n\t}\n\treturn 0;\n\nerror:\n\tscm_destroy(p);\n\treturn err;\n}", "target": 0, "cwe": ["CWE-284", "CWE-264"], "project": "linux", "commit_id": "92f28d973cce45ef5823209aab3138eb45d8b349", "hash": 128352795846518222485285729771551541776, "size": 97, "message": "scm: Require CAP_SYS_ADMIN over the current pidns to spoof pids.\n\nDon't allow spoofing pids over unix domain sockets in the corner\ncases where a user has created a user namespace but has not yet\ncreated a pid namespace.\n\nCc: stable@vger.kernel.org\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>", "idx": 502}
{"func": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    /* we have an error following */\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}", "target": 1, "cwe": ["CWE-787"], "project": "libvncserver", "commit_id": "a83439b9fbe0f03c48eb94ed05729cb016f8b72f", "hash": 24454650119470624978041941680066224286, "size": 14, "message": "LibVNCClient: fix three possible heap buffer overflows\n\nAn attacker could feed `0xffffffff`, causing a `malloc(0)` for the\nbuffers which are subsequently written to.\n\nCloses #247", "idx": 503}
{"func": "fill_record(THD *thd, TABLE *table_arg, List<Item> &fields, List<Item> &values,\n            bool ignore_errors, bool update)\n{\n  List_iterator_fast<Item> f(fields),v(values);\n  Item *value, *fld;\n  Item_field *field;\n  Field *rfield;\n  TABLE *table;\n  bool only_unvers_fields= update && table_arg->versioned();\n  bool save_abort_on_warning= thd->abort_on_warning;\n  bool save_no_errors= thd->no_errors;\n  DBUG_ENTER(\"fill_record\");\n\n  thd->no_errors= ignore_errors;\n  /*\n    Reset the table->auto_increment_field_not_null as it is valid for\n    only one row.\n  */\n  if (fields.elements)\n    table_arg->auto_increment_field_not_null= FALSE;\n\n  while ((fld= f++))\n  {\n    if (!(field= fld->field_for_view_update()))\n    {\n      my_error(ER_NONUPDATEABLE_COLUMN, MYF(0), fld->name.str);\n      goto err;\n    }\n    value=v++;\n    DBUG_ASSERT(value);\n    rfield= field->field;\n    table= rfield->table;\n    if (table->next_number_field &&\n        rfield->field_index ==  table->next_number_field->field_index)\n      table->auto_increment_field_not_null= TRUE;\n    const bool skip_sys_field= rfield->vers_sys_field(); // TODO: && !thd->vers_modify_history() [MDEV-16546]\n    if ((rfield->vcol_info || skip_sys_field) &&\n        !value->vcol_assignment_allowed_value() &&\n        table->s->table_category != TABLE_CATEGORY_TEMPORARY)\n    {\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                          ER_WARNING_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN,\n                          ER_THD(thd, ER_WARNING_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN),\n                          rfield->field_name.str, table->s->table_name.str);\n    }\n    if (only_unvers_fields && !rfield->vers_update_unversioned())\n      only_unvers_fields= false;\n\n    if (rfield->stored_in_db())\n    {\n      if (!skip_sys_field &&\n          unlikely(value->save_in_field(rfield, 0) < 0) && !ignore_errors)\n      {\n        my_message(ER_UNKNOWN_ERROR, ER_THD(thd, ER_UNKNOWN_ERROR), MYF(0));\n        goto err;\n      }\n      /*\n        In sql MODE_SIMULTANEOUS_ASSIGNMENT,\n        move field pointer on value stored in record[1]\n        which contains row before update (see MDEV-13417)\n      */\n      if (update && thd->variables.sql_mode & MODE_SIMULTANEOUS_ASSIGNMENT)\n        rfield->move_field_offset((my_ptrdiff_t) (table->record[1] -\n                                                  table->record[0]));\n    }\n    rfield->set_has_explicit_value();\n  }\n\n  if (update && thd->variables.sql_mode & MODE_SIMULTANEOUS_ASSIGNMENT)\n  {\n    // restore fields pointers on record[0]\n    f.rewind();\n    while ((fld= f++))\n    {\n      rfield= fld->field_for_view_update()->field;\n      if (rfield->stored_in_db())\n      {\n        table= rfield->table;\n        rfield->move_field_offset((my_ptrdiff_t) (table->record[0] -\n                                                  table->record[1]));\n      }\n    }\n  }\n\n  if (update)\n    table_arg->evaluate_update_default_function();\n  else\n    if (table_arg->default_field &&\n        table_arg->update_default_fields(ignore_errors))\n      goto err;\n\n  /* Update virtual fields */\n  if (table_arg->vfield &&\n      table_arg->update_virtual_fields(table_arg->file, VCOL_UPDATE_FOR_WRITE))\n    goto err;\n  if (table_arg->versioned() && !only_unvers_fields)\n    table_arg->vers_update_fields();\n  thd->abort_on_warning= save_abort_on_warning;\n  thd->no_errors=        save_no_errors;\n  DBUG_RETURN(thd->is_error());\nerr:\n  DBUG_PRINT(\"error\",(\"got error\"));\n  thd->abort_on_warning= save_abort_on_warning;\n  thd->no_errors=        save_no_errors;\n  if (fields.elements)\n    table_arg->auto_increment_field_not_null= FALSE;\n  DBUG_RETURN(TRUE);\n}", "target": 0, "cwe": ["CWE-416"], "project": "server", "commit_id": "c02ebf3510850ba78a106be9974c94c3b97d8585", "hash": 162025149567081595216503689482757741455, "size": 108, "message": "MDEV-24176 Preparations\n\n1. moved fix_vcol_exprs() call to open_table()\n\nmysql_alter_table() doesn't do lock_tables() so it cannot win from\nfix_vcol_exprs() from there. Tests affected: main.default_session\n\n2. Vanilla cleanups and comments.", "idx": 504}
{"func": "gdm_session_authorize (GdmSession *self,\n                       const char *service_name)\n{\n        GdmSessionConversation *conversation;\n\n        g_return_if_fail (GDM_IS_SESSION (self));\n\n        conversation = find_conversation_by_name (self, service_name);\n        if (conversation != NULL) {\n                gdm_dbus_worker_call_authorize (conversation->worker_proxy,\n                                                NULL,\n                                                (GAsyncReadyCallback) on_authorize_cb,\n                                                conversation);\n        }\n}", "target": 1, "cwe": [], "project": "gdm", "commit_id": "05e5fc24b0f803098c1d05dae86f5eb05bd0c2a4", "hash": 102567452857605676367831095105836468250, "size": 15, "message": "session: Cancel worker proxy async ops when freeing conversations\n\nWe need to cancel ongoing async ops for worker proxies when freeing\nconversations or we'll crash when the completion handler runs and we\naccess free'd memory.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=758032", "idx": 505}
{"func": "exif_entry_get_value (ExifEntry *e, char *val, unsigned int maxlen)\n{\n\tunsigned int i, j, k;\n\tExifShort v_short, v_short2, v_short3, v_short4;\n\tExifByte v_byte;\n\tExifRational v_rat;\n\tExifSRational v_srat;\n\tchar b[64];\n\tconst char *c;\n\tExifByteOrder o;\n\tdouble d;\n\tExifEntry *entry;\n\tstatic const struct {\n\t\tchar label[5];\n\t\tchar major, minor;\n\t} versions[] = {\n\t\t{\"0110\", 1,  1},\n\t\t{\"0120\", 1,  2},\n\t\t{\"0200\", 2,  0},\n\t\t{\"0210\", 2,  1},\n\t\t{\"0220\", 2,  2},\n\t\t{\"0221\", 2, 21},\n\t\t{\"0230\", 2,  3},\n\t\t{\"\"    , 0,  0}\n\t};\n\n\t(void) bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);\n\n\tif (!e || !e->parent || !e->parent->parent || !maxlen || !val)\n\t\treturn val;\n\n\t/* make sure the returned string is zero terminated */\n\t/* FIXME: this is inefficient in the case of long buffers and should\n\t * instead be taken care of on each write instead. */\n\tmemset (val, 0, maxlen);\n\n\t/* We need the byte order */\n\to = exif_data_get_byte_order (e->parent->parent);\n\n\t/* Sanity check */\n\tif (e->size != e->components * exif_format_get_size (e->format)) {\n\t\tsnprintf (val, maxlen, _(\"Invalid size of entry (%i, \"\n\t\t\t\"expected %li x %i).\"), e->size, e->components,\n\t\t\t\texif_format_get_size (e->format));\n\t\treturn val;\n\t}\n\n\tswitch (e->tag) {\n\tcase EXIF_TAG_USER_COMMENT:\n\n\t\t/*\n\t\t * The specification says UNDEFINED, but some\n\t\t * manufacturers don't care and use ASCII. If this is the\n\t\t * case here, only refuse to read it if there is no chance\n\t\t * of finding readable data.\n\t\t */\n\t\tif ((e->format != EXIF_FORMAT_ASCII) || \n\t\t    (e->size <= 8) ||\n\t\t    ( memcmp (e->data, \"ASCII\\0\\0\\0\"  , 8) &&\n\t\t      memcmp (e->data, \"UNICODE\\0\"    , 8) &&\n\t\t      memcmp (e->data, \"JIS\\0\\0\\0\\0\\0\", 8) &&\n\t\t      memcmp (e->data, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 8)))\n\t\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\n\t\t/*\n\t\t * Note that, according to the specification (V2.1, p 40),\n\t\t * the user comment field does not have to be \n\t\t * NULL terminated.\n\t\t */\n\t\tif ((e->size >= 8) && !memcmp (e->data, \"ASCII\\0\\0\\0\", 8)) {\n\t\t\tstrncpy (val, (char *) e->data + 8, MIN (e->size - 8, maxlen-1));\n\t\t\tbreak;\n\t\t}\n\t\tif ((e->size >= 8) && !memcmp (e->data, \"UNICODE\\0\", 8)) {\n\t\t\tstrncpy (val, _(\"Unsupported UNICODE string\"), maxlen-1);\n\t\t/* FIXME: use iconv to convert into the locale encoding.\n\t\t * EXIF 2.2 implies (but does not say) that this encoding is\n\t\t * UCS-2.\n\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tif ((e->size >= 8) && !memcmp (e->data, \"JIS\\0\\0\\0\\0\\0\", 8)) {\n\t\t\tstrncpy (val, _(\"Unsupported JIS string\"), maxlen-1);\n\t\t/* FIXME: use iconv to convert into the locale encoding */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Check if there is really some information in the tag. */\n\t\tfor (i = 0; (i < e->size) &&\n\t\t\t    (!e->data[i] || (e->data[i] == ' ')); i++);\n\t\tif (i == e->size) break;\n\n\t\t/*\n\t\t * If we reach this point, the tag does not\n \t\t * comply with the standard but seems to contain data.\n\t\t * Print as much as possible.\n\t\t * Note: make sure we do not overwrite the final \\0 at maxlen-1\n\t\t */\n\t\texif_entry_log (e, EXIF_LOG_CODE_DEBUG,\n\t\t\t_(\"Tag UserComment contains data but is \"\n\t\t\t  \"against specification.\"));\n \t\tfor (j = 0; (i < e->size) && (j < maxlen-1); i++, j++) {\n\t\t\texif_entry_log (e, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t_(\"Byte at position %i: 0x%02x\"), i, e->data[i]);\n \t\t\tval[j] = isprint (e->data[i]) ? e->data[i] : '.';\n\t\t}\n\t\tbreak;\n\n\tcase EXIF_TAG_EXIF_VERSION:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tstrncpy (val, _(\"Unknown Exif Version\"), maxlen-1);\n\t\tfor (i = 0; *versions[i].label; i++) {\n\t\t\tif (!memcmp (e->data, versions[i].label, 4)) {\n    \t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t_(\"Exif Version %d.%d\"),\n\t\t\t\t\tversions[i].major,\n\t\t\t\t\tversions[i].minor);\n    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_FLASH_PIX_VERSION:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tif (!memcmp (e->data, \"0100\", 4))\n\t\t\tstrncpy (val, _(\"FlashPix Version 1.0\"), maxlen-1);\n\t\telse if (!memcmp (e->data, \"0101\", 4))\n\t\t\tstrncpy (val, _(\"FlashPix Version 1.01\"), maxlen-1);\n\t\telse\n\t\t\tstrncpy (val, _(\"Unknown FlashPix Version\"), maxlen-1);\n\t\tbreak;\n\tcase EXIF_TAG_COPYRIGHT:\n\t\tCF (e, EXIF_FORMAT_ASCII, val, maxlen);\n\n\t\t/*\n\t\t * First part: Photographer.\n\t\t * Some cameras store a string like \"   \" here. Ignore it.\n\t\t * Remember that a corrupted tag might not be NUL-terminated\n\t\t */\n\t\tif (e->size && e->data && match_repeated_char(e->data, ' ', e->size))\n\t\t\tstrncpy (val, (char *) e->data, MIN (maxlen-1, e->size));\n\t\telse\n\t\t\tstrncpy (val, _(\"[None]\"), maxlen-1);\n\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n\t\tstrncat (val, _(\"(Photographer)\"), maxlen-1 - strlen (val));\n\n\t\t/* Second part: Editor. */\n\t\tstrncat (val, \" - \", maxlen-1 - strlen (val));\n\t\tk = 0;\n\t\tif (e->size && e->data) {\n\t\t\tconst unsigned char *tagdata = memchr(e->data, 0, e->size);\n\t\t\tif (tagdata++) {\n\t\t\t\tunsigned int editor_ofs = tagdata - e->data;\n\t\t\t\tunsigned int remaining = e->size - editor_ofs;\n\t\t\t\tif (match_repeated_char(tagdata, ' ', remaining)) {\n\t\t\t\t\tstrncat (val, (const char*)tagdata, MIN (maxlen-1 - strlen (val), remaining));\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!k)\n\t\t\tstrncat (val, _(\"[None]\"), maxlen-1 - strlen (val));\n\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n\t\tstrncat (val, _(\"(Editor)\"), maxlen-1 - strlen (val));\n\n\t\tbreak;\n\tcase EXIF_TAG_FNUMBER:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"f/%.01f\", d);\n\t\tbreak;\n\tcase EXIF_TAG_APERTURE_VALUE:\n\tcase EXIF_TAG_MAX_APERTURE_VALUE:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator || (0x80000000 == v_rat.numerator)) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tsnprintf (b, sizeof (b), _(\" (f/%.01f)\"), pow (2, d / 2.));\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_FOCAL_LENGTH:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For calculation of the 35mm equivalent,\n\t\t * Minolta cameras need a multiplier that depends on the\n\t\t * camera model.\n\t\t */\n\t\td = 0.;\n\t\tentry = exif_content_get_entry (\n\t\t\te->parent->parent->ifd[EXIF_IFD_0], EXIF_TAG_MAKE);\n\t\tif (entry && entry->data &&\n\t\t    !strncmp ((char *)entry->data, \"Minolta\", 7)) {\n\t\t\tentry = exif_content_get_entry (\n\t\t\t\t\te->parent->parent->ifd[EXIF_IFD_0],\n\t\t\t\t\tEXIF_TAG_MODEL);\n\t\t\tif (entry && entry->data) {\n\t\t\t\tif (!strncmp ((char *)entry->data, \"DiMAGE 7\", 8))\n\t\t\t\t\td = 3.9;\n\t\t\t\telse if (!strncmp ((char *)entry->data, \"DiMAGE 5\", 8))\n\t\t\t\t\td = 4.9;\n\t\t\t}\n\t\t}\n\t\tif (d)\n\t\t\tsnprintf (b, sizeof (b), _(\" (35 equivalent: %.0f mm)\"),\n\t\t\t\t  (d * (double) v_rat.numerator /\n\t\t\t\t       (double) v_rat.denominator));\n\t\telse\n\t\t\tb[0] = 0;\n\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"%.1f mm\", d);\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_SUBJECT_DISTANCE:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"%.1f m\", d);\n\t\tbreak;\n\tcase EXIF_TAG_EXPOSURE_TIME:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tif (d < 1)\n\t\t\tsnprintf (val, maxlen, _(\"1/%.0f\"), 1. / d);\n\t\telse\n\t\t\tsnprintf (val, maxlen, \"%.0f\", d);\n\t\tstrncat (val, _(\" sec.\"), maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_SHUTTER_SPEED_VALUE:\n\t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_srat = exif_get_srational (e->data, o);\n\t\tif (!v_srat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\td = 1. / pow (2, d);\n\t\tif (d < 1)\n\t\t  snprintf (b, sizeof (b), _(\" (1/%.0f sec.)\"), 1. / d);\n\t\telse\n\t\t  snprintf (b, sizeof (b), _(\" (%.0f sec.)\"), d);\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_BRIGHTNESS_VALUE:\n\t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_srat = exif_get_srational (e->data, o);\n\t\tif (!v_srat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tsnprintf (b, sizeof (b), _(\" (%.02f cd/m^2)\"),\n\t\t\t1. / (M_PI * 0.3048 * 0.3048) * pow (2, d));\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_FILE_SOURCE:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tif (v_byte == 3)\n\t\t\tstrncpy (val, _(\"DSC\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_byte);\n\t\tbreak;\n\tcase EXIF_TAG_COMPONENTS_CONFIGURATION:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tswitch (e->data[i]) {\n\t\t\tcase 0: c = _(\"-\"); break;\n\t\t\tcase 1: c = _(\"Y\"); break;\n\t\t\tcase 2: c = _(\"Cb\"); break;\n\t\t\tcase 3: c = _(\"Cr\"); break;\n\t\t\tcase 4: c = _(\"R\"); break;\n\t\t\tcase 5: c = _(\"G\"); break;\n\t\t\tcase 6: c = _(\"B\"); break;\n\t\t\tdefault: c = _(\"Reserved\"); break;\n\t\t\t}\n\t\t\tstrncat (val, c, maxlen-1 - strlen (val));\n\t\t\tif (i < 3)\n\t\t\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_EXPOSURE_BIAS_VALUE:\n\t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_srat = exif_get_srational (e->data, o);\n\t\tif (!v_srat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tbreak;\n\tcase EXIF_TAG_SCENE_TYPE:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tif (v_byte == 1)\n\t\t\tstrncpy (val, _(\"Directly photographed\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_byte);\n\t\tbreak;\n\tcase EXIF_TAG_YCBCR_SUB_SAMPLING:\n\t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC (e, 2, val, maxlen);\n\t\tv_short  = exif_get_short (e->data, o);\n\t\tv_short2 = exif_get_short (\n\t\t\te->data + exif_format_get_size (e->format),\n\t\t\to);\n\t\tif ((v_short == 2) && (v_short2 == 1))\n\t\t\tstrncpy (val, _(\"YCbCr4:2:2\"), maxlen-1);\n\t\telse if ((v_short == 2) && (v_short2 == 2))\n\t\t\tstrncpy (val, _(\"YCbCr4:2:0\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, \"%u, %u\", v_short, v_short2);\n\t\tbreak;\n\tcase EXIF_TAG_SUBJECT_AREA:\n\t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tswitch (e->components) {\n\t\tcase 2:\n\t\t\tv_short  = exif_get_short (e->data, o);\n\t\t\tv_short2 = exif_get_short (e->data + 2, o);\n\t\t\tsnprintf (val, maxlen, \"(x,y) = (%i,%i)\",\n\t\t\t\t  v_short, v_short2);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tv_short  = exif_get_short (e->data, o);\n\t\t\tv_short2 = exif_get_short (e->data + 2, o);\n\t\t\tv_short3 = exif_get_short (e->data + 4, o);\n\t\t\tsnprintf (val, maxlen, _(\"Within distance %i of \"\n\t\t\t\t\"(x,y) = (%i,%i)\"), v_short3, v_short,\n\t\t\t\tv_short2);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tv_short  = exif_get_short (e->data, o);\n\t\t\tv_short2 = exif_get_short (e->data + 2, o);\n\t\t\tv_short3 = exif_get_short (e->data + 4, o);\n\t\t\tv_short4 = exif_get_short (e->data + 6, o);\n\t\t\tsnprintf (val, maxlen, _(\"Within rectangle \"\n\t\t\t\t\"(width %i, height %i) around \"\n\t\t\t\t\"(x,y) = (%i,%i)\"), v_short3, v_short4,\n\t\t\t\tv_short, v_short2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf (val, maxlen, _(\"Unexpected number \"\n\t\t\t\t\"of components (%li, expected 2, 3, or 4).\"),\n\t\t\t\te->components);\t\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_GPS_VERSION_ID:\n\t\t/* This is only valid in the GPS IFD */\n\t\tCF (e, EXIF_FORMAT_BYTE, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tsnprintf (val, maxlen, \"%u\", v_byte);\n\t\tfor (i = 1; i < e->components; i++) {\n\t\t\tv_byte = e->data[i];\n\t\t\tsnprintf (b, sizeof (b), \".%u\", v_byte);\n\t\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_INTEROPERABILITY_VERSION:\n\t/* a.k.a. case EXIF_TAG_GPS_LATITUDE: */\n\t\t/* This tag occurs in EXIF_IFD_INTEROPERABILITY */\n\t\tif (e->format == EXIF_FORMAT_UNDEFINED) {\n\t\t\tstrncpy (val, (char *) e->data, MIN (maxlen-1, e->size));\n\t\t\tbreak;\n\t\t}\n\t\t/* EXIF_TAG_GPS_LATITUDE is the same numerically as\n\t\t * EXIF_TAG_INTEROPERABILITY_VERSION but in EXIF_IFD_GPS\n\t\t */\n\t\texif_entry_format_value(e, val, maxlen);\n\t\tbreak;\n\tcase EXIF_TAG_GPS_ALTITUDE_REF:\n\t\t/* This is only valid in the GPS IFD */\n\t\tCF (e, EXIF_FORMAT_BYTE, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tif (v_byte == 0)\n\t\t\tstrncpy (val, _(\"Sea level\"), maxlen-1);\n\t\telse if (v_byte == 1)\n\t\t\tstrncpy (val, _(\"Sea level reference\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_byte);\n\t\tbreak;\n\tcase EXIF_TAG_GPS_TIME_STAMP:\n\t\t/* This is only valid in the GPS IFD */\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 3, val, maxlen);\n\n\t\tv_rat  = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\ti = v_rat.numerator / v_rat.denominator;\n\n\t\tv_rat = exif_get_rational (e->data +\n\t\t\t\t\t     exif_format_get_size (e->format),\n\t\t\t\t\t   o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\tj = v_rat.numerator / v_rat.denominator;\n\n\t\tv_rat = exif_get_rational (e->data +\n\t\t\t\t\t     2*exif_format_get_size (e->format),\n\t\t\t\t\t     o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"%02u:%02u:%05.2f\", i, j, d);\n\t\tbreak;\n\n\tcase EXIF_TAG_METERING_MODE:\n\tcase EXIF_TAG_COMPRESSION:\n\tcase EXIF_TAG_LIGHT_SOURCE:\n\tcase EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT:\n\tcase EXIF_TAG_RESOLUTION_UNIT:\n\tcase EXIF_TAG_EXPOSURE_PROGRAM:\n\tcase EXIF_TAG_FLASH:\n\tcase EXIF_TAG_SUBJECT_DISTANCE_RANGE:\n\tcase EXIF_TAG_COLOR_SPACE:\n\t\tCF (e,EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_short = exif_get_short (e->data, o);\n\n\t\t/* Search the tag */\n\t\tfor (i = 0; list2[i].tag && (list2[i].tag != e->tag); i++);\n\t\tif (!list2[i].tag) {\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_short);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the value */\n\t\tfor (j = 0; list2[i].elem[j].values[0] &&\n\t\t\t    (list2[i].elem[j].index < v_short); j++);\n\t\tif (list2[i].elem[j].index != v_short) {\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_short);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Find a short enough value */\n\t\tmemset (val, 0, maxlen);\n\t\tfor (k = 0; list2[i].elem[j].values[k]; k++) {\n\t\t\tsize_t l = strlen (_(list2[i].elem[j].values[k]));\n\t\t\tif ((maxlen > l) && (strlen (val) < l))\n\t\t\t\tstrncpy (val, _(list2[i].elem[j].values[k]), maxlen-1);\n\t\t}\n\t\tif (!val[0]) snprintf (val, maxlen, \"%i\", v_short);\n\n\t\tbreak;\n\n\tcase EXIF_TAG_PLANAR_CONFIGURATION:\n\tcase EXIF_TAG_SENSING_METHOD:\n\tcase EXIF_TAG_ORIENTATION:\n\tcase EXIF_TAG_YCBCR_POSITIONING:\n\tcase EXIF_TAG_PHOTOMETRIC_INTERPRETATION:\n\tcase EXIF_TAG_CUSTOM_RENDERED:\n\tcase EXIF_TAG_EXPOSURE_MODE:\n\tcase EXIF_TAG_WHITE_BALANCE:\n\tcase EXIF_TAG_SCENE_CAPTURE_TYPE:\n\tcase EXIF_TAG_GAIN_CONTROL:\n\tcase EXIF_TAG_SATURATION:\n\tcase EXIF_TAG_CONTRAST:\n\tcase EXIF_TAG_SHARPNESS:\n\t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_short = exif_get_short (e->data, o);\n\n\t\t/* Search the tag */\n\t\tfor (i = 0; list[i].tag && (list[i].tag != e->tag); i++);\n\t\tif (!list[i].tag) {\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_short);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the value */\n\t\tfor (j = 0; list[i].strings[j] && (j < v_short); j++);\n\t\tif (!list[i].strings[j])\n\t\t\tsnprintf (val, maxlen, \"%i\", v_short);\n\t\telse if (!*list[i].strings[j])\n\t\t\tsnprintf (val, maxlen, _(\"Unknown value %i\"), v_short);\n\t\telse\n\t\t\tstrncpy (val, _(list[i].strings[j]), maxlen-1);\n\t\tbreak;\n\n\tcase EXIF_TAG_XP_TITLE:\n\tcase EXIF_TAG_XP_COMMENT:\n\tcase EXIF_TAG_XP_AUTHOR:\n\tcase EXIF_TAG_XP_KEYWORDS:\n\tcase EXIF_TAG_XP_SUBJECT:\n\t{\n\t\tunsigned short *utf16;\n\n\t\t/* Sanity check the size to prevent overflow */\n\t\tif (e->size+sizeof(unsigned short) < e->size) break;\n\n\t\t/* The tag may not be U+0000-terminated , so make a local\n\t\t   U+0000-terminated copy before converting it */\n\t\tutf16 = exif_mem_alloc (e->priv->mem, e->size+sizeof(unsigned short));\n\t\tif (!utf16) break;\n\t\tmemcpy(utf16, e->data, e->size);\n\n\t\t/* NUL terminate the string. If the size is odd (which isn't possible\n\t\t * for a UTF16 string), then this will overwrite the final garbage byte.\n\t\t */\n\t\tutf16[e->size/sizeof(unsigned short)] = 0;\n\n\t\t/* Warning! The texts are converted from UTF16 to UTF8 */\n\t\t/* FIXME: use iconv to convert into the locale encoding */\n\t\texif_convert_utf16_to_utf8(val, utf16, maxlen);\n\t\texif_mem_free(e->priv->mem, utf16);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t/* Use a generic value formatting */\n\t\texif_entry_format_value(e, val, maxlen);\n\t}\n\n\treturn val;\n}", "target": 1, "cwe": ["CWE-125"], "project": "libexif", "commit_id": "f9bb9f263fb00f0603ecbefa8957cad24168cbff", "hash": 70773760791743057967136308184471812249, "size": 567, "message": "Fix a buffer read overflow in exif_entry_get_value\n\nWhile parsing EXIF_TAG_FOCAL_LENGTH it was possible to read 8 bytes past\nthe end of a heap buffer. This was detected by the OSS Fuzz project.\nPatch from Google.\n\nFixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=7344 and\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14543", "idx": 506}
{"func": "int do_ssl3_write(SSL *s, int type, const unsigned char *buf,\n                  unsigned int *pipelens, unsigned int numpipes,\n                  int create_empty_fragment)\n{\n    unsigned char *outbuf[SSL_MAX_PIPELINES], *plen[SSL_MAX_PIPELINES];\n    SSL3_RECORD wr[SSL_MAX_PIPELINES];\n    int i, mac_size, clear = 0;\n    int prefix_len = 0;\n    int eivlen;\n    size_t align = 0;\n    SSL3_BUFFER *wb;\n    SSL_SESSION *sess;\n    unsigned int totlen = 0;\n    unsigned int j;\n\n    for (j = 0; j < numpipes; j++)\n        totlen += pipelens[j];\n    /*\n     * first check if there is a SSL3_BUFFER still being written out.  This\n     * will happen with non blocking IO\n     */\n    if (RECORD_LAYER_write_pending(&s->rlayer))\n        return (ssl3_write_pending(s, type, buf, totlen));\n\n    /* If we have an alert to send, lets send it */\n    if (s->s3->alert_dispatch) {\n        i = s->method->ssl_dispatch_alert(s);\n        if (i <= 0)\n            return (i);\n        /* if it went, fall through and send more stuff */\n    }\n\n    if (s->rlayer.numwpipes < numpipes)\n        if (!ssl3_setup_write_buffer(s, numpipes, 0))\n            return -1;\n\n    if (totlen == 0 && !create_empty_fragment)\n        return 0;\n\n    sess = s->session;\n\n    if ((sess == NULL) ||\n        (s->enc_write_ctx == NULL) || (EVP_MD_CTX_md(s->write_hash) == NULL)) {\n        clear = s->enc_write_ctx ? 0 : 1; /* must be AEAD cipher */\n        mac_size = 0;\n    } else {\n        mac_size = EVP_MD_CTX_size(s->write_hash);\n        if (mac_size < 0)\n            goto err;\n    }\n\n    /*\n     * 'create_empty_fragment' is true only when this function calls itself\n     */\n    if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done) {\n        /*\n         * countermeasure against known-IV weakness in CBC ciphersuites (see\n         * http://www.openssl.org/~bodo/tls-cbc.txt)\n         */\n\n        if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {\n            /*\n             * recursive function call with 'create_empty_fragment' set; this\n             * prepares and buffers the data for an empty fragment (these\n             * 'prefix_len' bytes are sent out later together with the actual\n             * payload)\n             */\n            unsigned int tmppipelen = 0;\n\n            prefix_len = do_ssl3_write(s, type, buf, &tmppipelen, 1, 1);\n            if (prefix_len <= 0)\n                goto err;\n\n            if (prefix_len >\n                (SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD)) {\n                /* insufficient space */\n                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n\n        s->s3->empty_fragment_done = 1;\n    }\n\n    if (create_empty_fragment) {\n        wb = &s->rlayer.wbuf[0];\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n        /*\n         * extra fragment would be couple of cipher blocks, which would be\n         * multiple of SSL3_ALIGN_PAYLOAD, so if we want to align the real\n         * payload, then we can just pretend we simply have two headers.\n         */\n        align = (size_t)SSL3_BUFFER_get_buf(wb) + 2 * SSL3_RT_HEADER_LENGTH;\n        align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n#endif\n        outbuf[0] = SSL3_BUFFER_get_buf(wb) + align;\n        SSL3_BUFFER_set_offset(wb, align);\n    } else if (prefix_len) {\n        wb = &s->rlayer.wbuf[0];\n        outbuf[0] = SSL3_BUFFER_get_buf(wb) + SSL3_BUFFER_get_offset(wb)\n            + prefix_len;\n    } else {\n        for (j = 0; j < numpipes; j++) {\n            wb = &s->rlayer.wbuf[j];\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n            align = (size_t)SSL3_BUFFER_get_buf(wb) + SSL3_RT_HEADER_LENGTH;\n            align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n#endif\n            outbuf[j] = SSL3_BUFFER_get_buf(wb) + align;\n            SSL3_BUFFER_set_offset(wb, align);\n        }\n    }\n\n    /* Explicit IV length, block ciphers appropriate version flag */\n    if (s->enc_write_ctx && SSL_USE_EXPLICIT_IV(s)) {\n        int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);\n        if (mode == EVP_CIPH_CBC_MODE) {\n            eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);\n            if (eivlen <= 1)\n                eivlen = 0;\n        }\n        /* Need explicit part of IV for GCM mode */\n        else if (mode == EVP_CIPH_GCM_MODE)\n            eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;\n        else if (mode == EVP_CIPH_CCM_MODE)\n            eivlen = EVP_CCM_TLS_EXPLICIT_IV_LEN;\n        else\n            eivlen = 0;\n    } else\n        eivlen = 0;\n\n    totlen = 0;\n    /* Clear our SSL3_RECORD structures */\n    memset(wr, 0, sizeof wr);\n    for (j = 0; j < numpipes; j++) {\n        /* write the header */\n        *(outbuf[j]++) = type & 0xff;\n        SSL3_RECORD_set_type(&wr[j], type);\n\n        *(outbuf[j]++) = (s->version >> 8);\n        /*\n         * Some servers hang if initial client hello is larger than 256 bytes\n         * and record version number > TLS 1.0\n         */\n        if (SSL_get_state(s) == TLS_ST_CW_CLNT_HELLO\n            && !s->renegotiate && TLS1_get_version(s) > TLS1_VERSION)\n            *(outbuf[j]++) = 0x1;\n        else\n            *(outbuf[j]++) = s->version & 0xff;\n\n        /* field where we are to write out packet length */\n        plen[j] = outbuf[j];\n        outbuf[j] += 2;\n\n        /* lets setup the record stuff. */\n        SSL3_RECORD_set_data(&wr[j], outbuf[j] + eivlen);\n        SSL3_RECORD_set_length(&wr[j], (int)pipelens[j]);\n        SSL3_RECORD_set_input(&wr[j], (unsigned char *)&buf[totlen]);\n        totlen += pipelens[j];\n\n        /*\n         * we now 'read' from wr->input, wr->length bytes into wr->data\n         */\n\n        /* first we compress */\n        if (s->compress != NULL) {\n            if (!ssl3_do_compress(s, &wr[j])) {\n                SSLerr(SSL_F_DO_SSL3_WRITE, SSL_R_COMPRESSION_FAILURE);\n                goto err;\n            }\n        } else {\n            memcpy(wr[j].data, wr[j].input, wr[j].length);\n            SSL3_RECORD_reset_input(&wr[j]);\n        }\n\n        /*\n         * we should still have the output to wr->data and the input from\n         * wr->input.  Length should be wr->length. wr->data still points in the\n         * wb->buf\n         */\n\n        if (!SSL_USE_ETM(s) && mac_size != 0) {\n            if (s->method->ssl3_enc->mac(s, &wr[j],\n                                         &(outbuf[j][wr[j].length + eivlen]),\n                                         1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&wr[j], mac_size);\n        }\n\n        SSL3_RECORD_set_data(&wr[j], outbuf[j]);\n        SSL3_RECORD_reset_input(&wr[j]);\n\n        if (eivlen) {\n            /*\n             * if (RAND_pseudo_bytes(p, eivlen) <= 0) goto err;\n             */\n            SSL3_RECORD_add_length(&wr[j], eivlen);\n        }\n    }\n\n    if (s->method->ssl3_enc->enc(s, wr, numpipes, 1) < 1)\n        goto err;\n\n    for (j = 0; j < numpipes; j++) {\n        if (SSL_USE_ETM(s) && mac_size != 0) {\n            if (s->method->ssl3_enc->mac(s, &wr[j],\n                                         outbuf[j] + wr[j].length, 1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&wr[j], mac_size);\n        }\n\n        /* record length after mac and block padding */\n        s2n(SSL3_RECORD_get_length(&wr[j]), plen[j]);\n\n        if (s->msg_callback)\n            s->msg_callback(1, 0, SSL3_RT_HEADER, plen[j] - 5, 5, s,\n                            s->msg_callback_arg);\n\n        /*\n         * we should now have wr->data pointing to the encrypted data, which is\n         * wr->length long\n         */\n        SSL3_RECORD_set_type(&wr[j], type); /* not needed but helps for\n                                             * debugging */\n        SSL3_RECORD_add_length(&wr[j], SSL3_RT_HEADER_LENGTH);\n\n        if (create_empty_fragment) {\n            /*\n             * we are in a recursive call; just return the length, don't write\n             * out anything here\n             */\n            if (j > 0) {\n                /* We should never be pipelining an empty fragment!! */\n                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            return SSL3_RECORD_get_length(wr);\n        }\n\n        /* now let's set up wb */\n        SSL3_BUFFER_set_left(&s->rlayer.wbuf[j],\n                             prefix_len + SSL3_RECORD_get_length(&wr[j]));\n    }\n\n    /*\n     * memorize arguments so that ssl3_write_pending can detect bad write\n     * retries later\n     */\n    s->rlayer.wpend_tot = totlen;\n    s->rlayer.wpend_buf = buf;\n    s->rlayer.wpend_type = type;\n    s->rlayer.wpend_ret = totlen;\n\n    /* we now just need to write the buffer */\n    return ssl3_write_pending(s, type, buf, totlen);\n err:\n    return -1;\n}", "target": 1, "cwe": ["CWE-20"], "project": "openssl", "commit_id": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2", "hash": 169566362905628907670688734200798997761, "size": 258, "message": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>", "idx": 507}
{"func": "static bool load_permissions_file(\n        AccessPermissionsHandle& ah,\n        std::string& permissions_file,\n        PermissionsData& permissions,\n        SecurityException& exception)\n{\n    bool returned_value = false;\n\n    BIO* file_mem = load_signed_file(ah->store_, permissions_file, exception);\n\n    if (file_mem != nullptr)\n    {\n        BUF_MEM* ptr = nullptr;\n        BIO_get_mem_ptr(file_mem, &ptr);\n\n        if (ptr != nullptr)\n        {\n            PermissionsParser parser;\n            if ((returned_value = parser.parse_stream(ptr->data, ptr->length)) == true)\n            {\n                parser.swap(permissions);\n            }\n            else\n            {\n                exception = _SecurityException_(std::string(\"Malformed permissions file \") + permissions_file);\n            }\n        }\n        else\n        {\n            exception = _SecurityException_(std::string(\"OpenSSL library cannot retrieve mem ptr from file \")\n                            + permissions_file);\n        }\n\n        BIO_free(file_mem);\n    }\n\n    return returned_value;\n}", "target": 0, "cwe": ["CWE-284"], "project": "Fast-DDS", "commit_id": "d2aeab37eb4fad4376b68ea4dfbbf285a2926384", "hash": 101593726266687392466214193789337612668, "size": 38, "message": "check remote permissions (#1387)\n\n* Refs 5346. Blackbox test\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 5346. one-way string compare\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 5346. Do not add partition separator on last partition\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 5346. Uncrustify\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 5346. Uncrustify\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 3680. Access control unit testing\r\n\r\nIt only covers Partition and Topic permissions\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs #3680. Fix partition check on Permissions plugin.\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 3680. Uncrustify\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 3680. Fix tests on mac\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 3680. Fix windows tests\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 3680. Avoid memory leak on test\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* Refs 3680. Proxy data mocks should not return temporary objects\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\n* refs 3680. uncrustify\r\n\r\nSigned-off-by: Iker Luengo <ikerluengo@eprosima.com>\r\n\r\nCo-authored-by: Miguel Company <MiguelCompany@eprosima.com>", "idx": 508}
{"func": "static uint get_table_structure(char *table, char *db, char *table_type,\n                                char *ignore_flag)\n{\n  my_bool    init=0, delayed, write_data, complete_insert;\n  my_ulonglong num_fields;\n  char       *result_table, *opt_quoted_table;\n  const char *insert_option;\n  char\t     name_buff[NAME_LEN+3],table_buff[NAME_LEN*2+3];\n  char       table_buff2[NAME_LEN*2+3], query_buff[QUERY_LENGTH];\n  const char *show_fields_stmt= \"SELECT `COLUMN_NAME` AS `Field`, \"\n                                \"`COLUMN_TYPE` AS `Type`, \"\n                                \"`IS_NULLABLE` AS `Null`, \"\n                                \"`COLUMN_KEY` AS `Key`, \"\n                                \"`COLUMN_DEFAULT` AS `Default`, \"\n                                \"`EXTRA` AS `Extra`, \"\n                                \"`COLUMN_COMMENT` AS `Comment` \"\n                                \"FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE \"\n                                \"TABLE_SCHEMA = '%s' AND TABLE_NAME = '%s'\";\n  FILE       *sql_file= md_result_file;\n  int        len;\n  my_bool    is_log_table;\n  MYSQL_RES  *result;\n  MYSQL_ROW  row;\n  DBUG_ENTER(\"get_table_structure\");\n  DBUG_PRINT(\"enter\", (\"db: %s  table: %s\", db, table));\n\n  *ignore_flag= check_if_ignore_table(table, table_type);\n\n  delayed= opt_delayed;\n  if (delayed && (*ignore_flag & IGNORE_INSERT_DELAYED))\n  {\n    delayed= 0;\n    verbose_msg(\"-- Warning: Unable to use delayed inserts for table '%s' \"\n                \"because it's of type %s\\n\", table, table_type);\n  }\n\n  complete_insert= 0;\n  if ((write_data= !(*ignore_flag & IGNORE_DATA)))\n  {\n    complete_insert= opt_complete_insert;\n    if (!insert_pat_inited)\n    {\n      insert_pat_inited= 1;\n      init_dynamic_string_checked(&insert_pat, \"\", 1024, 1024);\n    }\n    else\n      dynstr_set_checked(&insert_pat, \"\");\n  }\n\n  insert_option= ((delayed && opt_ignore) ? \" DELAYED IGNORE \" :\n                  delayed ? \" DELAYED \" : opt_ignore ? \" IGNORE \" : \"\");\n\n  verbose_msg(\"-- Retrieving table structure for table %s...\\n\", table);\n\n  len= my_snprintf(query_buff, sizeof(query_buff),\n                   \"SET SQL_QUOTE_SHOW_CREATE=%d\",\n                   (opt_quoted || opt_keywords));\n  if (!create_options)\n    strmov(query_buff+len,\n           \"/*!40102 ,SQL_MODE=concat(@@sql_mode, _utf8 ',NO_KEY_OPTIONS,NO_TABLE_OPTIONS,NO_FIELD_OPTIONS') */\");\n\n  result_table=     quote_name(table, table_buff, 1);\n  opt_quoted_table= quote_name(table, table_buff2, 0);\n\n  if (opt_order_by_primary)\n    order_by= primary_key_fields(result_table);\n\n  if (!opt_xml && !mysql_query_with_error_report(mysql, 0, query_buff))\n  {\n    /* using SHOW CREATE statement */\n    if (!opt_no_create_info)\n    {\n      /* Make an sql-file, if path was given iow. option -T was given */\n      char buff[20+FN_REFLEN];\n      MYSQL_FIELD *field;\n\n      my_snprintf(buff, sizeof(buff), \"show create table %s\", result_table);\n\n      if (switch_character_set_results(mysql, \"binary\") ||\n          mysql_query_with_error_report(mysql, &result, buff) ||\n          switch_character_set_results(mysql, default_charset))\n        DBUG_RETURN(0);\n\n      if (path)\n      {\n        if (!(sql_file= open_sql_file_for_table(table, O_WRONLY)))\n          DBUG_RETURN(0);\n\n        write_header(sql_file, db);\n      }\n\n      if (strcmp (table_type, \"VIEW\") == 0)         /* view */\n        print_comment(sql_file, 0,\n                      \"\\n--\\n-- Temporary table structure for view %s\\n--\\n\\n\",\n                      result_table);\n      else\n        print_comment(sql_file, 0,\n                      \"\\n--\\n-- Table structure for table %s\\n--\\n\\n\",\n                      result_table);\n\n      if (opt_drop)\n      {\n      /*\n        Even if the \"table\" is a view, we do a DROP TABLE here.  The\n        view-specific code below fills in the DROP VIEW.\n        We will skip the DROP TABLE for general_log and slow_log, since\n        those stmts will fail, in case we apply dump by enabling logging.\n       */\n        if (!general_log_or_slow_log_tables(db, table))\n          fprintf(sql_file, \"DROP TABLE IF EXISTS %s;\\n\",\n                  opt_quoted_table);\n        check_io(sql_file);\n      }\n\n      field= mysql_fetch_field_direct(result, 0);\n      if (strcmp(field->name, \"View\") == 0)\n      {\n        char *scv_buff= NULL;\n        my_ulonglong n_cols;\n\n        verbose_msg(\"-- It's a view, create dummy table for view\\n\");\n\n        /* save \"show create\" statement for later */\n        if ((row= mysql_fetch_row(result)) && (scv_buff=row[1]))\n          scv_buff= my_strdup(scv_buff, MYF(0));\n\n        mysql_free_result(result);\n\n        /*\n          Create a table with the same name as the view and with columns of\n          the same name in order to satisfy views that depend on this view.\n          The table will be removed when the actual view is created.\n\n          The properties of each column, are not preserved in this temporary\n          table, because they are not necessary.\n\n          This will not be necessary once we can determine dependencies\n          between views and can simply dump them in the appropriate order.\n        */\n        my_snprintf(query_buff, sizeof(query_buff),\n                    \"SHOW FIELDS FROM %s\", result_table);\n        if (switch_character_set_results(mysql, \"binary\") ||\n            mysql_query_with_error_report(mysql, &result, query_buff) ||\n            switch_character_set_results(mysql, default_charset))\n        {\n          /*\n            View references invalid or privileged table/col/fun (err 1356),\n            so we cannot create a stand-in table.  Be defensive and dump\n            a comment with the view's 'show create' statement. (Bug #17371)\n          */\n\n          if (mysql_errno(mysql) == ER_VIEW_INVALID)\n            fprintf(sql_file, \"\\n-- failed on view %s: %s\\n\\n\", result_table, scv_buff ? scv_buff : \"\");\n\n          my_free(scv_buff);\n\n          DBUG_RETURN(0);\n        }\n        else\n          my_free(scv_buff);\n\n        n_cols= mysql_num_rows(result);\n        if (0 != n_cols)\n        {\n\n          /*\n            The actual formula is based on the column names and how the .FRM\n            files are stored and is too volatile to be repeated here.\n            Thus we simply warn the user if the columns exceed a limit we\n            know works most of the time.\n          */\n          if (n_cols >= 1000)\n            fprintf(stderr,\n                    \"-- Warning: Creating a stand-in table for view %s may\"\n                    \" fail when replaying the dump file produced because \"\n                    \"of the number of columns exceeding 1000. Exercise \"\n                    \"caution when replaying the produced dump file.\\n\", \n                    table);\n          if (opt_drop)\n          {\n            /*\n              We have already dropped any table of the same name above, so\n              here we just drop the view.\n            */\n\n            fprintf(sql_file, \"/*!50001 DROP VIEW IF EXISTS %s*/;\\n\",\n                    opt_quoted_table);\n            check_io(sql_file);\n          }\n\n          fprintf(sql_file,\n                  \"SET @saved_cs_client     = @@character_set_client;\\n\"\n                  \"SET character_set_client = utf8;\\n\"\n                  \"/*!50001 CREATE TABLE %s (\\n\",\n                  result_table);\n\n          /*\n            Get first row, following loop will prepend comma - keeps from\n            having to know if the row being printed is last to determine if\n            there should be a _trailing_ comma.\n          */\n\n          row= mysql_fetch_row(result);\n\n          /*\n            The actual column type doesn't matter anyway, since the table will\n            be dropped at run time.\n            We do tinyint to avoid hitting the row size limit.\n          */\n          fprintf(sql_file, \"  %s tinyint NOT NULL\",\n                  quote_name(row[0], name_buff, 0));\n\n          while((row= mysql_fetch_row(result)))\n          {\n            /* col name, col type */\n            fprintf(sql_file, \",\\n  %s tinyint NOT NULL\",\n                    quote_name(row[0], name_buff, 0));\n          }\n\n          /*\n            Stand-in tables are always MyISAM tables as the default\n            engine might have a column-limit that's lower than the\n            number of columns in the view, and MyISAM support is\n            guaranteed to be in the server anyway.\n          */\n          fprintf(sql_file,\n                  \"\\n) ENGINE=MyISAM */;\\n\"\n                  \"SET character_set_client = @saved_cs_client;\\n\");\n\n          check_io(sql_file);\n        }\n\n        mysql_free_result(result);\n\n        if (path)\n          my_fclose(sql_file, MYF(MY_WME));\n\n        seen_views= 1;\n        DBUG_RETURN(0);\n      }\n\n      row= mysql_fetch_row(result);\n\n      is_log_table= general_log_or_slow_log_tables(db, table);\n      if (is_log_table)\n        row[1]+= 13; /* strlen(\"CREATE TABLE \")= 13 */\n      if (opt_compatible_mode & 3)\n      {\n        fprintf(sql_file,\n                is_log_table ? \"CREATE TABLE IF NOT EXISTS %s;\\n\" : \"%s;\\n\",\n                row[1]);\n      }\n      else\n      {\n        fprintf(sql_file,\n                \"/*!40101 SET @saved_cs_client     = @@character_set_client */;\\n\"\n                \"/*!40101 SET character_set_client = utf8 */;\\n\"\n                \"%s%s;\\n\"\n                \"/*!40101 SET character_set_client = @saved_cs_client */;\\n\",\n                is_log_table ? \"CREATE TABLE IF NOT EXISTS \" : \"\",\n                row[1]);\n      }\n\n      check_io(sql_file);\n      mysql_free_result(result);\n    }\n    my_snprintf(query_buff, sizeof(query_buff), \"show fields from %s\",\n                result_table);\n    if (mysql_query_with_error_report(mysql, &result, query_buff))\n    {\n      if (path)\n        my_fclose(sql_file, MYF(MY_WME));\n      DBUG_RETURN(0);\n    }\n\n    /*\n      If write_data is true, then we build up insert statements for\n      the table's data. Note: in subsequent lines of code, this test\n      will have to be performed each time we are appending to\n      insert_pat.\n    */\n    if (write_data)\n    {\n      if (opt_replace_into)\n        dynstr_append_checked(&insert_pat, \"REPLACE \");\n      else\n        dynstr_append_checked(&insert_pat, \"INSERT \");\n      dynstr_append_checked(&insert_pat, insert_option);\n      dynstr_append_checked(&insert_pat, \"INTO \");\n      dynstr_append_checked(&insert_pat, opt_quoted_table);\n      if (complete_insert)\n      {\n        dynstr_append_checked(&insert_pat, \" (\");\n      }\n      else\n      {\n        dynstr_append_checked(&insert_pat, \" VALUES \");\n        if (!extended_insert)\n          dynstr_append_checked(&insert_pat, \"(\");\n      }\n    }\n\n    while ((row= mysql_fetch_row(result)))\n    {\n      if (complete_insert)\n      {\n        if (init)\n        {\n          dynstr_append_checked(&insert_pat, \", \");\n        }\n        init=1;\n        dynstr_append_checked(&insert_pat,\n                      quote_name(row[SHOW_FIELDNAME], name_buff, 0));\n      }\n    }\n    num_fields= mysql_num_rows(result);\n    mysql_free_result(result);\n  }\n  else\n  {\n    verbose_msg(\"%s: Warning: Can't set SQL_QUOTE_SHOW_CREATE option (%s)\\n\",\n                my_progname, mysql_error(mysql));\n\n    my_snprintf(query_buff, sizeof(query_buff), show_fields_stmt, db, table);\n\n    if (mysql_query_with_error_report(mysql, &result, query_buff))\n      DBUG_RETURN(0);\n\n    /* Make an sql-file, if path was given iow. option -T was given */\n    if (!opt_no_create_info)\n    {\n      if (path)\n      {\n        if (!(sql_file= open_sql_file_for_table(table, O_WRONLY)))\n          DBUG_RETURN(0);\n        write_header(sql_file, db);\n      }\n\n      print_comment(sql_file, 0,\n                    \"\\n--\\n-- Table structure for table %s\\n--\\n\\n\",\n                    result_table);\n      if (opt_drop)\n        fprintf(sql_file, \"DROP TABLE IF EXISTS %s;\\n\", result_table);\n      if (!opt_xml)\n        fprintf(sql_file, \"CREATE TABLE %s (\\n\", result_table);\n      else\n        print_xml_tag(sql_file, \"\\t\", \"\\n\", \"table_structure\", \"name=\", table, \n                NullS);\n      check_io(sql_file);\n    }\n\n    if (write_data)\n    {\n      if (opt_replace_into)\n        dynstr_append_checked(&insert_pat, \"REPLACE \");\n      else\n        dynstr_append_checked(&insert_pat, \"INSERT \");\n      dynstr_append_checked(&insert_pat, insert_option);\n      dynstr_append_checked(&insert_pat, \"INTO \");\n      dynstr_append_checked(&insert_pat, result_table);\n      if (complete_insert)\n        dynstr_append_checked(&insert_pat, \" (\");\n      else\n      {\n        dynstr_append_checked(&insert_pat, \" VALUES \");\n        if (!extended_insert)\n          dynstr_append_checked(&insert_pat, \"(\");\n      }\n    }\n\n    while ((row= mysql_fetch_row(result)))\n    {\n      ulong *lengths= mysql_fetch_lengths(result);\n      if (init)\n      {\n        if (!opt_xml && !opt_no_create_info)\n        {\n          fputs(\",\\n\",sql_file);\n          check_io(sql_file);\n        }\n        if (complete_insert)\n          dynstr_append_checked(&insert_pat, \", \");\n      }\n      init=1;\n      if (complete_insert)\n        dynstr_append_checked(&insert_pat,\n                      quote_name(row[SHOW_FIELDNAME], name_buff, 0));\n      if (!opt_no_create_info)\n      {\n        if (opt_xml)\n        {\n          print_xml_row(sql_file, \"field\", result, &row, NullS);\n          continue;\n        }\n\n        if (opt_keywords)\n          fprintf(sql_file, \"  %s.%s %s\", result_table,\n                  quote_name(row[SHOW_FIELDNAME],name_buff, 0),\n                  row[SHOW_TYPE]);\n        else\n          fprintf(sql_file, \"  %s %s\", quote_name(row[SHOW_FIELDNAME],\n                                                  name_buff, 0),\n                  row[SHOW_TYPE]);\n        if (row[SHOW_DEFAULT])\n        {\n          fputs(\" DEFAULT \", sql_file);\n          unescape(sql_file, row[SHOW_DEFAULT], lengths[SHOW_DEFAULT]);\n        }\n        if (!row[SHOW_NULL][0])\n          fputs(\" NOT NULL\", sql_file);\n        if (row[SHOW_EXTRA][0])\n          fprintf(sql_file, \" %s\",row[SHOW_EXTRA]);\n        check_io(sql_file);\n      }\n    }\n    num_fields= mysql_num_rows(result);\n    mysql_free_result(result);\n    if (!opt_no_create_info)\n    {\n      /* Make an sql-file, if path was given iow. option -T was given */\n      char buff[20+FN_REFLEN];\n      uint keynr,primary_key;\n      my_snprintf(buff, sizeof(buff), \"show keys from %s\", result_table);\n      if (mysql_query_with_error_report(mysql, &result, buff))\n      {\n        if (mysql_errno(mysql) == ER_WRONG_OBJECT)\n        {\n          /* it is VIEW */\n          fputs(\"\\t\\t<options Comment=\\\"view\\\" />\\n\", sql_file);\n          goto continue_xml;\n        }\n        fprintf(stderr, \"%s: Can't get keys for table %s (%s)\\n\",\n                my_progname, result_table, mysql_error(mysql));\n        if (path)\n          my_fclose(sql_file, MYF(MY_WME));\n        DBUG_RETURN(0);\n      }\n\n      /* Find first which key is primary key */\n      keynr=0;\n      primary_key=INT_MAX;\n      while ((row= mysql_fetch_row(result)))\n      {\n        if (atoi(row[3]) == 1)\n        {\n          keynr++;\n#ifdef FORCE_PRIMARY_KEY\n          if (atoi(row[1]) == 0 && primary_key == INT_MAX)\n            primary_key=keynr;\n#endif\n          if (!strcmp(row[2],\"PRIMARY\"))\n          {\n            primary_key=keynr;\n            break;\n          }\n        }\n      }\n      mysql_data_seek(result,0);\n      keynr=0;\n      while ((row= mysql_fetch_row(result)))\n      {\n        if (opt_xml)\n        {\n          print_xml_row(sql_file, \"key\", result, &row, NullS);\n          continue;\n        }\n\n        if (atoi(row[3]) == 1)\n        {\n          if (keynr++)\n            putc(')', sql_file);\n          if (atoi(row[1]))       /* Test if duplicate key */\n            /* Duplicate allowed */\n            fprintf(sql_file, \",\\n  KEY %s (\",quote_name(row[2],name_buff,0));\n          else if (keynr == primary_key)\n            fputs(\",\\n  PRIMARY KEY (\",sql_file); /* First UNIQUE is primary */\n          else\n            fprintf(sql_file, \",\\n  UNIQUE %s (\",quote_name(row[2],name_buff,\n                                                            0));\n        }\n        else\n          putc(',', sql_file);\n        fputs(quote_name(row[4], name_buff, 0), sql_file);\n        if (row[7])\n          fprintf(sql_file, \" (%s)\",row[7]);      /* Sub key */\n        check_io(sql_file);\n      }\n      mysql_free_result(result);\n      if (!opt_xml)\n      {\n        if (keynr)\n          putc(')', sql_file);\n        fputs(\"\\n)\",sql_file);\n        check_io(sql_file);\n      }\n\n      /* Get MySQL specific create options */\n      if (create_options)\n      {\n        char show_name_buff[NAME_LEN*2+2+24];\n\n        /* Check memory for quote_for_like() */\n        my_snprintf(buff, sizeof(buff), \"show table status like %s\",\n                    quote_for_like(table, show_name_buff));\n\n        if (mysql_query_with_error_report(mysql, &result, buff))\n        {\n          if (mysql_errno(mysql) != ER_PARSE_ERROR)\n          {                                     /* If old MySQL version */\n            verbose_msg(\"-- Warning: Couldn't get status information for \" \\\n                        \"table %s (%s)\\n\", result_table,mysql_error(mysql));\n          }\n        }\n        else if (!(row= mysql_fetch_row(result)))\n        {\n          fprintf(stderr,\n                  \"Error: Couldn't read status information for table %s (%s)\\n\",\n                  result_table,mysql_error(mysql));\n        }\n        else\n        {\n          if (opt_xml)\n            print_xml_row(sql_file, \"options\", result, &row, NullS);\n          else\n          {\n            fputs(\"/*!\",sql_file);\n            print_value(sql_file,result,row,\"engine=\",\"Engine\",0);\n            print_value(sql_file,result,row,\"\",\"Create_options\",0);\n            print_value(sql_file,result,row,\"comment=\",\"Comment\",1);\n            fputs(\" */\",sql_file);\n            check_io(sql_file);\n          }\n        }\n        mysql_free_result(result);              /* Is always safe to free */\n      }\ncontinue_xml:\n      if (!opt_xml)\n        fputs(\";\\n\", sql_file);\n      else\n        fputs(\"\\t</table_structure>\\n\", sql_file);\n      check_io(sql_file);\n    }\n  }\n  if (complete_insert)\n  {\n    dynstr_append_checked(&insert_pat, \") VALUES \");\n    if (!extended_insert)\n      dynstr_append_checked(&insert_pat, \"(\");\n  }\n  if (sql_file != md_result_file)\n  {\n    fputs(\"\\n\", sql_file);\n    write_footer(sql_file);\n    my_fclose(sql_file, MYF(MY_WME));\n  }\n  DBUG_RETURN((uint) num_fields);\n} /* get_table_structure */", "target": 1, "cwe": [], "project": "mysql-server", "commit_id": "6fa5e0814662d691be1a29bf88332348ec7c50c9", "hash": 646626500561472887164239463934577004, "size": 557, "message": "Bug #25717383: MYSQLDUMP MAY EXECUTE ANY ARBITRARY QUERY\n\nWhile writing comments if database object names has a new\nline character, then next line is considered a command, rather\nthan a comment.\nThis patch fixes the way comments are constructed in mysqldump.\n\n(cherry picked from commit 1099f9d17b1c697c2760f86556f5bae7d202b444)", "idx": 509}
{"func": "static inline int restore_altivec(struct task_struct *tsk) { return 0; }", "target": 1, "cwe": ["CWE-662"], "project": "linux", "commit_id": "a8318c13e79badb92bc6640704a64cc022a6eb97", "hash": 75969356617120414016503362189629016204, "size": 1, "message": "powerpc/tm: Fix restoring FP/VMX facility incorrectly on interrupts\n\nWhen in userspace and MSR FP=0 the hardware FP state is unrelated to\nthe current process. This is extended for transactions where if tbegin\nis run with FP=0, the hardware checkpoint FP state will also be\nunrelated to the current process. Due to this, we need to ensure this\nhardware checkpoint is updated with the correct state before we enable\nFP for this process.\n\nUnfortunately we get this wrong when returning to a process from a\nhardware interrupt. A process that starts a transaction with FP=0 can\ntake an interrupt. When the kernel returns back to that process, we\nchange to FP=1 but with hardware checkpoint FP state not updated. If\nthis transaction is then rolled back, the FP registers now contain the\nwrong state.\n\nThe process looks like this:\n   Userspace:                      Kernel\n\n               Start userspace\n                with MSR FP=0 TM=1\n                  < -----\n   ...\n   tbegin\n   bne\n               Hardware interrupt\n                   ---- >\n                                    <do_IRQ...>\n                                    ....\n                                    ret_from_except\n                                      restore_math()\n\t\t\t\t        /* sees FP=0 */\n                                        restore_fp()\n                                          tm_active_with_fp()\n\t\t\t\t\t    /* sees FP=1 (Incorrect) */\n                                          load_fp_state()\n                                        FP = 0 -> 1\n                  < -----\n               Return to userspace\n                 with MSR TM=1 FP=1\n                 with junk in the FP TM checkpoint\n   TM rollback\n   reads FP junk\n\nWhen returning from the hardware exception, tm_active_with_fp() is\nincorrectly making restore_fp() call load_fp_state() which is setting\nFP=1.\n\nThe fix is to remove tm_active_with_fp().\n\ntm_active_with_fp() is attempting to handle the case where FP state\nhas been changed inside a transaction. In this case the checkpointed\nand transactional FP state is different and hence we must restore the\nFP state (ie. we can't do lazy FP restore inside a transaction that's\nused FP). It's safe to remove tm_active_with_fp() as this case is\nhandled by restore_tm_state(). restore_tm_state() detects if FP has\nbeen using inside a transaction and will set load_fp and call\nrestore_math() to ensure the FP state (checkpoint and transaction) is\nrestored.\n\nThis is a data integrity problem for the current process as the FP\nregisters are corrupted. It's also a security problem as the FP\nregisters from one process may be leaked to another.\n\nSimilarly for VMX.\n\nA simple testcase to replicate this will be posted to\ntools/testing/selftests/powerpc/tm/tm-poison.c\n\nThis fixes CVE-2019-15031.\n\nFixes: a7771176b439 (\"powerpc: Don't enable FP/Altivec if not checkpointed\")\nCc: stable@vger.kernel.org # 4.15+\nSigned-off-by: Gustavo Romero <gromero@linux.ibm.com>\nSigned-off-by: Michael Neuling <mikey@neuling.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20190904045529.23002-2-gromero@linux.vnet.ibm.com", "idx": 510}
{"func": "static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)\n{\n\treturn hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,\n\t\t\t\t    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,\n\t\t\t\t    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);\n}", "target": 0, "cwe": ["CWE-787"], "project": "linux", "commit_id": "d9d4b1e46d9543a82c23f6df03f4ad697dab361b", "hash": 65930271821767666086906024985704226563, "size": 6, "message": "HID: Fix assumption that devices have inputs\n\nThe syzbot fuzzer found a slab-out-of-bounds write bug in the hid-gaff\ndriver.  The problem is caused by the driver's assumption that the\ndevice must have an input report.  While this will be true for all\nnormal HID input devices, a suitably malicious device can violate the\nassumption.\n\nThe same assumption is present in over a dozen other HID drivers.\nThis patch fixes them by checking that the list of hid_inputs for the\nhid_device is nonempty before allowing it to be used.\n\nReported-and-tested-by: syzbot+403741a091bf41d4ae79@syzkaller.appspotmail.com\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nCC: <stable@vger.kernel.org>\nSigned-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>", "idx": 511}
{"func": "void gdImageRectangle (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;\n\tint thick = im->thick;\n\tint t;\n\n\tif (x1 == x2 && y1 == y2 && thick == 1) {\n\t\tgdImageSetPixel(im, x1, y1, color);\n\t\treturn;\n\t}\n\n\tif (y2 < y1) {\n\t\tt=y1;\n\t\ty1 = y2;\n\t\ty2 = t;\n\n\t\tt = x1;\n\t\tx1 = x2;\n\t\tx2 = t;\n\t}\n\n\tx1h = x1; x1v = x1; y1h = y1; y1v = y1; x2h = x2; x2v = x2; y2h = y2; y2v = y2;\n\tif (thick > 1) {\n\t\tint cx, cy, x1ul, y1ul, x2lr, y2lr;\n\t\tint half = thick >> 1;\n\n\t\tx1ul = x1 - half;\n\t\ty1ul = y1 - half;\n\t\t\n\t\tx2lr = x2 + half;\n\t\ty2lr = y2 + half;\n\n\t\tcy = y1ul + thick;\n\t\twhile (cy-- > y1ul) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y2lr - thick;\n\t\twhile (cy++ < y2lr) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x1ul + thick) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x2lr - thick - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t} else {\n\t\ty1v = y1h + 1;\n\t\ty2v = y2h - 1;\n\t\tgdImageLine(im, x1h, y1h, x2h, y1h, color);\n\t\tgdImageLine(im, x1h, y2h, x2h, y2h, color);\n\t\tgdImageLine(im, x1v, y1v, x1v, y2v, color);\n\t\tgdImageLine(im, x2v, y1v, x2v, y2v, color);\n\t}\n}", "target": 1, "cwe": ["CWE-190"], "project": "php-src", "commit_id": "c395c6e5d7e8df37a21265ff76e48fe75ceb5ae6", "hash": 298506650791838280782131453067210935734, "size": 74, "message": "iFixed bug #72446 - Integer Overflow in gdImagePaletteToTrueColor() resulting in heap overflow", "idx": 512}
{"func": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n\n  DECLARE_MBSTATE;\n\n  open = 0;\n  send = string + strlen (string);\n\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\n\tcase '[':\n\t  open++;\n\t  continue;\n\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t/*)*/\n\t    return (1);\n\t  continue;\n\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n\n      /* Advance one fewer byte than an entire multibyte character to\n\t account for the auto-increment in the loop above. */\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}", "target": 1, "cwe": ["CWE-273", "CWE-787"], "project": "bash", "commit_id": "951bdaad7a18cc0dc1036bba86b18b90874d39ff", "hash": 18255109763054970387836941011625076997, "size": 53, "message": "commit bash-20190628 snapshot", "idx": 513}
{"func": "static int gnutls_system_mutex_deinit(void **priv)\n{\n\tpthread_mutex_destroy((pthread_mutex_t *) * priv);\n\tfree(*priv);\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-20"], "project": "gnutls", "commit_id": "b0a3048e56611a2deee4976aeba3b8c0740655a6", "hash": 60137215777251517272551517643231269616, "size": 6, "message": "env: use secure_getenv when reading environment variables", "idx": 514}
{"func": "void unix_gc(void)\n{\n\tstatic DEFINE_MUTEX(unix_gc_sem);\n\tint i;\n\tstruct sock *s;\n\tstruct sk_buff_head hitlist;\n\tstruct sk_buff *skb;\n\n\t/*\n\t *\tAvoid a recursive GC.\n\t */\n\n\tif (!mutex_trylock(&unix_gc_sem))\n\t\treturn;\n\n\tspin_lock(&unix_table_lock);\n\n\tforall_unix_sockets(i, s)\n\t{\n\t\tunix_sk(s)->gc_tree = GC_ORPHAN;\n\t}\n\t/*\n\t *\tEverything is now marked\n\t */\n\n\t/* Invariant to be maintained:\n\t\t- everything unmarked is either:\n\t\t-- (a) on the stack, or\n\t\t-- (b) has all of its children unmarked\n\t\t- everything on the stack is always unmarked\n\t\t- nothing is ever pushed onto the stack twice, because:\n\t\t-- nothing previously unmarked is ever pushed on the stack\n\t */\n\n\t/*\n\t *\tPush root set\n\t */\n\n\tforall_unix_sockets(i, s)\n\t{\n\t\tint open_count = 0;\n\n\t\t/*\n\t\t *\tIf all instances of the descriptor are not\n\t\t *\tin flight we are in use.\n\t\t *\n\t\t *\tSpecial case: when socket s is embrion, it may be\n\t\t *\thashed but still not in queue of listening socket.\n\t\t *\tIn this case (see unix_create1()) we set artificial\n\t\t *\tnegative inflight counter to close race window.\n\t\t *\tIt is trick of course and dirty one.\n\t\t */\n\t\tif (s->sk_socket && s->sk_socket->file)\n\t\t\topen_count = file_count(s->sk_socket->file);\n\t\tif (open_count > atomic_read(&unix_sk(s)->inflight))\n\t\t\tmaybe_unmark_and_push(s);\n\t}\n\n\t/*\n\t *\tMark phase\n\t */\n\n\twhile (!empty_stack())\n\t{\n\t\tstruct sock *x = pop_stack();\n\t\tstruct sock *sk;\n\n\t\tspin_lock(&x->sk_receive_queue.lock);\n\t\tskb = skb_peek(&x->sk_receive_queue);\n\n\t\t/*\n\t\t *\tLoop through all but first born\n\t\t */\n\n\t\twhile (skb && skb != (struct sk_buff *)&x->sk_receive_queue) {\n\t\t\t/*\n\t\t\t *\tDo we have file descriptors ?\n\t\t\t */\n\t\t\tif(UNIXCB(skb).fp)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t *\tProcess the descriptors of this socket\n\t\t\t\t */\n\t\t\t\tint nfd=UNIXCB(skb).fp->count;\n\t\t\t\tstruct file **fp = UNIXCB(skb).fp->fp;\n\t\t\t\twhile(nfd--)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t *\tGet the socket the fd matches if\n\t\t\t\t\t *\tit indeed does so\n\t\t\t\t\t */\n\t\t\t\t\tif((sk=unix_get_socket(*fp++))!=NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaybe_unmark_and_push(sk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* We have to scan not-yet-accepted ones too */\n\t\t\tif (x->sk_state == TCP_LISTEN)\n\t\t\t\tmaybe_unmark_and_push(skb->sk);\n\t\t\tskb=skb->next;\n\t\t}\n\t\tspin_unlock(&x->sk_receive_queue.lock);\n\t\tsock_put(x);\n\t}\n\n\tskb_queue_head_init(&hitlist);\n\n\tforall_unix_sockets(i, s)\n\t{\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (u->gc_tree == GC_ORPHAN) {\n\t\t\tstruct sk_buff *nextsk;\n\n\t\t\tspin_lock(&s->sk_receive_queue.lock);\n\t\t\tskb = skb_peek(&s->sk_receive_queue);\n\t\t\twhile (skb &&\n\t\t\t       skb != (struct sk_buff *)&s->sk_receive_queue) {\n\t\t\t\tnextsk = skb->next;\n\t\t\t\t/*\n\t\t\t\t *\tDo we have file descriptors ?\n\t\t\t\t */\n\t\t\t\tif (UNIXCB(skb).fp) {\n\t\t\t\t\t__skb_unlink(skb,\n\t\t\t\t\t\t     &s->sk_receive_queue);\n\t\t\t\t\t__skb_queue_tail(&hitlist, skb);\n\t\t\t\t}\n\t\t\t\tskb = nextsk;\n\t\t\t}\n\t\t\tspin_unlock(&s->sk_receive_queue.lock);\n\t\t}\n\t\tu->gc_tree = GC_ORPHAN;\n\t}\n\tspin_unlock(&unix_table_lock);\n\n\t/*\n\t *\tHere we are. Hitlist is filled. Die.\n\t */\n\n\t__skb_queue_purge(&hitlist);\n\tmutex_unlock(&unix_gc_sem);\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "1fd05ba5a2f2aa8e7b9b52ef55df850e2e7d54c9", "hash": 33298602564084208798965686270060731488, "size": 143, "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 515}
{"func": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            /* module check */\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n\n            /* direct name check */\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}", "target": 1, "cwe": ["CWE-119"], "project": "libyang", "commit_id": "32fb4993bc8bb49e93e84016af3c10ea53964be5", "hash": 307155218306670828322382448572519427818, "size": 33, "message": "schema tree BUGFIX do not check features while still resolving schema\n\nFixes #723", "idx": 516}
{"func": "TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {\n    // true means multikey\n    addIndex(BSON(\"a.b\" << 1 << \"a.c\" << 1), true);\n    runQuery(fromjson(\"{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}\"));\n\n    assertNumSolutions(3U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: \"\n        \"{'a.b': [[1,1,true,true]], \"\n        \" 'a.c': [[1,1,true,true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: \"\n        \"{'a.b': [[1,1,true,true]], \"\n        \" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}\");\n}", "target": 0, "cwe": ["CWE-834"], "project": "mongo", "commit_id": "94d0e046baa64d1aa1a6af97e2d19bb466cc1ff5", "hash": 157274512261813535943713591673514226747, "size": 16, "message": "SERVER-38164 $or pushdown optimization does not correctly handle $not within an $elemMatch", "idx": 517}
{"func": "int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)\n{\n    cmsStage* Anterior = NULL, *pt;\n\n    if (lut == NULL || mpe == NULL)\n        return FALSE;\n\n    switch (loc) {\n\n        case cmsAT_BEGIN:\n            mpe ->Next = lut ->Elements;\n            lut ->Elements = mpe;\n            break;\n\n        case cmsAT_END:\n\n            if (lut ->Elements == NULL)\n                lut ->Elements = mpe;\n            else {\n\n                for (pt = lut ->Elements;\n                     pt != NULL;\n                     pt = pt -> Next) Anterior = pt;\n\n                Anterior ->Next = mpe;\n                mpe ->Next = NULL;\n            }\n            break;\n        default:;\n            return FALSE;\n    }\n\n    BlessLUT(lut);\n    return TRUE;\n}", "target": 0, "cwe": [], "project": "Little-CMS", "commit_id": "41d222df1bc6188131a8f46c32eab0a4d4cdf1b6", "hash": 178726617340397531344953024346267619334, "size": 35, "message": "Memory squeezing fix: lcms2 cmsPipeline construction\n\nWhen creating a new pipeline, lcms would often try to allocate a stage\nand pass it to cmsPipelineInsertStage without checking whether the\nallocation succeeded. cmsPipelineInsertStage would then assert (or crash)\nif it had not.\n\nThe fix here is to change cmsPipelineInsertStage to check and return\nan error value. All calling code is then checked to test this return\nvalue and cope.", "idx": 518}
{"func": "static bool is_physical_fs(const struct statfs *sfs) {\n        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);\n}", "target": 0, "cwe": ["CWE-674"], "project": "systemd", "commit_id": "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1", "hash": 101182742827133072562381487930374172089, "size": 3, "message": "shared/rm-rf: loop over nested directories instead of instead of recursing\n\nTo remove directory structures, we need to remove the innermost items first,\nand then recursively remove higher-level directories. We would recursively\ndescend into directories and invoke rm_rf_children and rm_rm_children_inner.\nThis is problematic when too many directories are nested.\n\nInstead, let's create a \"TODO\" queue. In the the queue, for each level we\nhold the DIR* object we were working on, and the name of the directory. This\nallows us to leave a partially-processed directory, and restart the removal\nloop one level down. When done with the inner directory, we use the name to\nunlinkat() it from the parent, and proceed with the removal of other items.\n\nBecause the nesting is increased by one level, it is best to view this patch\nwith -b/--ignore-space-change.\n\nThis fixes CVE-2021-3997, https://bugzilla.redhat.com/show_bug.cgi?id=2024639.\nThe issue was reported and patches reviewed by Qualys Team.\nMauro Matteo Cascella and Riccardo Schirone from Red Hat handled the disclosure.", "idx": 519}
{"func": "static void release_unused_pictures(H264Context *h, int remove_current)\n{\n    int i;\n\n    /* release non reference frames */\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&\n            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {\n            unref_picture(h, &h->DPB[i]);\n        }\n    }\n}", "target": 0, "cwe": ["CWE-703"], "project": "FFmpeg", "commit_id": "29ffeef5e73b8f41ff3a3f2242d356759c66f91f", "hash": 329179868791930776516063760715074245016, "size": 12, "message": "avcodec/h264: do not trust last_pic_droppable when marking pictures as done\n\nThis simplifies the code and fixes a deadlock\n\nFixes Ticket2927\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "idx": 520}
{"func": "rsvg_new_image (void)\n{\n    RsvgNodeImage *image;\n    image = g_new (RsvgNodeImage, 1);\n    _rsvg_node_init (&image->super);\n    g_assert (image->super.state);\n    image->img = NULL;\n    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;\n    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (\"0\");\n    image->super.free = rsvg_node_image_free;\n    image->super.draw = rsvg_node_image_draw;\n    image->super.set_atts = rsvg_node_image_set_atts;\n    return &image->super;\n}", "target": 1, "cwe": [], "project": "librsvg", "commit_id": "34c95743ca692ea0e44778e41a7c0a129363de84", "hash": 84996539023426876711639191315173018959, "size": 14, "message": "Store node type separately in RsvgNode\n\nThe node name (formerly RsvgNode:type) cannot be used to infer\nthe sub-type of RsvgNode that we're dealing with, since for unknown\nelements we put type = node-name. This lead to a (potentially exploitable)\ncrash e.g. when the element name started with \"fe\" which tricked\nthe old code into considering it as a RsvgFilterPrimitive.\n\nCVE-2011-3146\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=658014", "idx": 521}
{"func": "handle_raw_ping(struct query *q, int dns_fd, int userid)\n{\n\tif (check_user_and_ip(userid, q) != 0) {\n\t\treturn;\n\t}\n\n\t/* Update query and time info for user */\n\tusers[userid].last_pkt = time(NULL);\n\tmemcpy(&(users[userid].q), q, sizeof(struct query));\n\n\tif (debug >= 1) {\n\t\tfprintf(stderr, \"IN   ping raw, from user %d\\n\", userid);\n\t}\n\n\t/* Send ping reply */\n\tsend_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);\n}", "target": 1, "cwe": [], "project": "iodine", "commit_id": "b715be5cf3978fbe589b03b09c9398d0d791f850", "hash": 133411971222770293360292868720618879582, "size": 17, "message": "Fix authentication bypass bug\n\nThe client could bypass the password check by continuing after getting error\nfrom the server and guessing the network parameters. The server would still\naccept the rest of the setup and also network traffic.\n\nAdd checks for normal and raw mode that user has authenticated before allowing\nany other communication.\n\nProblem found by Oscar Reparaz.", "idx": 522}
{"func": "dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok)\n\t{\n\tunsigned char wire[DTLS1_HM_HEADER_LENGTH];\n\tunsigned long len, frag_off, frag_len;\n\tint i,al;\n\tstruct hm_header_st msg_hdr;\n\n\t/* see if we have the required fragment already */\n\tif ((frag_len = dtls1_retrieve_buffered_fragment(s,max,ok)) || *ok)\n\t\t{\n\t\tif (*ok)\ts->init_num = frag_len;\n\t\treturn frag_len;\n\t\t}\n\n\t/* read handshake message header */\n\ti=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,wire,\n\t\tDTLS1_HM_HEADER_LENGTH, 0);\n\tif (i <= 0) \t/* nbio, or an error */\n\t\t{\n\t\ts->rwstate=SSL_READING;\n\t\t*ok = 0;\n\t\treturn i;\n\t\t}\n\t/* Handshake fails if message header is incomplete */\n\tif (i != DTLS1_HM_HEADER_LENGTH)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);\n\t\tgoto f_err;\n\t\t}\n\n\t/* parse the message fragment header */\n\tdtls1_get_message_header(wire, &msg_hdr);\n\n\t/* \n\t * if this is a future (or stale) message it gets buffered\n\t * (or dropped)--no further processing at this time\n\t * While listening, we accept seq 1 (ClientHello with cookie)\n\t * although we're still expecting seq 0 (ClientHello)\n\t */\n\tif (msg_hdr.seq != s->d1->handshake_read_seq && !(s->d1->listen && msg_hdr.seq == 1))\n\t\treturn dtls1_process_out_of_seq_message(s, &msg_hdr, ok);\n\n\tlen = msg_hdr.msg_len;\n\tfrag_off = msg_hdr.frag_off;\n\tfrag_len = msg_hdr.frag_len;\n\n\tif (frag_len && frag_len < len)\n\t\treturn dtls1_reassemble_fragment(s, &msg_hdr, ok);\n\n\tif (!s->server && s->d1->r_msg_hdr.frag_off == 0 &&\n\t\twire[0] == SSL3_MT_HELLO_REQUEST)\n\t\t{\n\t\t/* The server may always send 'Hello Request' messages --\n\t\t * we are doing a handshake anyway now, so ignore them\n\t\t * if their format is correct. Does not count for\n\t\t * 'Finished' MAC. */\n\t\tif (wire[1] == 0 && wire[2] == 0 && wire[3] == 0)\n\t\t\t{\n\t\t\tif (s->msg_callback)\n\t\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, \n\t\t\t\t\twire, DTLS1_HM_HEADER_LENGTH, s, \n\t\t\t\t\ts->msg_callback_arg);\n\t\t\t\n\t\t\ts->init_num = 0;\n\t\t\treturn dtls1_get_message_fragment(s, st1, stn,\n\t\t\t\tmax, ok);\n\t\t\t}\n\t\telse /* Incorrectly formated Hello request */\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\n\tif ((al=dtls1_preprocess_fragment(s,&msg_hdr,max)))\n\t\tgoto f_err;\n\n\t/* XDTLS:  ressurect this when restart is in place */\n\ts->state=stn;\n\n\tif ( frag_len > 0)\n\t\t{\n\t\tunsigned char *p=(unsigned char *)s->init_buf->data+DTLS1_HM_HEADER_LENGTH;\n\n\t\ti=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\t\t&p[frag_off],frag_len,0);\n\t\t/* XDTLS:  fix this--message fragments cannot span multiple packets */\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\ts->rwstate=SSL_READING;\n\t\t\t*ok = 0;\n\t\t\treturn i;\n\t\t\t}\n\t\t}\n\telse\n\t\ti = 0;\n\n\t/* XDTLS:  an incorrectly formatted fragment should cause the \n\t * handshake to fail */\n\tif (i != (int)frag_len)\n\t\t{\n\t\tal=SSL3_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL3_AD_ILLEGAL_PARAMETER);\n\t\tgoto f_err;\n\t\t}\n\n\t*ok = 1;\n\n\t/* Note that s->init_num is *not* used as current offset in\n\t * s->init_buf->data, but as a counter summing up fragments'\n\t * lengths: as soon as they sum up to handshake packet\n\t * length, we assume we have got all the fragments. */\n\ts->init_num = frag_len;\n\treturn frag_len;\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\ts->init_num = 0;\n\n\t*ok=0;\n\treturn(-1);\n\t}", "target": 1, "cwe": ["CWE-399"], "project": "openssl", "commit_id": "d3152655d5319ce883c8e3ac4b99f8de4c59d846", "hash": 90631114156898598891323928453950043087, "size": 124, "message": "Fix CVE-2014-0221\n\nUnnecessary recursion when receiving a DTLS hello request can be used to\ncrash a DTLS client. Fixed by handling DTLS hello request without recursion.\n\nThanks to Imre Rad (Search-Lab Ltd.) for discovering this issue.", "idx": 523}
{"func": "void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,\n\t\t\t\t        unsigned int status,\n\t\t\t\t\tconst char *enh_code,\n\t\t\t\t\tconst char *const *text_lines)\n{\n\tstruct smtp_reply reply;\n\n\ti_zero(&reply);\n\treply.status = status;\n\treply.text_lines = text_lines;\n\n\tif (!smtp_reply_parse_enhanced_code(\n\t\tenh_code, &reply.enhanced_code, NULL))\n\t\treply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);\n\n\tT_BEGIN {\n\t\tstring_t *str;\n\n\t\te_debug(conn->event, \"Sent: %s\", smtp_reply_log(&reply));\n\n\t\tstr = t_str_new(256);\n\t\tsmtp_reply_write(str, &reply);\n\t\to_stream_nsend(conn->conn.output, str_data(str), str_len(str));\n\t} T_END;\n}", "target": 0, "cwe": ["CWE-77"], "project": "core", "commit_id": "321c339756f9b2b98fb7326359d1333adebb5295", "hash": 201034679748701630223916782317250726641, "size": 25, "message": "lib-smtp: smtp-server-connection - Fix STARTTLS command injection vulnerability.\n\nThe input handler kept reading more commands even though the input was locked by\nthe STARTTLS command, thereby causing it to read the command pipelined beyond\nSTARTTLS. This causes a STARTTLS command injection vulerability.", "idx": 524}
{"func": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\n\t/* Make sure the string is properly terminated. */\n\tstart [maxlen - 1] = 0 ;\n\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\n\treturn ;\n} /* psf_asciiheader_printf */", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "libsndfile", "commit_id": "708e996c87c5fae77b104ccfeb8f6db784c32074", "hash": 128597200954796564390056329081902924835, "size": 20, "message": "src/ : Move to a variable length header buffer\n\nPreviously, the `psf->header` buffer was a fixed length specified by\n`SF_HEADER_LEN` which was set to `12292`. This was problematic for\ntwo reasons; this value was un-necessarily large for the majority\nof files and too small for some others.\n\nNow the size of the header buffer starts at 256 bytes and grows as\nnecessary up to a maximum of 100k.", "idx": 525}
{"func": "static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,\n\t\t\t\tstruct discovery_client **client)\n{\n\tGSList *list = g_slist_find_custom(adapter->discovery_list, owner,\n\t\t\t\t\t\t\t\tcompare_sender);\n\tif (list) {\n\t\t*client = list->data;\n\t\treturn true;\n\t}\n\n\tlist = g_slist_find_custom(adapter->set_filter_list, owner,\n\t\t\t\t\t\t\t\tcompare_sender);\n\tif (list) {\n\t\t*client = list->data;\n\t\treturn false;\n\t}\n\n\t*client = NULL;\n\treturn false;\n}", "target": 0, "cwe": ["CWE-862", "CWE-863"], "project": "bluez", "commit_id": "b497b5942a8beb8f89ca1c359c54ad67ec843055", "hash": 135667517655917309927983080506601724832, "size": 20, "message": "adapter: Fix storing discoverable setting\n\ndiscoverable setting shall only be store when changed via Discoverable\nproperty and not when discovery client set it as that be considered\ntemporary just for the lifetime of the discovery.", "idx": 526}
{"func": "load_cache (GeglProperties *op_magick_load)\n{\n  if (!op_magick_load->user_data)\n    {\n      gchar    *filename;\n      gchar    *cmd;\n      GeglNode *graph, *sink, *loader;\n      GeglBuffer *newbuf = NULL;\n\n      /* ImageMagick backed fallback FIXME: make this robust.\n       * maybe use pipes in a manner similar to the raw loader,\n       * or at least use a properly unique filename  */\n\n      filename = g_build_filename (g_get_tmp_dir (), \"gegl-magick.png\", NULL);\n      cmd = g_strdup_printf (\"convert \\\"%s\\\"'[0]' \\\"%s\\\"\",\n                             op_magick_load->path, filename);\n      if (system (cmd) == -1)\n        g_warning (\"Error executing ImageMagick convert program\");\n\n\n      graph = gegl_node_new ();\n      sink = gegl_node_new_child (graph,\n                                 \"operation\", \"gegl:buffer-sink\",\n                                 \"buffer\", &newbuf, NULL);\n      loader = gegl_node_new_child (graph,\n                                    \"operation\", \"gegl:png-load\",\n                                    \"path\", filename, NULL);\n      gegl_node_link_many (loader, sink, NULL);\n      gegl_node_process (sink);\n      op_magick_load->user_data = (gpointer) newbuf;\n      g_object_unref (graph);\n      g_free (cmd);\n      g_free (filename);\n    }\n}", "target": 1, "cwe": [], "project": "gegl", "commit_id": "bfce470f0f2f37968862129d5038b35429f2909b", "hash": 128207149302076836420080513313021708603, "size": 35, "message": "magick-load: use more robust g_spawn_async() instead of system()\n\nThis fixes issue #298 by avoiding the shell parsing being invoked at\nall, this less brittle than any forms of escaping characters, while\nretaining the ability to address all existing files.", "idx": 527}
{"func": "static BOOL rdp_print_input_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 inputFlags;\n\tUINT16 pad2OctetsA;\n\tUINT32 keyboardLayout;\n\tUINT32 keyboardType;\n\tUINT32 keyboardSubType;\n\tUINT32 keyboardFunctionKey;\n\tWLog_INFO(TAG, \"InputCapabilitySet (length %\" PRIu16 \")\", length);\n\n\tif (length < 88)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, inputFlags);          /* inputFlags (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsA);         /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT32(s, keyboardLayout);      /* keyboardLayout (4 bytes) */\n\tStream_Read_UINT32(s, keyboardType);        /* keyboardType (4 bytes) */\n\tStream_Read_UINT32(s, keyboardSubType);     /* keyboardSubType (4 bytes) */\n\tStream_Read_UINT32(s, keyboardFunctionKey); /* keyboardFunctionKeys (4 bytes) */\n\tStream_Seek(s, 64);                         /* imeFileName (64 bytes) */\n\tWLog_INFO(TAG, \"\\tinputFlags: 0x%04\" PRIX16 \"\", inputFlags);\n\tWLog_INFO(TAG, \"\\tpad2OctetsA: 0x%04\" PRIX16 \"\", pad2OctetsA);\n\tWLog_INFO(TAG, \"\\tkeyboardLayout: 0x%08\" PRIX32 \"\", keyboardLayout);\n\tWLog_INFO(TAG, \"\\tkeyboardType: 0x%08\" PRIX32 \"\", keyboardType);\n\tWLog_INFO(TAG, \"\\tkeyboardSubType: 0x%08\" PRIX32 \"\", keyboardSubType);\n\tWLog_INFO(TAG, \"\\tkeyboardFunctionKey: 0x%08\" PRIX32 \"\", keyboardFunctionKey);\n\treturn TRUE;\n}", "target": 0, "cwe": ["CWE-119", "CWE-125"], "project": "FreeRDP", "commit_id": "3627aaf7d289315b614a584afb388f04abfb5bbf", "hash": 92834056900707877098460532450876414616, "size": 28, "message": "Fixed #6011: Bounds check in rdp_read_font_capability_set", "idx": 528}
{"func": "Value ExpressionMod::evaluate(const Document& root, Variables* variables) const {\n    Value lhs = _children[0]->evaluate(root, variables);\n    Value rhs = _children[1]->evaluate(root, variables);\n\n    BSONType leftType = lhs.getType();\n    BSONType rightType = rhs.getType();\n\n    if (lhs.numeric() && rhs.numeric()) {\n        auto assertNonZero = [](bool isZero) { uassert(16610, \"can't $mod by zero\", !isZero); };\n\n        // If either side is decimal, perform the operation in decimal.\n        if (leftType == NumberDecimal || rightType == NumberDecimal) {\n            Decimal128 left = lhs.coerceToDecimal();\n            Decimal128 right = rhs.coerceToDecimal();\n            assertNonZero(right.isZero());\n\n            return Value(left.modulo(right));\n        }\n\n        // ensure we aren't modding by 0\n        double right = rhs.coerceToDouble();\n        assertNonZero(right == 0);\n\n        if (leftType == NumberDouble || (rightType == NumberDouble && !rhs.integral())) {\n            // Need to do fmod. Integer-valued double case is handled below.\n\n            double left = lhs.coerceToDouble();\n            return Value(fmod(left, right));\n        }\n\n        if (leftType == NumberLong || rightType == NumberLong) {\n            // if either is long, return long\n            long long left = lhs.coerceToLong();\n            long long rightLong = rhs.coerceToLong();\n            return Value(overflow::safeMod(left, rightLong));\n        }\n\n        // lastly they must both be ints, return int\n        int left = lhs.coerceToInt();\n        int rightInt = rhs.coerceToInt();\n        return Value(overflow::safeMod(left, rightInt));\n    } else if (lhs.nullish() || rhs.nullish()) {\n        return Value(BSONNULL);\n    } else {\n        uasserted(16611,\n                  str::stream() << \"$mod only supports numeric types, not \"\n                                << typeName(lhs.getType()) << \" and \" << typeName(rhs.getType()));\n    }\n}", "target": 0, "cwe": [], "project": "mongo", "commit_id": "1772b9a0393b55e6a280a35e8f0a1f75c014f301", "hash": 253748621487697431947889292632136886984, "size": 49, "message": "SERVER-49404 Enforce additional checks in $arrayToObject", "idx": 529}
{"func": "struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\trefcount_inc(&fc->count);\n\treturn fc;\n}", "target": 0, "cwe": ["CWE-459"], "project": "linux", "commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "hash": 304044279088143834312830916865264261077, "size": 5, "message": "fuse: fix bad inode\n\nJan Kara's analysis of the syzbot report (edited):\n\n  The reproducer opens a directory on FUSE filesystem, it then attaches\n  dnotify mark to the open directory.  After that a fuse_do_getattr() call\n  finds that attributes returned by the server are inconsistent, and calls\n  make_bad_inode() which, among other things does:\n\n          inode->i_mode = S_IFREG;\n\n  This then confuses dnotify which doesn't tear down its structures\n  properly and eventually crashes.\n\nAvoid calling make_bad_inode() on a live inode: switch to a private flag on\nthe fuse inode.  Also add the test to ops which the bad_inode_ops would\nhave caught.\n\nThis bug goes back to the initial merge of fuse in 2.6.14...\n\nReported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>\nTested-by: Jan Kara <jack@suse.cz>\nCc: <stable@vger.kernel.org>", "idx": 530}
{"func": "static void stub_disconnect(struct usb_device *udev)\n{\n\tstruct stub_device *sdev;\n\tconst char *udev_busid = dev_name(&udev->dev);\n\tstruct bus_id_priv *busid_priv;\n\tint rc;\n\n\tdev_dbg(&udev->dev, \"Enter disconnect\\n\");\n\n\tbusid_priv = get_busid_priv(udev_busid);\n\tif (!busid_priv) {\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tsdev = dev_get_drvdata(&udev->dev);\n\n\t/* get stub_device */\n\tif (!sdev) {\n\t\tdev_err(&udev->dev, \"could not get device\");\n\t\treturn;\n\t}\n\n\tdev_set_drvdata(&udev->dev, NULL);\n\n\t/*\n\t * NOTE: rx/tx threads are invoked for each usb_device.\n\t */\n\tstub_remove_files(&udev->dev);\n\n\t/* release port */\n\trc = usb_hub_release_port(udev->parent, udev->portnum,\n\t\t\t\t  (struct usb_dev_state *) udev);\n\tif (rc) {\n\t\tdev_dbg(&udev->dev, \"unable to release port\\n\");\n\t\treturn;\n\t}\n\n\t/* If usb reset is called from event handler */\n\tif (usbip_in_eh(current))\n\t\treturn;\n\n\t/* shutdown the current connection */\n\tshutdown_busid(busid_priv);\n\n\tusb_put_dev(sdev->udev);\n\n\t/* free sdev */\n\tbusid_priv->sdev = NULL;\n\tstub_device_free(sdev);\n\n\tif (busid_priv->status == STUB_BUSID_ALLOC)\n\t\tbusid_priv->status = STUB_BUSID_ADDED;\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux", "commit_id": "22076557b07c12086eeb16b8ce2b0b735f7a27e7", "hash": 307022128137800435789612927799408541720, "size": 54, "message": "usbip: usbip_host: fix NULL-ptr deref and use-after-free errors\n\nusbip_host updates device status without holding lock from stub probe,\ndisconnect and rebind code paths. When multiple requests to import a\ndevice are received, these unprotected code paths step all over each\nother and drive fails with NULL-ptr deref and use-after-free errors.\n\nThe driver uses a table lock to protect the busid array for adding and\ndeleting busids to the table. However, the probe, disconnect and rebind\npaths get the busid table entry and update the status without holding\nthe busid table lock. Add a new finer grain lock to protect the busid\nentry. This new lock will be held to search and update the busid entry\nfields from get_busid_idx(), add_match_busid() and del_match_busid().\n\nmatch_busid_show() does the same to access the busid entry fields.\n\nget_busid_priv() changed to return the pointer to the busid entry holding\nthe busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()\ncall put_busid_priv() to release the busid lock before returning. This\nchanges fixes the unprotected code paths eliminating the race conditions\nin updating the busid entries.\n\nReported-by: Jakub Jirasek\nSigned-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>\nCc: stable <stable@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 531}
{"func": "static int check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\tint res = 0;\n\n\tif (p->ptrace) {\n\t\tif (p->ptrace & PT_PTRACE_CAP)\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;\n\t\telse\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\t}\n\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\tfor (t = next_thread(p); t != p; t = next_thread(t)) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs) {\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\t} else {\n\t\tres = -EAGAIN;\n\t\tif (!p->fs->in_exec) {\n\t\t\tp->fs->in_exec = 1;\n\t\t\tres = 1;\n\t\t}\n\t}\n\tspin_unlock(&p->fs->lock);\n\n\treturn res;\n}", "target": 1, "cwe": ["CWE-264"], "project": "linux", "commit_id": "259e5e6c75a910f3b5e656151dc602f53f9d7548", "hash": 227689233180007090841567326632998195911, "size": 35, "message": "Add PR_{GET,SET}_NO_NEW_PRIVS to prevent execve from granting privs\n\nWith this change, calling\n  prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)\ndisables privilege granting operations at execve-time.  For example, a\nprocess will not be able to execute a setuid binary to change their uid\nor gid if this bit is set.  The same is true for file capabilities.\n\nAdditionally, LSM_UNSAFE_NO_NEW_PRIVS is defined to ensure that\nLSMs respect the requested behavior.\n\nTo determine if the NO_NEW_PRIVS bit is set, a task may call\n  prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0);\nIt returns 1 if set and 0 if it is not set. If any of the arguments are\nnon-zero, it will return -1 and set errno to -EINVAL.\n(PR_SET_NO_NEW_PRIVS behaves similarly.)\n\nThis functionality is desired for the proposed seccomp filter patch\nseries.  By using PR_SET_NO_NEW_PRIVS, it allows a task to modify the\nsystem call behavior for itself and its child tasks without being\nable to impact the behavior of a more privileged task.\n\nAnother potential use is making certain privileged operations\nunprivileged.  For example, chroot may be considered \"safe\" if it cannot\naffect privileged tasks.\n\nNote, this patch causes execve to fail when PR_SET_NO_NEW_PRIVS is\nset and AppArmor is in use.  It is fixed in a subsequent patch.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Will Drewry <wad@chromium.org>\nAcked-by: Eric Paris <eparis@redhat.com>\nAcked-by: Kees Cook <keescook@chromium.org>\n\nv18: updated change desc\nv17: using new define values as per 3.4\nSigned-off-by: James Morris <james.l.morris@oracle.com>", "idx": 532}
{"func": "static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\t     struct prefix_info *pinfo, u32 portid, u32 seq,\n\t\t\t     int event, unsigned int flags)\n{\n\tstruct prefixmsg *pmsg;\n\tstruct nlmsghdr *nlh;\n\tstruct prefix_cacheinfo\tci;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tpmsg = nlmsg_data(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_pad1 = 0;\n\tpmsg->prefix_pad2 = 0;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\tpmsg->prefix_pad3 = 0;\n\tpmsg->prefix_flags = 0;\n\tif (pinfo->onlink)\n\t\tpmsg->prefix_flags |= IF_PREFIX_ONLINK;\n\tif (pinfo->autoconf)\n\t\tpmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\n\n\tif (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))\n\t\tgoto nla_put_failure;\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tif (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0, "cwe": ["CWE-20"], "project": "linux", "commit_id": "77751427a1ff25b27d47a4c36b12c3c8667855ac", "hash": 324452314957553596350656333551997379415, "size": 39, "message": "ipv6: addrconf: validate new MTU before applying it\n\nCurrently we don't check if the new MTU is valid or not and this allows\none to configure a smaller than minimum allowed by RFCs or even bigger\nthan interface own MTU, which is a problem as it may lead to packet\ndrops.\n\nIf you have a daemon like NetworkManager running, this may be exploited\nby remote attackers by forging RA packets with an invalid MTU, possibly\nleading to a DoS. (NetworkManager currently only validates for values\ntoo small, but not for too big ones.)\n\nThe fix is just to make sure the new value is valid. That is, between\nIPV6_MIN_MTU and interface's MTU.\n\nNote that similar check is already performed at\nndisc_router_discovery(), for when kernel itself parses the RA.\n\nSigned-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 533}
{"func": "static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_frontend *fe;\n\tfe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,\n\t\t\t&adap->dev->i2c_adap, &d680_dmb_tuner);\n\treturn (fe == NULL) ? -EIO : 0;\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "linux", "commit_id": "3f190e3aec212fc8c61e202c51400afa7384d4bc", "hash": 209182876931569696794176464276046824591, "size": 7, "message": "[media] cxusb: Use a dma capable buffer also for reading\n\nCommit 17ce039b4e54 (\"[media] cxusb: don't do DMA on stack\")\nadded a kmalloc'ed bounce buffer for writes, but missed to do the same\nfor reads. As the read only happens after the write is finished, we can\nreuse the same buffer.\n\nAs dvb_usb_generic_rw handles a read length of 0 by itself, avoid calling\nit using the dvb_usb_generic_read wrapper function.\n\nSigned-off-by: Stefan Brüns <stefan.bruens@rwth-aachen.de>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>", "idx": 534}
{"func": "i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,\n                             uint elt_size, client_name_t cname)\n{\n    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;\n    obj_header_t *obj;\n\n#ifdef MEMENTO\n    if (Memento_failThisEvent())\n        return NULL;\n#endif\n\n    obj = alloc_obj(imem, (ulong) num_elements * elt_size,\n                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,\n                    cname);\n\n    if_debug6m('A', mem, \"[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\\n\",\n               alloc_trace_space(imem), client_name_string(cname),\n               (ulong) num_elements * elt_size,\n               num_elements, elt_size, (ulong) obj);\n    return (byte *) obj;\n}", "target": 1, "cwe": ["CWE-190"], "project": "ghostpdl", "commit_id": "cfde94be1d4286bc47633c6e6eaf4e659bd78066", "hash": 136655422353746728520307109447937689778, "size": 21, "message": "Bug 697985: bounds check the array allocations methods\n\nThe clump allocator has four allocation functions that use 'number of elements'\nand 'size of elements' parameters (rather than a simple 'number of bytes').\n\nThose need specific bounds checking.", "idx": 535}
{"func": "populate_hash_table_from_refs_map (GHashTable         *ret_all_refs,\n                                   GHashTable         *ref_timestamps,\n                                   VarRefMapRef        ref_map,\n                                   const char         *opt_collection_id,\n                                   FlatpakRemoteState *state)\n{\n  gsize len, i;\n\n  len = var_ref_map_get_length (ref_map);\n  for (i = 0; i < len; i++)\n    {\n      VarRefMapEntryRef entry = var_ref_map_get_at (ref_map, i);\n      const char *ref_name = var_ref_map_entry_get_ref (entry);\n      const guint8 *csum_bytes;\n      gsize csum_len;\n      VarRefInfoRef info;\n      guint64 *new_timestamp = NULL;\n      g_autoptr(FlatpakDecomposed) decomposed = NULL;\n\n      if (!flatpak_remote_state_allow_ref (state, ref_name))\n        continue;\n\n      info = var_ref_map_entry_get_info (entry);\n\n      csum_bytes = var_ref_info_peek_checksum (info, &csum_len);\n      if (csum_len != OSTREE_SHA256_DIGEST_LEN)\n        continue;\n\n      decomposed = flatpak_decomposed_new_from_col_ref (ref_name, opt_collection_id, NULL);\n      if (decomposed == NULL)\n        continue;\n\n      if (ref_timestamps)\n        {\n          guint64 timestamp = get_timestamp_from_ref_info (info);\n          gpointer value;\n\n          if (g_hash_table_lookup_extended (ref_timestamps, ref_name, NULL, &value))\n            {\n              guint64 *old_timestamp = value;\n              if (*old_timestamp >= timestamp)\n                continue; /* New timestamp is older, skip this commit */\n            }\n\n          new_timestamp = g_memdup (&timestamp, sizeof (guint64));\n        }\n\n      g_hash_table_replace (ret_all_refs, g_steal_pointer (&decomposed), ostree_checksum_from_bytes (csum_bytes));\n      if (new_timestamp)\n        g_hash_table_replace (ref_timestamps, g_strdup (ref_name), new_timestamp);\n    }\n}", "target": 0, "cwe": ["CWE-74"], "project": "flatpak", "commit_id": "fb473cad801c6b61706353256cab32330557374a", "hash": 168114217684985188112558306880534199952, "size": 52, "message": "dir: Pass environment via bwrap --setenv when running apply_extra\n\nThis means we can systematically pass the environment variables\nthrough bwrap(1), even if it is setuid and thus is filtering out\nsecurity-sensitive environment variables. bwrap ends up being\nrun with an empty environment instead.\n\nAs with the previous commit, this regressed while fixing CVE-2021-21261.\n\nFixes: 6d1773d2 \"run: Convert all environment variables into bwrap arguments\"\nSigned-off-by: Simon McVittie <smcv@collabora.com>", "idx": 536}
{"func": "TEST_F(ServerSelectorTestFixture, ShouldSelectRandomlyWhenMultipleOptionsAreAvailable) {\n    TopologyStateMachine stateMachine(sdamConfiguration);\n    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);\n\n    const auto s0Latency = Milliseconds(1);\n    auto primary = ServerDescriptionBuilder()\n                       .withAddress(HostAndPort(\"s0\"))\n                       .withType(ServerType::kRSPrimary)\n                       .withLastUpdateTime(Date_t::now())\n                       .withLastWriteDate(Date_t::now())\n                       .withRtt(s0Latency)\n                       .withSetName(\"set\")\n                       .withHost(HostAndPort(\"s0\"))\n                       .withHost(HostAndPort(\"s1\"))\n                       .withHost(HostAndPort(\"s2\"))\n                       .withHost(HostAndPort(\"s3\"))\n                       .withMinWireVersion(WireVersion::SUPPORTS_OP_MSG)\n                       .withMaxWireVersion(WireVersion::LATEST_WIRE_VERSION)\n                       .instance();\n    stateMachine.onServerDescription(*topologyDescription, primary);\n\n    const auto s1Latency = Milliseconds((s0Latency + sdamConfiguration.getLocalThreshold()) / 2);\n    auto secondaryInLatencyWindow =\n        make_with_latency(s1Latency, HostAndPort(\"s1\"), ServerType::kRSSecondary);\n    stateMachine.onServerDescription(*topologyDescription, secondaryInLatencyWindow);\n\n    // s2 is on the boundary of the latency window\n    const auto s2Latency = s0Latency + sdamConfiguration.getLocalThreshold();\n    auto secondaryOnBoundaryOfLatencyWindow =\n        make_with_latency(s2Latency, HostAndPort(\"s2\"), ServerType::kRSSecondary);\n    stateMachine.onServerDescription(*topologyDescription, secondaryOnBoundaryOfLatencyWindow);\n\n    // s3 should not be selected\n    const auto s3Latency = s2Latency + Milliseconds(10);\n    auto secondaryTooFar =\n        make_with_latency(s3Latency, HostAndPort(\"s3\"), ServerType::kRSSecondary);\n    stateMachine.onServerDescription(*topologyDescription, secondaryTooFar);\n\n    std::map<HostAndPort, int> frequencyInfo{{HostAndPort(\"s0\"), 0},\n                                             {HostAndPort(\"s1\"), 0},\n                                             {HostAndPort(\"s2\"), 0},\n                                             {HostAndPort(\"s3\"), 0}};\n    for (int i = 0; i < NUM_ITERATIONS; i++) {\n        auto server = selector.selectServer(topologyDescription,\n                                            ReadPreferenceSetting(ReadPreference::Nearest));\n        if (server) {\n            frequencyInfo[(*server)->getAddress()]++;\n        }\n    }\n\n    ASSERT(frequencyInfo[HostAndPort(\"s0\")]);\n    ASSERT(frequencyInfo[HostAndPort(\"s1\")]);\n    ASSERT(frequencyInfo[HostAndPort(\"s2\")]);\n    ASSERT_FALSE(frequencyInfo[HostAndPort(\"s3\")]);\n}", "target": 1, "cwe": ["CWE-755"], "project": "mongo", "commit_id": "75f7184eafa78006a698cda4c4adfb57f1290047", "hash": 297473696697055349163565540966833798955, "size": 55, "message": "SERVER-50170 fix max staleness read preference parameter for server selection", "idx": 537}
{"func": "static void tg3_ptp_init(struct tg3 *tp)\n{\n\tif (!tg3_flag(tp, PTP_CAPABLE))\n\t\treturn;\n\n\t/* Initialize the hardware clock to the system time. */\n\ttg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));\n\ttp->ptp_adjust = 0;\n\ttp->ptp_info = tg3_ptp_caps;\n}", "target": 0, "cwe": ["CWE-476", "CWE-119"], "project": "linux", "commit_id": "715230a44310a8cf66fbfb5a46f9a62a9b2de424", "hash": 12367731295593046973066646537084862746, "size": 10, "message": "tg3: fix length overflow in VPD firmware parsing\n\nCommit 184b89044fb6e2a74611dafa69b1dce0d98612c6 (\"tg3: Use VPD fw version\nwhen present\") introduced VPD parsing that contained a potential length\noverflow.\n\nLimit the hardware's reported firmware string length (max 255 bytes) to\nstay inside the driver's firmware string length (32 bytes). On overflow,\ntruncate the formatted firmware string instead of potentially overwriting\nportions of the tg3 struct.\n\nhttp://cansecwest.com/slides/2013/PrivateCore%20CSW%202013.pdf\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nReported-by: Oded Horovitz <oded@privatecore.com>\nReported-by: Brad Spengler <spender@grsecurity.net>\nCc: stable@vger.kernel.org\nCc: Matt Carlson <mcarlson@broadcom.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 538}
{"func": "static void hidp_process_report(struct hidp_session *session,\n\t\t\t\tint type, const u8 *data, int len, int intr)\n{\n\tif (len > HID_MAX_BUFFER_SIZE)\n\t\tlen = HID_MAX_BUFFER_SIZE;\n\n\tmemcpy(session->input_buf, data, len);\n\thid_input_report(session->hid, type, session->input_buf, len, intr);\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "7992c18810e568b95c869b227137a2215702a805", "hash": 137044641428517035105968077195861839204, "size": 9, "message": "Bluetooth: hidp: buffer overflow in hidp_process_report\n\nCVE-2018-9363\n\nThe buffer length is unsigned at all layers, but gets cast to int and\nchecked in hidp_process_report and can lead to a buffer overflow.\nSwitch len parameter to unsigned int to resolve issue.\n\nThis affects 3.18 and newer kernels.\n\nSigned-off-by: Mark Salyzyn <salyzyn@android.com>\nFixes: a4b1b5877b514b276f0f31efe02388a9c2836728 (\"HID: Bluetooth: hidp: make sure input buffers are big enough\")\nCc: Marcel Holtmann <marcel@holtmann.org>\nCc: Johan Hedberg <johan.hedberg@gmail.com>\nCc: \"David S. Miller\" <davem@davemloft.net>\nCc: Kees Cook <keescook@chromium.org>\nCc: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nCc: linux-bluetooth@vger.kernel.org\nCc: netdev@vger.kernel.org\nCc: linux-kernel@vger.kernel.org\nCc: security@kernel.org\nCc: kernel-team@android.com\nAcked-by: Kees Cook <keescook@chromium.org>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>", "idx": 539}
{"func": "request_rec *h2_request_create_rec(const h2_request *req, conn_rec *c)\n{\n    int access_status;\n\n#if AP_MODULE_MAGIC_AT_LEAST(20150222, 13)\n    request_rec *r = ap_create_request(c);\n#else\n    request_rec *r = my_ap_create_request(c);\n#endif\n\n#if AP_MODULE_MAGIC_AT_LEAST(20200331, 3)\n    ap_run_pre_read_request(r, c);\n\n    /* Time to populate r with the data we have. */\n    r->request_time = req->request_time;\n    r->the_request = apr_psprintf(r->pool, \"%s %s HTTP/2.0\",\n                                  req->method, req->path ? req->path : \"\");\n    r->headers_in = apr_table_clone(r->pool, req->headers);\n\n    /* Start with r->hostname = NULL, ap_check_request_header() will get it\n     * form Host: header, otherwise we get complains about port numbers.\n     */\n    r->hostname = NULL;\n\n    /* Validate HTTP/1 request and select vhost. */\n    if (!ap_parse_request_line(r) || !ap_check_request_header(r)) {\n        /* we may have switched to another server still */\n        r->per_dir_config = r->server->lookup_defaults;\n        if (req->http_status != H2_HTTP_STATUS_UNSET) {\n            access_status = req->http_status;\n            /* Be safe and close the connection */\n            c->keepalive = AP_CONN_CLOSE;\n        }\n        else {\n            access_status = r->status;\n        }\n        r->status = HTTP_OK;\n        goto die;\n    }\n#else\n    {\n        const char *s;\n\n        r->headers_in = apr_table_clone(r->pool, req->headers);\n        ap_run_pre_read_request(r, c);\n\n        /* Time to populate r with the data we have. */\n        r->request_time = req->request_time;\n        r->method = apr_pstrdup(r->pool, req->method);\n        /* Provide quick information about the request method as soon as known */\n        r->method_number = ap_method_number_of(r->method);\n        if (r->method_number == M_GET && r->method[0] == 'H') {\n            r->header_only = 1;\n        }\n        ap_parse_uri(r, req->path ? req->path : \"\");\n        r->protocol = (char*)\"HTTP/2.0\";\n        r->proto_num = HTTP_VERSION(2, 0);\n        r->the_request = apr_psprintf(r->pool, \"%s %s HTTP/2.0\",\n                                      r->method, req->path ? req->path : \"\");\n\n        /* Start with r->hostname = NULL, ap_check_request_header() will get it\n         * form Host: header, otherwise we get complains about port numbers.\n         */\n        r->hostname = NULL;\n        ap_update_vhost_from_headers(r);\n\n         /* we may have switched to another server */\n         r->per_dir_config = r->server->lookup_defaults;\n\n         s = apr_table_get(r->headers_in, \"Expect\");\n         if (s && s[0]) {\n            if (ap_cstr_casecmp(s, \"100-continue\") == 0) {\n                r->expecting_100 = 1;\n            }\n            else {\n                r->status = HTTP_EXPECTATION_FAILED;\n                access_status = r->status;\n                goto die;\n            }\n         }\n    }\n#endif\n\n    /* we may have switched to another server */\n    r->per_dir_config = r->server->lookup_defaults;\n\n    if (req->http_status != H2_HTTP_STATUS_UNSET) {\n        access_status = req->http_status;\n        r->status = HTTP_OK;\n        /* Be safe and close the connection */\n        c->keepalive = AP_CONN_CLOSE;\n        goto die;\n    }\n\n    /*\n     * Add the HTTP_IN filter here to ensure that ap_discard_request_body\n     * called by ap_die and by ap_send_error_response works correctly on\n     * status codes that do not cause the connection to be dropped and\n     * in situations where the connection should be kept alive.\n     */\n    ap_add_input_filter_handle(ap_http_input_filter_handle,\n                               NULL, r, r->connection);\n    \n    if ((access_status = ap_run_post_read_request(r))) {\n        /* Request check post hooks failed. An example of this would be a\n         * request for a vhost where h2 is disabled --> 421.\n         */\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(03367)\n                      \"h2_request: access_status=%d, request_create failed\",\n                      access_status);\n        goto die;\n    }\n\n    AP_READ_REQUEST_SUCCESS((uintptr_t)r, (char *)r->method, \n                            (char *)r->uri, (char *)r->server->defn_name, \n                            r->status);\n    return r;\n\ndie:\n    ap_die(access_status, r);\n\n    /* ap_die() sent the response through the output filters, we must now\n     * end the request with an EOR bucket for stream/pipeline accounting.\n     */\n    {\n        apr_bucket_brigade *eor_bb;\n#if AP_MODULE_MAGIC_AT_LEAST(20180905, 1)\n        eor_bb = ap_acquire_brigade(c);\n        APR_BRIGADE_INSERT_TAIL(eor_bb,\n                                ap_bucket_eor_create(c->bucket_alloc, r));\n        ap_pass_brigade(c->output_filters, eor_bb);\n        ap_release_brigade(c, eor_bb);\n#else\n        eor_bb = apr_brigade_create(c->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(eor_bb,\n                                ap_bucket_eor_create(c->bucket_alloc, r));\n        ap_pass_brigade(c->output_filters, eor_bb);\n        apr_brigade_destroy(eor_bb);\n#endif\n    }\n\n    r = NULL;\n    AP_READ_REQUEST_FAILURE((uintptr_t)r);\n    return NULL;\n}", "target": 1, "cwe": [], "project": "httpd", "commit_id": "ecebcc035ccd8d0e2984fe41420d9e944f456b3c", "hash": 91833231971634560043166623682246692909, "size": 145, "message": "Merged r1734009,r1734231,r1734281,r1838055,r1838079,r1840229,r1876664,r1876674,r1876784,r1879078,r1881620,r1887311,r1888871 from trunk:\n\n  *) core: Split ap_create_request() from ap_read_request(). [Graham Leggett]\n\n  *) core, h2: common ap_parse_request_line() and ap_check_request_header()\n     code. [Yann Ylavic]\n\n  *) core: Add StrictHostCheck to allow unconfigured hostnames to be\n     rejected. [Eric Covener]\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1890245 13f79535-47bb-0310-9956-ffa450edef68", "idx": 540}
{"func": "static void *bundling_thread(void *arg)\n{\n    struct bundling_params_t *params = (struct bundling_params_t *)arg;\n    ncInstance *instance = params->instance;\n    char cmd[MAX_PATH];\n    char buf[MAX_PATH];\n\n    LOGDEBUG(\"[%s] spawning bundling thread\\n\", instance->instanceId);\n    LOGINFO(\"[%s] waiting for instance to shut down\\n\", instance->instanceId);\n    // wait until monitor thread changes the state of the instance instance\n    if (wait_state_transition(instance, BUNDLING_SHUTDOWN, BUNDLING_SHUTOFF)) {\n        if (instance->bundleCanceled) { // cancel request came in while the instance was shutting down\n            LOGINFO(\"[%s] cancelled while bundling instance\\n\", instance->instanceId);\n            cleanup_bundling_task(instance, params, BUNDLING_CANCELLED);\n        } else {\n            LOGINFO(\"[%s] failed while bundling instance\\n\", instance->instanceId);\n            cleanup_bundling_task(instance, params, BUNDLING_FAILED);\n        }\n        return NULL;\n    }\n\n    LOGINFO(\"[%s] started bundling instance\\n\", instance->instanceId);\n\n    int rc = EUCA_OK;\n    char bundlePath[MAX_PATH];\n    bundlePath[0] = '\\0';\n    if (clone_bundling_backing(instance, params->filePrefix, bundlePath) != EUCA_OK) {\n        LOGERROR(\"[%s] could not clone the instance image\\n\", instance->instanceId);\n        cleanup_bundling_task(instance, params, BUNDLING_FAILED);\n    } else {\n        char prefixPath[MAX_PATH];\n        snprintf(prefixPath, MAX_PATH, \"%s/%s\", instance->instancePath, params->filePrefix);\n        if (strcmp(bundlePath, prefixPath) != 0 && rename(bundlePath, prefixPath) != 0) {\n            LOGERROR(\"[%s] could not rename from %s to %s\\n\", instance->instanceId, bundlePath, prefixPath);\n            cleanup_bundling_task(instance, params, BUNDLING_FAILED);\n            return NULL;\n        }\n        // USAGE: euca-nc-bundle-upload -i <image_path> -d <working dir> -b <bucket>\n        int pid, status;\n\n        // set up environment for euca2ools\n        snprintf(buf, MAX_PATH, EUCALYPTUS_KEYS_DIR \"/node-cert.pem\", params->eucalyptusHomePath);\n        setenv(\"EC2_CERT\", buf, 1);\n\n        snprintf(buf, MAX_PATH, \"IGNORED\");\n        setenv(\"EC2_SECRET_KEY\", buf, 1);\n\n        snprintf(buf, MAX_PATH, EUCALYPTUS_KEYS_DIR \"/cloud-cert.pem\", params->eucalyptusHomePath);\n        setenv(\"EUCALYPTUS_CERT\", buf, 1);\n\n        snprintf(buf, MAX_PATH, \"%s\", params->walrusURL);\n        setenv(\"S3_URL\", buf, 1);\n\n        snprintf(buf, MAX_PATH, \"%s\", params->userPublicKey);\n        setenv(\"EC2_ACCESS_KEY\", buf, 1);\n\n        snprintf(buf, MAX_PATH, \"123456789012\");\n        setenv(\"EC2_USER_ID\", buf, 1);\n\n        snprintf(buf, MAX_PATH, EUCALYPTUS_KEYS_DIR \"/node-cert.pem\", params->eucalyptusHomePath);\n        setenv(\"EUCA_CERT\", buf, 1);\n\n        snprintf(buf, MAX_PATH, EUCALYPTUS_KEYS_DIR \"/node-pk.pem\", params->eucalyptusHomePath);\n        setenv(\"EUCA_PRIVATE_KEY\", buf, 1);\n\n        // check to see if the bucket exists in advance\n        snprintf(cmd, MAX_PATH, \"%s -b %s --euca-auth\", params->ncCheckBucketCmd, params->bucketName);\n        LOGDEBUG(\"[%s] running cmd '%s'\\n\", instance->instanceId, cmd);\n        rc = system(cmd);\n        rc = rc >> 8;\n        instance->bundleBucketExists = rc;\n\n        if (instance->bundleCanceled) {\n            LOGINFO(\"[%s] bundle task canceled; terminating bundling thread\\n\", instance->instanceId);\n            cleanup_bundling_task(instance, params, BUNDLING_CANCELLED);\n            return NULL;\n        }\n\n        pid = fork();\n        if (!pid) {\n            LOGDEBUG(\"[%s] running cmd '%s -i %s -d %s -b %s -c %s --policysignature %s --euca-auth'\\n\", instance->instanceId,\n                     params->ncBundleUploadCmd, prefixPath, params->workPath, params->bucketName, params->S3Policy, params->S3PolicySig);\n            exit(execlp\n                 (params->ncBundleUploadCmd, params->ncBundleUploadCmd, \"-i\", prefixPath, \"-d\", params->workPath, \"-b\", params->bucketName, \"-c\",\n                  params->S3Policy, \"--policysignature\", params->S3PolicySig, \"--euca-auth\", NULL));\n        } else {\n            instance->bundlePid = pid;\n            rc = waitpid(pid, &status, 0);\n            if (WIFEXITED(status)) {\n                rc = WEXITSTATUS(status);\n            } else {\n                rc = -1;\n            }\n        }\n\n        if (rc == 0) {\n            cleanup_bundling_task(instance, params, BUNDLING_SUCCESS);\n            LOGINFO(\"[%s] finished bundling instance\\n\", instance->instanceId);\n        } else if (rc == -1) {\n            // bundler child was cancelled (killed), but should report it as failed\n            cleanup_bundling_task(instance, params, BUNDLING_FAILED);\n            LOGINFO(\"[%s] cancelled while bundling instance (rc=%d)\\n\", instance->instanceId, rc);\n        } else {\n            cleanup_bundling_task(instance, params, BUNDLING_FAILED);\n            LOGINFO(\"[%s] failed while bundling instance (rc=%d)\\n\", instance->instanceId, rc);\n        }\n    }\n    return NULL;\n}", "target": 1, "cwe": [], "project": "eucalyptus", "commit_id": "c252889a46f41b4c396b89e005ec89836f2524be", "hash": 175364125000247119588401997535570113154, "size": 109, "message": "Input validation, shellout hardening on back-end\n\n- validating bucketName and bucketPath in BundleInstance\n- validating device name in Attach and DetachVolume\n- removed some uses of system() and popen()\n\nFixes EUCA-7572, EUCA-7520", "idx": 541}
{"func": "static void _dom_document_schema_validate(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tzval *id;\n\txmlDoc *docp;\n\tdom_object *intern;\n\tchar *source = NULL, *valid_file = NULL;\n\tint source_len = 0;\n\txmlSchemaParserCtxtPtr  parser;\n\txmlSchemaPtr            sptr;\n\txmlSchemaValidCtxtPtr   vptr;\n\tint                     is_valid;\n\tchar resolved_path[MAXPATHLEN + 1];\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Op\", &id, dom_document_class_entry, &source, &source_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (source_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid Schema source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tDOM_GET_OBJ(docp, id, xmlDocPtr, intern);\n\n\tswitch (type) {\n\tcase DOM_LOAD_FILE:\n\t\tvalid_file = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);\n\t\tif (!valid_file) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid Schema file source\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tparser = xmlSchemaNewParserCtxt(valid_file);\n\t\tbreak;\n\tcase DOM_LOAD_STRING:\n\t\tparser = xmlSchemaNewMemParserCtxt(source, source_len);\n\t\t/* If loading from memory, we need to set the base directory for the document\n\t\t   but it is not apparent how to do that for schema's */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\txmlSchemaSetParserErrors(parser,\n\t\t(xmlSchemaValidityErrorFunc) php_libxml_error_handler,\n\t\t(xmlSchemaValidityWarningFunc) php_libxml_error_handler,\n\t\tparser);\n\tsptr = xmlSchemaParse(parser);\n\txmlSchemaFreeParserCtxt(parser);\n\tif (!sptr) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid Schema\");\n\t\tRETURN_FALSE;\n\t}\n\n\tdocp = (xmlDocPtr) dom_object_get_node(intern);\n\n\tvptr = xmlSchemaNewValidCtxt(sptr);\n\tif (!vptr) {\n\t\txmlSchemaFree(sptr);\n\t\tphp_error(E_ERROR, \"Invalid Schema Validation Context\");\n\t\tRETURN_FALSE;\n\t}\n\n\txmlSchemaSetValidErrors(vptr, php_libxml_error_handler, php_libxml_error_handler, vptr);\n\tis_valid = xmlSchemaValidateDoc(vptr, docp);\n\txmlSchemaFree(sptr);\n\txmlSchemaFreeValidCtxt(vptr);\n\n\tif (is_valid == 0) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1, "cwe": ["CWE-20"], "project": "php-src", "commit_id": "f7d7befae8bcc2db0093f8adaa9f72eeb7ad891e", "hash": 265588436946748617655544027804460095967, "size": 73, "message": "Fix #69719 - more checks for nulls in paths", "idx": 542}
{"func": "static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,\n                              size_t keylen, const unsigned char *iv,\n                              size_t ivlen, const OSSL_PARAM params[])\n{\n    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))\n        return 0;\n    return rc4_hmac_md5_set_ctx_params(ctx, params);\n}", "target": 0, "cwe": ["CWE-327"], "project": "openssl", "commit_id": "7d56a74a96828985db7354a55227a511615f732b", "hash": 31378539553680314717770349773254374616, "size": 8, "message": "Fix the RC4-MD5 cipher\n\nA copy&paste error meant that the RC4-MD5 cipher (used in TLS) used the TLS\nAAD data as the MAC key.\n\nCVE-2022-1434\n\nFixes #18112\n\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\nReviewed-by: Matt Caswell <matt@openssl.org>", "idx": 543}
{"func": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119"], "project": "target-pending", "commit_id": "cea4dcfdad926a27a18e188720efe0f2c9403456", "hash": 245345227922364390697209198060550598991, "size": 29, "message": "iscsi-target: fix heap buffer overflow on error\n\nIf a key was larger than 64 bytes, as checked by iscsi_check_key(), the\nerror response packet, generated by iscsi_add_notunderstood_response(),\nwould still attempt to copy the entire key into the packet, overflowing\nthe structure on the heap.\n\nRemote preauthentication kernel memory corruption was possible if a\ntarget was configured and listening on the network.\n\nCVE-2013-2850\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>", "idx": 544}
{"func": "ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)\n{\n\tint ret;\n\tu16 tmp16;\n\n\tax88179_phy_mmd_indirect(dev, prtad, devad);\n\n\tret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t       MII_MMD_DATA, 2, &tmp16);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn tmp16;\n}", "target": 0, "cwe": ["CWE-787"], "project": "linux", "commit_id": "57bc3d3ae8c14df3ceb4e17d26ddf9eeab304581", "hash": 217382501444794545519182401759692659970, "size": 14, "message": "net: usb: ax88179_178a: Fix out-of-bounds accesses in RX fixup\n\nax88179_rx_fixup() contains several out-of-bounds accesses that can be\ntriggered by a malicious (or defective) USB device, in particular:\n\n - The metadata array (hdr_off..hdr_off+2*pkt_cnt) can be out of bounds,\n   causing OOB reads and (on big-endian systems) OOB endianness flips.\n - A packet can overlap the metadata array, causing a later OOB\n   endianness flip to corrupt data used by a cloned SKB that has already\n   been handed off into the network stack.\n - A packet SKB can be constructed whose tail is far beyond its end,\n   causing out-of-bounds heap data to be considered part of the SKB's\n   data.\n\nI have tested that this can be used by a malicious USB device to send a\nbogus ICMPv6 Echo Request and receive an ICMPv6 Echo Reply in response\nthat contains random kernel heap data.\nIt's probably also possible to get OOB writes from this on a\nlittle-endian system somehow - maybe by triggering skb_cow() via IP\noptions processing -, but I haven't tested that.\n\nFixes: e2ca90c276e1 (\"ax88179_178a: ASIX AX88179_178A USB 3.0/2.0 to gigabit ethernet adapter driver\")\nCc: stable@kernel.org\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 545}
{"func": "val_exp_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t *context_handle,\n    gss_buffer_t interprocess_token)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (interprocess_token != GSS_C_NO_BUFFER) {\n\tinterprocess_token->length = 0;\n\tinterprocess_token->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL || *context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (interprocess_token == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}", "target": 0, "cwe": ["CWE-415"], "project": "krb5", "commit_id": "56f7b1bc95a2a3eeb420e069e7655fb181ade5cf", "hash": 44548067691622707919426354805153214778, "size": 29, "message": "Preserve GSS context on init/accept failure\n\nAfter gss_init_sec_context() or gss_accept_sec_context() has created a\ncontext, don't delete the mechglue context on failures from subsequent\ncalls, even if the mechanism deletes the mech-specific context (which\nis allowed by RFC 2744 but not preferred).  Check for union contexts\nwith no mechanism context in each GSS function which accepts a\ngss_ctx_id_t.\n\nCVE-2017-11462:\n\nRFC 2744 permits a GSS-API implementation to delete an existing\nsecurity context on a second or subsequent call to\ngss_init_sec_context() or gss_accept_sec_context() if the call results\nin an error.  This API behavior has been found to be dangerous,\nleading to the possibility of memory errors in some callers.  For\nsafety, GSS-API implementations should instead preserve existing\nsecurity contexts on error until the caller deletes them.\n\nAll versions of MIT krb5 prior to this change may delete acceptor\ncontexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through\n1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on\nerror.\n\nticket: 8598 (new)\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup", "idx": 546}
{"func": "DEFUN (no_neighbor_nexthop_local_unchanged,\n       no_neighbor_nexthop_local_unchanged_cmd,\n       NO_NEIGHBOR_CMD2 \"nexthop-local unchanged\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure treatment of outgoing link-local-nexthop attribute\\n\"\n       \"Leave link-local nexthop unchanged for this peer\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n                                PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED );\n}", "target": 0, "cwe": ["CWE-125"], "project": "frr", "commit_id": "6d58272b4cf96f0daa846210dd2104877900f921", "hash": 181849262573175612548963586122664769906, "size": 13, "message": "[bgpd] cleanup, compact and consolidate capability parsing code\n\n2007-07-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Clean up and compact capability parsing slightly.\n\t  Consolidate validation of length and logging of generic TLV, and\n\t  memcpy of capability data, thus removing such from cap specifc\n\t  code (not always present or correct).\n\t* bgp_open.h: Add structures for the generic capability TLV header\n\t  and for the data formats of the various specific capabilities we\n\t  support.  Hence remove the badly named, or else misdefined, struct\n\t  capability.\n\t* bgp_open.c: (bgp_capability_vty_out) Use struct capability_mp_data.\n\t  Do the length checks *before* memcpy()'ing based on that length\n\t  (stored capability - should have been validated anyway on input,\n\t  but..).\n\t  (bgp_afi_safi_valid_indices) new function to validate (afi,safi)\n\t  which is about to be used as index into arrays, consolidates\n\t  several instances of same, at least one of which appeared to be\n\t  incomplete..\n\t  (bgp_capability_mp) Much condensed.\n\t  (bgp_capability_orf_entry) New, process one ORF entry\n\t  (bgp_capability_orf) Condensed. Fixed to process all ORF entries.\n\t  (bgp_capability_restart) Condensed, and fixed to use a\n\t  cap-specific type, rather than abusing capability_mp.\n\t  (struct message capcode_str) added to aid generic logging.\n\t  (size_t cap_minsizes[]) added to aid generic validation of\n\t  capability length field.\n\t  (bgp_capability_parse) Generic logging and validation of TLV\n\t  consolidated here. Code compacted as much as possible.\n\t* bgp_packet.c: (bgp_open_receive) Capability parsers now use\n\t  streams, so no more need here to manually fudge the input stream\n\t  getp.\n\t  (bgp_capability_msg_parse) use struct capability_mp_data. Validate\n\t  lengths /before/ memcpy. Use bgp_afi_safi_valid_indices.\n\t  (bgp_capability_receive) Exported for use by test harness.\n\t* bgp_vty.c: (bgp_show_summary) fix conversion warning\n\t  (bgp_show_peer) ditto\n\t* bgp_debug.h: Fix storage 'extern' after type 'const'.\n        * lib/log.c: (mes_lookup) warning about code not being in\n          same-number array slot should be debug, not warning. E.g. BGP\n          has several discontigious number spaces, allocating from\n          different parts of a space is not uncommon (e.g. IANA\n          assigned versus vendor-assigned code points in some number\n          space).", "idx": 547}
{"func": "static FILE* prepare_ftp_session(FILE **dfpp, struct host_info *target, len_and_sockaddr *lsa)\n{\n\tFILE *sfp;\n\tchar *pass;\n\tint port;\n\n\tsfp = open_socket(lsa);\n#if ENABLE_FEATURE_WGET_HTTPS\n\tif (target->protocol == P_FTPS)\n\t\tspawn_ssl_client(target->host, fileno(sfp), TLSLOOP_EXIT_ON_LOCAL_EOF);\n#endif\n\n\tif (ftpcmd(NULL, NULL, sfp) != 220)\n\t\tbb_error_msg_and_die(\"%s\", G.wget_buf);\n\t\t/* note: ftpcmd() sanitizes G.wget_buf, ok to print */\n\n\t/* Split username:password pair */\n\tpass = (char*)\"busybox\"; /* password for \"anonymous\" */\n\tif (target->user) {\n\t\tpass = strchr(target->user, ':');\n\t\tif (pass)\n\t\t\t*pass++ = '\\0';\n\t}\n\n\t/* Log in */\n\tswitch (ftpcmd(\"USER \", target->user ?: \"anonymous\", sfp)) {\n\tcase 230:\n\t\tbreak;\n\tcase 331:\n\t\tif (ftpcmd(\"PASS \", pass, sfp) == 230)\n\t\t\tbreak;\n\t\t/* fall through (failed login) */\n\tdefault:\n\t\tbb_error_msg_and_die(\"ftp login: %s\", G.wget_buf);\n\t}\n\n\tftpcmd(\"TYPE I\", NULL, sfp);\n\n\t/* Query file size */\n\tif (ftpcmd(\"SIZE \", target->path, sfp) == 213) {\n\t\tG.content_len = BB_STRTOOFF(G.wget_buf + 4, NULL, 10);\n\t\tif (G.content_len < 0 || errno) {\n\t\t\tbb_error_msg_and_die(\"SIZE value is garbage\");\n\t\t}\n\t\tG.got_clen = 1;\n\t}\n\n\t/* Enter passive mode */\n\tif (ENABLE_FEATURE_IPV6 && ftpcmd(\"EPSV\", NULL, sfp) == 229) {\n\t\t/* good */\n\t} else\n\tif (ftpcmd(\"PASV\", NULL, sfp) != 227) {\n pasv_error:\n\t\tbb_error_msg_and_die(\"bad response to %s: %s\", \"PASV\", G.wget_buf);\n\t}\n\tport = parse_pasv_epsv(G.wget_buf);\n\tif (port < 0)\n\t\tgoto pasv_error;\n\n\tset_nport(&lsa->u.sa, htons(port));\n\n\t*dfpp = open_socket(lsa);\n\n#if ENABLE_FEATURE_WGET_HTTPS\n\tif (target->protocol == P_FTPS) {\n\t\t/* \"PROT P\" enables encryption of data stream.\n\t\t * Without it (or with \"PROT C\"), data is sent unencrypted.\n\t\t */\n\t\tif (ftpcmd(\"PROT P\", NULL, sfp) == 200)\n\t\t\tspawn_ssl_client(target->host, fileno(*dfpp), /*flags*/ 0);\n\t}\n#endif\n\n\tif (G.beg_range != 0) {\n\t\tsprintf(G.wget_buf, \"REST %\"OFF_FMT\"u\", G.beg_range);\n\t\tif (ftpcmd(G.wget_buf, NULL, sfp) == 350)\n\t\t\tG.content_len -= G.beg_range;\n\t\telse\n\t\t\treset_beg_range_to_zero();\n\t}\n\n//TODO: needs ftp-escaping 0xff and '\\n' bytes here.\n//Or disallow '\\n' altogether via sanitize_string() in parse_url().\n//But 0xff's are possible in valid utf8 filenames.\n\tif (ftpcmd(\"RETR \", target->path, sfp) > 150)\n\t\tbb_error_msg_and_die(\"bad response to %s: %s\", \"RETR\", G.wget_buf);\n\n\treturn sfp;\n}", "target": 1, "cwe": ["CWE-120"], "project": "busybox", "commit_id": "8e2174e9bd836e53c8b9c6e00d1bc6e2a718686e", "hash": 17419610891272180017319868437225070231, "size": 89, "message": "wget: check chunk length for overflowing off_t\n\nfunction                                             old     new   delta\nretrieve_file_data                                   428     465     +37\nwget_main                                           2386    2389      +3\n------------------------------------------------------------------------------\n(add/remove: 0/0 grow/shrink: 2/0 up/down: 40/0)               Total: 40 bytes\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>", "idx": 548}
{"func": "static void probe_driver(struct btd_adapter *adapter, gpointer user_data)\n{\n\tstruct btd_adapter_driver *driver = user_data;\n\tint err;\n\n\tif (driver->probe == NULL)\n\t\treturn;\n\n\terr = driver->probe(adapter);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"%s: %s (%d)\", driver->name,\n\t\t\t\t\t\t\tstrerror(-err), -err);\n\t\treturn;\n\t}\n\n\tadapter->drivers = g_slist_prepend(adapter->drivers, driver);\n}", "target": 0, "cwe": ["CWE-862", "CWE-863"], "project": "bluez", "commit_id": "b497b5942a8beb8f89ca1c359c54ad67ec843055", "hash": 133293680759988167269847735250187060324, "size": 17, "message": "adapter: Fix storing discoverable setting\n\ndiscoverable setting shall only be store when changed via Discoverable\nproperty and not when discovery client set it as that be considered\ntemporary just for the lifetime of the discovery.", "idx": 549}
{"func": "PERL_STATIC_INLINE IV\nS_invlist_previous_index(SV* const invlist)\n{\n    /* Returns cached index of previous search */\n\n    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;\n\n    return *get_invlist_previous_index_addr(invlist);", "target": 0, "cwe": ["CWE-190", "CWE-787"], "project": "perl5", "commit_id": "897d1f7fd515b828e4b198d8b8bef76c6faf03ed", "hash": 9388894393865421433534572388331564878, "size": 8, "message": "regcomp.c: Prevent integer overflow from nested regex quantifiers.\n\n(CVE-2020-10543) On 32bit systems the size calculations for nested regular\nexpression quantifiers could overflow causing heap memory corruption.\n\nFixes: Perl/perl5-security#125\n(cherry picked from commit bfd31397db5dc1a5c5d3e0a1f753a4f89a736e71)", "idx": 550}
{"func": "find_ucmd(\n    exarg_T\t*eap,\n    char_u\t*p,\t // end of the command (possibly including count)\n    int\t\t*full,\t // set to TRUE for a full match\n    expand_T\t*xp,\t // used for completion, NULL otherwise\n    int\t\t*complp) // completion flags or NULL\n{\n    int\t\tlen = (int)(p - eap->cmd);\n    int\t\tj, k, matchlen = 0;\n    ucmd_T\t*uc;\n    int\t\tfound = FALSE;\n    int\t\tpossible = FALSE;\n    char_u\t*cp, *np;\t    // Point into typed cmd and test name\n    garray_T\t*gap;\n    int\t\tamb_local = FALSE;  // Found ambiguous buffer-local command,\n\t\t\t\t    // only full match global is accepted.\n\n    /*\n     * Look for buffer-local user commands first, then global ones.\n     */\n    gap =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t&curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (j = 0; j < gap->ga_len; ++j)\n\t{\n\t    uc = USER_CMD_GA(gap, j);\n\t    cp = eap->cmd;\n\t    np = uc->uc_name;\n\t    k = 0;\n\t    while (k < len && *np != NUL && *cp++ == *np++)\n\t\tk++;\n\t    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))\n\t    {\n\t\t// If finding a second match, the command is ambiguous.  But\n\t\t// not if a buffer-local command wasn't a full match and a\n\t\t// global command is a full match.\n\t\tif (k == len && found && *np != NUL)\n\t\t{\n\t\t    if (gap == &ucmds)\n\t\t\treturn NULL;\n\t\t    amb_local = TRUE;\n\t\t}\n\n\t\tif (!found || (k == len && *np == NUL))\n\t\t{\n\t\t    // If we matched up to a digit, then there could\n\t\t    // be another command including the digit that we\n\t\t    // should use instead.\n\t\t    if (k == len)\n\t\t\tfound = TRUE;\n\t\t    else\n\t\t\tpossible = TRUE;\n\n\t\t    if (gap == &ucmds)\n\t\t\teap->cmdidx = CMD_USER;\n\t\t    else\n\t\t\teap->cmdidx = CMD_USER_BUF;\n\t\t    eap->argt = (long)uc->uc_argt;\n\t\t    eap->useridx = j;\n\t\t    eap->addr_type = uc->uc_addr_type;\n\n\t\t    if (complp != NULL)\n\t\t\t*complp = uc->uc_compl;\n# ifdef FEAT_EVAL\n\t\t    if (xp != NULL)\n\t\t    {\n\t\t\txp->xp_arg = uc->uc_compl_arg;\n\t\t\txp->xp_script_ctx = uc->uc_script_ctx;\n\t\t\txp->xp_script_ctx.sc_lnum += SOURCING_LNUM;\n\t\t    }\n# endif\n\t\t    // Do not search for further abbreviations\n\t\t    // if this is an exact match.\n\t\t    matchlen = k;\n\t\t    if (k == len && *np == NUL)\n\t\t    {\n\t\t\tif (full != NULL)\n\t\t\t    *full = TRUE;\n\t\t\tamb_local = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Stop if we found a full match or searched all.\n\tif (j < gap->ga_len || gap == &ucmds)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    // Only found ambiguous matches.\n    if (amb_local)\n    {\n\tif (xp != NULL)\n\t    xp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn NULL;\n    }\n\n    // The match we found may be followed immediately by a number.  Move \"p\"\n    // back to point to it.\n    if (found || possible)\n\treturn p + (matchlen - len);\n    return p;\n}", "target": 1, "cwe": ["CWE-476"], "project": "vim", "commit_id": "0f6e28f686dbb59ab3b562408ab9b2234797b9b1", "hash": 272943414362398615154134337831121036858, "size": 109, "message": "patch 8.2.4428: crash when switching tabpage while in the cmdline window\n\nProblem:    Crash when switching tabpage while in the cmdline window.\nSolution:   Disallow switching tabpage when in the cmdline window.", "idx": 551}
{"func": "static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)\n{\n\tif (copy_from_user(kp, up, sizeof(*up)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "a1dfb4c48cc1e64eeb7800a27c66a6f7e88d075a", "hash": 190121595591668338035783627015041170651, "size": 6, "message": "media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic\n\nThe 32-bit compat v4l2 ioctl handling is implemented based on its 64-bit\nequivalent. It converts 32-bit data structures into its 64-bit\nequivalents and needs to provide the data to the 64-bit ioctl in user\nspace memory which is commonly allocated using\ncompat_alloc_user_space().\n\nHowever, due to how that function is implemented, it can only be called\na single time for every syscall invocation.\n\nSupposedly to avoid this limitation, the existing code uses a mix of\nmemory from the kernel stack and memory allocated through\ncompat_alloc_user_space().\n\nUnder normal circumstances, this would not work, because the 64-bit\nioctl expects all pointers to point to user space memory. As a\nworkaround, set_fs(KERNEL_DS) is called to temporarily disable this\nextra safety check and allow kernel pointers. However, this might\nintroduce a security vulnerability: The result of the 32-bit to 64-bit\nconversion is writeable by user space because the output buffer has been\nallocated via compat_alloc_user_space(). A malicious user space process\ncould then manipulate pointers inside this output buffer, and due to the\nprevious set_fs(KERNEL_DS) call, functions like get_user() or put_user()\nno longer prevent kernel memory access.\n\nThe new approach is to pre-calculate the total amount of user space\nmemory that is needed, allocate it using compat_alloc_user_space() and\nthen divide up the allocated memory to accommodate all data structures\nthat need to be converted.\n\nAn alternative approach would have been to retain the union type karg\nthat they allocated on the kernel stack in do_video_ioctl(), copy all\ndata from user space into karg and then back to user space. However, we\ndecided against this approach because it does not align with other\ncompat syscall implementations. Instead, we tried to replicate the\nget_user/put_user pairs as found in other places in the kernel:\n\n    if (get_user(clipcount, &up->clipcount) ||\n        put_user(clipcount, &kp->clipcount)) return -EFAULT;\n\nNotes from hans.verkuil@cisco.com:\n\nThis patch was taken from:\n    https://github.com/LineageOS/android_kernel_samsung_apq8084/commit/97b733953c06e4f0398ade18850f0817778255f7\n\nClearly nobody could be bothered to upstream this patch or at minimum\ntell us :-( We only heard about this a week ago.\n\nThis patch was rebased and cleaned up. Compared to the original I\nalso swapped the order of the convert_in_user arguments so that they\nmatched copy_in_user. It was hard to review otherwise. I also replaced\nthe ALLOC_USER_SPACE/ALLOC_AND_GET by a normal function.\n\nFixes: 6b5a9492ca (\"v4l: introduce string control support.\")\n\nSigned-off-by: Daniel Mentz <danielmentz@google.com>\nCo-developed-by: Hans Verkuil <hans.verkuil@cisco.com>\nAcked-by: Sakari Ailus <sakari.ailus@linux.intel.com>\nSigned-off-by: Hans Verkuil <hans.verkuil@cisco.com>\nCc: <stable@vger.kernel.org>      # for v4.15 and up\nSigned-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>", "idx": 552}
{"func": "  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }", "target": 0, "cwe": [], "project": "mysql-server", "commit_id": "f7316aa0c9a3909fc7498e7b95d5d3af044a7e21", "hash": 248432429619520806392467176166599396065, "size": 1, "message": "Bug#26361149  MYSQL SERVER CRASHES AT: COL IN(IFNULL(CONST,\n                       COL), NAME_CONST('NAME', NULL))\n\nBackport of Bug#19143243 fix.\n\nNAME_CONST item can return NULL_ITEM type in case of incorrect arguments.\nNULL_ITEM has special processing in Item_func_in function.\nIn Item_func_in::fix_length_and_dec an array of possible comparators is\ncreated. Since NAME_CONST function has NULL_ITEM type, corresponding\narray element is empty. Then NAME_CONST is wrapped to ITEM_CACHE.\nITEM_CACHE can not return proper type(NULL_ITEM) in Item_func_in::val_int(),\nso the NULL_ITEM is attempted compared with an empty comparator.\nThe fix is to disable the caching of Item_name_const item.", "idx": 553}
{"func": " */\nstatic inline bool skb_head_is_locked(const struct sk_buff *skb)\n{\n\treturn !skb->head_frag || skb_cloned(skb);", "target": 0, "cwe": ["CWE-20"], "project": "linux", "commit_id": "2b16f048729bf35e6c28a40cbfad07239f9dcd90", "hash": 275636112731684115705649106869442666096, "size": 4, "message": "net: create skb_gso_validate_mac_len()\n\nIf you take a GSO skb, and split it into packets, will the MAC\nlength (L2 + L3 + L4 headers + payload) of those packets be small\nenough to fit within a given length?\n\nMove skb_gso_mac_seglen() to skbuff.h with other related functions\nlike skb_gso_network_seglen() so we can use it, and then create\nskb_gso_validate_mac_len to do the full calculation.\n\nSigned-off-by: Daniel Axtens <dja@axtens.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 554}
{"func": "static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi,\n\t\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct snd_usb_midi_endpoint_info ep_info;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_endpoint_descriptor *epd;\n\tint cable, err;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\tintfd = get_iface_desc(hostif);\n\t/*\n\t * The various MidiSport devices have more or less random endpoint\n\t * numbers, so we have to identify the endpoints by their index in\n\t * the descriptor array, like the driver for that other OS does.\n\t *\n\t * There is one interrupt input endpoint for all input ports, one\n\t * bulk output endpoint for even-numbered ports, and one for odd-\n\t * numbered ports.  Both bulk output endpoints have corresponding\n\t * input bulk endpoints (at indices 1 and 3) which aren't used.\n\t */\n\tif (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {\n\t\tdev_dbg(&umidi->dev->dev, \"not enough endpoints\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tepd = get_endpoint(hostif, 0);\n\tif (!usb_endpoint_dir_in(epd) || !usb_endpoint_xfer_int(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[0] isn't interrupt\\n\");\n\t\treturn -ENXIO;\n\t}\n\tepd = get_endpoint(hostif, 2);\n\tif (!usb_endpoint_dir_out(epd) || !usb_endpoint_xfer_bulk(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[2] isn't bulk output\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (endpoint->out_cables > 0x0001) {\n\t\tepd = get_endpoint(hostif, 4);\n\t\tif (!usb_endpoint_dir_out(epd) ||\n\t\t    !usb_endpoint_xfer_bulk(epd)) {\n\t\t\tdev_dbg(&umidi->dev->dev,\n\t\t\t\t\"endpoint[4] isn't bulk output\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tep_info.out_ep = get_endpoint(hostif, 2)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.out_interval = 0;\n\tep_info.out_cables = endpoint->out_cables & 0x5555;\n\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t      &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tep_info.in_ep = get_endpoint(hostif, 0)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.in_interval = get_endpoint(hostif, 0)->bInterval;\n\tep_info.in_cables = endpoint->in_cables;\n\terr = snd_usbmidi_in_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t     &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (endpoint->out_cables > 0x0001) {\n\t\tep_info.out_ep = get_endpoint(hostif, 4)->bEndpointAddress &\n\t\t\tUSB_ENDPOINT_NUMBER_MASK;\n\t\tep_info.out_cables = endpoint->out_cables & 0xaaaa;\n\t\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t\t      &umidi->endpoints[1]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (cable = 0; cable < 0x10; ++cable) {\n\t\tif (endpoint->out_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   &umidi->endpoints[cable & 1].out->ports[cable].substream);\n\t\tif (endpoint->in_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   &umidi->endpoints[0].in->ports[cable].substream);\n\t}\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-703"], "project": "linux", "commit_id": "07d86ca93db7e5cdf4743564d98292042ec21af7", "hash": 174177232207794710973647456524510374050, "size": 92, "message": "ALSA: usb-audio: avoid freeing umidi object twice\n\nThe 'umidi' object will be free'd on the error path by snd_usbmidi_free()\nwhen tearing down the rawmidi interface. So we shouldn't try to free it\nin snd_usbmidi_create() after having registered the rawmidi interface.\n\nFound by KASAN.\n\nSigned-off-by: Andrey Konovalov <andreyknvl@gmail.com>\nAcked-by: Clemens Ladisch <clemens@ladisch.de>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "idx": 555}
{"func": "int oe_iov_pack(\n    const struct oe_iovec* iov,\n    int iovcnt,\n    void** buf_out,\n    size_t* buf_size_out)\n{\n    int ret = -1;\n    struct oe_iovec* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (buf_out)\n        *buf_out = NULL;\n\n    if (buf_size_out)\n        *buf_size_out = 0;\n\n    /* Reject invalid parameters. */\n    if (iovcnt < 0 || (iovcnt > 0 && !iov) || !buf_out || !buf_size_out)\n        goto done;\n\n    /* Handle zero-sized iovcnt up front. */\n    if (iovcnt == 0)\n    {\n        if (iov)\n        {\n            if (!(buf = oe_calloc(1, sizeof(uint64_t))))\n                goto done;\n\n            buf_size = sizeof(uint64_t);\n        }\n\n        *buf_out = buf;\n        *buf_size_out = buf_size;\n        buf = NULL;\n        ret = 0;\n        goto done;\n    }\n\n    /* Calculate the total number of data bytes. */\n    for (int i = 0; i < iovcnt; i++)\n        data_size += iov[i].iov_len;\n\n    /* Calculate the total size of the resulting buffer. */\n    buf_size = (sizeof(struct oe_iovec) * (size_t)iovcnt) + data_size;\n\n    /* Allocate the output buffer. */\n    if (!(buf = oe_calloc(1, buf_size)))\n        goto done;\n\n    /* Initialize the array elements. */\n    {\n        uint8_t* p = (uint8_t*)&buf[iovcnt];\n        size_t n = data_size;\n        int i;\n\n        for (i = 0; i < iovcnt; i++)\n        {\n            const size_t iov_len = iov[i].iov_len;\n            const void* iov_base = iov[i].iov_base;\n\n            if (iov_len)\n            {\n                buf[i].iov_len = iov_len;\n                buf[i].iov_base = (void*)(p - (uint8_t*)buf);\n\n                if (!iov_base)\n                    goto done;\n\n                if (oe_memcpy_s(p, n, iov_base, iov_len) != OE_OK)\n                    goto done;\n\n                p += iov_len;\n                n -= iov_len;\n            }\n        }\n\n        /* Fail if the data was not exhausted. */\n        if (n != 0)\n            goto done;\n    }\n\n    *buf_out = buf;\n    *buf_size_out = buf_size;\n    buf = NULL;\n    ret = 0;\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}", "target": 1, "cwe": ["CWE-200", "CWE-552"], "project": "openenclave", "commit_id": "bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b", "hash": 305224069655884496621619524015505919339, "size": 94, "message": "Merge pull request from GHSA-525h-wxcc-f66m\n\nSigned-off-by: Ming-Wei Shih <mishih@microsoft.com>", "idx": 556}
{"func": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20", "CWE-88"], "project": "git", "commit_id": "1a7fd1fb2998002da6e9ff2ee46e1bdd25ee8404", "hash": 143503348806154219816935316183843270546, "size": 27, "message": "fsck: detect submodule paths starting with dash\n\nAs with urls, submodule paths with dashes are ignored by\ngit, but may end up confusing older versions. Detecting them\nvia fsck lets us prevent modern versions of git from being a\nvector to spread broken .gitmodules to older versions.\n\nCompared to blocking leading-dash urls, though, this\ndetection may be less of a good idea:\n\n  1. While such paths provide confusing and broken results,\n     they don't seem to actually work as option injections\n     against anything except \"cd\". In particular, the\n     submodule code seems to canonicalize to an absolute\n     path before running \"git clone\" (so it passes\n     /your/clone/-sub).\n\n  2. It's more likely that we may one day make such names\n     actually work correctly. Even after we revert this fsck\n     check, it will continue to be a hassle until hosting\n     servers are all updated.\n\nOn the other hand, it's not entirely clear that the behavior\nin older versions is safe. And if we do want to eventually\nallow this, we may end up doing so with a special syntax\nanyway (e.g., writing \"./-sub\" in the .gitmodules file, and\nteaching the submodule code to canonicalize it when\ncomparing).\n\nSo on balance, this is probably a good protection.\n\nSigned-off-by: Jeff King <peff@peff.net>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>", "idx": 557}
{"func": "xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,\n              xmlChar *name, const xmlChar *content) {\n    xmlNodePtr cur;\n\n    cur = xmlNewNodeEatName(ns, name);\n    if (cur != NULL) {\n        cur->doc = doc;\n\tif (content != NULL) {\n\t    cur->children = xmlStringGetNodeList(doc, content);\n\t    UPDATE_LAST_CHILD_AND_PARENT(cur)\n\t}\n    } else {\n        /* if name don't come from the doc dictionary free it here */\n        if ((name != NULL) && (doc != NULL) &&\n\t    (!(xmlDictOwns(doc->dict, name))))\n\t    xmlFree(name);\n    }\n    return(cur);\n}", "target": 0, "cwe": ["CWE-20"], "project": "libxml2", "commit_id": "bdd66182ef53fe1f7209ab6535fda56366bd7ac9", "hash": 241852597303660989640792442426098699528, "size": 19, "message": "Avoid building recursive entities\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=762100\n\nWhen we detect a recusive entity we should really not\nbuild the associated data, moreover if someone bypass\nlibxml2 fatal errors and still tries to serialize a broken\nentity make sure we don't risk to get ito a recursion\n\n* parser.c: xmlParserEntityCheck() don't build if entity loop\n  were found and remove the associated text content\n* tree.c: xmlStringGetNodeList() avoid a potential recursion", "idx": 558}
{"func": "lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)\n{\n    if (!node || !sibling) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_nextto(sibling, node, 1, 1);\n}", "target": 0, "cwe": ["CWE-119"], "project": "libyang", "commit_id": "32fb4993bc8bb49e93e84016af3c10ea53964be5", "hash": 249595412958128150341059932303108929540, "size": 9, "message": "schema tree BUGFIX do not check features while still resolving schema\n\nFixes #723", "idx": 559}
{"func": "S3BootScriptSaveInformation (\r\n  IN  UINT32                                InformationLength,\r\n  IN  VOID                                 *Information\r\n  )\r\n{\r\n  UINT8                 Length;\r\n  UINT8                 *Script;\r\n  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;\r\n\r\n  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);\r\n\r\n  Script = S3BootScriptGetEntryAddAddress (Length);\r\n  if (Script == NULL) {\r\n    return RETURN_OUT_OF_RESOURCES;\r\n  }\r\n  //\r\n  // Build script data\r\n  //\r\n  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;\r\n  ScriptInformation.Length     = Length;\r\n\r\n\r\n  ScriptInformation.InformationLength = InformationLength;\r\n\r\n  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));\r\n  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);\r\n\r\n  SyncBootScript (Script);\r\n\r\n  return RETURN_SUCCESS;\r\n\r\n}\r", "target": 1, "cwe": ["CWE-787"], "project": "edk2", "commit_id": "322ac05f8bbc1bce066af1dabd1b70ccdbe28891", "hash": 234685404253552911688789998142548102385, "size": 32, "message": "MdeModulePkg/PiDxeS3BootScriptLib: Fix potential numeric truncation (CVE-2019-14563)\n\nREF:https://bugzilla.tianocore.org/show_bug.cgi?id=2001\n\nFor S3BootScriptLib APIs:\n\nS3BootScriptSaveIoWrite\nS3BootScriptSaveMemWrite\nS3BootScriptSavePciCfgWrite\nS3BootScriptSavePciCfg2Write\nS3BootScriptSaveSmbusExecute\nS3BootScriptSaveInformation\nS3BootScriptSaveInformationAsciiString\nS3BootScriptLabel (happen in S3BootScriptLabelInternal())\n\npossible numeric truncations will happen that may lead to S3 boot script\nentry with improper size being returned to store the boot script data.\nThis commit will add checks to prevent this kind of issue.\n\nPlease note that the remaining S3BootScriptLib APIs:\n\nS3BootScriptSaveIoReadWrite\nS3BootScriptSaveMemReadWrite\nS3BootScriptSavePciCfgReadWrite\nS3BootScriptSavePciCfg2ReadWrite\nS3BootScriptSaveStall\nS3BootScriptSaveDispatch2\nS3BootScriptSaveDispatch\nS3BootScriptSaveMemPoll\nS3BootScriptSaveIoPoll\nS3BootScriptSavePciPoll\nS3BootScriptSavePci2Poll\nS3BootScriptCloseTable\nS3BootScriptExecute\nS3BootScriptMoveLastOpcode\nS3BootScriptCompare\n\nare not affected by such numeric truncation.\n\nSigned-off-by: Hao A Wu <hao.a.wu@intel.com>\nReviewed-by: Laszlo Ersek <lersek@redhat.com>\nReviewed-by: Eric Dong <eric.dong@intel.com>\nAcked-by: Jian J Wang <jian.j.wang@intel.com>", "idx": 560}
{"func": "refresh_account (GoaProvider    *provider,\n                 GoaClient      *client,\n                 GoaObject      *object,\n                 GtkWindow      *parent,\n                 GError        **error)\n{\n  AddAccountData data;\n  GVariantBuilder builder;\n  GoaAccount *account;\n  GoaHttpClient *http_client;\n  GtkWidget *dialog;\n  GtkWidget *vbox;\n  gboolean ret;\n  const gchar *password;\n  const gchar *username;\n  gchar *uri;\n  gchar *uri_webdav;\n  gint response;\n\n  g_return_val_if_fail (GOA_IS_OWNCLOUD_PROVIDER (provider), FALSE);\n  g_return_val_if_fail (GOA_IS_CLIENT (client), FALSE);\n  g_return_val_if_fail (GOA_IS_OBJECT (object), FALSE);\n  g_return_val_if_fail (parent == NULL || GTK_IS_WINDOW (parent), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  http_client = NULL;\n  uri = NULL;\n  uri_webdav = NULL;\n\n  ret = FALSE;\n\n  dialog = gtk_dialog_new_with_buttons (NULL,\n                                        parent,\n                                        GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,\n                                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,\n                                        NULL);\n  gtk_container_set_border_width (GTK_CONTAINER (dialog), 12);\n  gtk_window_set_modal (GTK_WINDOW (dialog), TRUE);\n  gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);\n\n  vbox = gtk_dialog_get_content_area (GTK_DIALOG (dialog));\n  gtk_box_set_spacing (GTK_BOX (vbox), 12);\n\n  memset (&data, 0, sizeof (AddAccountData));\n  data.cancellable = g_cancellable_new ();\n  data.loop = g_main_loop_new (NULL, FALSE);\n  data.dialog = GTK_DIALOG (dialog);\n  data.error = NULL;\n\n  create_account_details_ui (provider, GTK_DIALOG (dialog), GTK_BOX (vbox), FALSE, &data);\n\n  uri = goa_util_lookup_keyfile_string (object, \"Uri\");\n  gtk_entry_set_text (GTK_ENTRY (data.uri), uri);\n  gtk_editable_set_editable (GTK_EDITABLE (data.uri), FALSE);\n\n  account = goa_object_peek_account (object);\n  username = goa_account_get_identity (account);\n  gtk_entry_set_text (GTK_ENTRY (data.username), username);\n  gtk_editable_set_editable (GTK_EDITABLE (data.username), FALSE);\n\n  gtk_widget_show_all (dialog);\n  g_signal_connect (dialog, \"response\", G_CALLBACK (dialog_response_cb), &data);\n\n  http_client = goa_http_client_new ();\n  uri_webdav = g_strconcat (uri, WEBDAV_ENDPOINT, NULL);\n\n http_again:\n  response = gtk_dialog_run (GTK_DIALOG (dialog));\n  if (response != GTK_RESPONSE_OK)\n    {\n      g_set_error (&data.error,\n                   GOA_ERROR,\n                   GOA_ERROR_DIALOG_DISMISSED,\n                   _(\"Dialog was dismissed\"));\n      goto out;\n    }\n\n  password = gtk_entry_get_text (GTK_ENTRY (data.password));\n  g_cancellable_reset (data.cancellable);\n  goa_http_client_check (http_client,\n                         uri_webdav,\n                         username,\n                         password,\n                         data.cancellable,\n                         check_cb,\n                         &data);\n  gtk_widget_set_sensitive (data.connect_button, FALSE);\n  gtk_widget_show (data.progress_grid);\n  g_main_loop_run (data.loop);\n\n  if (g_cancellable_is_cancelled (data.cancellable))\n    {\n      g_prefix_error (&data.error,\n                      _(\"Dialog was dismissed (%s, %d): \"),\n                      g_quark_to_string (data.error->domain),\n                      data.error->code);\n      data.error->domain = GOA_ERROR;\n      data.error->code = GOA_ERROR_DIALOG_DISMISSED;\n      goto out;\n    }\n  else if (data.error != NULL)\n    {\n      gchar *markup;\n\n      markup = g_strdup_printf (\"<b>%s:</b> %s\",\n                                _(\"Error connecting to ownCloud server\"),\n                                data.error->message);\n      g_clear_error (&data.error);\n\n      gtk_label_set_markup (GTK_LABEL (data.cluebar_label), markup);\n      g_free (markup);\n\n      gtk_button_set_label (GTK_BUTTON (data.connect_button), _(\"_Try Again\"));\n      gtk_widget_set_no_show_all (data.cluebar, FALSE);\n      gtk_widget_show_all (data.cluebar);\n      goto http_again;\n    }\n\n  /* TODO: run in worker thread */\n  g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);\n  g_variant_builder_add (&builder, \"{sv}\", \"password\", g_variant_new_string (password));\n\n  if (!goa_utils_store_credentials_for_object_sync (provider,\n                                                    object,\n                                                    g_variant_builder_end (&builder),\n                                                    NULL, /* GCancellable */\n                                                    &data.error))\n    goto out;\n\n  goa_account_call_ensure_credentials (account,\n                                       NULL, /* GCancellable */\n                                       NULL, NULL); /* callback, user_data */\n\n  ret = TRUE;\n\n out:\n  if (data.error != NULL)\n    g_propagate_error (error, data.error);\n\n  gtk_widget_destroy (dialog);\n  g_free (uri);\n  g_free (uri_webdav);\n  if (data.loop != NULL)\n    g_main_loop_unref (data.loop);\n  g_clear_object (&data.cancellable);\n  g_clear_object (&http_client);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "project": "gnome-online-accounts", "commit_id": "edde7c63326242a60a075341d3fea0be0bc4d80e", "hash": 300570325580069215395488553628233160451, "size": 148, "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240", "idx": 561}
{"func": "int process_open(ProcessHandle process, const char *fname) {\n\tint rv = process_open_nofail(process, fname);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot open /proc/%d/%s: %s\\n\", process->pid, fname, strerror(errno));\n\t\texit(1);\n\t}\n\n\treturn rv;\n}", "target": 1, "cwe": ["CWE-269", "CWE-94"], "project": "firejail", "commit_id": "dab835e7a0eb287822016f5ae4e87f46e1d363e7", "hash": 236016576801399307892343637225457104690, "size": 9, "message": "CVE-2022-31214: fixing the fix", "idx": 562}
{"func": "static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)\n{\n\tsmart_str nstype = {0};\n\tget_type_str(node, ns, type, &nstype);\n\tset_xsi_type(node, nstype.c);\n\tsmart_str_free(&nstype);\n}", "target": 0, "cwe": ["CWE-19"], "project": "php-src", "commit_id": "c8eaca013a3922e8383def6158ece2b63f6ec483", "hash": 81595902128922174108578994141052174498, "size": 7, "message": "Added type checks", "idx": 563}
{"func": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth == 0) || (sun_info.depth > 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=\n        sun_info.length || !sun_info.length)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&\n        ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    sun_pixels=sun_data;\n    bytes_per_line=0;\n    if (sun_info.type == RT_ENCODED)\n      {\n        size_t\n          height;\n\n        /*\n          Read run-length encoded raster pixels.\n        */\n        height=sun_info.height;\n        if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n            ((bytes_per_line/sun_info.depth) != sun_info.width))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line+=15;\n        bytes_per_line<<=1;\n        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line>>=4;\n        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,\n          bytes_per_line*sizeof(*sun_pixels));\n        if (sun_pixels == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\n          height);\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n      }\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          if (bytes_per_line == 0)\n            bytes_per_line=image->columns;\n          length=image->rows*(image->columns+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p++,q);\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            bytes_per_pixel++;\n          if (bytes_per_line == 0)\n            bytes_per_line=bytes_per_pixel*image->columns;\n          length=image->rows*(bytes_per_line+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "ImageMagick", "commit_id": "450bd716ed3b9186dd10f9e60f630a3d9eeea2a4", "hash": 232633560843254991331023188387827228847, "size": 409, "message": "", "idx": 564}
{"func": "static MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define MaxCount  128\n#define PictCropRegionOp  0x01\n#define PictEndOfPictureOp  0xff\n#define PictJPEGOp  0x8200\n#define PictInfoOp  0x0C00\n#define PictInfoSize  512\n#define PictPixmapOp  0x9A\n#define PictPICTOp  0x98\n#define PictVersion  0x11\n\n  const StringInfo\n    *profile;\n\n  double\n    x_resolution,\n    y_resolution;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  PICTPixmap\n    pixmap;\n\n  PICTRectangle\n    bounds,\n    crop_rectangle,\n    destination_rectangle,\n    frame_rectangle,\n    size_rectangle,\n    source_rectangle;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    bytes_per_line,\n    count,\n    row_bytes,\n    storage_class;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *packed_scanline,\n    *scanline;\n\n  unsigned short\n    base_address,\n    transfer_mode;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize image info.\n  */\n  size_rectangle.top=0;\n  size_rectangle.left=0;\n  size_rectangle.bottom=(short) image->rows;\n  size_rectangle.right=(short) image->columns;\n  frame_rectangle=size_rectangle;\n  crop_rectangle=size_rectangle;\n  source_rectangle=size_rectangle;\n  destination_rectangle=size_rectangle;\n  base_address=0xff;\n  row_bytes=image->columns;\n  bounds.top=0;\n  bounds.left=0;\n  bounds.bottom=(short) image->rows;\n  bounds.right=(short) image->columns;\n  pixmap.version=0;\n  pixmap.pack_type=0;\n  pixmap.pack_size=0;\n  pixmap.pixel_type=0;\n  pixmap.bits_per_pixel=8;\n  pixmap.component_count=1;\n  pixmap.component_size=8;\n  pixmap.plane_bytes=0;\n  pixmap.table=0;\n  pixmap.reserved=0;\n  transfer_mode=0;\n  x_resolution=image->resolution.x != 0.0 ? image->resolution.x :\n    DefaultResolution;\n  y_resolution=image->resolution.y != 0.0 ? image->resolution.y :\n    DefaultResolution;\n  storage_class=image->storage_class;\n  if (image_info->compression == JPEGCompression)\n    storage_class=DirectClass;\n  if (storage_class == DirectClass)\n    {\n      pixmap.component_count=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n      pixmap.pixel_type=16;\n      pixmap.bits_per_pixel=32;\n      pixmap.pack_type=0x04;\n      transfer_mode=0x40;\n      row_bytes=4*image->columns;\n    }\n  /*\n    Allocate memory.\n  */\n  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.right);\n  (void) WriteBlobMSBShort(image,PictVersion);\n  (void) WriteBlobMSBShort(image,0x02ff);  /* version #2 */\n  (void) WriteBlobMSBShort(image,PictInfoOp);\n  (void) WriteBlobMSBLong(image,0xFFFE0000UL);\n  /*\n    Write full size of the file, resolution, frame bounding box, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.right);\n  (void) WriteBlobMSBLong(image,0x00000000L);\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0x1f2);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobString(image,\"8BIM\");\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    }\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,4);\n      (void) WriteBlobMSBLong(image,0x00000002UL);\n    }\n  /*\n    Write crop region opcode and crop bounding box.\n  */\n  (void) WriteBlobMSBShort(image,PictCropRegionOp);\n  (void) WriteBlobMSBShort(image,0xa);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.right);\n  if (image_info->compression == JPEGCompression)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      size_t\n        length;\n\n      unsigned char\n        *blob;\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          return(MagickFalse);\n        }\n      jpeg_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(jpeg_info->magick,\"JPEG\",MagickPathExtent);\n      length=0;\n      blob=(unsigned char *) ImageToBlob(jpeg_info,jpeg_image,&length,\n        exception);\n      jpeg_info=DestroyImageInfo(jpeg_info);\n      if (blob == (unsigned char *) NULL)\n        return(MagickFalse);\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) WriteBlobMSBShort(image,PictJPEGOp);\n      (void) WriteBlobMSBLong(image,(unsigned int) length+154);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x40000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00400000UL);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00566A70UL);\n      (void) WriteBlobMSBLong(image,0x65670000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000001UL);\n      (void) WriteBlobMSBLong(image,0x00016170UL);\n      (void) WriteBlobMSBLong(image,0x706C0000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x87AC0001UL);\n      (void) WriteBlobMSBLong(image,0x0B466F74UL);\n      (void) WriteBlobMSBLong(image,0x6F202D20UL);\n      (void) WriteBlobMSBLong(image,0x4A504547UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x0018FFFFUL);\n      (void) WriteBlob(image,length,blob);\n      if ((length & 0x01) != 0)\n        (void) WriteBlobByte(image,'\\0');\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n  /*\n    Write picture opcode, row bytes, and picture bounding box, and version.\n  */\n  if (storage_class == PseudoClass)\n    (void) WriteBlobMSBShort(image,PictPICTOp);\n  else\n    {\n      (void) WriteBlobMSBShort(image,PictPixmapOp);\n      (void) WriteBlobMSBLong(image,(size_t) base_address);\n    }\n  (void) WriteBlobMSBShort(image,(unsigned short) (row_bytes | 0x8000));\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.right);\n  /*\n    Write pack type, pack size, resolution, pixel type, and pixel size.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.version);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pack_type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.pack_size);\n  (void) WriteBlobMSBShort(image,(unsigned short) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pixel_type);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.bits_per_pixel);\n  /*\n    Write component count, size, plane bytes, table size, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_count);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_size);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.plane_bytes);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.table);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.reserved);\n  if (storage_class == PseudoClass)\n    {\n      /*\n        Write image colormap.\n      */\n      (void) WriteBlobMSBLong(image,0x00000000L);  /* color seed */\n      (void) WriteBlobMSBShort(image,0L);  /* color flags */\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->colors-1));\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        (void) WriteBlobMSBShort(image,(unsigned short) i);\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].red));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].green));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].blue));\n      }\n    }\n  /*\n    Write source and destination rectangle.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) transfer_mode);\n  /*\n    Write picture data.\n  */\n  count=0;\n  if (storage_class == PseudoClass)\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        scanline[x]=(unsigned char) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n      count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n        packed_scanline);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  else\n    if (image_info->compression == JPEGCompression)\n      {\n        (void) ResetMagickMemory(scanline,0,row_bytes);\n        for (y=0; y < (ssize_t) image->rows; y++)\n          count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n            packed_scanline);\n      }\n    else\n      {\n        register unsigned char\n          *blue,\n          *green,\n          *opacity,\n          *red;\n\n        red=scanline;\n        green=scanline+image->columns;\n        blue=scanline+2*image->columns;\n        opacity=scanline+3*image->columns;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          red=scanline;\n          green=scanline+image->columns;\n          blue=scanline+2*image->columns;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              opacity=scanline;\n              red=scanline+image->columns;\n              green=scanline+2*image->columns;\n              blue=scanline+3*image->columns;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *red++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *green++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *blue++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *opacity++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n          }\n          count+=EncodeImage(image,scanline,bytes_per_line,packed_scanline);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n  if ((count & 0x01) != 0)\n    (void) WriteBlobByte(image,'\\0');\n  (void) WriteBlobMSBShort(image,PictEndOfPictureOp);\n  offset=TellBlob(image);\n  offset=SeekBlob(image,512,SEEK_SET);\n  (void) WriteBlobMSBShort(image,(unsigned short) offset);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  packed_scanline=(unsigned char *) RelinquishMagickMemory(packed_scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 1, "cwe": ["CWE-772", "CWE-401"], "project": "ImageMagick", "commit_id": "c1b09bbec148f6ae11d0b686fdb89ac6dc0ab14e", "hash": 316430389580795598482647571810870066908, "size": 438, "message": "https://github.com/ImageMagick/ImageMagick/issues/577", "idx": 565}
{"func": "static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,\n\t\t\t\t\t phys_addr_t base, phys_addr_t limit)\n{\n\tstruct cma *cma;\n\tint ret;\n\tret = dma_contiguous_reserve_area(size, base, limit, &cma, true);\n\tif (ret == 0)\n\t\tdev_set_cma_area(dev, cma);\n\n\treturn ret;\n}", "target": 0, "cwe": ["CWE-682"], "project": "linux", "commit_id": "67a2e213e7e937c41c52ab5bc46bf3f4de469f6e", "hash": 225586685643024064136539888761620524824, "size": 11, "message": "mm: cma: fix incorrect type conversion for size during dma allocation\n\nThis was found during userspace fuzzing test when a large size dma cma\nallocation is made by driver(like ion) through userspace.\n\n  show_stack+0x10/0x1c\n  dump_stack+0x74/0xc8\n  kasan_report_error+0x2b0/0x408\n  kasan_report+0x34/0x40\n  __asan_storeN+0x15c/0x168\n  memset+0x20/0x44\n  __dma_alloc_coherent+0x114/0x18c\n\nSigned-off-by: Rohit Vaswani <rvaswani@codeaurora.org>\nAcked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nCc: Marek Szyprowski <m.szyprowski@samsung.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 566}
{"func": "static void cirrus_vga_save(QEMUFile *f, void *opaque)\n{\n    CirrusVGAState *s = opaque;\n\n    if (s->pci_dev)\n        pci_device_save(s->pci_dev, f);\n\n    qemu_put_be32s(f, &s->latch);\n    qemu_put_8s(f, &s->sr_index);\n    qemu_put_buffer(f, s->sr, 256);\n    qemu_put_8s(f, &s->gr_index);\n    qemu_put_8s(f, &s->cirrus_shadow_gr0);\n    qemu_put_8s(f, &s->cirrus_shadow_gr1);\n    qemu_put_buffer(f, s->gr + 2, 254);\n    qemu_put_8s(f, &s->ar_index);\n    qemu_put_buffer(f, s->ar, 21);\n    qemu_put_be32(f, s->ar_flip_flop);\n    qemu_put_8s(f, &s->cr_index);\n    qemu_put_buffer(f, s->cr, 256);\n    qemu_put_8s(f, &s->msr);\n    qemu_put_8s(f, &s->fcr);\n    qemu_put_8s(f, &s->st00);\n    qemu_put_8s(f, &s->st01);\n\n    qemu_put_8s(f, &s->dac_state);\n    qemu_put_8s(f, &s->dac_sub_index);\n    qemu_put_8s(f, &s->dac_read_index);\n    qemu_put_8s(f, &s->dac_write_index);\n    qemu_put_buffer(f, s->dac_cache, 3);\n    qemu_put_buffer(f, s->palette, 768);\n\n    qemu_put_be32(f, s->bank_offset);\n\n    qemu_put_8s(f, &s->cirrus_hidden_dac_lockindex);\n    qemu_put_8s(f, &s->cirrus_hidden_dac_data);\n\n    qemu_put_be32s(f, &s->hw_cursor_x);\n    qemu_put_be32s(f, &s->hw_cursor_y);\n    /* XXX: we do not save the bitblt state - we assume we do not save\n       the state when the blitter is active */\n}", "target": 0, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 70932604365626628254069575058805645317, "size": 41, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162", "idx": 567}
{"func": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_mmu(vcpu);\n}", "target": 0, "cwe": ["CWE-476"], "project": "linux", "commit_id": "9f46c187e2e680ecd9de7983e4d081c3391acc76", "hash": 116315786419233792162191852215336477654, "size": 5, "message": "KVM: x86/mmu: fix NULL pointer dereference on guest INVPCID\n\nWith shadow paging enabled, the INVPCID instruction results in a call\nto kvm_mmu_invpcid_gva.  If INVPCID is executed with CR0.PG=0, the\ninvlpg callback is not set and the result is a NULL pointer dereference.\nFix it trivially by checking for mmu->invlpg before every call.\n\nThere are other possibilities:\n\n- check for CR0.PG, because KVM (like all Intel processors after P5)\n  flushes guest TLB on CR0.PG changes so that INVPCID/INVLPG are a\n  nop with paging disabled\n\n- check for EFER.LMA, because KVM syncs and flushes when switching\n  MMU contexts outside of 64-bit mode\n\nAll of these are tricky, go for the simple solution.  This is CVE-2022-1789.\n\nReported-by: Yongkang Jia <kangel@zju.edu.cn>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 568}
{"func": "static void line6_toneport_disconnect(struct usb_line6 *line6)\n{\n\tstruct usb_line6_toneport *toneport =\n\t\t(struct usb_line6_toneport *)line6;\n\n\tcancel_delayed_work_sync(&toneport->pcm_work);\n\n\tif (toneport_has_led(toneport))\n\t\ttoneport_remove_leds(toneport);\n}", "target": 1, "cwe": ["CWE-476"], "project": "linux", "commit_id": "0b074ab7fc0d575247b9cc9f93bb7e007ca38840", "hash": 16210252510649925178652649551785217237, "size": 10, "message": "ALSA: line6: Assure canceling delayed work at disconnection\n\nThe current code performs the cancel of a delayed work at the late\nstage of disconnection procedure, which may lead to the access to the\nalready cleared state.\n\nThis patch assures to call cancel_delayed_work_sync() at the beginning\nof the disconnection procedure for avoiding that race.  The delayed\nwork object is now assigned in the common line6 object instead of its\nderivative, so that we can call cancel_delayed_work_sync().\n\nAlong with the change, the startup function is called via the new\ncallback instead.  This will make it easier to port other LINE6\ndrivers to use the delayed work for startup in later patches.\n\nReported-by: syzbot+5255458d5e0a2b10bbb9@syzkaller.appspotmail.com\nFixes: 7f84ff68be05 (\"ALSA: line6: toneport: Fix broken usage of timer for delayed execution\")\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "idx": 569}
{"func": "static int display_open(void *handle, void *device)\n{\n\n    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));\n    if (img == NULL)\n        return -1;\n    memset(img, 0, sizeof(IMAGE));\n\n    if (first_image == NULL) {\n        gdk_rgb_init();\n        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());\n        gtk_widget_set_default_visual(gdk_rgb_get_visual());\n    }\n\n    /* add to list */\n    if (first_image)\n        img->next = first_image;\n    first_image = img;\n\n    /* remember device and handle */\n    img->handle = handle;\n    img->device = device;\n\n    /* create window */\n    window_create(img);\n\n    gtk_main_iteration_do(FALSE);\n    return 0;\n}", "target": 1, "cwe": [], "project": "ghostpdl", "commit_id": "514595fc2cc84f51efdef563cf7a35a0050902e5", "hash": 19942997581211898073526767699658941441, "size": 29, "message": "Bug 693038 - allow gsx to build against GTK+ 3.x\n\nPatch from galtgendo@gmail.com applied with changes to maintain compatibility\nwith GTK+ 2.x, and replace a function deprecated in GTK+ 3.x.\n\nThis patch drops GTK+ 1.x support.\n\nNo cluster differences.", "idx": 570}
{"func": "  static void  Ins_IP( INS_ARG )\n  {\n    TT_F26Dot6  org_a, org_b, org_x,\n                cur_a, cur_b, cur_x,\n                distance;\n    Int         point;\n    (void)args;\n\n    if ( CUR.top < CUR.GS.loop )\n    {\n      CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    org_a = CUR_Func_dualproj( CUR.zp0.org_x[CUR.GS.rp1],\n                               CUR.zp0.org_y[CUR.GS.rp1] );\n\n    org_b = CUR_Func_dualproj( CUR.zp1.org_x[CUR.GS.rp2],\n                               CUR.zp1.org_y[CUR.GS.rp2] );\n\n    cur_a = CUR_Func_project( CUR.zp0.cur_x[CUR.GS.rp1],\n                              CUR.zp0.cur_y[CUR.GS.rp1] );\n\n    cur_b = CUR_Func_project( CUR.zp1.cur_x[CUR.GS.rp2],\n                              CUR.zp1.cur_y[CUR.GS.rp2] );\n\n    while ( CUR.GS.loop > 0 )\n    {\n      CUR.args--;\n\n      point = (Int)CUR.stack[CUR.args];\n      if ( BOUNDS( point, CUR.zp2.n_points ) )\n      {\n        CUR.error = TT_Err_Invalid_Reference;\n        return;\n      }\n\n      org_x = CUR_Func_dualproj( CUR.zp2.org_x[point],\n                                 CUR.zp2.org_y[point] );\n\n      cur_x = CUR_Func_project( CUR.zp2.cur_x[point],\n                                CUR.zp2.cur_y[point] );\n\n      if ( ( org_a <= org_b && org_x <= org_a ) ||\n           ( org_a >  org_b && org_x >= org_a ) )\n\n        distance = ( cur_a - org_a ) + ( org_x - cur_x );\n\n      else if ( ( org_a <= org_b  &&  org_x >= org_b ) ||\n                ( org_a >  org_b  &&  org_x <  org_b ) )\n\n        distance = ( cur_b - org_b ) + ( org_x - cur_x );\n\n      else\n         /* note: it seems that rounding this value isn't a good */\n         /*       idea (cf. width of capital 'S' in Times)       */\n\n         distance = MulDiv_Round( cur_b - cur_a,\n                                  org_x - org_a,\n                                  org_b - org_a ) + ( cur_a - cur_x );\n\n      CUR_Func_move( &CUR.zp2, point, distance );\n\n      CUR.GS.loop--;\n    }\n\n    CUR.GS.loop = 1;\n    CUR.new_top = CUR.args;\n  }", "target": 1, "cwe": ["CWE-416"], "project": "ghostpdl", "commit_id": "98f6da60b9d463c617e631fc254cf6d66f2e8e3c", "hash": 173227980573218714546663869812007152008, "size": 69, "message": "Bug 698026: bounds check zone pointers in Ins_IP()", "idx": 571}
{"func": "opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n\t\t\t\t\t\t\t\t\t\topj_cp_t *p_cp,\n\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_tile_no)\n{\n\t/* loop */\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions */\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers */\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif\n\t\t(! l_tmp_data)\n\t{\n\t\treturn 00;\n\t}\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif\n\t\t(! l_tmp_ptr)\n\t{\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi */\n\tl_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array */\n\tfor\n\t\t(compno = 0; compno < p_image->numcomps; ++compno)\n\t{\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\t/* get encoding parameters */\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations */\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator */\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\n\t/*l_current_pi->dx = l_img_comp->dx;*/\n\t/*l_current_pi->dy = l_img_comp->dy;*/\n\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor\n\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t{\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t/* resolutions have already been initialized */\n\t\tfor\n\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t{\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino )\n\t{\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\t/*l_current_pi->dx = l_dx_min;*/\n\t\t/*l_current_pi->dy = l_dy_min;*/\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor\n\t\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t\t{\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor\n\t\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t\t{\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\tif\n\t\t(l_tcp->POC)\n\t{\n\t\topj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\telse\n\t{\n\t\topj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\treturn l_pi;\n}", "target": 1, "cwe": ["CWE-190", "CWE-125", "CWE-787"], "project": "openjpeg", "commit_id": "c16bc057ba3f125051c9966cf1f5b68a05681de4", "hash": 324525441819541283758612439352611158590, "size": 197, "message": "Fix an integer overflow issue (#809)\n\nPrevent an integer overflow issue in function opj_pi_create_decode of\r\npi.c.", "idx": 572}
{"func": "static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {\n\tsize_t pos, nextpos = 0;\n\tx86newTokenType last_type;\n\tint size_token = 1;\n\tbool explicit_size = false;\n\tint reg_index = 0;\n\t// Reset type\n\top->type = 0;\n\t// Consume tokens denoting the operand size\n\twhile (size_token) {\n\t\tpos = nextpos;\n\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\t// Token may indicate size: then skip\n\t\tif (!r_str_ncasecmp (str + pos, \"ptr\", 3)) {\n\t\t\tcontinue;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"byte\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_BYTE;\n\t\t\top->dest_size = OT_BYTE;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"word\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_WORD;\n\t\t\top->dest_size = OT_WORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"dword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_DWORD;\n\t\t\top->dest_size = OT_DWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"qword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_QWORD;\n\t\t\top->dest_size = OT_QWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"oword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_OWORD;\n\t\t\top->dest_size = OT_OWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"tbyte\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_TBYTE;\n\t\t\top->dest_size = OT_TBYTE;\n\t\t\texplicit_size = true;\n\t\t} else { // the current token doesn't denote a size\n\t\t\tsize_token = 0;\n\t\t}\n\t}\n\n\t// Next token: register, immediate, or '['\n\tif (str[pos] == '[') {\n\t\t// Don't care about size, if none is given.\n\t\tif (!op->type) {\n\t\t\top->type = OT_MEMORY;\n\t\t}\n\t\t// At the moment, we only accept plain linear combinations:\n\t\t// part := address | [factor *] register\n\t\t// address := part {+ part}*\n\t\top->offset = op->scale[0] = op->scale[1] = 0;\n\n\t\tut64 temp = 1;\n\t\tRegister reg = X86R_UNDEFINED;\n\t\tbool first_reg = true;\n\t\twhile (str[pos] != ']') {\n\t\t\tif (pos > nextpos) {\n\t\t\t//\teprintf (\"Error parsing instruction\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = nextpos;\n\t\t\tif (!str[pos]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\t\tif (last_type == TT_SPECIAL) {\n\t\t\t\tif (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {\n\t\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\t\top->regs[reg_index] = reg;\n\t\t\t\t\t\top->scale[reg_index] = temp;\n\t\t\t\t\t\t++reg_index;\n\t\t\t\t\t} else {\n\t\t\t\t\t\top->offset += temp;\n\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n\t\t\t\t\t}\n\n\t\t\t\t\ttemp = 1;\n\t\t\t\t\treg = X86R_UNDEFINED;\n\t\t\t\t} else if (str[pos] == '*') {\n\t\t\t\t\t// go to ], + or - to get scale\n\n\t\t\t\t\t// Something to do here?\n\t\t\t\t\t// Seems we are just ignoring '*' or assuming it implicitly.\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (last_type == TT_WORD) {\n\t\t\t\tut32 reg_type = 0;\n\n\t\t\t\t// We can't multiply registers\n\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\n\t\t\t\t// Reset nextpos: parseReg wants to parse from the beginning\n\t\t\t\tnextpos = pos;\n\t\t\t\treg = parseReg (a, str, &nextpos, &reg_type);\n\n\t\t\t\tif (first_reg) {\n\t\t\t\t\top->extended = false;\n\t\t\t\t\tif (reg > 8) {\n\t\t\t\t\t\top->extended = true;\n\t\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t\t}\n\t\t\t\t\tfirst_reg = false;\n\t\t\t\t} else if (reg > 8) {\n\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t}\n\t\t\t\tif (reg_type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\t\t\top->reg = reg;\n\t\t\t\t\top->type = reg_type;\n\t\t\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\t\t\treturn nextpos;\n\t\t\t\t}\n\n\t\t\t\t// Still going to need to know the size if not specified\n\t\t\t\tif (!explicit_size) {\n\t\t\t\t\top->type |= reg_type;\n\t\t\t\t}\n\t\t\t\top->reg_size = reg_type;\n\t\t\t\top->explicit_size = explicit_size;\n\n\t\t\t\t// Addressing only via general purpose registers\n\t\t\t\tif (!(reg_type & OT_GPREG)) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchar *p = strchr (str, '+');\n\t\t\t\top->offset_sign = 1;\n\t\t\t\tif (!p) {\n\t\t\t\t\tp = strchr (str, '-');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//with SIB notation, we need to consider the right sign\n\t\t\t\tchar * plus = strchr (str, '+');\n\t\t\t\tchar * minus = strchr (str, '-');\n\t\t\t\tchar * closeB = strchr (str, ']');\n\t\t\t\tif (plus && minus && plus < closeB && minus < closeB) {\n\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t}\n\t\t\t\t// If there's a scale, we don't want to parse out the\n\t\t\t\t// scale with the offset (scale + offset) otherwise the scale\n\t\t\t\t// will be the sum of the two. This splits the numbers\n\t\t\t\tchar *tmp;\n\t\t\t\ttmp = malloc (strlen (str + pos) + 1);\n\t\t\t\tstrcpy (tmp, str + pos);\n\t\t\t\tstrtok (tmp, \"+-\");\n\t\t\t\tst64 read = getnum (a, tmp);\n\t\t\t\tfree (tmp);\n\t\t\t\ttemp *= read;\n\t\t\t}\n\t\t}\n\t} else if (last_type == TT_WORD) {   // register\n\t\tnextpos = pos;\n\t\tRFlagItem *flag;\n\n\t\tif (isrepop) {\n\t\t\top->is_good_flag = false;\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t\treturn nextpos;\n\t\t}\n\n\t\top->reg = parseReg (a, str, &nextpos, &op->type);\n\n\t\top->extended = false;\n\t\tif (op->reg > 8) {\n\t\t\top->extended = true;\n\t\t\top->reg -= 9;\n\t\t}\n\t\tif (op->type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\treturn nextpos;\n\t\t}\n\t\tif (op->reg == X86R_UNDEFINED) {\n\t\t\top->is_good_flag = false;\n\t\t\tif (a->num && a->num->value == 0) {\n\t\t\t\treturn nextpos;\n\t\t\t}\n\t\t\top->type = OT_CONSTANT;\n\t\t\tRCore *core = a->num? (RCore *)(a->num->userptr): NULL;\n\t\t\tif (core && (flag = r_flag_get (core->flags, str))) {\n\t\t\t\top->is_good_flag = true;\n\t\t\t}\n\n\t\t\tchar *p = strchr (str, '-');\n\t\t\tif (p) {\n\t\t\t\top->sign = -1;\n\t\t\t\tstr = ++p;\n\t\t\t}\n\t\t\top->immediate = getnum (a, str);\n\t\t} else if (op->reg < X86R_UNDEFINED) {\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t}\n\t} else {                             // immediate\n\t\t// We don't know the size, so let's just set no size flag.\n\t\top->type = OT_CONSTANT;\n\t\top->sign = 1;\n\t\tchar *p = strchr (str, '-');\n\t\tif (p) {\n\t\t\top->sign = -1;\n\t\t\tstr = ++p;\n\t\t}\n\t\top->immediate = getnum (a, str);\n\t}\n\n\treturn nextpos;\n}", "target": 1, "cwe": ["CWE-119", "CWE-125", "CWE-787"], "project": "radare2", "commit_id": "9b46d38dd3c4de6048a488b655c7319f845af185", "hash": 187843437059074419914917851821968256987, "size": 216, "message": "Fix #12372 and #12373 - Crash in x86 assembler (#12380)\n\n0 ,0,[bP-bL-bP-bL-bL-r-bL-bP-bL-bL-\r\nmov ,0,[ax+Bx-ax+Bx-ax+ax+Bx-ax+Bx--\r\nleA ,0,[bP-bL-bL-bP-bL-bP-bL-60@bL-\r\nleA ,0,[bP-bL-r-bP-bL-bP-bL-60@bL-\r\nmov ,0,[ax+Bx-ax+Bx-ax+ax+Bx-ax+Bx--", "idx": 573}
{"func": "  MonCapParser() : MonCapParser::base_type(moncap)\n  {\n    using qi::char_;\n    using qi::int_;\n    using qi::ulong_long;\n    using qi::lexeme;\n    using qi::alnum;\n    using qi::_val;\n    using qi::_1;\n    using qi::_2;\n    using qi::_3;\n    using qi::eps;\n    using qi::lit;\n\n    quoted_string %=\n      lexeme['\"' >> +(char_ - '\"') >> '\"'] | \n      lexeme['\\'' >> +(char_ - '\\'') >> '\\''];\n    unquoted_word %= +char_(\"a-zA-Z0-9_.-\");\n    str %= quoted_string | unquoted_word;\n\n    spaces = +(lit(' ') | lit('\\n') | lit('\\t'));\n\n    // command := command[=]cmd [k1=v1 k2=v2 ...]\n    str_match = '=' >> qi::attr(StringConstraint::MATCH_TYPE_EQUAL) >> str;\n    str_prefix = spaces >> lit(\"prefix\") >> spaces >>\n                 qi::attr(StringConstraint::MATCH_TYPE_PREFIX) >> str;\n    str_regex = spaces >> lit(\"regex\") >> spaces >>\n                 qi::attr(StringConstraint::MATCH_TYPE_REGEX) >> str;\n    kv_pair = str >> (str_match | str_prefix | str_regex);\n    kv_map %= kv_pair >> *(spaces >> kv_pair);\n    command_match = -spaces >> lit(\"allow\") >> spaces >> lit(\"command\") >> (lit('=') | spaces)\n\t\t\t    >> qi::attr(string()) >> qi::attr(string())\n\t\t\t    >> str\n\t\t\t    >> -(spaces >> lit(\"with\") >> spaces >> kv_map)\n\t\t\t    >> qi::attr(0);\n\n    // service foo rwxa\n    service_match %= -spaces >> lit(\"allow\") >> spaces >> lit(\"service\") >> (lit('=') | spaces)\n\t\t\t     >> str >> qi::attr(string()) >> qi::attr(string())\n\t\t\t     >> qi::attr(map<string,StringConstraint>())\n                             >> spaces >> rwxa;\n\n    // profile foo\n    profile_match %= -spaces >> -(lit(\"allow\") >> spaces)\n                             >> lit(\"profile\") >> (lit('=') | spaces)\n\t\t\t     >> qi::attr(string())\n\t\t\t     >> str\n\t\t\t     >> qi::attr(string())\n\t\t\t     >> qi::attr(map<string,StringConstraint>())\n\t\t\t     >> qi::attr(0);\n\n    // rwxa\n    rwxa_match %= -spaces >> lit(\"allow\") >> spaces\n\t\t\t  >> qi::attr(string()) >> qi::attr(string()) >> qi::attr(string())\n\t\t\t  >> qi::attr(map<string,StringConstraint>())\n\t\t\t  >> rwxa;\n\n    // rwxa := * | [r][w][x]\n    rwxa =\n      (lit(\"*\")[_val = MON_CAP_ANY]) |\n      (lit(\"all\")[_val = MON_CAP_ANY]) |\n      ( eps[_val = 0] >>\n\t( lit('r')[_val |= MON_CAP_R] ||\n\t  lit('w')[_val |= MON_CAP_W] ||\n\t  lit('x')[_val |= MON_CAP_X]\n\t  )\n\t);\n\n    // grant := allow ...\n    grant = -spaces >> (rwxa_match | profile_match | service_match | command_match) >> -spaces;\n\n    // moncap := grant [grant ...]\n    grants %= (grant % (*lit(' ') >> (lit(';') | lit(',')) >> *lit(' ')));\n    moncap = grants  [_val = phoenix::construct<MonCap>(_1)]; \n\n  }", "target": 1, "cwe": ["CWE-285"], "project": "ceph", "commit_id": "a2acedd2a7e12d58af6db35edbd8a9d29c557578", "hash": 298971371164798953931436196723270084064, "size": 76, "message": "mon/config-key: limit caps allowed to access the store\n\nHenceforth, we'll require explicit `allow` caps for commands, or for the\nconfig-key service. Blanket caps are no longer allowed for the\nconfig-key service, except for 'allow *'.\n\n(for luminous and mimic, we're also ensuring MonCap's parser is able to\nunderstand forward slashes '/' when parsing prefixes)\n\nSigned-off-by: Joao Eduardo Luis <joao@suse.de>\n(cherry picked from commit 5fff611041c5afeaf3c8eb09e4de0cc919d69237)", "idx": 574}
{"func": "similar_sgr(char *a, char *b)\n{\n    bool result = FALSE;\n    if (a != 0 && b != 0) {\n\tint csi_a = is_csi(a);\n\tint csi_b = is_csi(b);\n\tsize_t len_a;\n\tsize_t len_b;\n\n\tTR(TRACE_DATABASE, (\"similar_sgr:\\n\\t%s\\n\\t%s\",\n\t\t\t    _nc_visbuf2(1, a),\n\t\t\t    _nc_visbuf2(2, b)));\n\tif (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {\n\t    a += csi_a;\n\t    b += csi_b;\n\t    if (*a != *b) {\n\t\ta = skip_zero(a);\n\t\tb = skip_zero(b);\n\t    }\n\t}\n\tlen_a = strlen(a);\n\tlen_b = strlen(b);\n\tif (len_a && len_b) {\n\t    if (len_a > len_b)\n\t\tresult = (strncmp(a, b, len_b) == 0);\n\t    else\n\t\tresult = (strncmp(a, b, len_a) == 0);\n\t}\n\tTR(TRACE_DATABASE, (\"...similar_sgr: %d\\n\\t%s\\n\\t%s\", result,\n\t\t\t    _nc_visbuf2(1, a),\n\t\t\t    _nc_visbuf2(2, b)));\n    }\n    return result;\n}", "target": 0, "cwe": [], "project": "ncurses", "commit_id": "790a85dbd4a81d5f5d8dd02a44d84f01512ef443", "hash": 72499326094127038432791590742814532753, "size": 34, "message": "ncurses 6.2 - patch 20200531\n\n+ correct configure version-check/warnng for g++ to allow for 10.x\n+ re-enable \"bel\" in konsole-base (report by Nia Huang)\n+ add linux-s entry (patch by Alexandre Montaron).\n+ drop long-obsolete convert_configure.pl\n+ add test/test_parm.c, for checking tparm changes.\n+ improve parameter-checking for tparm, adding function _nc_tiparm() to\n  handle the most-used case, which accepts only numeric parameters\n  (report/testcase by \"puppet-meteor\").\n+ use a more conservative estimate of the buffer-size in lib_tparm.c's\n  save_text() and save_number(), in case the sprintf() function\n  passes-through unexpected characters from a format specifier\n  (report/testcase by \"puppet-meteor\").\n+ add a check for end-of-string in cvtchar to handle a malformed\n  string in infotocap (report/testcase by \"puppet-meteor\").", "idx": 575}
{"func": "rsvg_dpi_percentage (RsvgHandle * ctx)\n{\n    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);\n}", "target": 0, "cwe": ["CWE-20"], "project": "librsvg", "commit_id": "d1c9191949747f6dcfd207831d15dd4ba00e31f2", "hash": 99747065772439927318217265071800455568, "size": 4, "message": "state: Store mask as reference\n\nInstead of immediately looking up the mask, store the reference and look\nit up on use.", "idx": 576}
{"func": "ospf6_print(netdissect_options *ndo,\n            register const u_char *bp, register u_int length)\n{\n\tregister const struct ospf6hdr *op;\n\tregister const u_char *dataend;\n\tregister const char *cp;\n\tuint16_t datalen;\n\n\top = (const struct ospf6hdr *)bp;\n\n\t/* If the type is valid translate it, or just print the type */\n\t/* value.  If it's not valid, say so and return */\n\tND_TCHECK(op->ospf6_type);\n\tcp = tok2str(ospf6_type_values, \"unknown packet type (%u)\", op->ospf6_type);\n\tND_PRINT((ndo, \"OSPFv%u, %s, length %d\", op->ospf6_version, cp, length));\n\tif (*cp == 'u') {\n\t\treturn;\n\t}\n\n\tif(!ndo->ndo_vflag) { /* non verbose - so lets bail out here */\n\t\treturn;\n\t}\n\n\t/* OSPFv3 data always comes first and optional trailing data may follow. */\n\tND_TCHECK(op->ospf6_len);\n\tdatalen = EXTRACT_16BITS(&op->ospf6_len);\n\tif (datalen > length) {\n\t\tND_PRINT((ndo, \" [len %d]\", datalen));\n\t\treturn;\n\t}\n\tdataend = bp + datalen;\n\n\tND_TCHECK(op->ospf6_routerid);\n\tND_PRINT((ndo, \"\\n\\tRouter-ID %s\", ipaddr_string(ndo, &op->ospf6_routerid)));\n\n\tND_TCHECK(op->ospf6_areaid);\n\tif (EXTRACT_32BITS(&op->ospf6_areaid) != 0)\n\t\tND_PRINT((ndo, \", Area %s\", ipaddr_string(ndo, &op->ospf6_areaid)));\n\telse\n\t\tND_PRINT((ndo, \", Backbone Area\"));\n\tND_TCHECK(op->ospf6_instanceid);\n\tif (op->ospf6_instanceid)\n\t\tND_PRINT((ndo, \", Instance %u\", op->ospf6_instanceid));\n\n\t/* Do rest according to version.\t */\n\tswitch (op->ospf6_version) {\n\n\tcase 3:\n\t\t/* ospf version 3 */\n\t\tif (ospf6_decode_v3(ndo, op, dataend) ||\n\t\t    ospf6_decode_v3_trailer(ndo, op, dataend, length - datalen))\n\t\t\tgoto trunc;\n\t\tbreak;\n\t}\t\t\t/* end switch on version */\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}", "target": 0, "cwe": ["CWE-125"], "project": "tcpdump", "commit_id": "e01c9bf76740802025c9328901b55ee4a0c49ed6", "hash": 234314249949875943011847804811170323530, "size": 59, "message": "(for 4.9.3) CVE-2018-14880/OSPFv3: Fix a bounds check\n\nNeed to test bounds check for the last field of the structure lsa6_hdr.\nNo need to test other fields.\n\nInclude Security working under the Mozilla SOS program had independently\nidentified this vulnerability in 2018 by means of code audit.\n\nWang Junjie of 360 ESG Codesafe Team had independently identified this\nvulnerability in 2018 by means of fuzzing and provided the packet capture\nfile for the test.", "idx": 577}
{"func": "int ssl3_get_server_hello(SSL *s)\n{\n    STACK_OF(SSL_CIPHER) *sk;\n    const SSL_CIPHER *c;\n    CERT *ct = s->cert;\n    unsigned char *p, *d;\n    int i, al = SSL_AD_INTERNAL_ERROR, ok;\n    unsigned int j;\n    long n;\n#ifndef OPENSSL_NO_COMP\n    SSL_COMP *comp;\n#endif\n    /*\n     * Hello verify request and/or server hello version may not match so set\n     * first packet if we're negotiating version.\n     */\n    if (SSL_IS_DTLS(s))\n        s->first_packet = 1;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SRVR_HELLO_A,\n                                   SSL3_ST_CR_SRVR_HELLO_B, -1, 20000, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    if (SSL_IS_DTLS(s)) {\n        s->first_packet = 0;\n        if (s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n            if (s->d1->send_cookie == 0) {\n                s->s3->tmp.reuse_message = 1;\n                return 1;\n            } else {            /* already sent a cookie */\n\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n                goto f_err;\n            }\n        }\n    }\n\n    if (s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n        goto f_err;\n    }\n\n    d = p = (unsigned char *)s->init_msg;\n    if (s->method->version == DTLS_ANY_VERSION) {\n        /* Work out correct protocol version to use */\n        int hversion = (p[0] << 8) | p[1];\n        int options = s->options;\n        if (hversion == DTLS1_2_VERSION && !(options & SSL_OP_NO_DTLSv1_2))\n            s->method = DTLSv1_2_client_method();\n        else if (tls1_suiteb(s)) {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n                   SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n            s->version = hversion;\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        } else if (hversion == DTLS1_VERSION && !(options & SSL_OP_NO_DTLSv1))\n            s->method = DTLSv1_client_method();\n        else {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);\n            s->version = hversion;\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        }\n        s->version = s->method->version;\n    }\n\n    if ((p[0] != (s->version >> 8)) || (p[1] != (s->version & 0xff))) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);\n        s->version = (s->version & 0xff00) | p[1];\n        al = SSL_AD_PROTOCOL_VERSION;\n        goto f_err;\n    }\n    p += 2;\n\n    /* load the server hello data */\n    /* load the server random */\n    memcpy(s->s3->server_random, p, SSL3_RANDOM_SIZE);\n    p += SSL3_RANDOM_SIZE;\n\n    s->hit = 0;\n\n    /* get the session-id */\n    j = *(p++);\n\n    if ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_SSL3_SESSION_ID_TOO_LONG);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_TLSEXT\n    /*\n     * Check if we can resume the session based on external pre-shared secret.\n     * EAP-FAST (RFC 4851) supports two types of session resumption.\n     * Resumption based on server-side state works with session IDs.\n     * Resumption based on pre-shared Protected Access Credentials (PACs)\n     * works by overriding the SessionTicket extension at the application\n     * layer, and does not send a session ID. (We do not know whether EAP-FAST\n     * servers would honour the session ID.) Therefore, the session ID alone\n     * is not a reliable indicator of session resumption, so we first check if\n     * we can resume, and later peek at the next handshake message to see if the\n     * server wants to resume.\n     */\n    if (s->version >= TLS1_VERSION && s->tls_session_secret_cb &&\n        s->session->tlsext_tick) {\n        SSL_CIPHER *pref_cipher = NULL;\n        s->session->master_key_length = sizeof(s->session->master_key);\n        if (s->tls_session_secret_cb(s, s->session->master_key,\n                                     &s->session->master_key_length,\n                                     NULL, &pref_cipher,\n                                     s->tls_session_secret_cb_arg)) {\n            s->session->cipher = pref_cipher ?\n                pref_cipher : ssl_get_cipher_by_char(s, p + j);\n        } else {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto f_err;\n        }\n    }\n#endif                          /* OPENSSL_NO_TLSEXT */\n\n    if (j != 0 && j == s->session->session_id_length\n        && memcmp(p, s->session->session_id, j) == 0) {\n        if (s->sid_ctx_length != s->session->sid_ctx_length\n            || memcmp(s->session->sid_ctx, s->sid_ctx, s->sid_ctx_length)) {\n            /* actually a client application bug */\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n                   SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\n            goto f_err;\n        }\n        s->hit = 1;\n    } else {\n        /*\n         * If we were trying for session-id reuse but the server\n         * didn't echo the ID, make a new SSL_SESSION.\n         * In the case of EAP-FAST and PAC, we do not send a session ID,\n         * so the PAC-based session secret is always preserved. It'll be\n         * overwritten if the server refuses resumption.\n         */\n        if (s->session->session_id_length > 0) {\n            if (!ssl_get_new_session(s, 0)) {\n                goto f_err;\n            }\n        }\n        s->session->session_id_length = j;\n        memcpy(s->session->session_id, p, j); /* j could be 0 */\n    }\n    p += j;\n    c = ssl_get_cipher_by_char(s, p);\n    if (c == NULL) {\n        /* unknown cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNKNOWN_CIPHER_RETURNED);\n        goto f_err;\n    }\n    /*\n     * If it is a disabled cipher we didn't send it in client hello, so\n     * return an error.\n     */\n    if (c->algorithm_ssl & ct->mask_ssl ||\n        c->algorithm_mkey & ct->mask_k || c->algorithm_auth & ct->mask_a) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n    p += ssl_put_cipher_by_char(s, NULL, NULL);\n\n    sk = ssl_get_ciphers_by_id(s);\n    i = sk_SSL_CIPHER_find(sk, c);\n    if (i < 0) {\n        /* we did not say we would use this cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n\n    /*\n     * Depending on the session caching (internal/external), the cipher\n     * and/or cipher_id values may not be set. Make sure that cipher_id is\n     * set and use it for comparison.\n     */\n    if (s->session->cipher)\n        s->session->cipher_id = s->session->cipher->id;\n    if (s->hit && (s->session->cipher_id != c->id)) {\n/* Workaround is now obsolete */\n#if 0\n        if (!(s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))\n#endif\n        {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n                   SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\n            goto f_err;\n        }\n    }\n    s->s3->tmp.new_cipher = c;\n    /*\n     * Don't digest cached records if no sigalgs: we may need them for client\n     * authentication.\n     */\n    if (!SSL_USE_SIGALGS(s) && !ssl3_digest_cached_records(s))\n        goto f_err;\n    /* lets get the compression algorithm */\n    /* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n    if (*(p++) != 0) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    }\n    /*\n     * If compression is disabled we'd better not try to resume a session\n     * using compression.\n     */\n    if (s->session->compress_meth != 0) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_INCONSISTENT_COMPRESSION);\n        goto f_err;\n    }\n#else\n    j = *(p++);\n    if (s->hit && j != s->session->compress_meth) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);\n        goto f_err;\n    }\n    if (j == 0)\n        comp = NULL;\n    else if (s->options & SSL_OP_NO_COMPRESSION) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_COMPRESSION_DISABLED);\n        goto f_err;\n    } else\n        comp = ssl3_comp_find(s->ctx->comp_methods, j);\n\n    if ((j != 0) && (comp == NULL)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    } else {\n        s->s3->tmp.new_compression = comp;\n    }\n#endif\n\n#ifndef OPENSSL_NO_TLSEXT\n    /* TLS extensions */\n    if (!ssl_parse_serverhello_tlsext(s, &p, d, n)) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_PARSE_TLSEXT);\n        goto err;\n    }\n#endif\n\n    if (p != (d + n)) {\n        /* wrong packet length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_PACKET_LENGTH);\n        goto f_err;\n    }\n\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "target": 0, "cwe": ["CWE-310"], "project": "openssl", "commit_id": "10a70da729948bb573d27cef4459077c49f3eb46", "hash": 331425792678660436461198967913083472612, "size": 273, "message": "client: reject handshakes with DH parameters < 768 bits.\n\nSince the client has no way of communicating her supported parameter\nrange to the server, connections to servers that choose weak DH will\nsimply fail.\n\nReviewed-by: Kurt Roeckx <kurt@openssl.org>", "idx": 578}
{"func": "HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)\n{\n\tint n = 0;\n\tchar *reason = NULL;\n\trfbClientToServerTightMsg msg;\n\n\tmemset(&msg, 0, sizeof(rfbClientToServerTightMsg));\n\t\n\tif((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);\n\n\tif(msg.fdc.reasonLen == 0) {\n\t\trfbLog(\"File [%s]: Method [%s]: reason length received is Zero\\n\",\n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\t\n\treason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));\n\tif(reason == NULL) {\n\t\trfbLog(\"File [%s]: Method [%s]: Fatal Error: Memory alloc failed\\n\", \n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\n\tif((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t}\n\n\trfbLog(\"File [%s]: Method [%s]: File Download Cancel Request received:\"\n\t\t\t\t\t\" reason <%s>\\n\", __FILE__, __FUNCTION__, reason);\n\t\n\tpthread_mutex_lock(&fileDownloadMutex);\n\tCloseUndoneFileTransfer(cl, rtcp);\n\tpthread_mutex_unlock(&fileDownloadMutex);\n\t\n\tif(reason != NULL) {\n\t\tfree(reason);\n\t\treason = NULL;\n\t}\n\n}", "target": 1, "cwe": ["CWE-416"], "project": "libvncserver", "commit_id": "ca2a5ac02fbbadd0a21fabba779c1ea69173d10b", "hash": 26239629721356181132082331238417966035, "size": 55, "message": "tightvnc-filetransfer: fix heap use-after-free\n\nOne can only guess what the intended semantics were here, but as every\nother rfbCloseClient() call in this file is followed by an immediate\nreturn, let's assume this was forgotton in this case.\n\nAnyway, don't forget to clean up to not leak memory.\n\nCloses #241", "idx": 579}
{"func": "int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,\n                                             EC_POINT *point, const BIGNUM *x,\n                                             const BIGNUM *y, const BIGNUM *z,\n                                             BN_CTX *ctx)\n{\n    if (group->meth->point_set_Jprojective_coordinates_GFp == 0) {\n        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,\n              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (!ec_point_is_compat(point, group)) {\n        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,\n              EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    return group->meth->point_set_Jprojective_coordinates_GFp(group, point, x,\n                                                              y, z, ctx);\n}", "target": 0, "cwe": [], "project": "openssl", "commit_id": "30c22fa8b1d840036b8e203585738df62a03cec8", "hash": 117902564331219714434627143053402902832, "size": 18, "message": "[crypto/ec] for ECC parameters with NULL or zero cofactor, compute it\n\nThe cofactor argument to EC_GROUP_set_generator is optional, and SCA\nmitigations for ECC currently use it. So the library currently falls\nback to very old SCA-vulnerable code if the cofactor is not present.\n\nThis PR allows EC_GROUP_set_generator to compute the cofactor for all\ncurves of cryptographic interest. Steering scalar multiplication to more\nSCA-robust code.\n\nThis issue affects persisted private keys in explicit parameter form,\nwhere the (optional) cofactor field is zero or absent.\n\nIt also affects curves not built-in to the library, but constructed\nprogramatically with explicit parameters, then calling\nEC_GROUP_set_generator with a nonsensical value (NULL, zero).\n\nThe very old scalar multiplication code is known to be vulnerable to\nlocal uarch attacks, outside of the OpenSSL threat model. New results\nsuggest the code path is also vulnerable to traditional wall clock\ntiming attacks.\n\nCVE-2019-1547\n\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\n(Merged from https://github.com/openssl/openssl/pull/9781)", "idx": 580}
{"func": "unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)\n\t{\n\tint extdatalen=0;\n\tunsigned char *ret = p;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\tint next_proto_neg_seen;\n#endif\n\n\t/* don't add extensions for SSLv3, unless doing secure renegotiation */\n\tif (s->version == SSL3_VERSION && !s->s3->send_connection_binding)\n\t\treturn p;\n\t\n\tret+=2;\n\tif (ret>=limit) return NULL; /* this really never occurs, but ... */\n\n\tif (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)\n\t\t{ \n\t\tif ((long)(limit - ret - 4) < 0) return NULL; \n\n\t\ts2n(TLSEXT_TYPE_server_name,ret);\n\t\ts2n(0,ret);\n\t\t}\n\n\tif(s->s3->send_connection_binding)\n        {\n          int el;\n          \n          if(!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0))\n              {\n              SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n              return NULL;\n              }\n\n          if((limit - p - 4 - el) < 0) return NULL;\n          \n          s2n(TLSEXT_TYPE_renegotiate,ret);\n          s2n(el,ret);\n\n          if(!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el))\n              {\n              SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n              return NULL;\n              }\n\n          ret += el;\n        }\n\n#ifndef OPENSSL_NO_EC\n\tif (s->tlsext_ecpointformatlist != NULL &&\n\t    s->version != DTLS1_VERSION)\n\t\t{\n\t\t/* Add TLS extension ECPointFormats to the ServerHello message */\n\t\tlong lenmax; \n\n\t\tif ((lenmax = limit - ret - 5) < 0) return NULL; \n\t\tif (s->tlsext_ecpointformatlist_length > (unsigned long)lenmax) return NULL;\n\t\tif (s->tlsext_ecpointformatlist_length > 255)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t\n\t\ts2n(TLSEXT_TYPE_ec_point_formats,ret);\n\t\ts2n(s->tlsext_ecpointformatlist_length + 1,ret);\n\t\t*(ret++) = (unsigned char) s->tlsext_ecpointformatlist_length;\n\t\tmemcpy(ret, s->tlsext_ecpointformatlist, s->tlsext_ecpointformatlist_length);\n\t\tret+=s->tlsext_ecpointformatlist_length;\n\n\t\t}\n\t/* Currently the server should not respond with a SupportedCurves extension */\n#endif /* OPENSSL_NO_EC */\n\n\tif (s->tlsext_ticket_expected\n\t\t&& !(SSL_get_options(s) & SSL_OP_NO_TICKET)) \n\t\t{ \n\t\tif ((long)(limit - ret - 4) < 0) return NULL; \n\t\ts2n(TLSEXT_TYPE_session_ticket,ret);\n\t\ts2n(0,ret);\n\t\t}\n\n\tif (s->tlsext_status_expected)\n\t\t{ \n\t\tif ((long)(limit - ret - 4) < 0) return NULL; \n\t\ts2n(TLSEXT_TYPE_status_request,ret);\n\t\ts2n(0,ret);\n\t\t}\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tif (s->s3->server_opaque_prf_input != NULL &&\n\t    s->version != DTLS1_VERSION)\n\t\t{\n\t\tsize_t sol = s->s3->server_opaque_prf_input_len;\n\t\t\n\t\tif ((long)(limit - ret - 6 - sol) < 0)\n\t\t\treturn NULL;\n\t\tif (sol > 0xFFFD) /* can't happen */\n\t\t\treturn NULL;\n\n\t\ts2n(TLSEXT_TYPE_opaque_prf_input, ret); \n\t\ts2n(sol + 2, ret);\n\t\ts2n(sol, ret);\n\t\tmemcpy(ret, s->s3->server_opaque_prf_input, sol);\n\t\tret += sol;\n\t\t}\n#endif\n\n        if(s->srtp_profile)\n                {\n                int el;\n\n                ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);\n                \n                if((limit - p - 4 - el) < 0) return NULL;\n\n                s2n(TLSEXT_TYPE_use_srtp,ret);\n                s2n(el,ret);\n\n                if(ssl_add_serverhello_use_srtp_ext(s, ret, &el, el))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n                ret+=el;\n                }\n\n\tif (((s->s3->tmp.new_cipher->id & 0xFFFF)==0x80 || (s->s3->tmp.new_cipher->id & 0xFFFF)==0x81) \n\t\t&& (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG))\n\t\t{ const unsigned char cryptopro_ext[36] = {\n\t\t\t0xfd, 0xe8, /*65000*/\n\t\t\t0x00, 0x20, /*32 bytes length*/\n\t\t\t0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, \n\t\t\t0x03,   0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06, \n\t\t\t0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08, \n\t\t\t0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17};\n\t\t\tif (limit-ret<36) return NULL;\n\t\t\tmemcpy(ret,cryptopro_ext,36);\n\t\t\tret+=36;\n\n\t\t}\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\tnext_proto_neg_seen = s->s3->next_proto_neg_seen;\n\ts->s3->next_proto_neg_seen = 0;\n\tif (next_proto_neg_seen && s->ctx->next_protos_advertised_cb)\n\t\t{\n\t\tconst unsigned char *npa;\n\t\tunsigned int npalen;\n\t\tint r;\n\n\t\tr = s->ctx->next_protos_advertised_cb(s, &npa, &npalen, s->ctx->next_protos_advertised_cb_arg);\n\t\tif (r == SSL_TLSEXT_ERR_OK)\n\t\t\t{\n\t\t\tif ((long)(limit - ret - 4 - npalen) < 0) return NULL;\n\t\t\ts2n(TLSEXT_TYPE_next_proto_neg,ret);\n\t\t\ts2n(npalen,ret);\n\t\t\tmemcpy(ret, npa, npalen);\n\t\t\tret += npalen;\n\t\t\ts->s3->next_proto_neg_seen = 1;\n\t\t\t}\n\t\t}\n#endif\n\n\tif ((extdatalen = ret-p-2)== 0) \n\t\treturn p;\n\n\ts2n(extdatalen,p);\n\treturn ret;\n\t}", "target": 1, "cwe": [], "project": "openssl", "commit_id": "4817504d069b4c5082161b02a22116ad75f822b1", "hash": 136320064880633326796065269636506973024, "size": 168, "message": "PR: 2658\nSubmitted by: Robin Seggelmann <seggelmann@fh-muenster.de>\nReviewed by: steve\n\nSupport for TLS/DTLS heartbeats.", "idx": 581}
{"func": "static int usbredir_get_bufpq(QEMUFile *f, void *priv, size_t unused,\n                              const VMStateField *field)\n{\n    struct endp_data *endp = priv;\n    USBRedirDevice *dev = endp->dev;\n    struct buf_packet *bufp;\n    int i;\n\n    endp->bufpq_size = qemu_get_be32(f);\n    for (i = 0; i < endp->bufpq_size; i++) {\n        bufp = g_new(struct buf_packet, 1);\n        bufp->len = qemu_get_be32(f);\n        bufp->status = qemu_get_be32(f);\n        bufp->offset = 0;\n        bufp->data = qemu_oom_check(malloc(bufp->len)); /* regular malloc! */\n        bufp->free_on_destroy = bufp->data;\n        qemu_get_buffer(f, bufp->data, bufp->len);\n        QTAILQ_INSERT_TAIL(&endp->bufpq, bufp, next);\n        DPRINTF(\"get_bufpq %d/%d len %d status %d\\n\", i + 1, endp->bufpq_size,\n                bufp->len, bufp->status);\n    }\n    return 0;\n}", "target": 0, "cwe": ["CWE-770"], "project": "qemu", "commit_id": "7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986", "hash": 30365511408481543932832283077782944116, "size": 23, "message": "usb/redir: avoid dynamic stack allocation (CVE-2021-3527)\n\nUse autofree heap allocation instead.\n\nFixes: 4f4321c11ff (\"usb: use iovecs in USBPacket\")\nReviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nTested-by: Philippe Mathieu-Daudé <philmd@redhat.com>\nMessage-Id: <20210503132915.2335822-3-kraxel@redhat.com>", "idx": 582}
{"func": "static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf,\n                                          size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->handshake->new_session_ticket == 0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding session ticket extension\" ) );\n\n    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );\n    p += 2;\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}", "target": 0, "cwe": ["CWE-787"], "project": "mbedtls", "commit_id": "f333dfab4a6c2d8a604a61558a8f783145161de4", "hash": 22162908263898815122225607133320092194, "size": 22, "message": "More SSL debug messages for ClientHello parsing\n\nIn particular, be verbose when checking the ClientHello cookie in a possible\nDTLS reconnection.\n\nSigned-off-by: Gilles Peskine <Gilles.Peskine@arm.com>", "idx": 583}
{"func": "dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,\n  const uschar **fully_qualified_name)\n{\nint retval;\nunsigned long time_msec;\n\nif (!slow_lookup_log)\n  return dns_lookup(dnsa, name, type, fully_qualified_name);\n\ntime_msec = get_time_in_ms();\nretval = dns_lookup(dnsa, name, type, fully_qualified_name);\nif ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)\n  log_long_lookup(dns_text_type(type), name, time_msec);\nreturn retval;\n}", "target": 0, "cwe": ["CWE-787"], "project": "exim", "commit_id": "d4bc023436e4cce7c23c5f8bb5199e178b4cc743", "hash": 328175832208838621860688864575590500142, "size": 15, "message": "Fix host_name_lookup (Close 2747)\n\nThanks to Nico R for providing a reproducing configuration.\n\n        host_lookup             = *\n        message_size_limit      = ${if def:sender_host_name {32M}{32M}}\n        acl_smtp_connect        = acl_smtp_connect\n        acl_smtp_rcpt           = acl_smtp_rcpt\n\n        begin acl\n          acl_smtp_connect:\n                warn ratelimit = 256 / 1m / per_conn\n                accept\n\n          acl_smtp_rcpt:\n                accept hosts = 127.0.0.*\n\n        begin routers\n        null:\n          driver          = accept\n          transport       = null\n\n        begin transports\n        null:\n          driver          = appendfile\n          file            = /dev/null\n\nTested with\n\n        swaks -f mailbox@example.org -t mailbox@example.org --pipe 'exim -bh 127.0.0.1 -C /opt/exim/etc/exim-bug.conf'\n\nThe IP must have a PTR to \"localhost.\" to reproduce it.\n\n(cherry picked from commit 20812729e3e47a193a21d326ecd036d67a8b2724)", "idx": 584}
{"func": "dissect_dch_rx_timing_deviation(packet_info *pinfo, proto_tree *tree,\n                                tvbuff_t *tvb, int offset,\n                                struct fp_info *p_fp_info)\n{\n    guint16     timing_deviation;\n    gint        timing_deviation_chips;\n    proto_item *timing_deviation_ti;\n\n    /* CFN control */\n    proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Rx Timing Deviation */\n    timing_deviation = tvb_get_guint8(tvb, offset);\n    timing_deviation_ti = proto_tree_add_item(tree, hf_fp_dch_rx_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* May be extended in R7, but in this case there are at least 2 bytes remaining */\n    if ((p_fp_info->release == 7) &&\n        (tvb_reported_length_remaining(tvb, offset) >= 2)) {\n\n        /* New IE flags */\n        guint64 extended_bits_present;\n        guint64 e_rucch_present;\n\n        /* Read flags */\n        proto_tree_add_bits_ret_val(tree, hf_fp_e_rucch_present, tvb,\n                                    offset*8 + 6, 1, &e_rucch_present, ENC_BIG_ENDIAN);\n        proto_tree_add_bits_ret_val(tree, hf_fp_extended_bits_present, tvb,\n                                    offset*8 + 7, 1, &extended_bits_present, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Optional E-RUCCH */\n        if (e_rucch_present) {\n\n            /* Value of bit_offset depends upon division type */\n            int bit_offset;\n\n            switch (p_fp_info->division) {\n                case Division_TDD_384:\n                    bit_offset = 6;\n                    break;\n                case Division_TDD_768:\n                    bit_offset = 5;\n                    break;\n                default:\n                    {\n                        proto_tree_add_expert(tree, pinfo, &ei_fp_expecting_tdd, tvb, 0, 0);\n                        bit_offset = 6;\n                    }\n            }\n\n            proto_tree_add_item(tree, hf_fp_dch_e_rucch_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\n            proto_tree_add_bits_item(tree, hf_fp_dch_e_rucch_flag, tvb,\n                                     offset*8 + bit_offset, 1, ENC_BIG_ENDIAN);\n        }\n\n        /* Timing deviation may be extended by another:\n           - 1 bits (3.84 TDD)    OR\n           - 2 bits (7.68 TDD)\n        */\n        if (extended_bits_present) {\n            guint8 extra_bits;\n            guint bits_to_extend;\n            switch (p_fp_info->division) {\n                case Division_TDD_384:\n                    bits_to_extend = 1;\n                    break;\n                case Division_TDD_768:\n                    bits_to_extend = 2;\n                    break;\n\n                default:\n                    /* TODO: report unexpected division type */\n                    bits_to_extend = 1;\n                    break;\n            }\n            extra_bits = tvb_get_guint8(tvb, offset) &\n                             ((bits_to_extend == 1) ? 0x01 : 0x03);\n            timing_deviation = (extra_bits << 8) | (timing_deviation);\n            proto_item_append_text(timing_deviation_ti,\n                                   \" (extended to 0x%x)\",\n                                   timing_deviation);\n            proto_tree_add_bits_item(tree, hf_fp_extended_bits, tvb,\n                                     offset*8 + (8-bits_to_extend), bits_to_extend, ENC_BIG_ENDIAN);\n            offset++;\n        }\n    }\n\n    timing_deviation_chips = (timing_deviation*4) - 1024;\n    proto_item_append_text(timing_deviation_ti, \" (%d chips)\",\n                           timing_deviation_chips);\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" deviation = %u (%d chips)\",\n                    timing_deviation, timing_deviation_chips);\n\n    return offset;\n}", "target": 0, "cwe": ["CWE-20"], "project": "wireshark", "commit_id": "7d7190695ce2ff269fdffb04e87139995cde21f4", "hash": 4928825820678075322429367424594939637, "size": 98, "message": "UMTS_FP: fix handling reserved C/T value\n\nThe spec puts the reserved value at 0xf but our internal table has 'unknown' at\n0; since all the other values seem to be offset-by-one, just take the modulus\n0xf to avoid running off the end of the table.\n\nBug: 12191\nChange-Id: I83c8fb66797bbdee52a2246fb1eea6e37cbc7eb0\nReviewed-on: https://code.wireshark.org/review/15722\nReviewed-by: Evan Huus <eapache@gmail.com>\nPetri-Dish: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>", "idx": 585}
{"func": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 1, "cwe": ["CWE-703"], "project": "FFmpeg", "commit_id": "f173cdfe669556aa92857adafe60cbe5f2aa1210", "hash": 178483649043238657007421376841518450298, "size": 22, "message": "avformat/mxfdec: Fix DoS issues in mxf_read_index_entry_array()\n\nFixes: 20170829A.mxf\n\nCo-Author: 张洪亮(望初)\" <wangchu.zhl@alibaba-inc.com>\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 900f39692ca0337a98a7cf047e4e2611071810c2)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>", "idx": 586}
{"func": "  QUInt16() {}", "target": 1, "cwe": ["CWE-908", "CWE-787"], "project": "tensorflow", "commit_id": "ace0c15a22f7f054abcc1f53eabbcb0a1239a9e2", "hash": 221629453572736957963406356171784260674, "size": 1, "message": "Default initialize fixed point Eigen types.\n\nIn certain cases, tensors are filled with default values of the type. But, for these fixed point types, these values were uninitialized. Thus, we would have uninitialized memory access bugs, some of which were caught by MSAN.\n\nPiperOrigin-RevId: 344101137\nChange-Id: I14555fda74dca3b5f1582da9008901937e3f14e2", "idx": 587}
{"func": "ZSTD_encodeSequences_body(\n            void* dst, size_t dstCapacity,\n            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,\n            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,\n            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,\n            seqDef const* sequences, size_t nbSeq, int longOffsets)\n{\n    BIT_CStream_t blockStream;\n    FSE_CState_t  stateMatchLength;\n    FSE_CState_t  stateOffsetBits;\n    FSE_CState_t  stateLitLength;\n\n    CHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall); /* not enough space remaining */\n\n    /* first symbols */\n    FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);\n    FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);\n    FSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);\n    BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);\n    if (MEM_32bits()) BIT_flushBits(&blockStream);\n    BIT_addBits(&blockStream, sequences[nbSeq-1].matchLength, ML_bits[mlCodeTable[nbSeq-1]]);\n    if (MEM_32bits()) BIT_flushBits(&blockStream);\n    if (longOffsets) {\n        U32 const ofBits = ofCodeTable[nbSeq-1];\n        int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);\n        if (extraBits) {\n            BIT_addBits(&blockStream, sequences[nbSeq-1].offset, extraBits);\n            BIT_flushBits(&blockStream);\n        }\n        BIT_addBits(&blockStream, sequences[nbSeq-1].offset >> extraBits,\n                    ofBits - extraBits);\n    } else {\n        BIT_addBits(&blockStream, sequences[nbSeq-1].offset, ofCodeTable[nbSeq-1]);\n    }\n    BIT_flushBits(&blockStream);\n\n    {   size_t n;\n        for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */\n            BYTE const llCode = llCodeTable[n];\n            BYTE const ofCode = ofCodeTable[n];\n            BYTE const mlCode = mlCodeTable[n];\n            U32  const llBits = LL_bits[llCode];\n            U32  const ofBits = ofCode;\n            U32  const mlBits = ML_bits[mlCode];\n            DEBUGLOG(6, \"encoding: litlen:%2u - matchlen:%2u - offCode:%7u\",\n                        sequences[n].litLength,\n                        sequences[n].matchLength + MINMATCH,\n                        sequences[n].offset);\n                                                                            /* 32b*/  /* 64b*/\n                                                                            /* (7)*/  /* (7)*/\n            FSE_encodeSymbol(&blockStream, &stateOffsetBits, ofCode);       /* 15 */  /* 15 */\n            FSE_encodeSymbol(&blockStream, &stateMatchLength, mlCode);      /* 24 */  /* 24 */\n            if (MEM_32bits()) BIT_flushBits(&blockStream);                  /* (7)*/\n            FSE_encodeSymbol(&blockStream, &stateLitLength, llCode);        /* 16 */  /* 33 */\n            if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))\n                BIT_flushBits(&blockStream);                                /* (7)*/\n            BIT_addBits(&blockStream, sequences[n].litLength, llBits);\n            if (MEM_32bits() && ((llBits+mlBits)>24)) BIT_flushBits(&blockStream);\n            BIT_addBits(&blockStream, sequences[n].matchLength, mlBits);\n            if (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);\n            if (longOffsets) {\n                int const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);\n                if (extraBits) {\n                    BIT_addBits(&blockStream, sequences[n].offset, extraBits);\n                    BIT_flushBits(&blockStream);                            /* (7)*/\n                }\n                BIT_addBits(&blockStream, sequences[n].offset >> extraBits,\n                            ofBits - extraBits);                            /* 31 */\n            } else {\n                BIT_addBits(&blockStream, sequences[n].offset, ofBits);     /* 31 */\n            }\n            BIT_flushBits(&blockStream);                                    /* (7)*/\n    }   }\n\n    DEBUGLOG(6, \"ZSTD_encodeSequences: flushing ML state with %u bits\", stateMatchLength.stateLog);\n    FSE_flushCState(&blockStream, &stateMatchLength);\n    DEBUGLOG(6, \"ZSTD_encodeSequences: flushing Off state with %u bits\", stateOffsetBits.stateLog);\n    FSE_flushCState(&blockStream, &stateOffsetBits);\n    DEBUGLOG(6, \"ZSTD_encodeSequences: flushing LL state with %u bits\", stateLitLength.stateLog);\n    FSE_flushCState(&blockStream, &stateLitLength);\n\n    {   size_t const streamSize = BIT_closeCStream(&blockStream);\n        if (streamSize==0) return ERROR(dstSize_tooSmall);   /* not enough space */\n        return streamSize;\n    }\n}", "target": 1, "cwe": ["CWE-362"], "project": "zstd", "commit_id": "3e5cdf1b6a85843e991d7d10f6a2567c15580da0", "hash": 286572440669744595489615703868010253008, "size": 86, "message": "fixed T36302429", "idx": 588}
{"func": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    /* we have an error following */\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}", "target": 1, "cwe": ["CWE-787"], "project": "libvncserver", "commit_id": "e34bcbb759ca5bef85809967a268fdf214c1ad2c", "hash": 203894553166753742137856105884272995172, "size": 14, "message": "LibVNCClient: ignore server-sent reason strings longer than 1MB\n\nFixes #273", "idx": 589}
{"func": "static opj_pi_iterator_t * opj_pi_create(const opj_image_t *image,\n        const opj_cp_t *cp,\n        OPJ_UINT32 tileno)\n{\n    /* loop*/\n    OPJ_UINT32 pino, compno;\n    /* number of poc in the p_pi*/\n    OPJ_UINT32 l_poc_bound;\n\n    /* pointers to tile coding parameters and components.*/\n    opj_pi_iterator_t *l_pi = 00;\n    opj_tcp_t *tcp = 00;\n    const opj_tccp_t *tccp = 00;\n\n    /* current packet iterator being allocated*/\n    opj_pi_iterator_t *l_current_pi = 00;\n\n    /* preconditions in debug*/\n    assert(cp != 00);\n    assert(image != 00);\n    assert(tileno < cp->tw * cp->th);\n\n    /* initializations*/\n    tcp = &cp->tcps[tileno];\n    l_poc_bound = tcp->numpocs + 1;\n\n    /* memory allocations*/\n    l_pi = (opj_pi_iterator_t*) opj_calloc((l_poc_bound),\n                                           sizeof(opj_pi_iterator_t));\n    if (!l_pi) {\n        return NULL;\n    }\n\n    l_current_pi = l_pi;\n    for (pino = 0; pino < l_poc_bound ; ++pino) {\n\n        l_current_pi->comps = (opj_pi_comp_t*) opj_calloc(image->numcomps,\n                              sizeof(opj_pi_comp_t));\n        if (! l_current_pi->comps) {\n            opj_pi_destroy(l_pi, l_poc_bound);\n            return NULL;\n        }\n\n        l_current_pi->numcomps = image->numcomps;\n\n        for (compno = 0; compno < image->numcomps; ++compno) {\n            opj_pi_comp_t *comp = &l_current_pi->comps[compno];\n\n            tccp = &tcp->tccps[compno];\n\n            comp->resolutions = (opj_pi_resolution_t*) opj_calloc(tccp->numresolutions,\n                                sizeof(opj_pi_resolution_t));\n            if (!comp->resolutions) {\n                opj_pi_destroy(l_pi, l_poc_bound);\n                return 00;\n            }\n\n            comp->numresolutions = tccp->numresolutions;\n        }\n        ++l_current_pi;\n    }\n    return l_pi;\n}", "target": 1, "cwe": ["CWE-122"], "project": "openjpeg", "commit_id": "00383e162ae2f8fc951f5745bf1011771acb8dce", "hash": 56014134086012693286943104270479889643, "size": 63, "message": "pi.c: avoid out of bounds access with POC (refs https://github.com/uclouvain/openjpeg/issues/1293#issuecomment-737122836)", "idx": 590}
{"func": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc(reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "target": 1, "cwe": ["CWE-787"], "project": "libvncserver", "commit_id": "a83439b9fbe0f03c48eb94ed05729cb016f8b72f", "hash": 51055663918022564533703243562455713709, "size": 38, "message": "LibVNCClient: fix three possible heap buffer overflows\n\nAn attacker could feed `0xffffffff`, causing a `malloc(0)` for the\nbuffers which are subsequently written to.\n\nCloses #247", "idx": 591}
{"func": "static void setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\t  struct cifs_sb_info *cifs_sb)\n{\n\tif (pvolume_info->rsize > CIFSMaxBufSize) {\n\t\tcERROR(1, \"rsize %d too large, using MaxBufSize\",\n\t\t\tpvolume_info->rsize);\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\t} else if ((pvolume_info->rsize) &&\n\t\t\t(pvolume_info->rsize <= CIFSMaxBufSize))\n\t\tcifs_sb->rsize = pvolume_info->rsize;\n\telse /* default */\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\n\tif (pvolume_info->wsize > PAGEVEC_SIZE * PAGE_CACHE_SIZE) {\n\t\tcERROR(1, \"wsize %d too large, using 4096 instead\",\n\t\t\t  pvolume_info->wsize);\n\t\tcifs_sb->wsize = 4096;\n\t} else if (pvolume_info->wsize)\n\t\tcifs_sb->wsize = pvolume_info->wsize;\n\telse\n\t\tcifs_sb->wsize = min_t(const int,\n\t\t\t\t\tPAGEVEC_SIZE * PAGE_CACHE_SIZE,\n\t\t\t\t\t127*1024);\n\t\t/* old default of CIFSMaxBufSize was too small now\n\t\t   that SMB Write2 can send multiple pages in kvec.\n\t\t   RFC1001 does not describe what happens when frame\n\t\t   bigger than 128K is sent so use that as max in\n\t\t   conjunction with 52K kvec constraint on arch with 4K\n\t\t   page size  */\n\n\tif (cifs_sb->rsize < 2048) {\n\t\tcifs_sb->rsize = 2048;\n\t\t/* Windows ME may prefer this */\n\t\tcFYI(1, \"readsize set to minimum: 2048\");\n\t}\n\t/* calculate prepath */\n\tcifs_sb->prepath = pvolume_info->prepath;\n\tif (cifs_sb->prepath) {\n\t\tcifs_sb->prepathlen = strlen(cifs_sb->prepath);\n\t\t/* we can not convert the / to \\ in the path\n\t\tseparators in the prefixpath yet because we do not\n\t\tknow (until reset_cifs_unix_caps is called later)\n\t\twhether POSIX PATH CAP is available. We normalize\n\t\tthe / to \\ after reset_cifs_unix_caps is called */\n\t\tpvolume_info->prepath = NULL;\n\t} else\n\t\tcifs_sb->prepathlen = 0;\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcFYI(1, \"file mode: 0x%x  dir mode: 0x%x\",\n\t\tcifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->direct_io) {\n\t\tcFYI(1, \"mounting share using direct i/o\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcERROR(1, \"mount option dynperm ignored if cifsacl \"\n\t\t\t   \"mount option supported\");\n}", "target": 0, "cwe": ["CWE-284", "CWE-264"], "project": "linux", "commit_id": "4ff67b720c02c36e54d55b88c2931879b7db1cd2", "hash": 65995405882308480193621797025943813676, "size": 89, "message": "cifs: clean up cifs_find_smb_ses (try #2)\n\nThis patch replaces the earlier patch by the same name. The only\ndifference is that MAX_PASSWORD_SIZE has been increased to attempt to\nmatch the limits that windows enforces.\n\nDo a better job of matching sessions by authtype. Matching by username\nfor a Kerberos session is incorrect, and anonymous sessions need special\nhandling.\n\nAlso, in the case where we do match by username, we also need to match\nby password. That ensures that someone else doesn't \"borrow\" an existing\nsession without needing to know the password.\n\nFinally, passwords can be longer than 16 bytes. Bump MAX_PASSWORD_SIZE\nto 512 to match the size that the userspace mount helper allows.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>", "idx": 592}
{"func": "    //! Replace the image by an identity matrix \\newinstance.\n    CImg<T> get_identity_matrix() const {\n      return identity_matrix(std::max(_width,_height));", "target": 0, "cwe": ["CWE-125"], "project": "CImg", "commit_id": "10af1e8c1ad2a58a0a3342a856bae63e8f257abb", "hash": 201763036965580111910408166480316711938, "size": 3, "message": "Fix other issues in 'CImg<T>::load_bmp()'.", "idx": 593}
{"func": "static int ssl3_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor,al;\n\tint enc_err,n,i,ret= -1;\n\tSSL3_RECORD *rr;\n\tSSL_SESSION *sess;\n\tunsigned char *p;\n\tunsigned char md[EVP_MAX_MD_SIZE];\n\tshort version;\n\tunsigned int mac_size;\n\tint clear=0;\n\tsize_t extra;\n\tint decryption_failed_or_bad_record_mac = 0;\n\tunsigned char *mac = NULL;\n\n\trr= &(s->s3->rrec);\n\tsess=s->session;\n\n\tif (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)\n\t\textra=SSL3_RT_MAX_EXTRA;\n\telse\n\t\textra=0;\n\tif (extra != s->s3->rbuf.len - SSL3_RT_MAX_PACKET_SIZE)\n\t\t{\n\t\t/* actually likely an application error: SLS_OP_MICROSOFT_BIG_SSLV3_BUFFER\n\t\t * set after ssl3_setup_buffers() was done */\n\t\tSSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn -1;\n\t\t}\n\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < SSL3_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, SSL3_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\t/* Pull apart the header into the SSL3_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);\n                                if ((s->version & 0xFF00) == (version & 0xFF00))\n                                \t/* Send back error using their minor version number :-) */\n\t\t\t\t\ts->version = (unsigned short)version;\n\t\t\t\tal=SSL_AD_PROTOCOL_VERSION;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version>>8) != SSL3_VERSION_MAJOR)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)\n\t\t\t{\n\t\t\tal=SSL_AD_RECORD_OVERFLOW;\n\t\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PACKET_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-SSL3_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == SSL3_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\tif (n <= 0) return(n); /* error or non-blocking io */\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == SSL3_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,\n\t * and we have that many bytes in s->packet\n\t */\n\trr->input= &(s->packet[SSL3_RT_HEADER_LENGTH]);\n\n\t/* ok, we can now read from 's->packet' data into 'rr'\n\t * rr->input points at rr->length bytes, which\n\t * need to be copied into rr->data by either\n\t * the decryption or by the decompression\n\t * When the data is 'copied' into the rr->data buffer,\n\t * rr->input will be pointed at the new buffer */ \n\n\t/* We now have - encrypted [ MAC [ compressed [ plain ] ] ]\n\t * rr->length bytes of encrypted compressed stuff. */\n\n\t/* check is not needed I believe */\n\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)\n\t\t{\n\t\tal=SSL_AD_RECORD_OVERFLOW;\n\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n\t\tgoto f_err;\n\t\t}\n\n\t/* decrypt in place in 'rr->input' */\n\trr->data=rr->input;\n\n\tenc_err = s->method->ssl3_enc->enc(s,0);\n\tif (enc_err <= 0)\n\t\t{\n\t\tif (enc_err == 0)\n\t\t\t/* SSLerr() and ssl3_send_alert() have been called */\n\t\t\tgoto err;\n\n\t\t/* Otherwise enc_err == -1, which indicates bad padding\n\t\t * (rec->length has not been changed in this case).\n\t\t * To minimize information leaked via timing, we will perform\n\t\t * the MAC computation anyway. */\n\t\tdecryption_failed_or_bad_record_mac = 1;\n\t\t}\n\n#ifdef TLS_DEBUG\nprintf(\"dec %d\\n\",rr->length);\n{ unsigned int z; for (z=0; z<rr->length; z++) printf(\"%02X%c\",rr->data[z],((z+1)%16)?' ':'\\n'); }\nprintf(\"\\n\");\n#endif\n\n\t/* r->length is now the compressed data plus mac */\n\tif (\t(sess == NULL) ||\n\t\t(s->enc_read_ctx == NULL) ||\n\t\t(s->read_hash == NULL))\n\t\tclear=1;\n\n\tif (!clear)\n\t\t{\n\t\tmac_size=EVP_MD_size(s->read_hash);\n\n\t\tif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra+mac_size)\n\t\t\t{\n#if 0 /* OK only for stream ciphers (then rr->length is visible from ciphertext anyway) */\n\t\t\tal=SSL_AD_RECORD_OVERFLOW;\n\t\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PRE_MAC_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n#else\n\t\t\tdecryption_failed_or_bad_record_mac = 1;\n#endif\t\t\t\n\t\t\t}\n\t\t/* check the MAC for rr->input (it's in mac_size bytes at the tail) */\n\t\tif (rr->length >= mac_size)\n\t\t\t{\n\t\t\trr->length -= mac_size;\n\t\t\tmac = &rr->data[rr->length];\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* record (minus padding) is too short to contain a MAC */\n#if 0 /* OK only for stream ciphers */\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n#else\n\t\t\tdecryption_failed_or_bad_record_mac = 1;\n\t\t\trr->length = 0;\n#endif\n\t\t\t}\n\t\ti=s->method->ssl3_enc->mac(s,md,0);\n\t\tif (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n\t\t\t{\n\t\t\tdecryption_failed_or_bad_record_mac = 1;\n\t\t\t}\n\t\t}\n\n\tif (decryption_failed_or_bad_record_mac)\n\t\t{\n\t\t/* A separate 'decryption_failed' alert was introduced with TLS 1.0,\n\t\t * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption\n\t\t * failure is directly visible from the ciphertext anyway,\n\t\t * we should not reveal which kind of error occured -- this\n\t\t * might become visible to an attacker (e.g. via a logfile) */\n\t\tal=SSL_AD_BAD_RECORD_MAC;\n\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n\t\tgoto f_err;\n\t\t}\n\n\t/* r->length is now just compressed */\n\tif (s->expand != NULL)\n\t\t{\n\t\tif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra)\n\t\t\t{\n\t\t\tal=SSL_AD_RECORD_OVERFLOW;\n\t\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (!ssl3_do_uncompress(s))\n\t\t\t{\n\t\t\tal=SSL_AD_DECOMPRESSION_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_BAD_DECOMPRESSION);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\n\tif (rr->length > SSL3_RT_MAX_PLAIN_LENGTH+extra)\n\t\t{\n\t\tal=SSL_AD_RECORD_OVERFLOW;\n\t\tSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);\n\t\tgoto f_err;\n\t\t}\n\n\trr->off=0;\n\t/* So at this point the following is true\n\t * ssl->s3->rrec.type \tis the type of record\n\t * ssl->s3->rrec.length\t== number of bytes in record\n\t * ssl->s3->rrec.off\t== offset to first valid byte\n\t * ssl->s3->rrec.data\t== where to take bytes from, increment\n\t *\t\t\t   after use :-).\n\t */\n\n\t/* we have pulled in a full packet so zero things */\n\ts->packet_length=0;\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\treturn(1);\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(ret);\n\t}", "target": 1, "cwe": ["CWE-310"], "project": "openssl", "commit_id": "35a65e814beb899fa1c69a7673a8956c6059dce7", "hash": 324313543383639301631096791284993607729, "size": 241, "message": "Make CBC decoding constant time.\n\nThis patch makes the decoding of SSLv3 and TLS CBC records constant\ntime. Without this, a timing side-channel can be used to build a padding\noracle and mount Vaudenay's attack.\n\nThis patch also disables the stitched AESNI+SHA mode pending a similar\nfix to that code.\n\nIn order to be easy to backport, this change is implemented in ssl/,\nrather than as a generic AEAD mode. In the future this should be changed\naround so that HMAC isn't in ssl/, but crypto/ as FIPS expects.\n(cherry picked from commit e130841bccfc0bb9da254dc84e23bc6a1c78a64e)\n\nConflicts:\n\tcrypto/evp/c_allc.c\n\tssl/ssl_algs.c\n\tssl/ssl_locl.h\n\tssl/t1_enc.c\n(cherry picked from commit 3622239826698a0e534dcf0473204c724bb9b4b4)\n\nConflicts:\n\tssl/d1_enc.c\n\tssl/s3_enc.c\n\tssl/s3_pkt.c\n\tssl/ssl3.h\n\tssl/ssl_algs.c\n\tssl/t1_enc.c", "idx": 594}
{"func": "sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n{\n\tint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\n\tint sg_tablesize = sfp->parentdp->sg_tablesize;\n\tint blk_size = buff_size, order;\n\tgfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN | __GFP_ZERO;\n\tstruct sg_device *sdp = sfp->parentdp;\n\n\tif (blk_size < 0)\n\t\treturn -EFAULT;\n\tif (0 == blk_size)\n\t\t++blk_size;\t/* don't know why */\n\t/* round request up to next highest SG_SECTOR_SZ byte boundary */\n\tblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\"sg_build_indirect: buff_size=%d, blk_size=%d\\n\",\n\t\tbuff_size, blk_size));\n\n\t/* N.B. ret_sz carried into this block ... */\n\tmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\n\tif (mx_sc_elems < 0)\n\t\treturn mx_sc_elems;\t/* most likely -ENOMEM */\n\n\tnum = scatter_elem_sz;\n\tif (unlikely(num != scatter_elem_sz_prev)) {\n\t\tif (num < PAGE_SIZE) {\n\t\t\tscatter_elem_sz = PAGE_SIZE;\n\t\t\tscatter_elem_sz_prev = PAGE_SIZE;\n\t\t} else\n\t\t\tscatter_elem_sz_prev = num;\n\t}\n\n\tif (sdp->device->host->unchecked_isa_dma)\n\t\tgfp_mask |= GFP_DMA;\n\n\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n\n\t\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t \"sg_build_indirect: k=%d, num=%d, ret_sz=%d\\n\",\n\t\t\t\t k, num, ret_sz));\n\t}\t\t/* end of for loop */\n\n\tschp->page_order = order;\n\tschp->k_use_sg = k;\n\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t \"sg_build_indirect: k_use_sg=%d, rem_sz=%d\\n\",\n\t\t\t k, rem_sz));\n\n\tschp->bufflen = blk_size;\n\tif (rem_sz > 0)\t/* must have failed */\n\t\treturn -ENOMEM;\n\treturn 0;\nout:\n\tfor (i = 0; i < k; i++)\n\t\t__free_pages(schp->pages[i], order);\n\n\tif (--order >= 0)\n\t\tgoto retry;\n\n\treturn -ENOMEM;\n}", "target": 0, "cwe": [], "project": "linux", "commit_id": "83c6f2390040f188cc25b270b4befeb5628c1aee", "hash": 189799447264256276430351587560964037933, "size": 80, "message": "scsi: sg: add sg_remove_request in sg_write\n\nIf the __copy_from_user function failed we need to call sg_remove_request\nin sg_write.\n\nLink: https://lore.kernel.org/r/610618d9-e983-fd56-ed0f-639428343af7@huawei.com\nAcked-by: Douglas Gilbert <dgilbert@interlog.com>\nSigned-off-by: Wu Bo <wubo40@huawei.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>", "idx": 595}
{"func": "static av_cold int negate_init(AVFilterContext *ctx)\n{\n    LutContext *s = ctx->priv;\n    int i;\n\n    av_log(ctx, AV_LOG_DEBUG, \"negate_alpha:%d\\n\", s->negate_alpha);\n\n    for (i = 0; i < 4; i++) {\n        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?\n                                          \"val\" : \"negval\");\n        if (!s->comp_expr_str[i]) {\n            uninit(ctx);\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    return 0;\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "FFmpeg", "commit_id": "e43a0a232dbf6d3c161823c2e07c52e76227a1bc", "hash": 15133311006448748328963372907627341904, "size": 18, "message": "avfilter: fix plane validity checks\n\nFixes out of array accesses\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "idx": 596}
{"func": "static void hash_search(int f,struct sum_struct *s,\n\t\t\tstruct map_struct *buf, OFF_T len)\n{\n\tOFF_T offset, aligned_offset, end;\n\tint32 k, want_i, backup;\n\tchar sum2[SUM_LENGTH];\n\tuint32 s1, s2, sum;\n\tint more;\n\tschar *map;\n\n\t/* want_i is used to encourage adjacent matches, allowing the RLL\n\t * coding of the output to work more efficiently. */\n\twant_i = 0;\n\n\tif (verbose > 2) {\n\t\trprintf(FINFO, \"hash search b=%ld len=%.0f\\n\",\n\t\t\t(long)s->blength, (double)len);\n\t}\n\n\tk = (int32)MIN(len, (OFF_T)s->blength);\n\n\tmap = (schar *)map_ptr(buf, 0, k);\n\n\tsum = get_checksum1((char *)map, k);\n\ts1 = sum & 0xFFFF;\n\ts2 = sum >> 16;\n\tif (verbose > 3)\n\t\trprintf(FINFO, \"sum=%.8x k=%ld\\n\", sum, (long)k);\n\n\toffset = aligned_offset = 0;\n\n\tend = len + 1 - s->sums[s->count-1].len;\n\n\tif (verbose > 3) {\n\t\trprintf(FINFO, \"hash search s->blength=%ld len=%.0f count=%.0f\\n\",\n\t\t\t(long)s->blength, (double)len, (double)s->count);\n\t}\n\n\tdo {\n\t\tint done_csum2 = 0;\n\t\tint32 i;\n\n\t\tif (verbose > 4) {\n\t\t\trprintf(FINFO, \"offset=%.0f sum=%04x%04x\\n\",\n\t\t\t\t(double)offset, s2 & 0xFFFF, s1 & 0xFFFF);\n\t\t}\n\n\t\tif (tablesize == TRADITIONAL_TABLESIZE) {\n\t\t\tif ((i = hash_table[SUM2HASH2(s1,s2)]) < 0)\n\t\t\t\tgoto null_hash;\n\t\t\tsum = (s1 & 0xffff) | (s2 << 16);\n\t\t} else {\n\t\t\tsum = (s1 & 0xffff) | (s2 << 16);\n\t\t\tif ((i = hash_table[BIG_SUM2HASH(sum)]) < 0)\n\t\t\t\tgoto null_hash;\n\t\t}\n\n\t\thash_hits++;\n\t\tdo {\n\t\t\tint32 l;\n\n\t\t\tif (sum != s->sums[i].sum1)\n\t\t\t\tcontinue;\n\n\t\t\t/* also make sure the two blocks are the same length */\n\t\t\tl = (int32)MIN((OFF_T)s->blength, len-offset);\n\t\t\tif (l != s->sums[i].len)\n\t\t\t\tcontinue;\n\n\t\t\t/* in-place: ensure chunk's offset is either >= our\n\t\t\t * offset or that the data didn't move. */\n\t\t\tif (updating_basis_file && s->sums[i].offset < offset\n\t\t\t    && !(s->sums[i].flags & SUMFLG_SAME_OFFSET))\n\t\t\t\tcontinue;\n\n\t\t\tif (verbose > 3) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"potential match at %.0f i=%ld sum=%08x\\n\",\n\t\t\t\t\t(double)offset, (long)i, sum);\n\t\t\t}\n\n\t\t\tif (!done_csum2) {\n\t\t\t\tmap = (schar *)map_ptr(buf,offset,l);\n\t\t\t\tget_checksum2((char *)map,l,sum2);\n\t\t\t\tdone_csum2 = 1;\n\t\t\t}\n\n\t\t\tif (memcmp(sum2,s->sums[i].sum2,s->s2length) != 0) {\n\t\t\t\tfalse_alarms++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* When updating in-place, the best possible match is\n\t\t\t * one with an identical offset, so we prefer that over\n\t\t\t * the adjacent want_i optimization. */\n\t\t\tif (updating_basis_file) {\n\t\t\t\t/* All the generator's chunks start at blength boundaries. */\n\t\t\t\twhile (aligned_offset < offset)\n\t\t\t\t\taligned_offset += s->blength;\n\t\t\t\tif (offset == aligned_offset) {\n\t\t\t\t\tint32 i2;\n\t\t\t\t\tfor (i2 = i; i2 >= 0; i2 = s->sums[i2].chain) {\n\t\t\t\t\t\tif (s->sums[i2].offset != offset)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (i2 != i) {\n\t\t\t\t\t\t\tif (sum != s->sums[i2].sum1\n\t\t\t\t\t\t\t || l != s->sums[i2].len\n\t\t\t\t\t\t\t || memcmp(sum2, s->sums[i2].sum2, s->s2length) != 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\ti = i2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* This chunk remained in the same spot in the old and new file. */\n\t\t\t\t\t\ts->sums[i].flags |= SUMFLG_SAME_OFFSET;\n\t\t\t\t\t\twant_i = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* we've found a match, but now check to see\n\t\t\t * if want_i can hint at a better match. */\n\t\t\tif (i != want_i && want_i < s->count\n\t\t\t    && (!updating_basis_file || s->sums[want_i].offset >= offset\n\t\t\t     || s->sums[want_i].flags & SUMFLG_SAME_OFFSET)\n\t\t\t    && sum == s->sums[want_i].sum1\n\t\t\t    && memcmp(sum2, s->sums[want_i].sum2, s->s2length) == 0) {\n\t\t\t\t/* we've found an adjacent match - the RLL coder\n\t\t\t\t * will be happy */\n\t\t\t\ti = want_i;\n\t\t\t}\n\t\t\twant_i = i + 1;\n\n\t\t\tmatched(f,s,buf,offset,i);\n\t\t\toffset += s->sums[i].len - 1;\n\t\t\tk = (int32)MIN((OFF_T)s->blength, len-offset);\n\t\t\tmap = (schar *)map_ptr(buf, offset, k);\n\t\t\tsum = get_checksum1((char *)map, k);\n\t\t\ts1 = sum & 0xFFFF;\n\t\t\ts2 = sum >> 16;\n\t\t\tmatches++;\n\t\t\tbreak;\n\t\t} while ((i = s->sums[i].chain) >= 0);\n\n\t  null_hash:\n\t\tbackup = (int32)(offset - last_match);\n\t\t/* We sometimes read 1 byte prior to last_match... */\n\t\tif (backup < 0)\n\t\t\tbackup = 0;\n\n\t\t/* Trim off the first byte from the checksum */\n\t\tmore = offset + k < len;\n\t\tmap = (schar *)map_ptr(buf, offset - backup, k + more + backup)\n\t\t    + backup;\n\t\ts1 -= map[0] + CHAR_OFFSET;\n\t\ts2 -= k * (map[0]+CHAR_OFFSET);\n\n\t\t/* Add on the next byte (if there is one) to the checksum */\n\t\tif (more) {\n\t\t\ts1 += map[k] + CHAR_OFFSET;\n\t\t\ts2 += s1;\n\t\t} else\n\t\t\t--k;\n\n\t\t/* By matching early we avoid re-reading the\n\t\t   data 3 times in the case where a token\n\t\t   match comes a long way after last\n\t\t   match. The 3 reads are caused by the\n\t\t   running match, the checksum update and the\n\t\t   literal send. */\n\t\tif (backup >= s->blength+CHUNK_SIZE && end-offset > CHUNK_SIZE)\n\t\t\tmatched(f, s, buf, offset - s->blength, -2);\n\t} while (++offset < end);\n\n\tmatched(f, s, buf, len, -1);\n\tmap_ptr(buf, len-1, 1);\n}", "target": 1, "cwe": [], "project": "rsync", "commit_id": "c8255147b06b74dad940d32f9cef5fbe17595239", "hash": 13269351929661258568831239064102968322, "size": 176, "message": "Optimize finding the sum that matches our --inplace position.", "idx": 597}
{"func": "Status Examples::Initialize(OpKernelContext* const context,\n                            const ModelWeights& weights,\n                            const int num_sparse_features,\n                            const int num_sparse_features_with_values,\n                            const int num_dense_features) {\n  num_features_ = num_sparse_features + num_dense_features;\n\n  OpInputList sparse_example_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_example_indices\",\n                                         &sparse_example_indices_inputs));\n  if (sparse_example_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_example_indices but got \",\n        sparse_example_indices_inputs.size());\n  OpInputList sparse_feature_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_indices\",\n                                         &sparse_feature_indices_inputs));\n  if (sparse_feature_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_feature_indices but got \",\n        sparse_feature_indices_inputs.size());\n  OpInputList sparse_feature_values_inputs;\n  if (num_sparse_features_with_values > 0) {\n    TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_values\",\n                                           &sparse_feature_values_inputs));\n    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)\n      return errors::InvalidArgument(\n          \"Expected \", num_sparse_features_with_values,\n          \" tensors in sparse_feature_values but got \",\n          sparse_feature_values_inputs.size());\n  }\n\n  const Tensor* example_weights_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_weights\", &example_weights_t));\n  auto example_weights = example_weights_t->flat<float>();\n\n  if (example_weights.size() >= std::numeric_limits<int>::max()) {\n    return errors::InvalidArgument(strings::Printf(\n        \"Too many examples in a mini-batch: %zu > %d\", example_weights.size(),\n        std::numeric_limits<int>::max()));\n  }\n\n  // The static_cast here is safe since num_examples can be at max an int.\n  const int num_examples = static_cast<int>(example_weights.size());\n  const Tensor* example_labels_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_labels\", &example_labels_t));\n  auto example_labels = example_labels_t->flat<float>();\n\n  OpInputList dense_features_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"dense_features\", &dense_features_inputs));\n\n  examples_.clear();\n  examples_.resize(num_examples);\n  probabilities_.resize(num_examples);\n  sampled_index_.resize(num_examples);\n  sampled_count_.resize(num_examples);\n  for (int example_id = 0; example_id < num_examples; ++example_id) {\n    Example* const example = &examples_[example_id];\n    example->sparse_features_.resize(num_sparse_features);\n    example->dense_vectors_.resize(num_dense_features);\n    example->example_weight_ = example_weights(example_id);\n    example->example_label_ = example_labels(example_id);\n  }\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *context->device()->tensorflow_cpu_worker_threads();\n  TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(\n      worker_threads, num_examples, num_sparse_features, weights,\n      sparse_example_indices_inputs, sparse_feature_indices_inputs,\n      sparse_feature_values_inputs, &examples_));\n  TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(\n      worker_threads, num_examples, num_dense_features, weights,\n      dense_features_inputs, &examples_));\n  TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(\n      worker_threads, num_examples, num_sparse_features, num_dense_features,\n      &examples_));\n  return Status::OK();\n}", "target": 1, "cwe": ["CWE-703", "CWE-125"], "project": "tensorflow", "commit_id": "a4e138660270e7599793fa438cd7b2fc2ce215a6", "hash": 310715085860763790063727145741184772931, "size": 80, "message": "Add remaining validation to `sdca_internal.cc`\n\nPiperOrigin-RevId: 387738010\nChange-Id: I28eedcfd87a53aaf34deb075acea1f8c95470808", "idx": 598}
{"func": "static inline int zpff_init(struct hid_device *hid)\n{\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "d9d4b1e46d9543a82c23f6df03f4ad697dab361b", "hash": 21292509463556523893236561511229483187, "size": 4, "message": "HID: Fix assumption that devices have inputs\n\nThe syzbot fuzzer found a slab-out-of-bounds write bug in the hid-gaff\ndriver.  The problem is caused by the driver's assumption that the\ndevice must have an input report.  While this will be true for all\nnormal HID input devices, a suitably malicious device can violate the\nassumption.\n\nThe same assumption is present in over a dozen other HID drivers.\nThis patch fixes them by checking that the list of hid_inputs for the\nhid_device is nonempty before allowing it to be used.\n\nReported-and-tested-by: syzbot+403741a091bf41d4ae79@syzkaller.appspotmail.com\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nCC: <stable@vger.kernel.org>\nSigned-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>", "idx": 599}
{"func": "static int unix_dgram_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, msg->msg_name);\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned int hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie scm;\n\tint max_level;\n\tint data_len = 0;\n\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, &scm, false);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr\n\t    && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tif (len > SKB_MAX_ALLOC) {\n\t\tdata_len = min_t(size_t,\n\t\t\t\t len - SKB_MAX_ALLOC,\n\t\t\t\t MAX_SKB_FRAGS * PAGE_SIZE);\n\t\tdata_len = PAGE_ALIGN(data_len);\n\n\t\tBUILD_BUG_ON(SKB_MAX_ALLOC < PAGE_SIZE);\n\t}\n\n\tskb = sock_alloc_send_pskb(sk, len - data_len, data_len,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT, &err,\n\t\t\t\t   PAGE_ALLOC_COSTLY_ORDER);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = unix_scm_to_skb(&scm, skb, true);\n\tif (err < 0)\n\t\tgoto out_free;\n\tmax_level = err + 1;\n\n\tskb_put(skb, len - data_len);\n\tskb->data_len = data_len;\n\tskb->len = len;\n\terr = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tif (sk_filter(other, skb) < 0) {\n\t\t/* Toss the packet but do not return any error to the sender */\n\t\terr = len;\n\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk) = NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tif (sock_flag(other, SOCK_RCVTSTAMP))\n\t\t__net_timestamp(skb);\n\tmaybe_add_creds(skb, sock, other);\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tif (max_level > unix_sk(other)->recursion_level)\n\t\tunix_sk(other)->recursion_level = max_level;\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other);\n\tsock_put(other);\n\tscm_destroy(&scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(&scm);\n\treturn err;\n}", "target": 1, "cwe": [], "project": "net", "commit_id": "7d267278a9ece963d77eefec61630223fce08c6c", "hash": 67932525792952091808715179253343294162, "size": 173, "message": "unix: avoid use-after-free in ep_remove_wait_queue\n\nRainer Weikusat <rweikusat@mobileactivedefense.com> writes:\nAn AF_UNIX datagram socket being the client in an n:1 association with\nsome server socket is only allowed to send messages to the server if the\nreceive queue of this socket contains at most sk_max_ack_backlog\ndatagrams. This implies that prospective writers might be forced to go\nto sleep despite none of the message presently enqueued on the server\nreceive queue were sent by them. In order to ensure that these will be\nwoken up once space becomes again available, the present unix_dgram_poll\nroutine does a second sock_poll_wait call with the peer_wait wait queue\nof the server socket as queue argument (unix_dgram_recvmsg does a wake\nup on this queue after a datagram was received). This is inherently\nproblematic because the server socket is only guaranteed to remain alive\nfor as long as the client still holds a reference to it. In case the\nconnection is dissolved via connect or by the dead peer detection logic\nin unix_dgram_sendmsg, the server socket may be freed despite \"the\npolling mechanism\" (in particular, epoll) still has a pointer to the\ncorresponding peer_wait queue. There's no way to forcibly deregister a\nwait queue with epoll.\n\nBased on an idea by Jason Baron, the patch below changes the code such\nthat a wait_queue_t belonging to the client socket is enqueued on the\npeer_wait queue of the server whenever the peer receive queue full\ncondition is detected by either a sendmsg or a poll. A wake up on the\npeer queue is then relayed to the ordinary wait queue of the client\nsocket via wake function. The connection to the peer wait queue is again\ndissolved if either a wake up is about to be relayed or the client\nsocket reconnects or a dead peer is detected or the client socket is\nitself closed. This enables removing the second sock_poll_wait from\nunix_dgram_poll, thus avoiding the use-after-free, while still ensuring\nthat no blocked writer sleeps forever.\n\nSigned-off-by: Rainer Weikusat <rweikusat@mobileactivedefense.com>\nFixes: ec0d215f9420 (\"af_unix: fix 'poll for write'/connected DGRAM sockets\")\nReviewed-by: Jason Baron <jbaron@akamai.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 600}
{"func": "static void iscsi_timed_check_events(void *opaque)\n{\n    IscsiLun *iscsilun = opaque;\n\n    qemu_mutex_lock(&iscsilun->mutex);\n\n    /* check for timed out requests */\n    iscsi_service(iscsilun->iscsi, 0);\n\n    if (iscsilun->request_timed_out) {\n        iscsilun->request_timed_out = false;\n        iscsi_reconnect(iscsilun->iscsi);\n    }\n\n    /* newer versions of libiscsi may return zero events. Ensure we are able\n     * to return to service once this situation changes. */\n    iscsi_set_events(iscsilun);\n\n    qemu_mutex_unlock(&iscsilun->mutex);\n\n    timer_mod(iscsilun->event_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);\n}", "target": 0, "cwe": ["CWE-125"], "project": "qemu", "commit_id": "ff0507c239a246fd7215b31c5658fc6a3ee1e4c5", "hash": 202345793795509305863351201391919076994, "size": 23, "message": "block/iscsi:fix heap-buffer-overflow in iscsi_aio_ioctl_cb\n\nThere is an overflow, the source 'datain.data[2]' is 100 bytes,\n but the 'ss' is 252 bytes.This may cause a security issue because\n we can access a lot of unrelated memory data.\n\nThe len for sbp copy data should take the minimum of mx_sb_len and\n sb_len_wr, not the maximum.\n\nIf we use iscsi device for VM backend storage, ASAN show stack:\n\nREAD of size 252 at 0xfffd149dcfc4 thread T0\n    #0 0xaaad433d0d34 in __asan_memcpy (aarch64-softmmu/qemu-system-aarch64+0x2cb0d34)\n    #1 0xaaad45f9d6d0 in iscsi_aio_ioctl_cb /qemu/block/iscsi.c:996:9\n    #2 0xfffd1af0e2dc  (/usr/lib64/iscsi/libiscsi.so.8+0xe2dc)\n    #3 0xfffd1af0d174  (/usr/lib64/iscsi/libiscsi.so.8+0xd174)\n    #4 0xfffd1af19fac  (/usr/lib64/iscsi/libiscsi.so.8+0x19fac)\n    #5 0xaaad45f9acc8 in iscsi_process_read /qemu/block/iscsi.c:403:5\n    #6 0xaaad4623733c in aio_dispatch_handler /qemu/util/aio-posix.c:467:9\n    #7 0xaaad4622f350 in aio_dispatch_handlers /qemu/util/aio-posix.c:510:20\n    #8 0xaaad4622f350 in aio_dispatch /qemu/util/aio-posix.c:520\n    #9 0xaaad46215944 in aio_ctx_dispatch /qemu/util/async.c:298:5\n    #10 0xfffd1bed12f4 in g_main_context_dispatch (/lib64/libglib-2.0.so.0+0x512f4)\n    #11 0xaaad46227de0 in glib_pollfds_poll /qemu/util/main-loop.c:219:9\n    #12 0xaaad46227de0 in os_host_main_loop_wait /qemu/util/main-loop.c:242\n    #13 0xaaad46227de0 in main_loop_wait /qemu/util/main-loop.c:518\n    #14 0xaaad43d9d60c in qemu_main_loop /qemu/softmmu/vl.c:1662:9\n    #15 0xaaad4607a5b0 in main /qemu/softmmu/main.c:49:5\n    #16 0xfffd1a460b9c in __libc_start_main (/lib64/libc.so.6+0x20b9c)\n    #17 0xaaad43320740 in _start (aarch64-softmmu/qemu-system-aarch64+0x2c00740)\n\n0xfffd149dcfc4 is located 0 bytes to the right of 100-byte region [0xfffd149dcf60,0xfffd149dcfc4)\nallocated by thread T0 here:\n    #0 0xaaad433d1e70 in __interceptor_malloc (aarch64-softmmu/qemu-system-aarch64+0x2cb1e70)\n    #1 0xfffd1af0e254  (/usr/lib64/iscsi/libiscsi.so.8+0xe254)\n    #2 0xfffd1af0d174  (/usr/lib64/iscsi/libiscsi.so.8+0xd174)\n    #3 0xfffd1af19fac  (/usr/lib64/iscsi/libiscsi.so.8+0x19fac)\n    #4 0xaaad45f9acc8 in iscsi_process_read /qemu/block/iscsi.c:403:5\n    #5 0xaaad4623733c in aio_dispatch_handler /qemu/util/aio-posix.c:467:9\n    #6 0xaaad4622f350 in aio_dispatch_handlers /qemu/util/aio-posix.c:510:20\n    #7 0xaaad4622f350 in aio_dispatch /qemu/util/aio-posix.c:520\n    #8 0xaaad46215944 in aio_ctx_dispatch /qemu/util/async.c:298:5\n    #9 0xfffd1bed12f4 in g_main_context_dispatch (/lib64/libglib-2.0.so.0+0x512f4)\n    #10 0xaaad46227de0 in glib_pollfds_poll /qemu/util/main-loop.c:219:9\n    #11 0xaaad46227de0 in os_host_main_loop_wait /qemu/util/main-loop.c:242\n    #12 0xaaad46227de0 in main_loop_wait /qemu/util/main-loop.c:518\n    #13 0xaaad43d9d60c in qemu_main_loop /qemu/softmmu/vl.c:1662:9\n    #14 0xaaad4607a5b0 in main /qemu/softmmu/main.c:49:5\n    #15 0xfffd1a460b9c in __libc_start_main (/lib64/libc.so.6+0x20b9c)\n    #16 0xaaad43320740 in _start (aarch64-softmmu/qemu-system-aarch64+0x2c00740)\n\nReported-by: Euler Robot <euler.robot@huawei.com>\nSigned-off-by: Chen Qun <kuhn.chenqun@huawei.com>\nReviewed-by: Stefan Hajnoczi <stefanha@redhat.com>\nMessage-id: 20200418062602.10776-1-kuhn.chenqun@huawei.com\nReviewed-by: Daniel P. Berrangé <berrange@redhat.com>\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>", "idx": 601}
{"func": "static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tssize_t n;\n\n\tWARN_ONCE(1, \"%s is deprecated and scheduled for removal.\", __func__);\n\n\tdown_write(&tty->termios_rwsem);\n\tn = chars_in_buffer(tty);\n\tup_write(&tty->termios_rwsem);\n\treturn n;\n}", "target": 0, "cwe": ["CWE-362"], "project": "tty", "commit_id": "4291086b1f081b869c6d79e5b7441633dc3ace00", "hash": 20837734176751946024133241611217490621, "size": 11, "message": "n_tty: Fix n_tty_write crash when echoing in raw mode\n\nThe tty atomic_write_lock does not provide an exclusion guarantee for\nthe tty driver if the termios settings are LECHO & !OPOST.  And since\nit is unexpected and not allowed to call TTY buffer helpers like\ntty_insert_flip_string concurrently, this may lead to crashes when\nconcurrect writers call pty_write. In that case the following two\nwriters:\n* the ECHOing from a workqueue and\n* pty_write from the process\nrace and can overflow the corresponding TTY buffer like follows.\n\nIf we look into tty_insert_flip_string_fixed_flag, there is:\n  int space = __tty_buffer_request_room(port, goal, flags);\n  struct tty_buffer *tb = port->buf.tail;\n  ...\n  memcpy(char_buf_ptr(tb, tb->used), chars, space);\n  ...\n  tb->used += space;\n\nso the race of the two can result in something like this:\n              A                                B\n__tty_buffer_request_room\n                                  __tty_buffer_request_room\nmemcpy(buf(tb->used), ...)\ntb->used += space;\n                                  memcpy(buf(tb->used), ...) ->BOOM\n\nB's memcpy is past the tty_buffer due to the previous A's tb->used\nincrement.\n\nSince the N_TTY line discipline input processing can output\nconcurrently with a tty write, obtain the N_TTY ldisc output_lock to\nserialize echo output with normal tty writes.  This ensures the tty\nbuffer helper tty_insert_flip_string is not called concurrently and\neverything is fine.\n\nNote that this is nicely reproducible by an ordinary user using\nforkpty and some setup around that (raw termios + ECHO). And it is\npresent in kernels at least after commit\nd945cb9cce20ac7143c2de8d88b187f62db99bdc (pty: Rework the pty layer to\nuse the normal buffering logic) in 2.6.31-rc3.\n\njs: add more info to the commit log\njs: switch to bool\njs: lock unconditionally\njs: lock only the tty->ops->write call\n\nReferences: CVE-2014-0196\nReported-and-tested-by: Jiri Slaby <jslaby@suse.cz>\nSigned-off-by: Peter Hurley <peter@hurleysoftware.com>\nSigned-off-by: Jiri Slaby <jslaby@suse.cz>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Alan Cox <alan@lxorguk.ukuu.org.uk>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 602}
{"func": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\n\tcharsetDetector = ucsdet_open(&errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detector’s text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 1, "cwe": ["CWE-755"], "project": "detect-character-encoding", "commit_id": "992a11007fff6cfd40b952150ab8d30410c4a20a", "hash": 190770535096398050826415522264531116317, "size": 60, "message": "Return null if no charset matches\n\nFixes a segmentation fault if no charset matches. According to http://icu-project.org/apiref/icu4c/ucsdet_8h.html#aff2633b5055d472cff4108d94f97cf7d, ucsdet_detect() may return NULL if no charset matches.\n\nFixes: #15\nCo-authored-by: chenzhip <letme2010@gmail.com>", "idx": 603}
{"func": "int   MirrorJob::Do()\n{\n   int\t res;\n   int\t m=STALL;\n   FileInfo *file;\n   Job\t *j;\n\n   switch(state)\n   {\n   case(INITIAL_STATE):\n      remove_this_source_dir=(remove_source_dirs && source_dir.last_char()!='/');\n      if(!strcmp(target_dir,\".\") || !strcmp(target_dir,\"..\") || (FlagSet(SCAN_ALL_FIRST) && parent_mirror))\n\t create_target_dir=false;\n\n      source_session->Chdir(source_dir);\n      source_redirections=0;\n      source_session->Roll();\n      set_state(CHANGING_DIR_SOURCE);\n      m=MOVED;\n      /*fallthrough*/\n   case(CHANGING_DIR_SOURCE):\n      HandleChdir(source_session,source_redirections);\n      if(state!=CHANGING_DIR_SOURCE)\n\t return MOVED;\n      if(source_session->IsOpen())\n\t return m;\n\n      source_dir.set(source_session->GetCwd().GetDirectory());\n\n   pre_MAKE_TARGET_DIR:\n   {\n      if(!create_target_dir)\n\t goto pre_CHANGING_DIR_TARGET;\n      if(target_is_local)\n      {\n\t struct stat st;\n\t if((FlagSet(RETR_SYMLINKS)?stat:lstat)(target_dir,&st)!=-1)\n\t {\n\t    if(S_ISDIR(st.st_mode))\n\t    {\n\t       // try to enable write access\n\t       // only if not enabled as chmod can clear sgid flags on directories\n\t       if(!script_only && (st.st_mode!=(st.st_mode|0700)))\n\t\t  chmod(target_dir,st.st_mode|0700);\n\t       create_target_dir=false;\n\t       goto pre_CHANGING_DIR_TARGET;\n\t    }\n\t    else\n\t    {\n\t       Report(_(\"Removing old local file `%s'\"),target_dir.get());\n\t       if(script)\n\t       {\n\t\t  ArgV args(\"rm\");\n\t\t  args.Append(target_session->GetFileURL(target_dir));\n\t\t  xstring_ca cmd(args.CombineQuoted());\n\t\t  fprintf(script,\"%s\\n\",cmd.get());\n\t       }\n\t       if(!script_only)\n\t       {\n\t\t  if(remove(target_dir)==-1)\n\t\t     eprintf(\"mirror: remove(%s): %s\\n\",target_dir.get(),strerror(errno));\n\t       }\n\t    }\n\t }\n      }\n\n      if(FlagSet(DEPTH_FIRST))\n\t goto pre_GETTING_LIST_INFO;\n\n      if(target_relative_dir)\n\t Report(_(\"Making directory `%s'\"),target_relative_dir.get());\n      bool mkdir_p=(parent_mirror==0 || parent_mirror->create_target_dir);\n      if(script)\n      {\n\t ArgV args(\"mkdir\");\n\t if(mkdir_p)\n\t    args.Append(\"-p\");\n\t args.Append(target_session->GetFileURL(target_dir));\n\t xstring_ca cmd(args.CombineQuoted());\n\t fprintf(script,\"%s\\n\",cmd.get());\n\t if(script_only)\n\t    goto pre_CHANGING_DIR_TARGET;\n      }\n      target_session->Mkdir(target_dir,mkdir_p);\n      set_state(MAKE_TARGET_DIR);\n      m=MOVED;\n   }\n      /*fallthrough*/\n   case(MAKE_TARGET_DIR):\n      res=target_session->Done();\n      if(res==FA::IN_PROGRESS)\n\t return m;\n      target_session->Close();\n      create_target_dir=false;\n\n   pre_CHANGING_DIR_TARGET:\n      target_session->Chdir(target_dir);\n      target_redirections=0;\n      target_session->Roll();\n      set_state(CHANGING_DIR_TARGET);\n      m=MOVED;\n      /*fallthrough*/\n   case(CHANGING_DIR_TARGET):\n      HandleChdir(target_session,target_redirections);\n      if(state!=CHANGING_DIR_TARGET)\n\t return MOVED;\n      if(target_session->IsOpen())\n\t return m;\n      create_target_dir=false;\n\n      target_dir.set(target_session->GetCwd().GetDirectory());\n\n   pre_GETTING_LIST_INFO:\n      set_state(GETTING_LIST_INFO);\n      m=MOVED;\n      if(!source_set)\n\t HandleListInfoCreation(source_session,source_list_info,source_relative_dir);\n      if(!target_set && !create_target_dir\n      && (!FlagSet(DEPTH_FIRST) || FlagSet(ONLY_EXISTING))\n      && !(FlagSet(TARGET_FLAT) && parent_mirror))\n\t HandleListInfoCreation(target_session,target_list_info,target_relative_dir);\n      if(state!=GETTING_LIST_INFO)\n      {\n\t source_list_info=0;\n\t target_list_info=0;\n      }\n      return m;\t  // give time to other tasks\n   case(GETTING_LIST_INFO):\n      HandleListInfo(source_list_info,source_set);\n      HandleListInfo(target_list_info,target_set,&target_set_excluded);\n      if(state!=GETTING_LIST_INFO)\n\t return MOVED;\n      if(source_list_info || target_list_info)\n\t return m;\n\n      MirrorFinished(); // leave room for transfers.\n\n      if(FlagSet(DEPTH_FIRST) && source_set && !target_set)\n      {\n\t // transfer directories first\n\t InitSets();\n\t to_transfer->Unsort();\n\t to_transfer->SubtractNotDirs();\n\t goto pre_WAITING_FOR_TRANSFER;\n      }\n\n      // now we have both target and source file sets.\n      if(parent_mirror)\n\t stats.dirs++;\n\n      if(FlagSet(SCAN_ALL_FIRST) && parent_mirror)\n      {\n\t source_set->PrependPath(source_relative_dir);\n\t if(root_mirror->source_set_recursive)\n\t    root_mirror->source_set_recursive->Merge(source_set);\n\t else\n\t    root_mirror->source_set_recursive=source_set.borrow();\n\t if(target_set) {\n\t    target_set->PrependPath(target_relative_dir);\n\t    if(root_mirror->target_set_recursive)\n\t       root_mirror->target_set_recursive->Merge(target_set);\n\t    else\n\t       root_mirror->target_set_recursive=target_set.borrow();\n\t }\n\t if(target_set_excluded) {\n\t    target_set_excluded->PrependPath(target_relative_dir);\n\t    if(root_mirror->target_set_excluded)\n\t       root_mirror->target_set_excluded->Merge(target_set_excluded);\n\t    else\n\t       root_mirror->target_set_excluded=target_set_excluded.borrow();\n\t }\n\t root_mirror->stats.dirs++;\n\t transfer_count++; // parent mirror will decrement it.\n\t goto pre_DONE;\n      }\n\n      if(source_set_recursive) {\n\t source_set->Merge(source_set_recursive);\n\t source_set_recursive=0;\n      }\n      if(target_set_recursive) {\n\t target_set->Merge(target_set_recursive);\n\t target_set_recursive=0;\n      }\n      InitSets();\n\n      to_transfer->CountBytes(&bytes_to_transfer);\n      if(parent_mirror)\n\t parent_mirror->AddBytesToTransfer(bytes_to_transfer);\n\n      to_rm->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);\n      to_rm->rewind();\n      to_rm_mismatched->Count(&stats.del_dirs,&stats.del_files,&stats.del_symlinks,&stats.del_files);\n      to_rm_mismatched->rewind();\n\n      target_set->Merge(target_set_excluded);\n      target_set_excluded=0;\n\n      set_state(TARGET_REMOVE_OLD_FIRST);\n      goto TARGET_REMOVE_OLD_FIRST_label;\n\n   pre_TARGET_MKDIR:\n      if(!to_mkdir)\n\t goto pre_WAITING_FOR_TRANSFER;\n      to_mkdir->rewind();\n      set_state(TARGET_MKDIR);\n      m=MOVED;\n      /*fallthrough*/\n   case(TARGET_MKDIR):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==TARGET_MKDIR)\n      {\n\t file=to_mkdir->curr();\n\t if(!file)\n\t    goto pre_WAITING_FOR_TRANSFER;\n\t to_mkdir->next();\n\t if(!file->TypeIs(file->DIRECTORY))\n\t    continue;\n\t if(script)\n\t    fprintf(script,\"mkdir %s\\n\",target_session->GetFileURL(file->name).get());\n\t if(!script_only)\n\t {\n\t    ArgV *a=new ArgV(\"mkdir\");\n\t    a->Append(file->name);\n\t    mkdirJob *mkj=new mkdirJob(target_session->Clone(),a);\n\t    a->CombineTo(mkj->cmdline);\n\t    JobStarted(mkj);\n\t    m=MOVED;\n\t }\n      }\n      break;\n\n   pre_WAITING_FOR_TRANSFER:\n      to_transfer->rewind();\n      set_state(WAITING_FOR_TRANSFER);\n      m=MOVED;\n      /*fallthrough*/\n   case(WAITING_FOR_TRANSFER):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t TransferFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==WAITING_FOR_TRANSFER)\n      {\n\t file=to_transfer->curr();\n\t if(!file)\n\t {\n\t    // go to the next step only when all transfers have finished\n\t    if(waiting_num>0)\n\t       break;\n\t    if(FlagSet(DEPTH_FIRST))\n\t    {\n\t       // we have been in the depth, don't go there again\n\t       SetFlags(DEPTH_FIRST,false);\n\t       SetFlags(NO_RECURSION,true);\n\n\t       // if we have not created any subdirs and there are only subdirs,\n\t       // then the directory would be empty - skip it.\n\t       if(FlagSet(NO_EMPTY_DIRS) && stats.dirs==0 && only_dirs)\n\t\t  goto pre_FINISHING_FIX_LOCAL;\n\n\t       MirrorStarted();\n\t       goto pre_MAKE_TARGET_DIR;\n\t    }\n\t    goto pre_TARGET_REMOVE_OLD;\n\t }\n\t HandleFile(file);\n\t to_transfer->next();\n\t m=MOVED;\n      }\n      break;\n\n   pre_TARGET_REMOVE_OLD:\n      if(FlagSet(REMOVE_FIRST))\n\t goto pre_TARGET_CHMOD;\n      set_state(TARGET_REMOVE_OLD);\n      m=MOVED;\n      /*fallthrough*/\n   case(TARGET_REMOVE_OLD):\n   case(TARGET_REMOVE_OLD_FIRST):\n   TARGET_REMOVE_OLD_FIRST_label:\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && (state==TARGET_REMOVE_OLD || state==TARGET_REMOVE_OLD_FIRST))\n      {\n\t file=0;\n\t if(!file && state==TARGET_REMOVE_OLD_FIRST)\n\t {\n\t    file=to_rm_mismatched->curr();\n\t    to_rm_mismatched->next();\n\t }\n\t if(!file && (state==TARGET_REMOVE_OLD || FlagSet(REMOVE_FIRST)))\n\t {\n\t    file=to_rm->curr();\n\t    to_rm->next();\n\t }\n\t if(!file)\n\t {\n\t    if(waiting_num>0)\n\t       break;\n\t    if(state==TARGET_REMOVE_OLD)\n\t       goto pre_TARGET_CHMOD;\n\t    goto pre_TARGET_MKDIR;\n\t }\n\t if(!FlagSet(DELETE))\n\t {\n\t    if(FlagSet(REPORT_NOT_DELETED))\n\t    {\n\t       const char *target_name_rel=dir_file(target_relative_dir,file->name);\n\t       if(file->TypeIs(file->DIRECTORY))\n\t\t  Report(_(\"Old directory `%s' is not removed\"),target_name_rel);\n\t       else\n\t\t  Report(_(\"Old file `%s' is not removed\"),target_name_rel);\n\t    }\n\t    continue;\n\t }\n\t if(script)\n\t {\n\t    ArgV args(\"rm\");\n\t    if(file->TypeIs(file->DIRECTORY))\n\t    {\n\t       if(recursion_mode==RECURSION_NEVER)\n\t\t  args.setarg(0,\"rmdir\");\n\t       else\n\t\t  args.Append(\"-r\");\n\t    }\n\t    args.Append(target_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *args=new ArgV(\"rm\");\n\t    args->Append(file->name);\n\t    args->seek(1);\n\t    rmJob *j=new rmJob(target_session->Clone(),args);\n\t    args->CombineTo(j->cmdline);\n\t    JobStarted(j);\n\t    if(file->TypeIs(file->DIRECTORY))\n\t    {\n\t       if(recursion_mode==RECURSION_NEVER)\n\t       {\n\t\t  args->setarg(0,\"rmdir\");\n\t\t  j->Rmdir();\n\t       }\n\t       else\n\t\t  j->Recurse();\n\t    }\n\t }\n\t const char *target_name_rel=dir_file(target_relative_dir,file->name);\n\t if(file->TypeIs(file->DIRECTORY))\n\t    Report(_(\"Removing old directory `%s'\"),target_name_rel);\n\t else\n\t    Report(_(\"Removing old file `%s'\"),target_name_rel);\n      }\n      break;\n\n   pre_TARGET_CHMOD:\n      if(FlagSet(NO_PERMS))\n\t goto pre_FINISHING_FIX_LOCAL;\n\n      to_transfer->rewind();\n      if(FlagSet(TARGET_FLAT))\n\t to_transfer->Sort(FileSet::BYNAME_FLAT);\n      set_state(TARGET_CHMOD);\n      m=MOVED;\n      /*fallthrough*/\n   case(TARGET_CHMOD):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==TARGET_CHMOD)\n      {\n\t file=to_transfer->curr();\n\t if(!file)\n\t    goto pre_FINISHING_FIX_LOCAL;\n\t to_transfer->next();\n\t if(file->TypeIs(file->SYMLINK))\n\t    continue;\n\t if(!file->Has(file->MODE))\n\t    continue;\n\t mode_t mode_mask=get_mode_mask();\n\t mode_t def_mode=(file->TypeIs(file->DIRECTORY)?0775:0664)&~mode_mask;\n\t if(target_is_local && file->mode==def_mode)\n\t {\n\t    struct stat st;\n\t    if(!target_is_local || lstat(dir_file(target_dir,file->name),&st)==-1)\n\t       continue;\n\t    if((st.st_mode&07777)==(file->mode&~mode_mask))\n\t       continue;\n\t }\n\t FileInfo *target=target_set->FindByName(file->name);\n\t if(target && target->filetype==file->DIRECTORY && file->filetype==file->DIRECTORY\n\t && target->mode==(file->mode&~mode_mask) && (target->mode&0200))\n\t    continue;\n\t if(script)\n\t {\n\t    ArgV args(\"chmod\");\n\t    args.Append(xstring::format(\"%03lo\",(unsigned long)(file->mode&~mode_mask)));\n\t    args.Append(target_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *a=new ArgV(\"chmod\");\n\t    a->Append(file->name);\n\t    a->seek(1);\n\t    ChmodJob *cj=new ChmodJob(target_session->Clone(),\n\t\t\t\t file->mode&~mode_mask,a);\n\t    a->CombineTo(cj->cmdline);\n\t    if(!verbose_report)\n\t       cj->BeQuiet(); // chmod is not supported on all servers; be quiet.\n\t    JobStarted(cj);\n\t    m=MOVED;\n\t }\n      }\n      break;\n\n   pre_FINISHING_FIX_LOCAL:\n      if(target_is_local && !script_only)     // FIXME\n      {\n\t const bool flat=FlagSet(TARGET_FLAT);\n\t to_transfer->Sort(FileSet::BYNAME_FLAT);\n\t to_transfer->LocalUtime(target_dir,/*only_dirs=*/true,flat);\n\t if(FlagSet(ALLOW_CHOWN))\n\t    to_transfer->LocalChown(target_dir,flat);\n\t if(!FlagSet(NO_PERMS) && same)\n\t    same->LocalChmod(target_dir,get_mode_mask(),flat);\n\t if(FlagSet(ALLOW_CHOWN) && same)\n\t    same->LocalChown(target_dir,flat);\n      }\n      if(remove_source_files && (same || to_rm_src))\n\t goto pre_SOURCE_REMOVING_SAME;\n   pre_FINISHING:\n      set_state(FINISHING);\n      m=MOVED;\n      /*fallthrough*/\n   case(FINISHING):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(waiting_num>0)\n\t break;\n\n      // all jobs finished.\n      if(remove_this_source_dir) {\n\t // remove source directory once.\n\t remove_this_source_dir=false;\n\t if(script)\n\t {\n\t    ArgV args(\"rmdir\");\n\t    args.Append(source_session->GetFileURL(source_dir));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *args=new ArgV(\"rmdir\");\n\t    args->Append(source_dir);\n\t    args->seek(1);\n\t    rmJob *j=new rmJob(source_session->Clone(),args);\n\t    args->CombineTo(j->cmdline);\n\t    j->Rmdir();\n\t    JobStarted(j);\n\t }\n\t if(source_relative_dir)\n\t    Report(_(\"Removing source directory `%s'\"),source_relative_dir.get());\n\t m=MOVED;\n\t break;\n      }\n\n      // all jobs finished and src dir removed, if needed.\n\n      transfer_count++; // parent mirror will decrement it.\n      if(parent_mirror)\n\t parent_mirror->stats.Add(stats);\n      else\n      {\n\t if(stats.HaveSomethingDone(flags) && on_change)\n\t {\n\t    CmdExec *exec=new CmdExec(source_session->Clone(),0);\n\t    AddWaiting(exec);\n\t    exec->FeedCmd(on_change);\n\t    exec->FeedCmd(\"\\n\");\n\t    set_state(LAST_EXEC);\n\t    break;\n\t }\n      }\n      goto pre_DONE;\n\n   pre_SOURCE_REMOVING_SAME:\n      if(!same)\n\t same=to_rm_src.borrow();\n      else if(to_rm_src)\n\t same->Merge(to_rm_src);\n      same->rewind();\n      set_state(SOURCE_REMOVING_SAME);\n      m=MOVED;\n      /*fallthrough*/\n   case(SOURCE_REMOVING_SAME):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t JobFinished(j);\n\t m=MOVED;\n      }\n      if(max_error_count>0 && stats.error_count>=max_error_count)\n\t goto pre_FINISHING;\n      while(transfer_count<parallel && state==SOURCE_REMOVING_SAME)\n      {\n\t file=same->curr();\n\t same->next();\n\t if(!file)\n\t    goto pre_FINISHING;\n\t if(file->TypeIs(file->DIRECTORY))\n\t    continue;\n\t if(script)\n\t {\n\t    ArgV args(\"rm\");\n\t    args.Append(source_session->GetFileURL(file->name));\n\t    xstring_ca cmd(args.CombineQuoted());\n\t    fprintf(script,\"%s\\n\",cmd.get());\n\t }\n\t if(!script_only)\n\t {\n\t    ArgV *args=new ArgV(\"rm\");\n\t    args->Append(file->name);\n\t    args->seek(1);\n\t    rmJob *j=new rmJob(source_session->Clone(),args);\n\t    args->CombineTo(j->cmdline);\n\t    JobStarted(j);\n\t }\n\t const char *source_name_rel=dir_file(source_relative_dir,file->name);\n\t Report(_(\"Removing source file `%s'\"),source_name_rel);\n      }\n      break;\n\n   case(LAST_EXEC):\n      while((j=FindDoneAwaitedJob())!=0)\n      {\n\t RemoveWaiting(j);\n\t Delete(j);\n\t m=MOVED;\n      }\n      if(waiting_num>0)\n\t break;\n   pre_DONE:\n      set_state(DONE);\n      m=MOVED;\n      bytes_transferred=0;\n      if(!parent_mirror && FlagSet(LOOP) && stats.HaveSomethingDone(flags) && !stats.error_count)\n      {\n\t PrintStatus(0,\"\");\n\t printf(_(\"Retrying mirror...\\n\"));\n\t stats.Reset();\n\t source_set=0;\n\t target_set=0;\n\t goto pre_GETTING_LIST_INFO;\n      }\n      /*fallthrough*/\n   case(DONE):\n      break;\n   }\n   // give direct parent priority over grand-parents.\n   if(transfer_count<parallel && parent_mirror)\n      m|=parent_mirror->Roll();\n   return m;\n}", "target": 1, "cwe": ["CWE-20", "CWE-401"], "project": "lftp", "commit_id": "a27e07d90a4608ceaf928b1babb27d4d803e1992", "hash": 337169927869672317796037153213920834064, "size": 588, "message": "mirror: prepend ./ to rm and chmod arguments to avoid URL recognition (fix #452)", "idx": 604}
{"func": "int ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto)\n{\n\tstruct ip_mc_list *im;\n\tstruct ip_mc_list __rcu **mc_hash;\n\tstruct ip_sf_list *psf;\n\tint rv = 0;\n\n\tmc_hash = rcu_dereference(in_dev->mc_hash);\n\tif (mc_hash) {\n\t\tu32 hash = hash_32((__force u32)mc_addr, MC_HASH_SZ_LOG);\n\n\t\tfor (im = rcu_dereference(mc_hash[hash]);\n\t\t     im != NULL;\n\t\t     im = rcu_dereference(im->next_hash)) {\n\t\t\tif (im->multiaddr == mc_addr)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor_each_pmc_rcu(in_dev, im) {\n\t\t\tif (im->multiaddr == mc_addr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (im && proto == IPPROTO_IGMP) {\n\t\trv = 1;\n\t} else if (im) {\n\t\tif (src_addr) {\n\t\t\tfor (psf = im->sources; psf; psf = psf->sf_next) {\n\t\t\t\tif (psf->sf_inaddr == src_addr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (psf)\n\t\t\t\trv = psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] !=\n\t\t\t\t\tim->sfcount[MCAST_EXCLUDE];\n\t\t\telse\n\t\t\t\trv = im->sfcount[MCAST_EXCLUDE] != 0;\n\t\t} else\n\t\t\trv = 1; /* unspecified source; tentatively allow */\n\t}\n\treturn rv;\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux", "commit_id": "23d2b94043ca8835bd1e67749020e839f396a1c2", "hash": 177377112463722770771897898070120371070, "size": 42, "message": "igmp: Add ip_mc_list lock in ip_check_mc_rcu\n\nI got below panic when doing fuzz test:\n\nKernel panic - not syncing: panic_on_warn set ...\nCPU: 0 PID: 4056 Comm: syz-executor.3 Tainted: G    B             5.14.0-rc1-00195-gcff5c4254439-dirty #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014\nCall Trace:\ndump_stack_lvl+0x7a/0x9b\npanic+0x2cd/0x5af\nend_report.cold+0x5a/0x5a\nkasan_report+0xec/0x110\nip_check_mc_rcu+0x556/0x5d0\n__mkroute_output+0x895/0x1740\nip_route_output_key_hash_rcu+0x2d0/0x1050\nip_route_output_key_hash+0x182/0x2e0\nip_route_output_flow+0x28/0x130\nudp_sendmsg+0x165d/0x2280\nudpv6_sendmsg+0x121e/0x24f0\ninet6_sendmsg+0xf7/0x140\nsock_sendmsg+0xe9/0x180\n____sys_sendmsg+0x2b8/0x7a0\n___sys_sendmsg+0xf0/0x160\n__sys_sendmmsg+0x17e/0x3c0\n__x64_sys_sendmmsg+0x9e/0x100\ndo_syscall_64+0x3b/0x90\nentry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x462eb9\nCode: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8\n 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48>\n 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f3df5af1c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000133\nRAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462eb9\nRDX: 0000000000000312 RSI: 0000000020001700 RDI: 0000000000000007\nRBP: 0000000000000004 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f3df5af26bc\nR13: 00000000004c372d R14: 0000000000700b10 R15: 00000000ffffffff\n\nIt is one use-after-free in ip_check_mc_rcu.\nIn ip_mc_del_src, the ip_sf_list of pmc has been freed under pmc->lock protection.\nBut access to ip_sf_list in ip_check_mc_rcu is not protected by the lock.\n\nSigned-off-by: Liu Jian <liujian56@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 605}
{"func": "static ssize_t max_time_ms_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\tktime_t active_time;\n\tktime_t max_time = ws->max_time;\n\n\tif (ws->active) {\n\t\tactive_time = ktime_sub(ktime_get(), ws->last_time);\n\t\tif (active_time > max_time)\n\t\t\tmax_time = active_time;\n\t}\n\treturn sprintf(buf, \"%lld\\n\", ktime_to_ms(max_time));\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "aa838896d87af561a33ecefea1caa4c15a68bc47", "hash": 127600745477719675235478008843547109325, "size": 14, "message": "drivers core: Use sysfs_emit and sysfs_emit_at for show(device *...) functions\n\nConvert the various sprintf fmaily calls in sysfs device show functions\nto sysfs_emit and sysfs_emit_at for PAGE_SIZE buffer safety.\n\nDone with:\n\n$ spatch -sp-file sysfs_emit_dev.cocci --in-place --max-width=80 .\n\nAnd cocci script:\n\n$ cat sysfs_emit_dev.cocci\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tstrcpy(buf, chr);\n+\tsysfs_emit(buf, chr);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n-\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n+\tlen += sysfs_emit_at(buf, len,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t...\n-\tstrcpy(buf, chr);\n-\treturn strlen(buf);\n+\treturn sysfs_emit(buf, chr);\n}\n\nSigned-off-by: Joe Perches <joe@perches.com>\nLink: https://lore.kernel.org/r/3d033c33056d88bbe34d4ddb62afd05ee166ab9a.1600285923.git.joe@perches.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 606}
{"func": "issuerAndThisUpdateCheck(\n\tstruct berval *in,\n\tstruct berval *is,\n\tstruct berval *tu,\n\tvoid *ctx )\n{\n\tint numdquotes = 0;\n\tstruct berval x = *in;\n\tstruct berval ni = BER_BVNULL;\n\t/* Parse GSER format */ \n\tenum {\n\t\tHAVE_NONE = 0x0,\n\t\tHAVE_ISSUER = 0x1,\n\t\tHAVE_THISUPDATE = 0x2,\n\t\tHAVE_ALL = ( HAVE_ISSUER | HAVE_THISUPDATE )\n\t} have = HAVE_NONE;\n\n\n\tif ( in->bv_len < STRLENOF( \"{issuer \\\"\\\",thisUpdate \\\"YYMMDDhhmmssZ\\\"}\" ) ) return LDAP_INVALID_SYNTAX;\n\n\tif ( in->bv_val[0] != '{' && in->bv_val[in->bv_len-1] != '}' ) {\n\t\treturn LDAP_INVALID_SYNTAX;\n\t}\n\n\tx.bv_val++;\n\tx.bv_len -= STRLENOF(\"{}\");\n\n\tdo {\n\t\t/* eat leading spaces */\n\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t/* empty */;\n\t\t}\n\n\t\t/* should be at issuer or thisUpdate */\n\t\tif ( strncasecmp( x.bv_val, \"issuer\", STRLENOF(\"issuer\") ) == 0 ) {\n\t\t\tif ( have & HAVE_ISSUER ) return LDAP_INVALID_SYNTAX;\n\n\t\t\t/* parse issuer */\n\t\t\tx.bv_val += STRLENOF(\"issuer\");\n\t\t\tx.bv_len -= STRLENOF(\"issuer\");\n\n\t\t\tif ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\t/* eat leading spaces */\n\t\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t\t/* empty */;\n\t\t\t}\n\n\t\t\t/* For backward compatibility, this part is optional */\n\t\t\tif ( strncasecmp( x.bv_val, \"rdnSequence:\", STRLENOF(\"rdnSequence:\") ) != 0 ) {\n\t\t\t\treturn LDAP_INVALID_SYNTAX;\n\t\t\t}\n\t\t\tx.bv_val += STRLENOF(\"rdnSequence:\");\n\t\t\tx.bv_len -= STRLENOF(\"rdnSequence:\");\n\n\t\t\tif ( x.bv_val[0] != '\"' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\tis->bv_val = x.bv_val;\n\t\t\tis->bv_len = 0;\n\n\t\t\tfor ( ; is->bv_len < x.bv_len; ) {\n\t\t\t\tif ( is->bv_val[is->bv_len] != '\"' ) {\n\t\t\t\t\tis->bv_len++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( is->bv_val[is->bv_len+1] == '\"' ) {\n\t\t\t\t\t/* double dquote */\n\t\t\t\t\tnumdquotes++;\n\t\t\t\t\tis->bv_len += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx.bv_val += is->bv_len + 1;\n\t\t\tx.bv_len -= is->bv_len + 1;\n\n\t\t\thave |= HAVE_ISSUER;\n\n\t\t} else if ( strncasecmp( x.bv_val, \"thisUpdate\", STRLENOF(\"thisUpdate\") ) == 0 )\n\t\t{\n\t\t\tif ( have & HAVE_THISUPDATE ) return LDAP_INVALID_SYNTAX;\n\n\t\t\t/* parse thisUpdate */\n\t\t\tx.bv_val += STRLENOF(\"thisUpdate\");\n\t\t\tx.bv_len -= STRLENOF(\"thisUpdate\");\n\n\t\t\tif ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\t/* eat leading spaces */\n\t\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t\t/* empty */;\n\t\t\t}\n\n\t\t\tif ( !x.bv_len || x.bv_val[0] != '\"' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\ttu->bv_val = x.bv_val;\n\t\t\ttu->bv_len = 0;\n\n\t\t\tfor ( ; tu->bv_len < x.bv_len; tu->bv_len++ ) {\n\t\t\t\tif ( tu->bv_val[tu->bv_len] == '\"' ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.bv_val += tu->bv_len + 1;\n\t\t\tx.bv_len -= tu->bv_len + 1;\n\n\t\t\thave |= HAVE_THISUPDATE;\n\n\t\t} else {\n\t\t\treturn LDAP_INVALID_SYNTAX;\n\t\t}\n\n\t\t/* eat leading spaces */\n\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t/* empty */;\n\t\t}\n\n\t\tif ( have == HAVE_ALL ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( x.bv_val[0] != ',' ) {\n\t\t\treturn LDAP_INVALID_SYNTAX;\n\t\t}\n\n\t\tx.bv_val++;\n\t\tx.bv_len--;\n\t} while ( 1 );\n\n\t/* should have no characters left... */\n\tif ( x.bv_len ) return LDAP_INVALID_SYNTAX;\n\n\tif ( numdquotes == 0 ) {\n\t\tber_dupbv_x( &ni, is, ctx );\n\n\t} else {\n\t\tber_len_t src, dst;\n\n\t\tni.bv_len = is->bv_len - numdquotes;\n\t\tni.bv_val = ber_memalloc_x( ni.bv_len + 1, ctx );\n\t\tfor ( src = 0, dst = 0; src < is->bv_len; src++, dst++ ) {\n\t\t\tif ( is->bv_val[src] == '\"' ) {\n\t\t\t\tsrc++;\n\t\t\t}\n\t\t\tni.bv_val[dst] = is->bv_val[src];\n\t\t}\n\t\tni.bv_val[dst] = '\\0';\n\t}\n\t\t\n\t*is = ni;\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-191"], "project": "openldap", "commit_id": "91dccd25c347733b365adc74cb07d074512ed5ad", "hash": 312480371777965525993321132483307930828, "size": 161, "message": "ITS#9427 fix issuerAndThisUpdateCheck", "idx": 607}
{"func": "static int fts3DoAutoincrmerge(\n  Fts3Table *p,                   /* FTS3 table handle */\n  const char *zParam              /* Nul-terminated string containing boolean */\n){\n  int rc = SQLITE_OK;\n  sqlite3_stmt *pStmt = 0;\n  p->nAutoincrmerge = fts3Getint(&zParam);\n  if( p->nAutoincrmerge==1 || p->nAutoincrmerge>FTS3_MERGE_COUNT ){\n    p->nAutoincrmerge = 8;\n  }\n  if( !p->bHasStat ){\n    assert( p->bFts4==0 );\n    sqlite3Fts3CreateStatTable(&rc, p);\n    if( rc ) return rc;\n  }\n  rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);\n  if( rc ) return rc;\n  sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);\n  sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);\n  sqlite3_step(pStmt);\n  rc = sqlite3_reset(pStmt);\n  return rc;\n}", "target": 1, "cwe": ["CWE-787"], "project": "sqlite", "commit_id": "c72f2fb7feff582444b8ffdc6c900c69847ce8a9", "hash": 120148002406359821035549587870018734153, "size": 23, "message": "More improvements to shadow table corruption detection in FTS3.\n\nFossilOrigin-Name: 51525f9c3235967bc00a090e84c70a6400698c897aa4742e817121c725b8c99d", "idx": 608}
{"func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}", "target": 1, "cwe": ["CWE-617"], "project": "ImageMagick", "commit_id": "b76b2ffff70f2c314a069ea953f4a45b1e2ce5e6", "hash": 3298842614035262169371594678959466013, "size": 507, "message": "https://github.com/ImageMagick/ImageMagick/issues/547", "idx": 609}
{"func": "static void qemu_input_queue_process(void *opaque)\n{\n    struct QemuInputEventQueueHead *queue = opaque;\n    QemuInputEventQueue *item;\n\n    g_assert(!QTAILQ_EMPTY(queue));\n    item = QTAILQ_FIRST(queue);\n    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);\n    QTAILQ_REMOVE(queue, item, node);\n    g_free(item);\n\n    while (!QTAILQ_EMPTY(queue)) {\n        item = QTAILQ_FIRST(queue);\n        switch (item->type) {\n        case QEMU_INPUT_QUEUE_DELAY:\n            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)\n                      + item->delay_ms);\n            return;\n        case QEMU_INPUT_QUEUE_EVENT:\n            qemu_input_event_send(item->src, item->evt);\n            qapi_free_InputEvent(item->evt);\n            break;\n        case QEMU_INPUT_QUEUE_SYNC:\n            qemu_input_event_sync();\n            break;\n        }\n        QTAILQ_REMOVE(queue, item, node);\n        g_free(item);\n    }\n}", "target": 1, "cwe": ["CWE-772"], "project": "qemu", "commit_id": "fa18f36a461984eae50ab957e47ec78dae3c14fc", "hash": 221335255180166921243842364640439388740, "size": 30, "message": "input: limit kbd queue depth\n\nApply a limit to the number of items we accept into the keyboard queue.\n\nImpact: Without this limit vnc clients can exhaust host memory by\nsending keyboard events faster than qemu feeds them to the guest.\n\nFixes: CVE-2017-8379\nCc: P J P <ppandit@redhat.com>\nCc: Huawei PSIRT <PSIRT@huawei.com>\nReported-by: jiangxin1@huawei.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nMessage-id: 20170428084237.23960-1-kraxel@redhat.com", "idx": 610}
{"func": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */\n\tvmcs_writel(HOST_CR4, read_cr4());  /* 22.2.3, 22.2.5 */\n\tvmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * __vmx_load_host_state(), in case userspace uses the null selectors\n\t * too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */\n\tvmx->host_idt_base = dt.address;\n\n\tvmcs_writel(HOST_RIP, vmx_return); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 1, "cwe": ["CWE-400", "CWE-399", "CWE-703"], "project": "linux", "commit_id": "d974baa398f34393db76be45f7d4d04fbdbb4a0a", "hash": 214484766102192745931533157162257834289, "size": 42, "message": "x86,kvm,vmx: Preserve CR4 across VM entry\n\nCR4 isn't constant; at least the TSD and PCE bits can vary.\n\nTBH, treating CR0 and CR3 as constant scares me a bit, too, but it looks\nlike it's correct.\n\nThis adds a branch and a read from cr4 to each vm entry.  Because it is\nextremely likely that consecutive entries into the same vcpu will have\nthe same host cr4 value, this fixes up the vmcs instead of restoring cr4\nafter the fact.  A subsequent patch will add a kernel-wide cr4 shadow,\nreducing the overhead in the common case to just two memory reads and a\nbranch.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nAcked-by: Paolo Bonzini <pbonzini@redhat.com>\nCc: stable@vger.kernel.org\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Gleb Natapov <gleb@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 611}
{"func": "static inline size_t xfrm_sadinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_sadhinfo))\n\t       + nla_total_size(4); /* XFRMA_SAD_CNT */\n}", "target": 0, "cwe": ["CWE-264"], "project": "net", "commit_id": "90f62cf30a78721641e08737bda787552428061e", "hash": 255732847821799135909414559946206217018, "size": 6, "message": "net: Use netlink_ns_capable to verify the permisions of netlink messages\n\nIt is possible by passing a netlink socket to a more privileged\nexecutable and then to fool that executable into writing to the socket\ndata that happens to be valid netlink message to do something that\nprivileged executable did not intend to do.\n\nTo keep this from happening replace bare capable and ns_capable calls\nwith netlink_capable, netlink_net_calls and netlink_ns_capable calls.\nWhich act the same as the previous calls except they verify that the\nopener of the socket had the desired permissions as well.\n\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 612}
{"func": "PHP_FUNCTION(xml_parser_create)\n{\n\tphp_xml_parser_create_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\t\n}", "target": 1, "cwe": ["CWE-119"], "project": "php-src", "commit_id": "1248079be837808da4c97364fb3b4c96c8015fbf", "hash": 191580549156583846071158274672078801618, "size": 4, "message": "Fix bug #72099: xml_parse_into_struct segmentation fault", "idx": 613}
{"func": "int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20", "CWE-190"], "project": "jasper", "commit_id": "d42b2388f7f8e0332c846675133acea151fc557a", "hash": 191463958617021529505442890787747772366, "size": 18, "message": "The generation of the configuration file jas_config.h has been completely\nreworked in order to avoid pollution of the global namespace.\n\nSome problematic types like uchar, ulong, and friends have been replaced\nwith names with a jas_ prefix.\n\nAn option max_samples has been added to the BMP and JPEG decoders to\nrestrict the maximum size of image that they can decode.  This change\nwas made as a (possibly temporary) fix to address security concerns.\nA max_samples command-line option has also been added to imginfo.\n\nWhether an image component (for jas_image_t) is stored in memory or on\ndisk is now based on the component size (rather than the image size).\n\nSome debug log message were added.\n\nSome new integer overflow checks were added.\n\nSome new safe integer add/multiply functions were added.\n\nMore pre-C99 cruft was removed.  JasPer has numerous \"hacks\" to\nhandle pre-C99 compilers.  JasPer now assumes C99 support.  So, this\npre-C99 cruft is unnecessary and can be removed.\n\nThe regression jasper-doublefree-mem_close.jpg has been re-enabled.\nTheoretically, it should work more predictably now.", "idx": 614}
{"func": "bgp_attr_med (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  /* Length check. */\n  if (length != 4)\n    {\n      zlog (peer->log, LOG_ERR, \n\t    \"MED attribute length isn't four [%d]\", length);\n\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n\n  attr->med = stream_getl (peer->ibuf);\n\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}", "target": 0, "cwe": [], "project": "quagga", "commit_id": "8794e8d229dc9fe29ea31424883433d4880ef408", "hash": 79802759500674838769336838558014737967, "size": 23, "message": "bgpd: Fix regression in args consolidation, total should be inited from args\n\n* bgp_attr.c: (bgp_attr_unknown) total should be initialised from the args.", "idx": 615}
{"func": "static void lsi_reg_writeb(LSIState *s, int offset, uint8_t val)\n{\n#define CASE_SET_REG24(name, addr) \\\n    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \\\n    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \\\n    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break;\n\n#define CASE_SET_REG32(name, addr) \\\n    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \\\n    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \\\n    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break; \\\n    case addr + 3: s->name &= 0x00ffffff; s->name |= val << 24; break;\n\n    trace_lsi_reg_write(offset < ARRAY_SIZE(names) ? names[offset] : \"???\",\n                        offset, val);\n\n    switch (offset) {\n    case 0x00: /* SCNTL0 */\n        s->scntl0 = val;\n        if (val & LSI_SCNTL0_START) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: Start sequence not implemented\\n\");\n        }\n        break;\n    case 0x01: /* SCNTL1 */\n        s->scntl1 = val & ~LSI_SCNTL1_SST;\n        if (val & LSI_SCNTL1_IARB) {\n            qemu_log_mask(LOG_UNIMP,\n                      \"lsi_scsi: Immediate Arbritration not implemented\\n\");\n        }\n        if (val & LSI_SCNTL1_RST) {\n            if (!(s->sstat0 & LSI_SSTAT0_RST)) {\n                qbus_reset_all(BUS(&s->bus));\n                s->sstat0 |= LSI_SSTAT0_RST;\n                lsi_script_scsi_interrupt(s, LSI_SIST0_RST, 0);\n            }\n        } else {\n            s->sstat0 &= ~LSI_SSTAT0_RST;\n        }\n        break;\n    case 0x02: /* SCNTL2 */\n        val &= ~(LSI_SCNTL2_WSR | LSI_SCNTL2_WSS);\n        s->scntl2 = val;\n        break;\n    case 0x03: /* SCNTL3 */\n        s->scntl3 = val;\n        break;\n    case 0x04: /* SCID */\n        s->scid = val;\n        break;\n    case 0x05: /* SXFER */\n        s->sxfer = val;\n        break;\n    case 0x06: /* SDID */\n        if ((s->ssid & 0x80) && (val & 0xf) != (s->ssid & 0xf)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: Destination ID does not match SSID\\n\");\n        }\n        s->sdid = val & 0xf;\n        break;\n    case 0x07: /* GPREG0 */\n        break;\n    case 0x08: /* SFBR */\n        /* The CPU is not allowed to write to this register.  However the\n           SCRIPTS register move instructions are.  */\n        s->sfbr = val;\n        break;\n    case 0x0a: case 0x0b:\n        /* Openserver writes to these readonly registers on startup */\n        return;\n    case 0x0c: case 0x0d: case 0x0e: case 0x0f:\n        /* Linux writes to these readonly registers on startup.  */\n        return;\n    CASE_SET_REG32(dsa, 0x10)\n    case 0x14: /* ISTAT0 */\n        s->istat0 = (s->istat0 & 0x0f) | (val & 0xf0);\n        if (val & LSI_ISTAT0_ABRT) {\n            lsi_script_dma_interrupt(s, LSI_DSTAT_ABRT);\n        }\n        if (val & LSI_ISTAT0_INTF) {\n            s->istat0 &= ~LSI_ISTAT0_INTF;\n            lsi_update_irq(s);\n        }\n        if (s->waiting == LSI_WAIT_RESELECT && val & LSI_ISTAT0_SIGP) {\n            trace_lsi_awoken();\n            s->waiting = LSI_NOWAIT;\n            s->dsp = s->dnad;\n            lsi_execute_script(s);\n        }\n        if (val & LSI_ISTAT0_SRST) {\n            qdev_reset_all(DEVICE(s));\n        }\n        break;\n    case 0x16: /* MBOX0 */\n        s->mbox0 = val;\n        break;\n    case 0x17: /* MBOX1 */\n        s->mbox1 = val;\n        break;\n    case 0x18: /* CTEST0 */\n        /* nothing to do */\n        break;\n    case 0x1a: /* CTEST2 */\n        s->ctest2 = val & LSI_CTEST2_PCICIE;\n        break;\n    case 0x1b: /* CTEST3 */\n        s->ctest3 = val & 0x0f;\n        break;\n    CASE_SET_REG32(temp, 0x1c)\n    case 0x21: /* CTEST4 */\n        if (val & 7) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: Unimplemented CTEST4-FBL 0x%x\\n\", val);\n        }\n        s->ctest4 = val;\n        break;\n    case 0x22: /* CTEST5 */\n        if (val & (LSI_CTEST5_ADCK | LSI_CTEST5_BBCK)) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: CTEST5 DMA increment not implemented\\n\");\n        }\n        s->ctest5 = val;\n        break;\n    CASE_SET_REG24(dbc, 0x24)\n    CASE_SET_REG32(dnad, 0x28)\n    case 0x2c: /* DSP[0:7] */\n        s->dsp &= 0xffffff00;\n        s->dsp |= val;\n        break;\n    case 0x2d: /* DSP[8:15] */\n        s->dsp &= 0xffff00ff;\n        s->dsp |= val << 8;\n        break;\n    case 0x2e: /* DSP[16:23] */\n        s->dsp &= 0xff00ffff;\n        s->dsp |= val << 16;\n        break;\n    case 0x2f: /* DSP[24:31] */\n        s->dsp &= 0x00ffffff;\n        s->dsp |= val << 24;\n        if ((s->dmode & LSI_DMODE_MAN) == 0\n            && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n            lsi_execute_script(s);\n        break;\n    CASE_SET_REG32(dsps, 0x30)\n    CASE_SET_REG32(scratch[0], 0x34)\n    case 0x38: /* DMODE */\n        s->dmode = val;\n        break;\n    case 0x39: /* DIEN */\n        s->dien = val;\n        lsi_update_irq(s);\n        break;\n    case 0x3a: /* SBR */\n        s->sbr = val;\n        break;\n    case 0x3b: /* DCNTL */\n        s->dcntl = val & ~(LSI_DCNTL_PFF | LSI_DCNTL_STD);\n        if ((val & LSI_DCNTL_STD) && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n            lsi_execute_script(s);\n        break;\n    case 0x40: /* SIEN0 */\n        s->sien0 = val;\n        lsi_update_irq(s);\n        break;\n    case 0x41: /* SIEN1 */\n        s->sien1 = val;\n        lsi_update_irq(s);\n        break;\n    case 0x47: /* GPCNTL0 */\n        break;\n    case 0x48: /* STIME0 */\n        s->stime0 = val;\n        break;\n    case 0x49: /* STIME1 */\n        if (val & 0xf) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: General purpose timer not implemented\\n\");\n            /* ??? Raising the interrupt immediately seems to be sufficient\n               to keep the FreeBSD driver happy.  */\n            lsi_script_scsi_interrupt(s, 0, LSI_SIST1_GEN);\n        }\n        break;\n    case 0x4a: /* RESPID0 */\n        s->respid0 = val;\n        break;\n    case 0x4b: /* RESPID1 */\n        s->respid1 = val;\n        break;\n    case 0x4d: /* STEST1 */\n        s->stest1 = val;\n        break;\n    case 0x4e: /* STEST2 */\n        if (val & 1) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: Low level mode not implemented\\n\");\n        }\n        s->stest2 = val;\n        break;\n    case 0x4f: /* STEST3 */\n        if (val & 0x41) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: SCSI FIFO test mode not implemented\\n\");\n        }\n        s->stest3 = val;\n        break;\n    case 0x56: /* CCNTL0 */\n        s->ccntl0 = val;\n        break;\n    case 0x57: /* CCNTL1 */\n        s->ccntl1 = val;\n        break;\n    CASE_SET_REG32(mmrs, 0xa0)\n    CASE_SET_REG32(mmws, 0xa4)\n    CASE_SET_REG32(sfs, 0xa8)\n    CASE_SET_REG32(drs, 0xac)\n    CASE_SET_REG32(sbms, 0xb0)\n    CASE_SET_REG32(dbms, 0xb4)\n    CASE_SET_REG32(dnad64, 0xb8)\n    CASE_SET_REG32(pmjad1, 0xc0)\n    CASE_SET_REG32(pmjad2, 0xc4)\n    CASE_SET_REG32(rbc, 0xc8)\n    CASE_SET_REG32(ua, 0xcc)\n    CASE_SET_REG32(ia, 0xd4)\n    CASE_SET_REG32(sbc, 0xd8)\n    CASE_SET_REG32(csbc, 0xdc)\n    default:\n        if (offset >= 0x5c && offset < 0xa0) {\n            int n;\n            int shift;\n            n = (offset - 0x58) >> 2;\n            shift = (offset & 3) * 8;\n            s->scratch[n] = deposit32(s->scratch[n], shift, 8, val);\n        } else {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: invalid write to reg %s %x (0x%02x)\\n\",\n                          offset < ARRAY_SIZE(names) ? names[offset] : \"???\",\n                          offset, val);\n        }\n    }\n#undef CASE_SET_REG24\n#undef CASE_SET_REG32\n}", "target": 1, "cwe": ["CWE-835"], "project": "qemu", "commit_id": "de594e47659029316bbf9391efb79da0a1a08e08", "hash": 95546068408109141614201670074415591929, "size": 243, "message": "scsi: lsi: exit infinite loop while executing script (CVE-2019-12068)\n\nWhen executing script in lsi_execute_script(), the LSI scsi adapter\nemulator advances 's->dsp' index to read next opcode. This can lead\nto an infinite loop if the next opcode is empty. Move the existing\nloop exit after 10k iterations so that it covers no-op opcodes as\nwell.\n\nReported-by: Bugs SysSec <bugs-syssec@rub.de>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 616}
{"func": "static void calipso_doi_putdef(struct calipso_doi *doi_def)\n{\n\tif (!doi_def)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&doi_def->refcount))\n\t\treturn;\n\tspin_lock(&calipso_doi_list_lock);\n\tlist_del_rcu(&doi_def->list);\n\tspin_unlock(&calipso_doi_list_lock);\n\n\tcall_rcu(&doi_def->rcu, calipso_doi_free_rcu);\n}", "target": 1, "cwe": ["CWE-416"], "project": "linux", "commit_id": "ad5d07f4a9cd671233ae20983848874731102c08", "hash": 321199570476501283051654458521836581322, "size": 13, "message": "cipso,calipso: resolve a number of problems with the DOI refcounts\n\nThe current CIPSO and CALIPSO refcounting scheme for the DOI\ndefinitions is a bit flawed in that we:\n\n1. Don't correctly match gets/puts in netlbl_cipsov4_list().\n2. Decrement the refcount on each attempt to remove the DOI from the\n   DOI list, only removing it from the list once the refcount drops\n   to zero.\n\nThis patch fixes these problems by adding the missing \"puts\" to\nnetlbl_cipsov4_list() and introduces a more conventional, i.e.\nnot-buggy, refcounting mechanism to the DOI definitions.  Upon the\naddition of a DOI to the DOI list, it is initialized with a refcount\nof one, removing a DOI from the list removes it from the list and\ndrops the refcount by one; \"gets\" and \"puts\" behave as expected with\nrespect to refcounts, increasing and decreasing the DOI's refcount by\none.\n\nFixes: b1edeb102397 (\"netlabel: Replace protocol/NetLabel linking with refrerence counts\")\nFixes: d7cce01504a0 (\"netlabel: Add support for removing a CALIPSO DOI.\")\nReported-by: syzbot+9ec037722d2603a9f52e@syzkaller.appspotmail.com\nSigned-off-by: Paul Moore <paul@paul-moore.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 617}
{"func": "exif_mnote_data_olympus_load (ExifMnoteData *en,\n\t\t\t      const unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) en;\n\tExifShort c;\n\tsize_t i, tcount, o, o2, datao = 6, base = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\to2 = 6 + n->offset; /* Start of interesting data */\n\tif (CHECKOVERFLOW(o2,buf_size,10)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Olympus headers start with \"OLYMP\" and need to have at least\n\t * a size of 22 bytes (6 for 'OLYMP', 2 other bytes, 2 for the\n\t * number of entries, and 12 for one entry.\n\t *\n\t * Sanyo format is identical and uses identical tags except that\n\t * header starts with \"SANYO\".\n\t *\n\t * Epson format is identical and uses identical tags except that\n\t * header starts with \"EPSON\".\n\t *\n\t * Nikon headers start with \"Nikon\" (6 bytes including '\\0'), \n\t * version number (1 or 2).\n\t * \n\t * Version 1 continues with 0, 1, 0, number_of_tags,\n\t * or just with number_of_tags (models D1H, D1X...).\n\t * \n\t * Version 2 continues with an unknown byte (0 or 10),\n\t * two unknown bytes (0), \"MM\" or \"II\", another byte 0 and \n\t * lastly 0x2A.\n\t */\n\tn->version = exif_mnote_data_olympus_identify_variant(buf+o2, buf_size-o2);\n\tswitch (n->version) {\n\tcase olympusV1:\n\tcase sanyoV1:\n\tcase epsonV1:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus/Sanyo/Epson maker note v1...\");\n\n\t\t/* The number of entries is at position 8. */\n\t\tif (buf[o2 + 6] == 1)\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if (buf[o2 + 6 + 1] == 1)\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\to2 += 8;\n\t\tc = exif_get_short (buf + o2, n->order);\n\t\tif ((!(c & 0xFF)) && (c > 0x500)) {\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase olympusV2:\n\t\t/* Olympus S760, S770 */\n\t\tdatao = o2;\n\t\to2 += 8;\n\t\tif (CHECKOVERFLOW(o2,buf_size,4)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\tif ((buf[o2] == 'I') && (buf[o2 + 1] == 'I'))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if ((buf[o2] == 'M') && (buf[o2 + 1] == 'M'))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\n\t\t/* The number of entries is at position 8+4. */\n\t\to2 += 4;\n\t\tbreak;\n\n\tcase nikonV1:\n\t\to2 += 6;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v1 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\t/* Skip version number */\n\t\to2 += 1;\n\n\t\t/* Skip an unknown byte (00 or 0A). */\n\t\to2 += 1;\n\n\t\tbase = MNOTE_NIKON1_TAG_BASE;\n\t\t/* Fix endianness, if needed */\n\t\tc = exif_get_short (buf + o2, n->order);\n\t\tif ((!(c & 0xFF)) && (c > 0x500)) {\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase nikonV2:\n\t\to2 += 6;\n\t\tif (CHECKOVERFLOW(o2,buf_size,12)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3],\n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\n\t\t/* Skip version number */\n\t\to2 += 1;\n\n\t\t/* Skip an unknown byte (00 or 0A). */\n\t\to2 += 1;\n\n\t\t/* Skip 2 unknown bytes (00 00). */\n\t\to2 += 2;\n\n\t\t/*\n\t\t * Byte order. From here the data offset\n\t\t * gets calculated.\n\t\t */\n\t\tdatao = o2;\n\t\tif (!strncmp ((char *)&buf[o2], \"II\", 2))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if (!strncmp ((char *)&buf[o2], \"MM\", 2))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\telse {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\"ExifMnoteDataOlympus\", \"Unknown \"\n\t\t\t\t\"byte order '%c%c'\", buf[o2],\n\t\t\t\tbuf[o2 + 1]);\n\t\t\treturn;\n\t\t}\n\t\to2 += 2;\n\n\t\t/* Skip 2 unknown bytes (00 2A). */\n\t\to2 += 2;\n\n\t\t/* Go to where the number of entries is. */\n\t\to2 = datao + exif_get_long (buf + o2, n->order);\n\t\tbreak;\n\n\tcase nikonV0:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v0 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3], \n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\t\t/* 00 1b is # of entries in Motorola order - the rest should also be in MM order */\n\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\tbreak;\n\n\tdefault:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Unknown Olympus variant %i.\", n->version);\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tif (CHECKOVERFLOW(o2,buf_size,2)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + o2, n->order);\n\to2 += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_olympus_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnoteOlympusEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", sizeof (MnoteOlympusEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = o2; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif (CHECKOVERFLOW(o, buf_size, 12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t    n->entries[tcount].tag        = exif_get_short (buf + o, n->order) + base;\n\t    n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t    n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t    n->entries[tcount].order      = n->order;\n\n\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t      \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t      mnote_olympus_tag_get_name (n->entries[tcount].tag));\n/*\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t\t    \"0x%x %d %ld*(%d)\",\n\t\t    n->entries[tcount].tag,\n\t\t    n->entries[tcount].format,\n\t\t    n->entries[tcount].components,\n\t\t    (int)exif_format_get_size(n->entries[tcount].format)); */\n\n\t    /* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t     * we will check the buffer sizes closer later. */\n\t    if (exif_format_get_size (n->entries[tcount].format) &&\n\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t    ) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifMnoteOlympus\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\tcontinue;\n\t    }\n\t    /*\n\t     * Size? If bigger than 4 bytes, the actual data is not\n\t     * in the entry but somewhere else (offset).\n\t     */\n\t    s = exif_format_get_size (n->entries[tcount].format) *\n\t\t   \t\t\t n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) {\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + datao;\n#ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG\n\t\t\t\t/* Some Sanyo models (e.g. VPC-C5, C40) suffer from a bug when\n\t\t\t\t * writing the offset for the MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE\n\t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n\t\t\t\t * position in the file instead of the position within the IFD.\n\t\t\t\t */\n\t\t\t    if (dataofs > (buf_size - s) && n->version == sanyoV1) {\n\t\t\t\t\t/* fix pointer */\n\t\t\t\t\tdataofs -= datao + 6;\n\t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t\t  \"Inconsistent thumbnail tag offset; attempting to recover\");\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t  (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}", "target": 1, "cwe": ["CWE-416", "CWE-908"], "project": "libexif", "commit_id": "ec412aa4583ad71ecabb967d3c77162760169d1f", "hash": 330617258153773225177639968527568751553, "size": 269, "message": "Ensure the MakerNote data pointers are initialized with NULL.\n\nThis ensures that an uninitialized pointer isn't dereferenced later in\nthe case where the number of components (and therefore size) is 0.\n\nThis fixes the second issue reported at\nhttps://sourceforge.net/p/libexif/bugs/125/\n\nCVE-2020-13113", "idx": 618}
{"func": "static int accel_fp_mul(int idx, mp_int* k, ecc_point *R, mp_int* a,\n                        mp_int* modulus, mp_digit mp, int map)\n{\n#define KB_SIZE 128\n\n#ifdef WOLFSSL_SMALL_STACK\n   unsigned char* kb = NULL;\n#else\n   unsigned char kb[KB_SIZE];\n#endif\n   int      x, err;\n   unsigned y, z = 0, bitlen, bitpos, lut_gap, first;\n   mp_int   tk, order;\n\n   if (mp_init_multi(&tk, &order, NULL, NULL, NULL, NULL) != MP_OKAY)\n       return MP_INIT_E;\n\n   /* if it's smaller than modulus we fine */\n   if (mp_unsigned_bin_size(k) > mp_unsigned_bin_size(modulus)) {\n      /* find order */\n      y = mp_unsigned_bin_size(modulus);\n      for (x = 0; ecc_sets[x].size; x++) {\n         if (y <= (unsigned)ecc_sets[x].size) break;\n      }\n\n      /* back off if we are on the 521 bit curve */\n      if (y == 66) --x;\n\n      if ((err = mp_read_radix(&order, ecc_sets[x].order,\n                                                MP_RADIX_HEX)) != MP_OKAY) {\n         goto done;\n      }\n\n      /* k must be less than modulus */\n      if (mp_cmp(k, &order) != MP_LT) {\n         if ((err = mp_mod(k, &order, &tk)) != MP_OKAY) {\n            goto done;\n         }\n      } else {\n         if ((err = mp_copy(k, &tk)) != MP_OKAY) {\n            goto done;\n         }\n      }\n   } else {\n      if ((err = mp_copy(k, &tk)) != MP_OKAY) {\n         goto done;\n      }\n   }\n\n   /* get bitlen and round up to next multiple of FP_LUT */\n   bitlen  = mp_unsigned_bin_size(modulus) << 3;\n   x       = bitlen % FP_LUT;\n   if (x) {\n      bitlen += FP_LUT - x;\n   }\n   lut_gap = bitlen / FP_LUT;\n\n   /* get the k value */\n   if (mp_unsigned_bin_size(&tk) > (int)(KB_SIZE - 2)) {\n      err = BUFFER_E; goto done;\n   }\n\n   /* store k */\n#ifdef WOLFSSL_SMALL_STACK\n   kb = (unsigned char*)XMALLOC(KB_SIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (kb == NULL) {\n      err = MEMORY_E; goto done;\n   }\n#endif\n\n   XMEMSET(kb, 0, KB_SIZE);\n   if ((err = mp_to_unsigned_bin(&tk, kb)) == MP_OKAY) {\n      /* let's reverse kb so it's little endian */\n      x = 0;\n      y = mp_unsigned_bin_size(&tk);\n      if (y > 0) {\n          y -= 1;\n      }\n\n      while ((unsigned)x < y) {\n         z = kb[x]; kb[x] = kb[y]; kb[y] = (byte)z;\n         ++x; --y;\n      }\n\n      /* at this point we can start, yipee */\n      first = 1;\n      for (x = lut_gap-1; x >= 0; x--) {\n          /* extract FP_LUT bits from kb spread out by lut_gap bits and offset\n             by x bits from the start */\n          bitpos = x;\n          for (y = z = 0; y < FP_LUT; y++) {\n             z |= ((kb[bitpos>>3] >> (bitpos&7)) & 1) << y;\n             bitpos += lut_gap;  /* it's y*lut_gap + x, but here we can avoid\n                                    the mult in each loop */\n          }\n\n          /* double if not first */\n          if (!first) {\n             if ((err = ecc_projective_dbl_point(R, R, a, modulus,\n                                                             mp)) != MP_OKAY) {\n                break;\n             }\n          }\n\n          /* add if not first, otherwise copy */\n          if (!first && z) {\n             if ((err = ecc_projective_add_point(R, fp_cache[idx].LUT[z], R,\n                                                 a, modulus, mp)) != MP_OKAY) {\n                break;\n             }\n          } else if (z) {\n             if ((mp_copy(fp_cache[idx].LUT[z]->x, R->x) != MP_OKAY) ||\n                 (mp_copy(fp_cache[idx].LUT[z]->y, R->y) != MP_OKAY) ||\n                 (mp_copy(&fp_cache[idx].mu,       R->z) != MP_OKAY)) {\n                 err = GEN_MEM_ERR;\n                 break;\n             }\n                 first = 0;\n          }\n      }\n   }\n\n   if (err == MP_OKAY) {\n      (void) z; /* Acknowledge the unused assignment */\n      ForceZero(kb, KB_SIZE);\n\n      /* map R back from projective space */\n      if (map) {\n         err = ecc_map(R, modulus, mp);\n      } else {\n         err = MP_OKAY;\n      }\n   }\n\ndone:\n   /* cleanup */\n   mp_clear(&order);\n   mp_clear(&tk);\n\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(kb, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n#undef KB_SIZE\n\n   return err;\n}", "target": 0, "cwe": ["CWE-200"], "project": "wolfssl", "commit_id": "9b9568d500f31f964af26ba8d01e542e1f27e5ca", "hash": 55588046341039224725171828074635724967, "size": 147, "message": "Change ECDSA signing to use blinding.", "idx": 619}
{"func": "  const char *type_name()\n  {\n    return type == COLUMN ? \"COLUMN\" :\n           type == CHECK_CONSTRAINT ? \"CONSTRAINT\" :\n           type == KEY ? \"INDEX\" : \"FOREIGN KEY\";\n  }", "target": 0, "cwe": ["CWE-416"], "project": "server", "commit_id": "4681b6f2d8c82b4ec5cf115e83698251963d80d5", "hash": 251224855229362654707364240269987360727, "size": 6, "message": "MDEV-26281 ASAN use-after-poison when complex conversion is involved in blob\n\nthe bug was that in_vector array in Item_func_in was allocated in the\nstatement arena, not in the table->expr_arena.\n\nrevert part of the 5acd391e8b2d. Instead, change the arena correctly\nin fix_all_session_vcol_exprs().\n\nRemove TABLE_ARENA, that was introduced in 5acd391e8b2d to force\nitem tree changes to be rolled back (because they were allocated in the\nwrong arena and didn't persist. now they do)", "idx": 620}
{"func": "getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name, service_name;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n\n    xdr_free(xdr_getprivs_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1, "cwe": ["CWE-119", "CWE-772", "CWE-401"], "project": "krb5", "commit_id": "83ed75feba32e46f736fcce0d96a0445f29b96c2", "hash": 25108696959963005566115320249597464131, "size": 39, "message": "Fix leaks in kadmin server stubs [CVE-2015-8631]\n\nIn each kadmind server stub, initialize the client_name and\nserver_name variables, and release them in the cleanup handler.  Many\nof the stubs will otherwise leak the client and server name if\nkrb5_unparse_name() fails.  Also make sure to free the prime_arg\nvariables in rename_principal_2_svc(), or we can leak the first one if\nunparsing the second one fails.  Discovered by Simo Sorce.\n\nCVE-2015-8631:\n\nIn all versions of MIT krb5, an authenticated attacker can cause\nkadmind to leak memory by supplying a null principal name in a request\nwhich uses one.  Repeating these requests will eventually cause\nkadmind to exhaust all available memory.\n\n    CVSSv2 Vector: AV:N/AC:L/Au:S/C:N/I:N/A:C/E:POC/RL:OF/RC:C\n\nticket: 8343 (new)\ntarget_version: 1.14-next\ntarget_version: 1.13-next\ntags: pullup", "idx": 621}
{"func": "xfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t/* allocation argument structure */\n\txfs_agblock_t\tfoundbno,\t/* starting block in found extent */\n\txfs_extlen_t\tfoundlen,\t/* length in found extent */\n\txfs_agblock_t\t*resbno,\t/* result block number */\n\txfs_extlen_t\t*reslen,\t/* result length */\n\tunsigned\t*busy_gen)\n{\n\txfs_agblock_t\tbno = foundbno;\n\txfs_extlen_t\tlen = foundlen;\n\txfs_extlen_t\tdiff;\n\tbool\t\tbusy;\n\n\t/* Trim busy sections out of found extent */\n\tbusy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);\n\n\t/*\n\t * If we have a largish extent that happens to start before min_agbno,\n\t * see if we can shift it into range...\n\t */\n\tif (bno < args->min_agbno && bno + len > args->min_agbno) {\n\t\tdiff = args->min_agbno - bno;\n\t\tif (len > diff) {\n\t\t\tbno += diff;\n\t\t\tlen -= diff;\n\t\t}\n\t}\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\n\t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n\n\treturn busy;\n}", "target": 0, "cwe": ["CWE-400", "CWE-703", "CWE-835"], "project": "linux", "commit_id": "d0c7feaf87678371c2c09b3709400be416b2dc62", "hash": 165512308505164662076809873326746406591, "size": 42, "message": "xfs: add agf freeblocks verify in xfs_agf_verify\n\nWe recently used fuzz(hydra) to test XFS and automatically generate\ntmp.img(XFS v5 format, but some metadata is wrong)\n\nxfs_repair information(just one AG):\nagf_freeblks 0, counted 3224 in ag 0\nagf_longest 536874136, counted 3224 in ag 0\nsb_fdblocks 613, counted 3228\n\nTest as follows:\nmount tmp.img tmpdir\ncp file1M tmpdir\nsync\n\nIn 4.19-stable, sync will stuck, the reason is:\nxfs_mountfs\n  xfs_check_summary_counts\n    if ((!xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n       XFS_LAST_UNMOUNT_WAS_CLEAN(mp)) &&\n       !xfs_fs_has_sickness(mp, XFS_SICK_FS_COUNTERS))\n\treturn 0;  -->just return, incore sb_fdblocks still be 613\n    xfs_initialize_perag_data\n\ncp file1M tmpdir -->ok(write file to pagecache)\nsync -->stuck(write pagecache to disk)\nxfs_map_blocks\n  xfs_iomap_write_allocate\n    while (count_fsb != 0) {\n      nimaps = 0;\n      while (nimaps == 0) { --> endless loop\n         nimaps = 1;\n         xfs_bmapi_write(..., &nimaps) --> nimaps becomes 0 again\nxfs_bmapi_write\n  xfs_bmap_alloc\n    xfs_bmap_btalloc\n      xfs_alloc_vextent\n        xfs_alloc_fix_freelist\n          xfs_alloc_space_available -->fail(agf_freeblks is 0)\n\nIn linux-next, sync not stuck, cause commit c2b3164320b5 (\"xfs:\nuse the latest extent at writeback delalloc conversion time\") remove\nthe above while, dmesg is as follows:\n[   55.250114] XFS (loop0): page discard on page ffffea0008bc7380, inode 0x1b0c, offset 0.\n\nUsers do not know why this page is discard, the better soultion is:\n1. Like xfs_repair, make sure sb_fdblocks is equal to counted\n(xfs_initialize_perag_data did this, who is not called at this mount)\n2. Add agf verify, if fail, will tell users to repair\n\nThis patch use the second soultion.\n\nSigned-off-by: Zheng Bin <zhengbin13@huawei.com>\nSigned-off-by: Ren Xudong <renxudong1@huawei.com>\nReviewed-by: Darrick J. Wong <darrick.wong@oracle.com>\nSigned-off-by: Darrick J. Wong <darrick.wong@oracle.com>", "idx": 622}
{"func": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t/* cleanup if umh_setup() was successful but exec failed */\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}", "target": 1, "cwe": ["CWE-401"], "project": "linux", "commit_id": "f60a85cad677c4f9bb4cadd764f1d106c38c7cf8", "hash": 202261761255865455882373619018707547027, "size": 12, "message": "bpf: Fix umd memory leak in copy_process()\n\nThe syzbot reported a memleak as follows:\n\nBUG: memory leak\nunreferenced object 0xffff888101b41d00 (size 120):\n  comm \"kworker/u4:0\", pid 8, jiffies 4294944270 (age 12.780s)\n  backtrace:\n    [<ffffffff8125dc56>] alloc_pid+0x66/0x560\n    [<ffffffff81226405>] copy_process+0x1465/0x25e0\n    [<ffffffff81227943>] kernel_clone+0xf3/0x670\n    [<ffffffff812281a1>] kernel_thread+0x61/0x80\n    [<ffffffff81253464>] call_usermodehelper_exec_work\n    [<ffffffff81253464>] call_usermodehelper_exec_work+0xc4/0x120\n    [<ffffffff812591c9>] process_one_work+0x2c9/0x600\n    [<ffffffff81259ab9>] worker_thread+0x59/0x5d0\n    [<ffffffff812611c8>] kthread+0x178/0x1b0\n    [<ffffffff8100227f>] ret_from_fork+0x1f/0x30\n\nunreferenced object 0xffff888110ef5c00 (size 232):\n  comm \"kworker/u4:0\", pid 8414, jiffies 4294944270 (age 12.780s)\n  backtrace:\n    [<ffffffff8154a0cf>] kmem_cache_zalloc\n    [<ffffffff8154a0cf>] __alloc_file+0x1f/0xf0\n    [<ffffffff8154a809>] alloc_empty_file+0x69/0x120\n    [<ffffffff8154a8f3>] alloc_file+0x33/0x1b0\n    [<ffffffff8154ab22>] alloc_file_pseudo+0xb2/0x140\n    [<ffffffff81559218>] create_pipe_files+0x138/0x2e0\n    [<ffffffff8126c793>] umd_setup+0x33/0x220\n    [<ffffffff81253574>] call_usermodehelper_exec_async+0xb4/0x1b0\n    [<ffffffff8100227f>] ret_from_fork+0x1f/0x30\n\nAfter the UMD process exits, the pipe_to_umh/pipe_from_umh and\ntgid need to be released.\n\nFixes: d71fa5c9763c (\"bpf: Add kernel module with user mode driver that populates bpffs.\")\nReported-by: syzbot+44908bb56d2bfe56b28e@syzkaller.appspotmail.com\nSigned-off-by: Zqiang <qiang.zhang@windriver.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nLink: https://lore.kernel.org/bpf/20210317030915.2865-1-qiang.zhang@windriver.com", "idx": 623}
{"func": "Crypto::Crypto() \n    : digest_(0), cipher_(0), dh_(0) \n{}", "target": 0, "cwe": ["CWE-254"], "project": "mysql-server", "commit_id": "e7061f7e5a96c66cb2e0bf46bec7f6ff35801a69", "hash": 63608590027117549461460993521954273392, "size": 3, "message": "Bug #22738607:  YASSL FUNCTION X509_NAME_GET_INDEX_BY_NID IS NOT WORKING AS EXPECTED.", "idx": 624}
{"func": "replace_read_d2f\t(SF_PRIVATE *psf, float *ptr, sf_count_t len)\n{\tBUF_UNION\tubuf ;\n\tint\t\t\tbufferlen, readcount ;\n\tsf_count_t\ttotal = 0 ;\n\n\tbufferlen = ARRAY_LEN (ubuf.dbuf) ;\n\n\twhile (len > 0)\n\t{\tif (len < bufferlen)\n\t\t\tbufferlen = (int) len ;\n\t\treadcount = psf_fread (ubuf.dbuf, sizeof (double), bufferlen, psf) ;\n\n\t\tif (psf->data_endswap == SF_TRUE)\n\t\t\tendswap_double_array (ubuf.dbuf, bufferlen) ;\n\n\t\td2bd_read (ubuf.dbuf, bufferlen) ;\n\n\t\tmemcpy (ptr + total, ubuf.dbuf, bufferlen * sizeof (double)) ;\n\n\t\ttotal += readcount ;\n\t\tif (readcount < bufferlen)\n\t\t\tbreak ;\n\t\tlen -= readcount ;\n\t\t} ;\n\n\treturn total ;\n} /* replace_read_d2f */", "target": 0, "cwe": ["CWE-369"], "project": "libsndfile", "commit_id": "85c877d5072866aadbe8ed0c3e0590fbb5e16788", "hash": 98428794396637552789694374324860182988, "size": 27, "message": "double64_init: Check psf->sf.channels against upper bound\n\nThis prevents division by zero later in the code.\n\nWhile the trivial case to catch this (i.e. sf.channels < 1) has already\nbeen covered, a crafted file may report a number of channels that is\nso high (i.e. > INT_MAX/sizeof(double)) that it \"somehow\" gets\nmiscalculated to zero (if this makes sense) in the determination of the\nblockwidth. Since we only support a limited number of channels anyway,\nmake sure to check here as well.\n\nCVE-2017-14634\n\nCloses: https://github.com/erikd/libsndfile/issues/318\nSigned-off-by: Erik de Castro Lopo <erikd@mega-nerd.com>", "idx": 625}
{"func": "Status AuthorizationManager::getRolesDescription(OperationContext* txn,\n                                                 const std::vector<RoleName>& roleName,\n                                                 PrivilegeFormat privileges,\n                                                 BSONObj* result) {\n    return _externalState->getRolesDescription(txn, roleName, privileges, result);\n}", "target": 0, "cwe": ["CWE-613"], "project": "mongo", "commit_id": "64d8e9e1b12d16b54d6a592bae8110226c491b4e", "hash": 120397433542213827906153483340936351401, "size": 6, "message": "SERVER-38984 Validate unique User ID on UserCache hit\n\n(cherry picked from commit e55d6e2292e5dbe2f97153251d8193d1cc89f5d7)", "idx": 626}
{"func": "TEST(HeaderMapImplTest, Remove) {\n  HeaderMapImpl headers;\n\n  // Add random header and then remove by name.\n  LowerCaseString static_key(\"hello\");\n  std::string ref_value(\"value\");\n  headers.addReference(static_key, ref_value);\n  EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n  EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.remove(static_key);\n  EXPECT_EQ(nullptr, headers.get(static_key));\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_TRUE(headers.empty());\n\n  // Add and remove by inline.\n  headers.insertContentLength().value(5);\n  EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.removeContentLength();\n  EXPECT_EQ(nullptr, headers.ContentLength());\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_TRUE(headers.empty());\n\n  // Add inline and remove by name.\n  headers.insertContentLength().value(5);\n  EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.remove(Headers::get().ContentLength);\n  EXPECT_EQ(nullptr, headers.ContentLength());\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_TRUE(headers.empty());\n}", "target": 1, "cwe": ["CWE-400", "CWE-703"], "project": "envoy", "commit_id": "afc39bea36fd436e54262f150c009e8d72db5014", "hash": 118316256596932131506234269447033604888, "size": 36, "message": "Track byteSize of HeaderMap internally.\n\nIntroduces a cached byte size updated internally in HeaderMap. The value\nis stored as an optional, and is cleared whenever a non-const pointer or\nreference to a HeaderEntry is accessed. The cached value can be set with\nrefreshByteSize() which performs an iteration over the HeaderMap to sum\nthe size of each key and value in the HeaderMap.\n\nSigned-off-by: Asra Ali <asraa@google.com>", "idx": 627}
{"func": "int vhost_get_vq_desc(struct vhost_virtqueue *vq,\n\t\t      struct iovec iov[], unsigned int iov_size,\n\t\t      unsigned int *out_num, unsigned int *in_num,\n\t\t      struct vhost_log *log, unsigned int *log_num)\n{\n\tstruct vring_desc desc;\n\tunsigned int i, head, found = 0;\n\tu16 last_avail_idx;\n\t__virtio16 avail_idx;\n\t__virtio16 ring_head;\n\tint ret, access;\n\n\t/* Check it isn't doing very strange things with descriptor numbers. */\n\tlast_avail_idx = vq->last_avail_idx;\n\n\tif (vq->avail_idx == vq->last_avail_idx) {\n\t\tif (unlikely(vhost_get_avail_idx(vq, &avail_idx))) {\n\t\t\tvq_err(vq, \"Failed to access avail idx at %p\\n\",\n\t\t\t\t&vq->avail->idx);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tvq->avail_idx = vhost16_to_cpu(vq, avail_idx);\n\n\t\tif (unlikely((u16)(vq->avail_idx - last_avail_idx) > vq->num)) {\n\t\t\tvq_err(vq, \"Guest moved used index from %u to %u\",\n\t\t\t\tlast_avail_idx, vq->avail_idx);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/* If there's nothing new since last we looked, return\n\t\t * invalid.\n\t\t */\n\t\tif (vq->avail_idx == last_avail_idx)\n\t\t\treturn vq->num;\n\n\t\t/* Only get avail ring entries after they have been\n\t\t * exposed by guest.\n\t\t */\n\t\tsmp_rmb();\n\t}\n\n\t/* Grab the next descriptor number they're advertising, and increment\n\t * the index we've seen. */\n\tif (unlikely(vhost_get_avail_head(vq, &ring_head, last_avail_idx))) {\n\t\tvq_err(vq, \"Failed to read head: idx %d address %p\\n\",\n\t\t       last_avail_idx,\n\t\t       &vq->avail->ring[last_avail_idx % vq->num]);\n\t\treturn -EFAULT;\n\t}\n\n\thead = vhost16_to_cpu(vq, ring_head);\n\n\t/* If their number is silly, that's an error. */\n\tif (unlikely(head >= vq->num)) {\n\t\tvq_err(vq, \"Guest says index %u > %u is available\",\n\t\t       head, vq->num);\n\t\treturn -EINVAL;\n\t}\n\n\t/* When we start there are none of either input nor output. */\n\t*out_num = *in_num = 0;\n\tif (unlikely(log))\n\t\t*log_num = 0;\n\n\ti = head;\n\tdo {\n\t\tunsigned iov_count = *in_num + *out_num;\n\t\tif (unlikely(i >= vq->num)) {\n\t\t\tvq_err(vq, \"Desc index is %u > %u, head = %u\",\n\t\t\t       i, vq->num, head);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (unlikely(++found > vq->num)) {\n\t\t\tvq_err(vq, \"Loop detected: last one at %u \"\n\t\t\t       \"vq size %u head %u\\n\",\n\t\t\t       i, vq->num, head);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = vhost_get_desc(vq, &desc, i);\n\t\tif (unlikely(ret)) {\n\t\t\tvq_err(vq, \"Failed to get descriptor: idx %d addr %p\\n\",\n\t\t\t       i, vq->desc + i);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT)) {\n\t\t\tret = get_indirect(vq, iov, iov_size,\n\t\t\t\t\t   out_num, in_num,\n\t\t\t\t\t   log, log_num, &desc);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tif (ret != -EAGAIN)\n\t\t\t\t\tvq_err(vq, \"Failure detected \"\n\t\t\t\t\t\t\"in indirect descriptor at idx %d\\n\", i);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))\n\t\t\taccess = VHOST_ACCESS_WO;\n\t\telse\n\t\t\taccess = VHOST_ACCESS_RO;\n\t\tret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),\n\t\t\t\t     vhost32_to_cpu(vq, desc.len), iov + iov_count,\n\t\t\t\t     iov_size - iov_count, access);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\tvq_err(vq, \"Translation failure %d descriptor idx %d\\n\",\n\t\t\t\t\tret, i);\n\t\t\treturn ret;\n\t\t}\n\t\tif (access == VHOST_ACCESS_WO) {\n\t\t\t/* If this is an input descriptor,\n\t\t\t * increment that count. */\n\t\t\t*in_num += ret;\n\t\t\tif (unlikely(log)) {\n\t\t\t\tlog[*log_num].addr = vhost64_to_cpu(vq, desc.addr);\n\t\t\t\tlog[*log_num].len = vhost32_to_cpu(vq, desc.len);\n\t\t\t\t++*log_num;\n\t\t\t}\n\t\t} else {\n\t\t\t/* If it's an output descriptor, they're all supposed\n\t\t\t * to come before any input descriptors. */\n\t\t\tif (unlikely(*in_num)) {\n\t\t\t\tvq_err(vq, \"Descriptor has out after in: \"\n\t\t\t\t       \"idx %d\\n\", i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*out_num += ret;\n\t\t}\n\t} while ((i = next_desc(vq, &desc)) != -1);\n\n\t/* On success, increment avail index. */\n\tvq->last_avail_idx++;\n\n\t/* Assume notifications from guest are disabled at this point,\n\t * if they aren't we would need to update avail_event index. */\n\tBUG_ON(!(vq->used_flags & VRING_USED_F_NO_NOTIFY));\n\treturn head;\n}", "target": 1, "cwe": ["CWE-120"], "project": "linux", "commit_id": "060423bfdee3f8bc6e2c1bac97de24d5415e2bc4", "hash": 68969133136396422892072845949618295783, "size": 139, "message": "vhost: make sure log_num < in_num\n\nThe code assumes log_num < in_num everywhere, and that is true as long as\nin_num is incremented by descriptor iov count, and log_num by 1. However\nthis breaks if there's a zero sized descriptor.\n\nAs a result, if a malicious guest creates a vring desc with desc.len = 0,\nit may cause the host kernel to crash by overflowing the log array. This\nbug can be triggered during the VM migration.\n\nThere's no need to log when desc.len = 0, so just don't increment log_num\nin this case.\n\nFixes: 3a4d5c94e959 (\"vhost_net: a kernel-level virtio server\")\nCc: stable@vger.kernel.org\nReviewed-by: Lidong Chen <lidongchen@tencent.com>\nSigned-off-by: ruippan <ruippan@tencent.com>\nSigned-off-by: yongduan <yongduan@tencent.com>\nAcked-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Tyler Hicks <tyhicks@canonical.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>", "idx": 628}
{"func": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, struct compat_timespec __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err) {\n\t\terr = put_user(kts.tv_sec, &up->tv_sec);\n\t\terr |= __put_user(kts.tv_nsec, &up->tv_nsec);\n\t}\n\treturn err;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "644595f89620ba8446cc555be336d24a34464950", "hash": 264779786964067932284367068891704836105, "size": 16, "message": "compat: Handle COMPAT_USE_64BIT_TIME in net/socket.c\n\nUse helper functions aware of COMPAT_USE_64BIT_TIME to write struct\ntimeval and struct timespec to userspace in net/socket.c.\n\nSigned-off-by: H. Peter Anvin <hpa@zytor.com>", "idx": 629}
{"func": "struct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}", "target": 0, "cwe": ["CWE-269"], "project": "linux", "commit_id": "0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7", "hash": 144617412431360727510631695215698950059, "size": 42, "message": "Fix up non-directory creation in SGID directories\n\nsgid directories have special semantics, making newly created files in\nthe directory belong to the group of the directory, and newly created\nsubdirectories will also become sgid.  This is historically used for\ngroup-shared directories.\n\nBut group directories writable by non-group members should not imply\nthat such non-group members can magically join the group, so make sure\nto clear the sgid bit on non-directories for non-members (but remember\nthat sgid without group execute means \"mandatory locking\", just to\nconfuse things even more).\n\nReported-by: Jann Horn <jannh@google.com>\nCc: Andy Lutomirski <luto@kernel.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 630}
{"func": "rb_str_center(argc, argv, str)\n    int argc;\n    VALUE *argv;\n    VALUE str;\n{\n    return rb_str_justify(argc, argv, str, 'c');\n}", "target": 0, "cwe": ["CWE-20"], "project": "ruby", "commit_id": "e926ef5233cc9f1035d3d51068abe9df8b5429da", "hash": 229799828383910827814299699069898445097, "size": 7, "message": "* random.c (rb_genrand_int32, rb_genrand_real), intern.h: Export.\n\n* string.c (rb_str_tmp_new), intern.h: New function.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_1_8@16014 b2dd03c8-39d4-4d8f-98ff-823fe69b080e", "idx": 631}
{"func": "static unsigned long get_devid(uint8_t busnum, uint8_t devnum)\n{\n\treturn (busnum << 16) | devnum;\n}", "target": 0, "cwe": ["CWE-200"], "project": "linux", "commit_id": "2f2d0088eb93db5c649d2a5e34a3800a8a935fc5", "hash": 244856313595432300143611628544130660992, "size": 4, "message": "usbip: prevent vhci_hcd driver from leaking a socket pointer address\n\nWhen a client has a USB device attached over IP, the vhci_hcd driver is\nlocally leaking a socket pointer address via the\n\n/sys/devices/platform/vhci_hcd/status file (world-readable) and in debug\noutput when \"usbip --debug port\" is run.\n\nFix it to not leak. The socket pointer address is not used at the moment\nand it was made visible as a convenient way to find IP address from socket\npointer address by looking up /proc/net/{tcp,tcp6}.\n\nAs this opens a security hole, the fix replaces socket pointer address with\nsockfd.\n\nReported-by: Secunia Research <vuln@secunia.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Shuah Khan <shuahkh@osg.samsung.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 632}
{"func": "static bool numa_is_active_node(int nid, struct numa_group *ng)\n{\n\treturn group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;\n}", "target": 0, "cwe": ["CWE-400", "CWE-703", "CWE-835"], "project": "linux", "commit_id": "c40f7d74c741a907cfaeb73a7697081881c497d0", "hash": 224889839021383136698222003373076057860, "size": 4, "message": "sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c\n\nZhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the\nscheduler under high loads, starting at around the v4.18 time frame,\nand Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list\nmanipulation.\n\nDo a (manual) revert of:\n\n  a9e7f6544b9c (\"sched/fair: Fix O(nr_cgroups) in load balance path\")\n\nIt turns out that the list_del_leaf_cfs_rq() introduced by this commit\nis a surprising property that was not considered in followup commits\nsuch as:\n\n  9c2791f936ef (\"sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list\")\n\nAs Vincent Guittot explains:\n\n \"I think that there is a bigger problem with commit a9e7f6544b9c and\n  cfs_rq throttling:\n\n  Let take the example of the following topology TG2 --> TG1 --> root:\n\n   1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1\n      cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in\n      one path because it has never been used and can't be throttled so\n      tmp_alone_branch will point to leaf_cfs_rq_list at the end.\n\n   2) Then TG1 is throttled\n\n   3) and we add TG3 as a new child of TG1.\n\n   4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1\n      cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.\n\n  With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.\n  So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1\n  cfs_rq is removed from the list.\n  Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list\n  but tmp_alone_branch still points to TG3 cfs_rq because its throttled\n  parent can't be enqueued when the lock is released.\n  tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.\n\n  So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch\n  points on another TG cfs_rq, the next TG cfs_rq that will be added,\n  will be linked outside rq->leaf_cfs_rq_list - which is bad.\n\n  In addition, we can break the ordering of the cfs_rq in\n  rq->leaf_cfs_rq_list but this ordering is used to update and\n  propagate the update from leaf down to root.\"\n\nInstead of trying to work through all these cases and trying to reproduce\nthe very high loads that produced the lockup to begin with, simplify\nthe code temporarily by reverting a9e7f6544b9c - which change was clearly\nnot thought through completely.\n\nThis (hopefully) gives us a kernel that doesn't lock up so people\ncan continue to enjoy their holidays without worrying about regressions. ;-)\n\n[ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]\n\nAnalyzed-by: Xie XiuQi <xiexiuqi@huawei.com>\nAnalyzed-by: Vincent Guittot <vincent.guittot@linaro.org>\nReported-by: Zhipeng Xie <xiezhipeng1@huawei.com>\nReported-by: Sargun Dhillon <sargun@sargun.me>\nReported-by: Xie XiuQi <xiexiuqi@huawei.com>\nTested-by: Zhipeng Xie <xiezhipeng1@huawei.com>\nTested-by: Sargun Dhillon <sargun@sargun.me>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Vincent Guittot <vincent.guittot@linaro.org>\nCc: <stable@vger.kernel.org> # v4.13+\nCc: Bin Li <huawei.libin@huawei.com>\nCc: Mike Galbraith <efault@gmx.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Tejun Heo <tj@kernel.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nFixes: a9e7f6544b9c (\"sched/fair: Fix O(nr_cgroups) in load balance path\")\nLink: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>", "idx": 633}
{"func": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return &pair->list;\n}", "target": 1, "cwe": ["CWE-310"], "project": "jansson", "commit_id": "8f80c2d83808150724d31793e6ade92749b1faa4", "hash": 155392958952664067938187519062019503004, "size": 15, "message": "CVE-2013-6401: Change hash function, randomize hashes\n\nThanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing\nand testing.", "idx": 634}
{"func": "_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n\n      if (len != data_size)\n\t{\n\t  /* This is unexpected packet length, but\n\t   * just ignore it, for now.\n\t   */\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n\n      p = data + 2;\n\n      /* Count all server_names in the packet. */\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\n\t  p += len;\n\t}\n\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t/* no names found */\n\n      /* we cannot accept more server names.\n       */\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  switch (type)\n\t    {\n\t    case 0:\t\t/* NAME_DNS */\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* move to next record */\n\t  p += len;\n\t}\n    }\n  return 0;\n}", "target": 1, "cwe": ["CWE-189"], "project": "gnutls", "commit_id": "bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "hash": 168266384151590392485061020862846264327, "size": 81, "message": "Fix GNUTLS-SA-2008-1 security vulnerabilities.\nSee http://www.gnu.org/software/gnutls/security.html for updates.", "idx": 635}
{"func": "HiiGetString (\r\n  IN  CONST EFI_HII_STRING_PROTOCOL   *This,\r\n  IN  CONST CHAR8                     *Language,\r\n  IN  EFI_HII_HANDLE                  PackageList,\r\n  IN  EFI_STRING_ID                   StringId,\r\n  OUT EFI_STRING                      String,\r\n  IN  OUT UINTN                       *StringSize,\r\n  OUT EFI_FONT_INFO                   **StringFontInfo OPTIONAL\r\n  )\r\n{\r\n  EFI_STATUS                          Status;\r\n  LIST_ENTRY                          *Link;\r\n  HII_DATABASE_PRIVATE_DATA           *Private;\r\n  HII_DATABASE_RECORD                 *DatabaseRecord;\r\n  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageListNode;\r\n  HII_STRING_PACKAGE_INSTANCE         *StringPackage;\r\n\r\n  if (This == NULL || Language == NULL || StringId < 1 || StringSize == NULL || PackageList == NULL) {\r\n    return EFI_INVALID_PARAMETER;\r\n  }\r\n\r\n  if (String == NULL && *StringSize != 0) {\r\n    return EFI_INVALID_PARAMETER;\r\n  }\r\n\r\n  if (!IsHiiHandleValid (PackageList)) {\r\n    return EFI_NOT_FOUND;\r\n  }\r\n\r\n  Private = HII_STRING_DATABASE_PRIVATE_DATA_FROM_THIS (This);\r\n  PackageListNode = NULL;\r\n\r\n  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {\r\n    DatabaseRecord = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);\r\n    if (DatabaseRecord->Handle == PackageList) {\r\n      PackageListNode = DatabaseRecord->PackageList;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (PackageListNode != NULL) {\r\n    //\r\n    // First search: to match the StringId in the specified language.\r\n    //\r\n    for (Link =  PackageListNode->StringPkgHdr.ForwardLink;\r\n         Link != &PackageListNode->StringPkgHdr;\r\n         Link =  Link->ForwardLink\r\n        ) {\r\n        StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);\r\n        if (HiiCompareLanguage (StringPackage->StringPkgHdr->Language, (CHAR8 *) Language)) {\r\n          Status = GetStringWorker (Private, StringPackage, StringId, String, StringSize, StringFontInfo);\r\n          if (Status != EFI_NOT_FOUND) {\r\n            return Status;\r\n          }\r\n        }\r\n      }\r\n      //\r\n      // Second search: to match the StringId in other available languages if exist.\r\n      //\r\n      for (Link =  PackageListNode->StringPkgHdr.ForwardLink;\r\n           Link != &PackageListNode->StringPkgHdr;\r\n           Link =  Link->ForwardLink\r\n          ) {\r\n      StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);\r\n      Status = GetStringWorker (Private, StringPackage, StringId, NULL, NULL, NULL);\r\n      if (!EFI_ERROR (Status)) {\r\n        return EFI_INVALID_LANGUAGE;\r\n      }\r\n    }\r\n  }\r\n\r\n  return EFI_NOT_FOUND;\r\n}\r", "target": 0, "cwe": [], "project": "edk2", "commit_id": "764e8ba1389a617639d79d2c4f0d53f4ea4a7387", "hash": 123133027356585924100365551849616710742, "size": 73, "message": "MdeModulePkg/String.c: Zero memory before free (CVE-2019-14558)\n\nREF: https://bugzilla.tianocore.org/show_bug.cgi?id=1611\n\nCc: Liming Gao <liming.gao@intel.com>\nCc: Eric Dong <eric.dong@intel.com>\nCc: Jian J Wang <jian.j.wang@intel.com>\nSigned-off-by: Dandan Bi <dandan.bi@intel.com>\nReviewed-by: Eric Dong <eric.dong@intel.com>\nReviewed-by: Jian J Wang <jian.j.wang@intel.com>", "idx": 636}
{"func": "test_bson_concat (void)\n{\n   bson_t a = BSON_INITIALIZER;\n   bson_t b = BSON_INITIALIZER;\n   bson_t c = BSON_INITIALIZER;\n\n   bson_append_int32 (&a, \"abc\", 3, 1);\n   bson_append_int32 (&b, \"def\", 3, 1);\n   bson_concat (&a, &b);\n\n   bson_append_int32 (&c, \"abc\", 3, 1);\n   bson_append_int32 (&c, \"def\", 3, 1);\n\n   BSON_ASSERT (0 == bson_compare (&c, &a));\n\n   bson_destroy (&a);\n   bson_destroy (&b);\n   bson_destroy (&c);\n}", "target": 0, "cwe": ["CWE-125"], "project": "libbson", "commit_id": "42900956dc461dfe7fb91d93361d10737c1602b3", "hash": 287063769552434239642345656095737826799, "size": 19, "message": "CDRIVER-2269 Check for zero string length in codewscope", "idx": 637}
{"func": "static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)\n{\n    *stage = 0;\n    *cont = 1;\n    return 0;\n}", "target": 0, "cwe": [], "project": "ghostpdl", "commit_id": "b326a71659b7837d3acde954b18bda1a6f5e9498", "hash": 193919980902571547835301173095593334711, "size": 6, "message": "Bug 699655: Properly check the return value....\n\n...when getting a value from a dictionary", "idx": 638}
{"func": "static smart_ptr<DFA> ast_to_dfa(const spec_t &spec, Output &output)\n{\n    OutputBlock &block = output.block();\n    const opt_t *opts = block.opts;\n    const loc_t &loc = block.loc;\n    Msg &msg = output.msg;\n    const std::vector<ASTRule> &rules = spec.rules;\n    const std::string\n        &cond = spec.name,\n        name = make_name(output, cond, loc),\n        &setup = spec.setup.empty() ? \"\" : spec.setup[0]->text;\n\n    RangeMgr rangemgr;\n\n    RESpec re(rules, opts, msg, rangemgr);\n    split_charset(re);\n    find_fixed_tags(re);\n    insert_default_tags(re);\n    warn_nullable(re, cond);\n\n    size_t nfa_size, nfa_depth;\n    compute_size_and_depth(re.res, &nfa_size, &nfa_depth);\n    if (nfa_depth > MAX_NFA_DEPTH) {\n        error(\"NFA depth exceeds limits\");\n        exit(1);\n    } else if (nfa_size > MAX_NFA_STATES) {\n        error(\"NFA has too many states\");\n        exit(1);\n    }\n\n    nfa_t nfa(re, nfa_size);\n    DDUMP_NFA(opts, nfa);\n\n    dfa_t dfa(nfa, spec.def_rule, spec.eof_rule);\n    determinization(nfa, dfa, opts, msg, cond);\n    DDUMP_DFA_DET(opts, dfa);\n\n    rangemgr.clear();\n\n    // skeleton must be constructed after DFA construction\n    // but prior to any other DFA transformations\n    Skeleton skeleton(dfa, opts, name, cond, loc, msg);\n    warn_undefined_control_flow(skeleton);\n    if (opts->target == TARGET_SKELETON) {\n        emit_data(skeleton);\n    }\n\n    cutoff_dead_rules(dfa, opts, cond, msg);\n\n    insert_fallback_tags(opts, dfa);\n\n    // try to minimize the number of tag variables\n    compact_and_optimize_tags(opts, dfa);\n    DDUMP_DFA_TAGOPT(opts, dfa);\n\n    freeze_tags(dfa);\n\n    minimization(dfa, opts->dfa_minimization);\n    DDUMP_DFA_MIN(opts, dfa);\n\n    // find strongly connected components and calculate argument to YYFILL\n    std::vector<size_t> fill;\n    fillpoints(dfa, fill);\n\n    // ADFA stands for 'DFA with actions'\n    DFA *adfa = new DFA(dfa, fill, skeleton.sizeof_key, loc, name, cond,\n        setup, opts, msg);\n\n    // see note [reordering DFA states]\n    adfa->reorder();\n\n    // skeleton is constructed, do further DFA transformations\n    adfa->prepare(opts);\n    DDUMP_ADFA(opts, *adfa);\n\n    // gather overall DFA statistics and add it to the output block\n    adfa->calc_stats(block);\n    block.max_fill = std::max(block.max_fill, adfa->max_fill);\n    block.max_nmatch = std::max(block.max_nmatch, adfa->max_nmatch);\n    block.used_yyaccept = block.used_yyaccept || adfa->need_accept;\n\n    return make_smart_ptr(adfa);\n}", "target": 0, "cwe": ["CWE-787"], "project": "re2c", "commit_id": "a3473fd7be829cb33907cb08612f955133c70a96", "hash": 76003009775124222584402455538399201805, "size": 83, "message": "Limit maximum allowed NFA and DFA size.\n\nInstead of failing with an out of memory exception or crashing with a\nstack overflow, emit an error message and exit. This is a partial fix\nfor bug #394 \"Stack overflow due to recursion in src/dfa/dead_rules.cc\",\nwhere re2c hit stack overflow on a counted repetition regexp with high\nupper bound.\n\nThe patch adds the following limits:\n  1. the number of NFA states\n  2. NFA depth (maximum length of a non-looping path from start to end)\n  3. the number of DFA states\n  3. total DFA size (sum total of all NFA substates in all DFA states)\n\nThere are tests for the first three limits, but not for the DFA size as\nall examples that trigger this behavior take a long time to finish (a\nfew seconds), which increases test run time almost twice.", "idx": 639}
{"func": "int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint status = 0, size_change;\n\tint inode_locked = 0;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct dquot *transfer_to[MAXQUOTAS] = { };\n\tint qtype;\n\tint had_lock;\n\tstruct ocfs2_lock_holder oh;\n\n\ttrace_ocfs2_setattr(inode, dentry,\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    dentry->d_name.len, dentry->d_name.name,\n\t\t\t    attr->ia_valid, attr->ia_mode,\n\t\t\t    from_kuid(&init_user_ns, attr->ia_uid),\n\t\t\t    from_kgid(&init_user_ns, attr->ia_gid));\n\n\t/* ensuring we don't even attempt to truncate a symlink */\n\tif (S_ISLNK(inode->i_mode))\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n#define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \\\n\t\t\t   | ATTR_GID | ATTR_UID | ATTR_MODE)\n\tif (!(attr->ia_valid & OCFS2_VALID_ATTRS))\n\t\treturn 0;\n\n\tstatus = setattr_prepare(dentry, attr);\n\tif (status)\n\t\treturn status;\n\n\tif (is_quota_modification(inode, attr)) {\n\t\tstatus = dquot_initialize(inode);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\tsize_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE;\n\tif (size_change) {\n\t\tstatus = ocfs2_rw_lock(inode, 1);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\thad_lock = ocfs2_inode_lock_tracker(inode, &bh, 1, &oh);\n\tif (had_lock < 0) {\n\t\tstatus = had_lock;\n\t\tgoto bail_unlock_rw;\n\t} else if (had_lock) {\n\t\t/*\n\t\t * As far as we know, ocfs2_setattr() could only be the first\n\t\t * VFS entry point in the call chain of recursive cluster\n\t\t * locking issue.\n\t\t *\n\t\t * For instance:\n\t\t * chmod_common()\n\t\t *  notify_change()\n\t\t *   ocfs2_setattr()\n\t\t *    posix_acl_chmod()\n\t\t *     ocfs2_iop_get_acl()\n\t\t *\n\t\t * But, we're not 100% sure if it's always true, because the\n\t\t * ordering of the VFS entry points in the call chain is out\n\t\t * of our control. So, we'd better dump the stack here to\n\t\t * catch the other cases of recursive locking.\n\t\t */\n\t\tmlog(ML_ERROR, \"Another case of recursive locking:\\n\");\n\t\tdump_stack();\n\t}\n\tinode_locked = 1;\n\n\tif (size_change) {\n\t\tstatus = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (status)\n\t\t\tgoto bail_unlock;\n\n\t\tinode_dio_wait(inode);\n\n\t\tif (i_size_read(inode) >= attr->ia_size) {\n\t\t\tif (ocfs2_should_order_data(inode)) {\n\t\t\t\tstatus = ocfs2_begin_ordered_truncate(inode,\n\t\t\t\t\t\t\t\t      attr->ia_size);\n\t\t\t\tif (status)\n\t\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t\tstatus = ocfs2_truncate_file(inode, bh, attr->ia_size);\n\t\t} else\n\t\t\tstatus = ocfs2_extend_file(inode, bh, attr->ia_size);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail_unlock;\n\t\t}\n\t}\n\n\tif ((attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\t/*\n\t\t * Gather pointers to quota structures so that allocation /\n\t\t * freeing of quota structures happens here and not inside\n\t\t * dquot_transfer() where we have problems with lock ordering\n\t\t */\n\t\tif (attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)\n\t\t    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t    OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(attr->ia_uid));\n\t\t\tif (IS_ERR(transfer_to[USRQUOTA])) {\n\t\t\t\tstatus = PTR_ERR(transfer_to[USRQUOTA]);\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t}\n\t\tif (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid)\n\t\t    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t    OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(attr->ia_gid));\n\t\t\tif (IS_ERR(transfer_to[GRPQUOTA])) {\n\t\t\t\tstatus = PTR_ERR(transfer_to[GRPQUOTA]);\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t}\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS +\n\t\t\t\t\t   2 * ocfs2_quota_trans_credits(sb));\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t\tstatus = __dquot_transfer(inode, transfer_to);\n\t\tif (status < 0)\n\t\t\tgoto bail_commit;\n\t} else {\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\nbail_unlock:\n\tif (status && inode_locked) {\n\t\tocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);\n\t\tinode_locked = 0;\n\t}\nbail_unlock_rw:\n\tif (size_change)\n\t\tocfs2_rw_unlock(inode, 1);\nbail:\n\n\t/* Release quota pointers in case we acquired them */\n\tfor (qtype = 0; qtype < OCFS2_MAXQUOTAS; qtype++)\n\t\tdqput(transfer_to[qtype]);\n\n\tif (!status && attr->ia_valid & ATTR_MODE) {\n\t\tstatus = ocfs2_acl_chmod(inode, bh);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\tif (inode_locked)\n\t\tocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);\n\n\tbrelse(bh);\n\treturn status;\n}", "target": 1, "cwe": ["CWE-401"], "project": "linux", "commit_id": "28f5a8a7c033cbf3e32277f4cc9c6afd74f05300", "hash": 179566211098738861447127699172463020962, "size": 178, "message": "ocfs2: should wait dio before inode lock in ocfs2_setattr()\n\nwe should wait dio requests to finish before inode lock in\nocfs2_setattr(), otherwise the following deadlock will happen:\n\nprocess 1                  process 2                    process 3\ntruncate file 'A'          end_io of writing file 'A'   receiving the bast messages\nocfs2_setattr\n ocfs2_inode_lock_tracker\n  ocfs2_inode_lock_full\n inode_dio_wait\n  __inode_dio_wait\n  -->waiting for all dio\n  requests finish\n                                                        dlm_proxy_ast_handler\n                                                         dlm_do_local_bast\n                                                          ocfs2_blocking_ast\n                                                           ocfs2_generic_handle_bast\n                                                            set OCFS2_LOCK_BLOCKED flag\n                        dio_end_io\n                         dio_bio_end_aio\n                          dio_complete\n                           ocfs2_dio_end_io\n                            ocfs2_dio_end_io_write\n                             ocfs2_inode_lock\n                              __ocfs2_cluster_lock\n                               ocfs2_wait_for_mask\n                               -->waiting for OCFS2_LOCK_BLOCKED\n                               flag to be cleared, that is waiting\n                               for 'process 1' unlocking the inode lock\n                           inode_dio_end\n                           -->here dec the i_dio_count, but will never\n                           be called, so a deadlock happened.\n\nLink: http://lkml.kernel.org/r/59F81636.70508@huawei.com\nSigned-off-by: Alex Chen <alex.chen@huawei.com>\nReviewed-by: Jun Piao <piaojun@huawei.com>\nReviewed-by: Joseph Qi <jiangqi903@gmail.com>\nAcked-by: Changwei Ge <ge.changwei@h3c.com>\nCc: Mark Fasheh <mfasheh@versity.com>\nCc: Joel Becker <jlbec@evilplan.org>\nCc: Junxiao Bi <junxiao.bi@oracle.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 640}
{"func": "void AuthorizationManagerImpl::_invalidateRelevantCacheData(const char* op,\n                                                            const NamespaceString& ns,\n                                                            const BSONObj& o,\n                                                            const BSONObj* o2) {\n    if (ns == AuthorizationManager::rolesCollectionNamespace ||\n        ns == AuthorizationManager::versionCollectionNamespace) {\n        invalidateUserCache();\n        return;\n    }\n\n    if (*op == 'i' || *op == 'd' || *op == 'u') {\n        // If you got into this function isAuthzNamespace() must have returned true, and we've\n        // already checked that it's not the roles or version collection.\n        invariant(ns == AuthorizationManager::usersCollectionNamespace);\n\n        StatusWith<UserName> userName = (*op == 'u')\n            ? extractUserNameFromIdString((*o2)[\"_id\"].str())\n            : extractUserNameFromIdString(o[\"_id\"].str());\n\n        if (!userName.isOK()) {\n            warning() << \"Invalidating user cache based on user being updated failed, will \"\n                         \"invalidate the entire cache instead: \"\n                      << userName.getStatus();\n            invalidateUserCache();\n            return;\n        }\n        invalidateUserByName(userName.getValue());\n    } else {\n        invalidateUserCache();\n    }\n}", "target": 0, "cwe": ["CWE-613"], "project": "mongo", "commit_id": "6dfb92b1299de04677d0bd2230e89a52eb01003c", "hash": 312607616362125752847449268188958102097, "size": 31, "message": "SERVER-38984 Validate unique User ID on UserCache hit\n\n(cherry picked from commit e55d6e2292e5dbe2f97153251d8193d1cc89f5d7)", "idx": 641}
{"func": "void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)\n{\n    // no extensions supported yet\n    return 0;\n}", "target": 0, "cwe": ["CWE-254"], "project": "mysql-server", "commit_id": "e7061f7e5a96c66cb2e0bf46bec7f6ff35801a69", "hash": 91014496949951268919790474516209038386, "size": 5, "message": "Bug #22738607:  YASSL FUNCTION X509_NAME_GET_INDEX_BY_NID IS NOT WORKING AS EXPECTED.", "idx": 642}
{"func": "static void qemu_chr_free_common(CharDriverState *chr)\n{\n    g_free(chr->filename);\n    g_free(chr->label);\n    if (chr->logfd != -1) {\n        close(chr->logfd);\n    }\n    qemu_mutex_destroy(&chr->chr_write_lock);\n    g_free(chr);\n}", "target": 1, "cwe": ["CWE-416"], "project": "qemu", "commit_id": "a4afa548fc6dd9842ed86639b4d37d4d1c4ad480", "hash": 315208690440981813143094011980381505237, "size": 10, "message": "char: move front end handlers in CharBackend\n\nSince the hanlders are associated with a CharBackend, rather than the\nCharDriverState, it is more appropriate to store in CharBackend. This\navoids the handler copy dance in qemu_chr_fe_set_handlers() then\nmux_chr_update_read_handler(), by storing the CharBackend pointer\ndirectly.\n\nAlso a mux CharDriver should go through mux->backends[focused], since\nchr->be will stay NULL. Before that, it was possible to call\nchr->handler by mistake with surprising results, for ex through\nqemu_chr_be_can_write(), which would result in calling the last set\nhandler front end, not the one with focus.\n\nSigned-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>\nMessage-Id: <20161022095318.17775-22-marcandre.lureau@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 643}
{"func": "  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }", "target": 0, "cwe": ["CWE-770"], "project": "ceph", "commit_id": "ab29bed2fc9f961fe895de1086a8208e21ddaddc", "hash": 57696913021406220354794825478027962249, "size": 1, "message": "rgw: fix issues with 'enforce bounds' patch\n\nThe patch to enforce bounds on max-keys/max-uploads/max-parts had a few\nissues that would prevent us from compiling it. Instead of changing the\ncode provided by the submitter, we're addressing them in a separate\ncommit to maintain the DCO.\n\nSigned-off-by: Joao Eduardo Luis <joao@suse.de>\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>\n(cherry picked from commit 29bc434a6a81a2e5c5b8cfc4c8d5c82ca5bf538a)\nmimic specific fixes:\nAs the largeish change from master g_conf() isn't in mimic yet, use the g_conf\nglobal structure, also make rgw_op use the value from req_info ceph context as\nwe do for all the requests", "idx": 644}
{"func": "MagickExport int XDialogWidget(Display *display,XWindows *windows,\n  const char *action,const char *query,char *reply)\n{\n#define CancelButtonText  \"Cancel\"\n\n  char\n    primary_selection[MaxTextExtent];\n\n  int\n    x;\n\n  int\n    i;\n\n  static MagickBooleanType\n    raised = MagickFalse;\n\n  Status\n    status;\n\n  unsigned int\n    anomaly,\n    height,\n    width;\n\n  size_t\n    state;\n\n  XEvent\n    event;\n\n  XFontStruct\n    *font_info;\n\n  XTextProperty\n    window_name;\n\n  XWidgetInfo\n    action_info,\n    cancel_info,\n    reply_info,\n    special_info,\n    text_info;\n\n  XWindowChanges\n    window_changes;\n\n  /*\n    Determine Dialog widget attributes.\n  */\n  assert(display != (Display *) NULL);\n  assert(windows != (XWindows *) NULL);\n  assert(action != (char *) NULL);\n  assert(query != (char *) NULL);\n  assert(reply != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",action);\n  XCheckRefreshWindows(display,windows);\n  font_info=windows->widget.font_info;\n  width=WidgetTextWidth(font_info,(char *) action);\n  if (WidgetTextWidth(font_info,CancelButtonText) > width)\n    width=WidgetTextWidth(font_info,CancelButtonText);\n  width+=(3*QuantumMargin) >> 1;\n  height=(unsigned int) (font_info->ascent+font_info->descent);\n  /*\n    Position Dialog widget.\n  */\n  windows->widget.width=(unsigned int) MagickMax((int) (2*width),(int)\n    WidgetTextWidth(font_info,(char *) query));\n  if (windows->widget.width < WidgetTextWidth(font_info,reply))\n    windows->widget.width=WidgetTextWidth(font_info,reply);\n  windows->widget.width+=6*QuantumMargin;\n  windows->widget.min_width=(unsigned int)\n    (width+28*XTextWidth(font_info,\"#\",1)+4*QuantumMargin);\n  if (windows->widget.width < windows->widget.min_width)\n    windows->widget.width=windows->widget.min_width;\n  windows->widget.height=(unsigned int) (7*height+(QuantumMargin << 1));\n  windows->widget.min_height=windows->widget.height;\n  if (windows->widget.height < windows->widget.min_height)\n    windows->widget.height=windows->widget.min_height;\n  XConstrainWindowPosition(display,&windows->widget);\n  /*\n    Map Dialog widget.\n  */\n  (void) CopyMagickString(windows->widget.name,\"Dialog\",MaxTextExtent);\n  status=XStringListToTextProperty(&windows->widget.name,1,&window_name);\n  if (status != False)\n    {\n      XSetWMName(display,windows->widget.id,&window_name);\n      XSetWMIconName(display,windows->widget.id,&window_name);\n      (void) XFree((void *) window_name.value);\n    }\n  window_changes.width=(int) windows->widget.width;\n  window_changes.height=(int) windows->widget.height;\n  window_changes.x=windows->widget.x;\n  window_changes.y=windows->widget.y;\n  (void) XReconfigureWMWindow(display,windows->widget.id,windows->widget.screen,\n    (unsigned int) (CWWidth | CWHeight | CWX | CWY),&window_changes);\n  (void) XMapRaised(display,windows->widget.id);\n  windows->widget.mapped=MagickFalse;\n  /*\n    Respond to X events.\n  */\n  anomaly=(LocaleCompare(action,\"Background\") == 0) ||\n    (LocaleCompare(action,\"New\") == 0) ||\n    (LocaleCompare(action,\"Quantize\") == 0) ||\n    (LocaleCompare(action,\"Resize\") == 0) ||\n    (LocaleCompare(action,\"Save\") == 0) ||\n    (LocaleCompare(action,\"Shade\") == 0);\n  state=UpdateConfigurationState;\n  XSetCursorState(display,windows,MagickTrue);\n  do\n  {\n    if (state & UpdateConfigurationState)\n      {\n        /*\n          Initialize button information.\n        */\n        XGetWidgetInfo(CancelButtonText,&cancel_info);\n        cancel_info.width=width;\n        cancel_info.height=(unsigned int) ((3*height) >> 1);\n        cancel_info.x=(int)\n          (windows->widget.width-cancel_info.width-((3*QuantumMargin) >> 1));\n        cancel_info.y=(int)\n          (windows->widget.height-cancel_info.height-((3*QuantumMargin) >> 1));\n        XGetWidgetInfo(action,&action_info);\n        action_info.width=width;\n        action_info.height=(unsigned int) ((3*height) >> 1);\n        action_info.x=cancel_info.x-(cancel_info.width+QuantumMargin+\n          (action_info.bevel_width << 1));\n        action_info.y=cancel_info.y;\n        /*\n          Initialize reply information.\n        */\n        XGetWidgetInfo(reply,&reply_info);\n        reply_info.raised=MagickFalse;\n        reply_info.bevel_width--;\n        reply_info.width=windows->widget.width-(3*QuantumMargin);\n        reply_info.height=height << 1;\n        reply_info.x=(3*QuantumMargin) >> 1;\n        reply_info.y=action_info.y-reply_info.height-QuantumMargin;\n        /*\n          Initialize option information.\n        */\n        XGetWidgetInfo(\"Dither\",&special_info);\n        special_info.raised=raised;\n        special_info.bevel_width--;\n        special_info.width=(unsigned int) QuantumMargin >> 1;\n        special_info.height=(unsigned int) QuantumMargin >> 1;\n        special_info.x=reply_info.x;\n        special_info.y=action_info.y+action_info.height-special_info.height;\n        if (LocaleCompare(action,\"Background\") == 0)\n          special_info.text=(char *) \"Backdrop\";\n        if (LocaleCompare(action,\"New\") == 0)\n          special_info.text=(char *) \"Gradation\";\n        if (LocaleCompare(action,\"Resize\") == 0)\n          special_info.text=(char *) \"Constrain ratio\";\n        if (LocaleCompare(action,\"Save\") == 0)\n          special_info.text=(char *) \"Non-progressive\";\n        if (LocaleCompare(action,\"Shade\") == 0)\n          special_info.text=(char *) \"Color shading\";\n        /*\n          Initialize text information.\n        */\n        XGetWidgetInfo(query,&text_info);\n        text_info.width=reply_info.width;\n        text_info.height=height;\n        text_info.x=reply_info.x-(QuantumMargin >> 1);\n        text_info.y=QuantumMargin;\n        text_info.center=MagickFalse;\n        state&=(~UpdateConfigurationState);\n      }\n    if (state & RedrawWidgetState)\n      {\n        /*\n          Redraw Dialog widget.\n        */\n        XDrawWidgetText(display,&windows->widget,&text_info);\n        XDrawBeveledMatte(display,&windows->widget,&reply_info);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        if (anomaly)\n          XDrawBeveledButton(display,&windows->widget,&special_info);\n        XDrawBeveledButton(display,&windows->widget,&action_info);\n        XDrawBeveledButton(display,&windows->widget,&cancel_info);\n        XHighlightWidget(display,&windows->widget,BorderOffset,BorderOffset);\n        state&=(~RedrawWidgetState);\n      }\n    /*\n      Wait for next event.\n    */\n    (void) XIfEvent(display,&event,XScreenEvent,(char *) windows);\n    switch (event.type)\n    {\n      case ButtonPress:\n      {\n        if (anomaly)\n          if (MatteIsActive(special_info,event.xbutton))\n            {\n              /*\n                Option button status changed.\n              */\n              special_info.raised=!special_info.raised;\n              XDrawBeveledButton(display,&windows->widget,&special_info);\n              break;\n            }\n        if (MatteIsActive(action_info,event.xbutton))\n          {\n            /*\n              User pressed Action button.\n            */\n            action_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n            break;\n          }\n        if (MatteIsActive(cancel_info,event.xbutton))\n          {\n            /*\n              User pressed Cancel button.\n            */\n            cancel_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&cancel_info);\n            break;\n          }\n        if (MatteIsActive(reply_info,event.xbutton) == MagickFalse)\n          break;\n        if (event.xbutton.button != Button2)\n          {\n            static Time\n              click_time;\n\n            /*\n              Move text cursor to position of button press.\n            */\n            x=event.xbutton.x-reply_info.x-(QuantumMargin >> 2);\n            for (i=1; i <= Extent(reply_info.marker); i++)\n              if (XTextWidth(font_info,reply_info.marker,i) > x)\n                break;\n            reply_info.cursor=reply_info.marker+i-1;\n            if (event.xbutton.time > (click_time+DoubleClick))\n              reply_info.highlight=MagickFalse;\n            else\n              {\n                /*\n                  Become the XA_PRIMARY selection owner.\n                */\n                (void) CopyMagickString(primary_selection,reply_info.text,\n                  MaxTextExtent);\n                (void) XSetSelectionOwner(display,XA_PRIMARY,windows->widget.id,\n                  event.xbutton.time);\n                reply_info.highlight=XGetSelectionOwner(display,XA_PRIMARY) ==\n                  windows->widget.id ? MagickTrue : MagickFalse;\n              }\n            XDrawMatteText(display,&windows->widget,&reply_info);\n            click_time=event.xbutton.time;\n            break;\n          }\n        /*\n          Request primary selection.\n        */\n        (void) XConvertSelection(display,XA_PRIMARY,XA_STRING,XA_STRING,\n          windows->widget.id,event.xbutton.time);\n        break;\n      }\n      case ButtonRelease:\n      {\n        if (windows->widget.mapped == MagickFalse)\n          break;\n        if (action_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(action_info,event.xbutton))\n                state|=ExitState;\n            action_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n          }\n        if (cancel_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(cancel_info,event.xbutton))\n                {\n                  *reply_info.text='\\0';\n                  state|=ExitState;\n                }\n            cancel_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&cancel_info);\n          }\n        break;\n      }\n      case ClientMessage:\n      {\n        /*\n          If client window delete message, exit.\n        */\n        if (event.xclient.message_type != windows->wm_protocols)\n          break;\n        if (*event.xclient.data.l == (int) windows->wm_take_focus)\n          {\n            (void) XSetInputFocus(display,event.xclient.window,RevertToParent,\n              (Time) event.xclient.data.l[1]);\n            break;\n          }\n        if (*event.xclient.data.l != (int) windows->wm_delete_window)\n          break;\n        if (event.xclient.window == windows->widget.id)\n          {\n            *reply_info.text='\\0';\n            state|=ExitState;\n            break;\n          }\n        break;\n      }\n      case ConfigureNotify:\n      {\n        /*\n          Update widget configuration.\n        */\n        if (event.xconfigure.window != windows->widget.id)\n          break;\n        if ((event.xconfigure.width == (int) windows->widget.width) &&\n            (event.xconfigure.height == (int) windows->widget.height))\n          break;\n        windows->widget.width=(unsigned int)\n          MagickMax(event.xconfigure.width,(int) windows->widget.min_width);\n        windows->widget.height=(unsigned int)\n          MagickMax(event.xconfigure.height,(int) windows->widget.min_height);\n        state|=UpdateConfigurationState;\n        break;\n      }\n      case EnterNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state&=(~InactiveWidgetState);\n        break;\n      }\n      case Expose:\n      {\n        if (event.xexpose.window != windows->widget.id)\n          break;\n        if (event.xexpose.count != 0)\n          break;\n        state|=RedrawWidgetState;\n        break;\n      }\n      case KeyPress:\n      {\n        static char\n          command[MaxTextExtent];\n\n        static int\n          length;\n\n        static KeySym\n          key_symbol;\n\n        /*\n          Respond to a user key press.\n        */\n        if (event.xkey.window != windows->widget.id)\n          break;\n        length=XLookupString((XKeyEvent *) &event.xkey,command,\n          (int) sizeof(command),&key_symbol,(XComposeStatus *) NULL);\n        *(command+length)='\\0';\n        if ((key_symbol == XK_Return) || (key_symbol == XK_KP_Enter))\n          {\n            action_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n            state|=ExitState;\n            break;\n          }\n        if (key_symbol == XK_Control_L)\n          {\n            state|=ControlState;\n            break;\n          }\n        if (state & ControlState)\n          switch ((int) key_symbol)\n          {\n            case XK_u:\n            case XK_U:\n            {\n              /*\n                Erase the entire line of text.\n              */\n              *reply_info.text='\\0';\n              reply_info.cursor=reply_info.text;\n              reply_info.marker=reply_info.text;\n              reply_info.highlight=MagickFalse;\n              break;\n            }\n            default:\n              break;\n          }\n        XEditText(display,&reply_info,key_symbol,command,state);\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        break;\n      }\n      case KeyRelease:\n      {\n        static char\n          command[MaxTextExtent];\n\n        static KeySym\n          key_symbol;\n\n        /*\n          Respond to a user key release.\n        */\n        if (event.xkey.window != windows->widget.id)\n          break;\n        (void) XLookupString((XKeyEvent *) &event.xkey,command,\n          (int) sizeof(command),&key_symbol,(XComposeStatus *) NULL);\n        if (key_symbol == XK_Control_L)\n          state&=(~ControlState);\n        break;\n      }\n      case LeaveNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state|=InactiveWidgetState;\n        break;\n      }\n      case MotionNotify:\n      {\n        /*\n          Discard pending button motion events.\n        */\n        while (XCheckMaskEvent(display,ButtonMotionMask,&event)) ;\n        if (state & InactiveWidgetState)\n          break;\n        if (action_info.raised == MatteIsActive(action_info,event.xmotion))\n          {\n            /*\n              Action button status changed.\n            */\n            action_info.raised=action_info.raised == MagickFalse ?\n              MagickTrue : MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&action_info);\n            break;\n          }\n        if (cancel_info.raised == MatteIsActive(cancel_info,event.xmotion))\n          {\n            /*\n              Cancel button status changed.\n            */\n            cancel_info.raised=cancel_info.raised == MagickFalse ?\n              MagickTrue : MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&cancel_info);\n            break;\n          }\n        break;\n      }\n      case SelectionClear:\n      {\n        reply_info.highlight=MagickFalse;\n        XDrawMatteText(display,&windows->widget,&reply_info);\n        break;\n      }\n      case SelectionNotify:\n      {\n        Atom\n          type;\n\n        int\n          format;\n\n        unsigned char\n          *data;\n\n        unsigned long\n          after,\n          length;\n\n        /*\n          Obtain response from primary selection.\n        */\n        if (event.xselection.property == (Atom) None)\n          break;\n        status=XGetWindowProperty(display,event.xselection.requestor,\n          event.xselection.property,0L,2047L,MagickTrue,XA_STRING,&type,\n          &format,&length,&after,&data);\n        if ((status != Success) || (type != XA_STRING) || (format == 32) ||\n            (length == 0))\n          break;\n        if ((Extent(reply_info.text)+length) >= (MaxTextExtent-1))\n          (void) XBell(display,0);\n        else\n          {\n            /*\n              Insert primary selection in reply text.\n            */\n            *(data+length)='\\0';\n            XEditText(display,&reply_info,(KeySym) XK_Insert,(char *) data,\n              state);\n            XDrawMatteText(display,&windows->widget,&reply_info);\n          }\n        (void) XFree((void *) data);\n        break;\n      }\n      case SelectionRequest:\n      {\n        XSelectionEvent\n          notify;\n\n        XSelectionRequestEvent\n          *request;\n\n        if (reply_info.highlight == MagickFalse)\n          break;\n        /*\n          Set primary selection.\n        */\n        request=(&(event.xselectionrequest));\n        (void) XChangeProperty(request->display,request->requestor,\n          request->property,request->target,8,PropModeReplace,\n          (unsigned char *) primary_selection,Extent(primary_selection));\n        notify.type=SelectionNotify;\n        notify.display=request->display;\n        notify.requestor=request->requestor;\n        notify.selection=request->selection;\n        notify.target=request->target;\n        notify.time=request->time;\n        if (request->property == None)\n          notify.property=request->target;\n        else\n          notify.property=request->property;\n        (void) XSendEvent(request->display,request->requestor,False,0,\n          (XEvent *) &notify);\n      }\n      default:\n        break;\n    }\n  } while ((state & ExitState) == 0);\n  XSetCursorState(display,windows,MagickFalse);\n  (void) XWithdrawWindow(display,windows->widget.id,windows->widget.screen);\n  XCheckRefreshWindows(display,windows);\n  if (anomaly)\n    if (special_info.raised)\n      if (*reply != '\\0')\n        raised=MagickTrue;\n  return(raised == MagickFalse);\n}", "target": 0, "cwe": [], "project": "ImageMagick6", "commit_id": "366c9708a7ca1256ee03d0d4addb2690ed42273f", "hash": 310328290281152170139199012074681329403, "size": 542, "message": "https://github.com/ImageMagick/ImageMagick/issues/3333", "idx": 645}
{"func": "png_handle_tEXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_text  text_info;\n   png_bytep buffer;\n   png_charp key;\n   png_charp text;\n   png_uint_32 skip = 0;\n\n   png_debug(1, \"in png_handle_tEXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (length > 65535U)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\n      return;\n   }\n#endif\n\n   buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);\n\n   if (buffer == NULL)\n   {\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, skip) != 0)\n      return;\n\n   key = (png_charp)buffer;\n   key[length] = 0;\n\n   for (text = key; *text; text++)\n      /* Empty loop to find end of key */ ;\n\n   if (text != key + length)\n      text++;\n\n   text_info.compression = PNG_TEXT_COMPRESSION_NONE;\n   text_info.key = key;\n   text_info.lang = NULL;\n   text_info.lang_key = NULL;\n   text_info.itxt_length = 0;\n   text_info.text = text;\n   text_info.text_length = strlen(text);\n\n   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) != 0)\n      png_warning(png_ptr, \"Insufficient memory to process text chunk\");\n}", "target": 0, "cwe": ["CWE-190", "CWE-369"], "project": "libpng", "commit_id": "8a05766cb74af05c04c53e6c9d60c13fc4d59bf2", "hash": 121095384476496730682528128901564067726, "size": 76, "message": "[libpng16] Fix the calculation of row_factor in png_check_chunk_length\n\n(Bug report by Thuan Pham, SourceForge issue #278)", "idx": 646}
{"func": "con_header_read(agooCon c, size_t *mlenp) {\n    char\t\t*hend = strstr(c->buf, \"\\r\\n\\r\\n\");\n    agooMethod\t\tmethod;\n    struct _agooSeg\tpath;\n    char\t\t*query = NULL;\n    char\t\t*qend;\n    char\t\t*b;\n    size_t\t\tclen = 0;\n    long\t\tmlen;\n    agooHook\t\thook = NULL;\n    agooPage\t\tp;\n    struct _agooErr\terr = AGOO_ERR_INIT;\n\n    if (NULL == hend) {\n\tif (sizeof(c->buf) - 1 <= c->bcnt) {\n\t    return bad_request(c, 431, __LINE__);\n\t}\n\treturn HEAD_AGAIN;\n    }\n    if (agoo_req_cat.on) {\n\t*hend = '\\0';\n\tagoo_log_cat(&agoo_req_cat, \"%s %llu: %s\", agoo_con_kind_str(c->bind->kind), (unsigned long long)c->id, c->buf);\n\t*hend = '\\r';\n    }\n    for (b = c->buf; ' ' != *b; b++) {\n\tif ('\\0' == *b) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n    }\n    switch (toupper(*c->buf)) {\n    case 'G':\n\tif (3 != b - c->buf || 0 != strncmp(\"GET\", c->buf, 3)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_GET;\n\tbreak;\n    case 'P': {\n\tconst char\t*v;\n\tint\t\tvlen = 0;\n\tchar\t\t*vend;\n\n\tif (3 == b - c->buf && 0 == strncmp(\"PUT\", c->buf, 3)) {\n\t    method = AGOO_PUT;\n\t} else if (4 == b - c->buf && 0 == strncmp(\"POST\", c->buf, 4)) {\n\t    method = AGOO_POST;\n\t} else {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tif (NULL == (v = agoo_con_header_value(c->buf, (int)(hend - c->buf), \"Content-Length\", &vlen))) {\n\t    return bad_request(c, 411, __LINE__);\n\t}\n\tclen = (size_t)strtoul(v, &vend, 10);\n\tif (vend != v + vlen) {\n\t    return bad_request(c, 411, __LINE__);\n\t}\n\tbreak;\n    }\n    case 'D':\n\tif (6 != b - c->buf || 0 != strncmp(\"DELETE\", c->buf, 6)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_DELETE;\n\tbreak;\n    case 'H':\n\tif (4 != b - c->buf || 0 != strncmp(\"HEAD\", c->buf, 4)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_HEAD;\n\tbreak;\n    case 'O':\n\tif (7 != b - c->buf || 0 != strncmp(\"OPTIONS\", c->buf, 7)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_OPTIONS;\n\tbreak;\n    case 'C':\n\tif (7 != b - c->buf || 0 != strncmp(\"CONNECT\", c->buf, 7)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_CONNECT;\n\tbreak;\n    default:\n\treturn bad_request(c, 400, __LINE__);\n    }\n    for (; ' ' == *b; b++) {\n\tif ('\\0' == *b) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n    }\n    path.start = b;\n    for (; ' ' != *b; b++) {\n\tswitch (*b) {\n\tcase '?':\n\t    path.end = b;\n\t    query = b + 1;\n\t    break;\n\tcase '\\0':\n\t    return bad_request(c, 400, __LINE__);\n\tdefault:\n\t    break;\n\t}\n    }\n    if (NULL == query) {\n\tpath.end = b;\n\tquery = b;\n\tqend = b;\n    } else {\n\tqend = b;\n    }\n    mlen = hend - c->buf + 4 + clen;\n    *mlenp = mlen;\n\n    if (AGOO_GET == method) {\n\tchar\t\troot_buf[20148];\n\tconst char\t*root = NULL;\n\n\tif (NULL != (p = agoo_group_get(&err, path.start, (int)(path.end - path.start)))) {\n\t    if (page_response(c, p, hend)) {\n\t\treturn bad_request(c, 500, __LINE__);\n\t    }\n\t    return HEAD_HANDLED;\n\t}\n\tif (agoo_domain_use()) {\n\t    const char\t*host;\n\t    int\t\tvlen = 0;\n\n\t    if (NULL == (host = agoo_con_header_value(c->buf, (int)(hend - c->buf), \"Host\", &vlen))) {\n\t\treturn bad_request(c, 411, __LINE__);\n\t    }\n\t    ((char*)host)[vlen] = '\\0';\n\t    root = agoo_domain_resolve(host, root_buf, sizeof(root_buf));\n\t    ((char*)host)[vlen] = '\\r';\n\t}\n\tif (agoo_server.root_first &&\n\t    NULL != (p = agoo_page_get(&err, path.start, (int)(path.end - path.start), root))) {\n\t    if (page_response(c, p, hend)) {\n\t\treturn bad_request(c, 500, __LINE__);\n\t    }\n\t    return HEAD_HANDLED;\n\t}\n\tif (NULL == (hook = agoo_hook_find(agoo_server.hooks, method, &path))) {\n\t    if (NULL != (p = agoo_page_get(&err, path.start, (int)(path.end - path.start), root))) {\n\t\tif (page_response(c, p, hend)) {\n\t\t    return bad_request(c, 500, __LINE__);\n\t\t}\n\t\treturn HEAD_HANDLED;\n\t    }\n\t    if (NULL == agoo_server.hook404) {\n\t\treturn bad_request(c, 404, __LINE__);\n\t    }\n\t    hook = agoo_server.hook404;\n\t}\n    } else if (NULL == (hook = agoo_hook_find(agoo_server.hooks, method, &path))) {\n \treturn bad_request(c, 404, __LINE__);\n    }\n    // Create request and populate.\n    if (NULL == (c->req = agoo_req_create(mlen))) {\n\treturn bad_request(c, 413, __LINE__);\n    }\n    if ((long)c->bcnt <= mlen) {\n\tmemcpy(c->req->msg, c->buf, c->bcnt);\n\tif ((long)c->bcnt < mlen) {\n\t    memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);\n\t}\n    } else {\n\tmemcpy(c->req->msg, c->buf, mlen);\n    }\n    c->req->msg[mlen] = '\\0';\n    c->req->method = method;\n    c->req->upgrade = AGOO_UP_NONE;\n    c->req->up = NULL;\n    c->req->path.start = c->req->msg + (path.start - c->buf);\n    c->req->path.len = (int)(path.end - path.start);\n    c->req->query.start = c->req->msg + (query - c->buf);\n    c->req->query.len = (int)(qend - query);\n    c->req->query.start[c->req->query.len] = '\\0';\n    c->req->body.start = c->req->msg + (hend - c->buf + 4);\n    c->req->body.len = (unsigned int)clen;\n    b = strstr(b, \"\\r\\n\");\n    c->req->header.start = c->req->msg + (b + 2 - c->buf);\n    if (b < hend) {\n\tc->req->header.len = (unsigned int)(hend - b - 2);\n    } else {\n\tc->req->header.len = 0;\n    }\n    c->req->res = NULL;\n    c->req->hook = hook;\n\n    return HEAD_OK;\n}", "target": 1, "cwe": ["CWE-444", "CWE-61"], "project": "agoo", "commit_id": "23d03535cf7b50d679a60a953a0cae9519a4a130", "hash": 230426910782272243611202675577659438640, "size": 190, "message": "Remote addr (#99)\n\n* REMOTE_ADDR added\r\n\r\n* Ready for merge", "idx": 647}
{"func": "unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct * vma;\n\tunsigned long task_size = TASK_SIZE;\n\tunsigned long start_addr;\n\tint do_color_align;\n\n\tif (flags & MAP_FIXED) {\n\t\t/* We do not accept a shared mapping if it would violate\n\t\t * cache aliasing constraints.\n\t\t */\n\t\tif ((flags & MAP_SHARED) &&\n\t\t    ((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))\n\t\t\treturn -EINVAL;\n\t\treturn addr;\n\t}\n\n\tif (test_thread_flag(TIF_32BIT))\n\t\ttask_size = STACK_TOP32;\n\tif (unlikely(len > task_size || len >= VA_EXCLUDE_START))\n\t\treturn -ENOMEM;\n\n\tdo_color_align = 0;\n\tif (filp || (flags & MAP_SHARED))\n\t\tdo_color_align = 1;\n\n\tif (addr) {\n\t\tif (do_color_align)\n\t\t\taddr = COLOUR_ALIGN(addr, pgoff);\n\t\telse\n\t\t\taddr = PAGE_ALIGN(addr);\n\n\t\tvma = find_vma(mm, addr);\n\t\tif (task_size - len >= addr &&\n\t\t    (!vma || addr + len <= vma->vm_start))\n\t\t\treturn addr;\n\t}\n\n\tif (len > mm->cached_hole_size) {\n\t        start_addr = addr = mm->free_area_cache;\n\t} else {\n\t        start_addr = addr = TASK_UNMAPPED_BASE;\n\t        mm->cached_hole_size = 0;\n\t}\n\n\ttask_size -= len;\n\nfull_search:\n\tif (do_color_align)\n\t\taddr = COLOUR_ALIGN(addr, pgoff);\n\telse\n\t\taddr = PAGE_ALIGN(addr);\n\n\tfor (vma = find_vma(mm, addr); ; vma = vma->vm_next) {\n\t\t/* At this point:  (!vma || addr < vma->vm_end). */\n\t\tif (addr < VA_EXCLUDE_START &&\n\t\t    (addr + len) >= VA_EXCLUDE_START) {\n\t\t\taddr = VA_EXCLUDE_END;\n\t\t\tvma = find_vma(mm, VA_EXCLUDE_END);\n\t\t}\n\t\tif (unlikely(task_size < addr)) {\n\t\t\tif (start_addr != TASK_UNMAPPED_BASE) {\n\t\t\t\tstart_addr = addr = TASK_UNMAPPED_BASE;\n\t\t\t\tmm->cached_hole_size = 0;\n\t\t\t\tgoto full_search;\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (likely(!vma || addr + len <= vma->vm_start)) {\n\t\t\t/*\n\t\t\t * Remember the place where we stopped the search:\n\t\t\t */\n\t\t\tmm->free_area_cache = addr + len;\n\t\t\treturn addr;\n\t\t}\n\t\tif (addr + mm->cached_hole_size < vma->vm_start)\n\t\t        mm->cached_hole_size = vma->vm_start - addr;\n\n\t\taddr = vma->vm_end;\n\t\tif (do_color_align)\n\t\t\taddr = COLOUR_ALIGN(addr, pgoff);\n\t}\n}", "target": 0, "cwe": [], "project": "linux", "commit_id": "5a0efea09f42f7c92bd98a38d66b4dff9589266b", "hash": 132555072102990848554848702552591553443, "size": 84, "message": "sparc64: Sharpen address space randomization calculations.\n\nA recent patch to the x86 randomization code caused me to take\na quick look at what we do on sparc64, and in doing so I noticed\nthat we sometimes calculate a non-page-aligned randomization value\nand stick it into mmap_base.\n\nI also noticed that since I copied the logic over from PowerPC,\nthe powerpc code has tweaked the randomization ranges in ways that\nwould benefit us as well.\n\nFor one thing, we should allow up to at least 8MB of randomization\notherwise huge-page regions when HPAGE_SIZE is 4MB never randomize\nat all.\n\nAnd on the 64-bit side we were using up to 4GB.  Tone it down to\n1GB as 4GB can result in a lot of address space wastage.\n\nFinally, make sure all computations are unsigned.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 648}
{"func": "find_lively_task_by_vpid(pid_t vpid)\n{\n\tstruct task_struct *task;\n\tint err;\n\n\trcu_read_lock();\n\tif (!vpid)\n\t\ttask = current;\n\telse\n\t\ttask = find_task_by_vpid(vpid);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\tif (!task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\t/* Reuse ptrace permission checks for now. */\n\terr = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))\n\t\tgoto errout;\n\n\treturn task;\nerrout:\n\tput_task_struct(task);\n\treturn ERR_PTR(err);\n\n}", "target": 1, "cwe": ["CWE-667"], "project": "linux", "commit_id": "79c9ce57eb2d5f1497546a3946b4ae21b6fdc438", "hash": 20880746279222911912815191381291098425, "size": 28, "message": "perf/core: Fix perf_event_open() vs. execve() race\n\nJann reported that the ptrace_may_access() check in\nfind_lively_task_by_vpid() is racy against exec().\n\nSpecifically:\n\n  perf_event_open()\t\texecve()\n\n  ptrace_may_access()\n\t\t\t\tcommit_creds()\n  ...\t\t\t\tif (get_dumpable() != SUID_DUMP_USER)\n\t\t\t\t  perf_event_exit_task();\n  perf_install_in_context()\n\nwould result in installing a counter across the creds boundary.\n\nFix this by wrapping lots of perf_event_open() in cred_guard_mutex.\nThis should be fine as perf_event_exit_task() is already called with\ncred_guard_mutex held, so all perf locks already nest inside it.\n\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Alexander Shishkin <alexander.shishkin@linux.intel.com>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>", "idx": 649}
{"func": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1, "cwe": ["CWE-787"], "project": "openjpeg", "commit_id": "2cd30c2b06ce332dede81cccad8b334cde997281", "hash": 244520166809510843470720382189005262450, "size": 8, "message": "tgatoimage(): avoid excessive memory allocation attempt, and fixes unaligned load (#995)", "idx": 650}
{"func": "NTSTATUS get_ea_names_from_fsp(TALLOC_CTX *mem_ctx,\n\t\t\t\tfiles_struct *fsp,\n\t\t\t\tchar ***pnames,\n\t\t\t\tsize_t *pnum_names)\n{\n\tchar smallbuf[1024];\n\t/* Get a list of all xattrs. Max namesize is 64k. */\n\tsize_t ea_namelist_size = 1024;\n\tchar *ea_namelist = smallbuf;\n\tchar *to_free = NULL;\n\n\tchar *p;\n\tchar **names;\n\tsize_t num_names;\n\tssize_t sizeret = -1;\n\tNTSTATUS status;\n\n\tif (pnames) {\n\t\t*pnames = NULL;\n\t}\n\t*pnum_names = 0;\n\n\tif (fsp == NULL) {\n\t\t/*\n\t\t * Callers may pass fsp == NULL when passing smb_fname->fsp of a\n\t\t * symlink. This is ok, handle it here, by just return no EA's\n\t\t * on a symlink.\n\t\t */\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/* should be the case that fsp != NULL */\n\tSMB_ASSERT(fsp != NULL);\n\n\tsizeret = SMB_VFS_FLISTXATTR(fsp, ea_namelist,\n\t\t\t\t     ea_namelist_size);\n\n\tif ((sizeret == -1) && (errno == ERANGE)) {\n\t\tea_namelist_size = 65536;\n\t\tea_namelist = talloc_array(mem_ctx, char, ea_namelist_size);\n\t\tif (ea_namelist == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tto_free = ea_namelist;\n\n\t\tsizeret = SMB_VFS_FLISTXATTR(fsp, ea_namelist,\n\t\t\t\t\t     ea_namelist_size);\n\t}\n\n\tif (sizeret == -1) {\n\t\tstatus = map_nt_error_from_unix(errno);\n\t\tTALLOC_FREE(to_free);\n\t\treturn status;\n\t}\n\n\tDBG_DEBUG(\"ea_namelist size = %zd\\n\", sizeret);\n\n\tif (sizeret == 0) {\n\t\tTALLOC_FREE(to_free);\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/*\n\t * Ensure the result is 0-terminated\n\t */\n\n\tif (ea_namelist[sizeret-1] != '\\0') {\n\t\tTALLOC_FREE(to_free);\n\t\treturn NT_STATUS_INTERNAL_ERROR;\n\t}\n\n\t/*\n\t * count the names\n\t */\n\tnum_names = 0;\n\n\tfor (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {\n\t\tnum_names += 1;\n\t}\n\n\t*pnum_names = num_names;\n\n\tif (pnames == NULL) {\n\t\tTALLOC_FREE(to_free);\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tnames = talloc_array(mem_ctx, char *, num_names);\n\tif (names == NULL) {\n\t\tDEBUG(0, (\"talloc failed\\n\"));\n\t\tTALLOC_FREE(to_free);\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\n\tif (ea_namelist == smallbuf) {\n\t\tea_namelist = talloc_memdup(names, smallbuf, sizeret);\n\t\tif (ea_namelist == NULL) {\n\t\t\tTALLOC_FREE(names);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t} else {\n\t\ttalloc_steal(names, ea_namelist);\n\n\t\tea_namelist = talloc_realloc(names, ea_namelist, char,\n\t\t\t\t\t     sizeret);\n\t\tif (ea_namelist == NULL) {\n\t\t\tTALLOC_FREE(names);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t}\n\n\tnum_names = 0;\n\n\tfor (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {\n\t\tnames[num_names++] = p;\n\t}\n\n\t*pnames = names;\n\n\treturn NT_STATUS_OK;\n}", "target": 0, "cwe": ["CWE-787"], "project": "samba", "commit_id": "22b4091924977f6437b59627f33a8e6f02b41011", "hash": 277672412631589334972536220423689441955, "size": 121, "message": "CVE-2021-44142: smbd: add Netatalk xattr used by vfs_fruit to the list of private Samba xattrs\n\nThis is an internal xattr that should not be user visible.\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=14914\n\nSigned-off-by: Ralph Boehme <slow@samba.org>\nReviewed-by: Jeremy Allison <jra@samba.org>", "idx": 651}
{"func": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "linux", "commit_id": "027ef6c87853b0a9df53175063028edb4950d476", "hash": 145540160975471758109596639332261185740, "size": 4, "message": "mm: thp: fix pmd_present for split_huge_page and PROT_NONE with THP\n\nIn many places !pmd_present has been converted to pmd_none.  For pmds\nthat's equivalent and pmd_none is quicker so using pmd_none is better.\n\nHowever (unless we delete pmd_present) we should provide an accurate\npmd_present too.  This will avoid the risk of code thinking the pmd is non\npresent because it's under __split_huge_page_map, see the pmd_mknotpresent\nthere and the comment above it.\n\nIf the page has been mprotected as PROT_NONE, it would also lead to a\npmd_present false negative in the same way as the race with\nsplit_huge_page.\n\nBecause the PSE bit stays on at all times (both during split_huge_page and\nwhen the _PAGE_PROTNONE bit get set), we could only check for the PSE bit,\nbut checking the PROTNONE bit too is still good to remember pmd_present\nmust always keep PROT_NONE into account.\n\nThis explains a not reproducible BUG_ON that was seldom reported on the\nlists.\n\nThe same issue is in pmd_large, it would go wrong with both PROT_NONE and\nif it races with split_huge_page.\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: Johannes Weiner <jweiner@redhat.com>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 652}
{"func": "png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)\n{\n   double r = floor(100000 * fp + .5);\n\n   if (r > 2147483647. || r < -2147483648.)\n      png_fixed_error(png_ptr, text);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n   PNG_UNUSED(text)\n#  endif\n\n   return (png_fixed_point)r;\n}", "target": 0, "cwe": ["CWE-476"], "project": "libpng", "commit_id": "812768d7a9c973452222d454634496b25ed415eb", "hash": 232273933145119166087436669820322436523, "size": 13, "message": "[libpng16] Fixed a potential null pointer dereference in png_set_text_2()\n\n(bug report and patch by Patrick Keshishian).", "idx": 653}
{"func": "DefragIPv4TooLargeTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. */\n    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should have\n     * been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}", "target": 1, "cwe": ["CWE-358"], "project": "suricata", "commit_id": "4a04f814b15762eb446a5ead4d69d021512df6f8", "hash": 70042077662233538556594558484379202183, "size": 39, "message": "defrag - take protocol into account during re-assembly\n\nThe IP protocol was not being used to match fragments with\ntheir packets allowing a carefully constructed packet\nwith a different protocol to be matched, allowing re-assembly\nto complete, creating a packet that would not be re-assembled\nby the destination host.", "idx": 654}
{"func": "NAN_MODULE_INIT(init) {\n  ChaChaPolyCipher::Init(target);\n  AESGCMCipher::Init(target);\n  GenericCipher::Init(target);\n\n  ChaChaPolyDecipher::Init(target);\n  AESGCMDecipher::Init(target);\n  GenericDecipher::Init(target);\n}", "target": 0, "cwe": ["CWE-78"], "project": "ssh2", "commit_id": "f763271f41320e71d5cbee02ea5bc6a2ded3ca21", "hash": 292656264312618380592463574896769437115, "size": 9, "message": "examples,lib,test: switch to code rewrite\n\nFor more information see: https://github.com/mscdex/ssh2/issues/935", "idx": 655}
{"func": "transformRuleStmt(RuleStmt *stmt, const char *queryString,\n\t\t\t\t  List **actions, Node **whereClause)\n{\n\tRelation\trel;\n\tParseState *pstate;\n\tParseNamespaceItem *oldnsitem;\n\tParseNamespaceItem *newnsitem;\n\n\t/*\n\t * To avoid deadlock, make sure the first thing we do is grab\n\t * AccessExclusiveLock on the target relation.  This will be needed by\n\t * DefineQueryRewrite(), and we don't want to grab a lesser lock\n\t * beforehand.\n\t */\n\trel = table_openrv(stmt->relation, AccessExclusiveLock);\n\n\tif (rel->rd_rel->relkind == RELKIND_MATVIEW)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"rules on materialized views are not supported\")));\n\n\t/* Set up pstate */\n\tpstate = make_parsestate(NULL);\n\tpstate->p_sourcetext = queryString;\n\n\t/*\n\t * NOTE: 'OLD' must always have a varno equal to 1 and 'NEW' equal to 2.\n\t * Set up their ParseNamespaceItems in the main pstate for use in parsing\n\t * the rule qualification.\n\t */\n\toldnsitem = addRangeTableEntryForRelation(pstate, rel,\n\t\t\t\t\t\t\t\t\t\t\t  AccessShareLock,\n\t\t\t\t\t\t\t\t\t\t\t  makeAlias(\"old\", NIL),\n\t\t\t\t\t\t\t\t\t\t\t  false, false);\n\tnewnsitem = addRangeTableEntryForRelation(pstate, rel,\n\t\t\t\t\t\t\t\t\t\t\t  AccessShareLock,\n\t\t\t\t\t\t\t\t\t\t\t  makeAlias(\"new\", NIL),\n\t\t\t\t\t\t\t\t\t\t\t  false, false);\n\t/* Must override addRangeTableEntry's default access-check flags */\n\toldnsitem->p_rte->requiredPerms = 0;\n\tnewnsitem->p_rte->requiredPerms = 0;\n\n\t/*\n\t * They must be in the namespace too for lookup purposes, but only add the\n\t * one(s) that are relevant for the current kind of rule.  In an UPDATE\n\t * rule, quals must refer to OLD.field or NEW.field to be unambiguous, but\n\t * there's no need to be so picky for INSERT & DELETE.  We do not add them\n\t * to the joinlist.\n\t */\n\tswitch (stmt->event)\n\t{\n\t\tcase CMD_SELECT:\n\t\t\taddNSItemToQuery(pstate, oldnsitem, false, true, true);\n\t\t\tbreak;\n\t\tcase CMD_UPDATE:\n\t\t\taddNSItemToQuery(pstate, oldnsitem, false, true, true);\n\t\t\taddNSItemToQuery(pstate, newnsitem, false, true, true);\n\t\t\tbreak;\n\t\tcase CMD_INSERT:\n\t\t\taddNSItemToQuery(pstate, newnsitem, false, true, true);\n\t\t\tbreak;\n\t\tcase CMD_DELETE:\n\t\t\taddNSItemToQuery(pstate, oldnsitem, false, true, true);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized event type: %d\",\n\t\t\t\t (int) stmt->event);\n\t\t\tbreak;\n\t}\n\n\t/* take care of the where clause */\n\t*whereClause = transformWhereClause(pstate,\n\t\t\t\t\t\t\t\t\t\t(Node *) copyObject(stmt->whereClause),\n\t\t\t\t\t\t\t\t\t\tEXPR_KIND_WHERE,\n\t\t\t\t\t\t\t\t\t\t\"WHERE\");\n\t/* we have to fix its collations too */\n\tassign_expr_collations(pstate, *whereClause);\n\n\t/* this is probably dead code without add_missing_from: */\n\tif (list_length(pstate->p_rtable) != 2) /* naughty, naughty... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"rule WHERE condition cannot contain references to other relations\")));\n\n\t/*\n\t * 'instead nothing' rules with a qualification need a query rangetable so\n\t * the rewrite handler can add the negated rule qualification to the\n\t * original query. We create a query with the new command type CMD_NOTHING\n\t * here that is treated specially by the rewrite system.\n\t */\n\tif (stmt->actions == NIL)\n\t{\n\t\tQuery\t   *nothing_qry = makeNode(Query);\n\n\t\tnothing_qry->commandType = CMD_NOTHING;\n\t\tnothing_qry->rtable = pstate->p_rtable;\n\t\tnothing_qry->jointree = makeFromExpr(NIL, NULL);\t/* no join wanted */\n\n\t\t*actions = list_make1(nothing_qry);\n\t}\n\telse\n\t{\n\t\tListCell   *l;\n\t\tList\t   *newactions = NIL;\n\n\t\t/*\n\t\t * transform each statement, like parse_sub_analyze()\n\t\t */\n\t\tforeach(l, stmt->actions)\n\t\t{\n\t\t\tNode\t   *action = (Node *) lfirst(l);\n\t\t\tParseState *sub_pstate = make_parsestate(NULL);\n\t\t\tQuery\t   *sub_qry,\n\t\t\t\t\t   *top_subqry;\n\t\t\tbool\t\thas_old,\n\t\t\t\t\t\thas_new;\n\n\t\t\t/*\n\t\t\t * Since outer ParseState isn't parent of inner, have to pass down\n\t\t\t * the query text by hand.\n\t\t\t */\n\t\t\tsub_pstate->p_sourcetext = queryString;\n\n\t\t\t/*\n\t\t\t * Set up OLD/NEW in the rtable for this statement.  The entries\n\t\t\t * are added only to relnamespace, not varnamespace, because we\n\t\t\t * don't want them to be referred to by unqualified field names\n\t\t\t * nor \"*\" in the rule actions.  We decide later whether to put\n\t\t\t * them in the joinlist.\n\t\t\t */\n\t\t\toldnsitem = addRangeTableEntryForRelation(sub_pstate, rel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  AccessShareLock,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  makeAlias(\"old\", NIL),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  false, false);\n\t\t\tnewnsitem = addRangeTableEntryForRelation(sub_pstate, rel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  AccessShareLock,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  makeAlias(\"new\", NIL),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  false, false);\n\t\t\toldnsitem->p_rte->requiredPerms = 0;\n\t\t\tnewnsitem->p_rte->requiredPerms = 0;\n\t\t\taddNSItemToQuery(sub_pstate, oldnsitem, false, true, false);\n\t\t\taddNSItemToQuery(sub_pstate, newnsitem, false, true, false);\n\n\t\t\t/* Transform the rule action statement */\n\t\t\ttop_subqry = transformStmt(sub_pstate,\n\t\t\t\t\t\t\t\t\t   (Node *) copyObject(action));\n\n\t\t\t/*\n\t\t\t * We cannot support utility-statement actions (eg NOTIFY) with\n\t\t\t * nonempty rule WHERE conditions, because there's no way to make\n\t\t\t * the utility action execute conditionally.\n\t\t\t */\n\t\t\tif (top_subqry->commandType == CMD_UTILITY &&\n\t\t\t\t*whereClause != NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t\t errmsg(\"rules with WHERE conditions can only have SELECT, INSERT, UPDATE, or DELETE actions\")));\n\n\t\t\t/*\n\t\t\t * If the action is INSERT...SELECT, OLD/NEW have been pushed down\n\t\t\t * into the SELECT, and that's what we need to look at. (Ugly\n\t\t\t * kluge ... try to fix this when we redesign querytrees.)\n\t\t\t */\n\t\t\tsub_qry = getInsertSelectQuery(top_subqry, NULL);\n\n\t\t\t/*\n\t\t\t * If the sub_qry is a setop, we cannot attach any qualifications\n\t\t\t * to it, because the planner won't notice them.  This could\n\t\t\t * perhaps be relaxed someday, but for now, we may as well reject\n\t\t\t * such a rule immediately.\n\t\t\t */\n\t\t\tif (sub_qry->setOperations != NULL && *whereClause != NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"conditional UNION/INTERSECT/EXCEPT statements are not implemented\")));\n\n\t\t\t/*\n\t\t\t * Validate action's use of OLD/NEW, qual too\n\t\t\t */\n\t\t\thas_old =\n\t\t\t\trangeTableEntry_used((Node *) sub_qry, PRS2_OLD_VARNO, 0) ||\n\t\t\t\trangeTableEntry_used(*whereClause, PRS2_OLD_VARNO, 0);\n\t\t\thas_new =\n\t\t\t\trangeTableEntry_used((Node *) sub_qry, PRS2_NEW_VARNO, 0) ||\n\t\t\t\trangeTableEntry_used(*whereClause, PRS2_NEW_VARNO, 0);\n\n\t\t\tswitch (stmt->event)\n\t\t\t{\n\t\t\t\tcase CMD_SELECT:\n\t\t\t\t\tif (has_old)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t\t\t\t errmsg(\"ON SELECT rule cannot use OLD\")));\n\t\t\t\t\tif (has_new)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t\t\t\t errmsg(\"ON SELECT rule cannot use NEW\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase CMD_UPDATE:\n\t\t\t\t\t/* both are OK */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CMD_INSERT:\n\t\t\t\t\tif (has_old)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t\t\t\t errmsg(\"ON INSERT rule cannot use OLD\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase CMD_DELETE:\n\t\t\t\t\tif (has_new)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t\t\t\t errmsg(\"ON DELETE rule cannot use NEW\")));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized event type: %d\",\n\t\t\t\t\t\t (int) stmt->event);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OLD/NEW are not allowed in WITH queries, because they would\n\t\t\t * amount to outer references for the WITH, which we disallow.\n\t\t\t * However, they were already in the outer rangetable when we\n\t\t\t * analyzed the query, so we have to check.\n\t\t\t *\n\t\t\t * Note that in the INSERT...SELECT case, we need to examine the\n\t\t\t * CTE lists of both top_subqry and sub_qry.\n\t\t\t *\n\t\t\t * Note that we aren't digging into the body of the query looking\n\t\t\t * for WITHs in nested sub-SELECTs.  A WITH down there can\n\t\t\t * legitimately refer to OLD/NEW, because it'd be an\n\t\t\t * indirect-correlated outer reference.\n\t\t\t */\n\t\t\tif (rangeTableEntry_used((Node *) top_subqry->cteList,\n\t\t\t\t\t\t\t\t\t PRS2_OLD_VARNO, 0) ||\n\t\t\t\trangeTableEntry_used((Node *) sub_qry->cteList,\n\t\t\t\t\t\t\t\t\t PRS2_OLD_VARNO, 0))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"cannot refer to OLD within WITH query\")));\n\t\t\tif (rangeTableEntry_used((Node *) top_subqry->cteList,\n\t\t\t\t\t\t\t\t\t PRS2_NEW_VARNO, 0) ||\n\t\t\t\trangeTableEntry_used((Node *) sub_qry->cteList,\n\t\t\t\t\t\t\t\t\t PRS2_NEW_VARNO, 0))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"cannot refer to NEW within WITH query\")));\n\n\t\t\t/*\n\t\t\t * For efficiency's sake, add OLD to the rule action's jointree\n\t\t\t * only if it was actually referenced in the statement or qual.\n\t\t\t *\n\t\t\t * For INSERT, NEW is not really a relation (only a reference to\n\t\t\t * the to-be-inserted tuple) and should never be added to the\n\t\t\t * jointree.\n\t\t\t *\n\t\t\t * For UPDATE, we treat NEW as being another kind of reference to\n\t\t\t * OLD, because it represents references to *transformed* tuples\n\t\t\t * of the existing relation.  It would be wrong to enter NEW\n\t\t\t * separately in the jointree, since that would cause a double\n\t\t\t * join of the updated relation.  It's also wrong to fail to make\n\t\t\t * a jointree entry if only NEW and not OLD is mentioned.\n\t\t\t */\n\t\t\tif (has_old || (has_new && stmt->event == CMD_UPDATE))\n\t\t\t{\n\t\t\t\tRangeTblRef *rtr;\n\n\t\t\t\t/*\n\t\t\t\t * If sub_qry is a setop, manipulating its jointree will do no\n\t\t\t\t * good at all, because the jointree is dummy. (This should be\n\t\t\t\t * a can't-happen case because of prior tests.)\n\t\t\t\t */\n\t\t\t\tif (sub_qry->setOperations != NULL)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t errmsg(\"conditional UNION/INTERSECT/EXCEPT statements are not implemented\")));\n\t\t\t\t/* hackishly add OLD to the already-built FROM clause */\n\t\t\t\trtr = makeNode(RangeTblRef);\n\t\t\t\trtr->rtindex = oldnsitem->p_rtindex;\n\t\t\t\tsub_qry->jointree->fromlist =\n\t\t\t\t\tlappend(sub_qry->jointree->fromlist, rtr);\n\t\t\t}\n\n\t\t\tnewactions = lappend(newactions, top_subqry);\n\n\t\t\tfree_parsestate(sub_pstate);\n\t\t}\n\n\t\t*actions = newactions;\n\t}\n\n\tfree_parsestate(pstate);\n\n\t/* Close relation, but keep the exclusive lock */\n\ttable_close(rel, NoLock);\n}", "target": 0, "cwe": ["CWE-94"], "project": "postgres", "commit_id": "7e92f78abe80e4b30e648a40073abb59057e21f8", "hash": 29415575257443031531798632944147119750, "size": 296, "message": "In extensions, don't replace objects not belonging to the extension.\n\nPreviously, if an extension script did CREATE OR REPLACE and there was\nan existing object not belonging to the extension, it would overwrite\nthe object and adopt it into the extension.  This is problematic, first\nbecause the overwrite is probably unintentional, and second because we\ndidn't change the object's ownership.  Thus a hostile user could create\nan object in advance of an expected CREATE EXTENSION command, and would\nthen have ownership rights on an extension object, which could be\nmodified for trojan-horse-type attacks.\n\nHence, forbid CREATE OR REPLACE of an existing object unless it already\nbelongs to the extension.  (Note that we've always forbidden replacing\nan object that belongs to some other extension; only the behavior for\npreviously-free-standing objects changes here.)\n\nFor the same reason, also fail CREATE IF NOT EXISTS when there is\nan existing object that doesn't belong to the extension.\n\nOur thanks to Sven Klemm for reporting this problem.\n\nSecurity: CVE-2022-2625", "idx": 656}
{"func": "CreateSchemaCommand(CreateSchemaStmt *stmt, const char *queryString,\n\t\t\t\t\tint stmt_location, int stmt_len)\n{\n\tconst char *schemaName = stmt->schemaname;\n\tOid\t\t\tnamespaceId;\n\tOverrideSearchPath *overridePath;\n\tList\t   *parsetree_list;\n\tListCell   *parsetree_item;\n\tOid\t\t\towner_uid;\n\tOid\t\t\tsaved_uid;\n\tint\t\t\tsave_sec_context;\n\tAclResult\taclresult;\n\tObjectAddress address;\n\n\tGetUserIdAndSecContext(&saved_uid, &save_sec_context);\n\n\t/*\n\t * Who is supposed to own the new schema?\n\t */\n\tif (stmt->authrole)\n\t\towner_uid = get_rolespec_oid(stmt->authrole, false);\n\telse\n\t\towner_uid = saved_uid;\n\n\t/* fill schema name with the user name if not specified */\n\tif (!schemaName)\n\t{\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(AUTHOID, ObjectIdGetDatum(owner_uid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for role %u\", owner_uid);\n\t\tschemaName =\n\t\t\tpstrdup(NameStr(((Form_pg_authid) GETSTRUCT(tuple))->rolname));\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/*\n\t * To create a schema, must have schema-create privilege on the current\n\t * database and must be able to become the target role (this does not\n\t * imply that the target role itself must have create-schema privilege).\n\t * The latter provision guards against \"giveaway\" attacks.  Note that a\n\t * superuser will always have both of these privileges a fortiori.\n\t */\n\taclresult = pg_database_aclcheck(MyDatabaseId, saved_uid, ACL_CREATE);\n\tif (aclresult != ACLCHECK_OK)\n\t\taclcheck_error(aclresult, ACL_KIND_DATABASE,\n\t\t\t\t\t   get_database_name(MyDatabaseId));\n\n\tcheck_is_member_of_role(saved_uid, owner_uid);\n\n\t/* Additional check to protect reserved schema names */\n\tif (!allowSystemTableMods && IsReservedName(schemaName))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_RESERVED_NAME),\n\t\t\t\t errmsg(\"unacceptable schema name \\\"%s\\\"\", schemaName),\n\t\t\t\t errdetail(\"The prefix \\\"pg_\\\" is reserved for system schemas.\")));\n\n\t/*\n\t * If if_not_exists was given and the schema already exists, bail out.\n\t * (Note: we needn't check this when not if_not_exists, because\n\t * NamespaceCreate will complain anyway.)  We could do this before making\n\t * the permissions checks, but since CREATE TABLE IF NOT EXISTS makes its\n\t * creation-permission check first, we do likewise.\n\t */\n\tif (stmt->if_not_exists &&\n\t\tSearchSysCacheExists1(NAMESPACENAME, PointerGetDatum(schemaName)))\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errcode(ERRCODE_DUPLICATE_SCHEMA),\n\t\t\t\t errmsg(\"schema \\\"%s\\\" already exists, skipping\",\n\t\t\t\t\t\tschemaName)));\n\t\treturn InvalidOid;\n\t}\n\n\t/*\n\t * If the requested authorization is different from the current user,\n\t * temporarily set the current user so that the object(s) will be created\n\t * with the correct ownership.\n\t *\n\t * (The setting will be restored at the end of this routine, or in case of\n\t * error, transaction abort will clean things up.)\n\t */\n\tif (saved_uid != owner_uid)\n\t\tSetUserIdAndSecContext(owner_uid,\n\t\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE);\n\n\t/* Create the schema's namespace */\n\tnamespaceId = NamespaceCreate(schemaName, owner_uid, false);\n\n\t/* Advance cmd counter to make the namespace visible */\n\tCommandCounterIncrement();\n\n\t/*\n\t * Temporarily make the new namespace be the front of the search path, as\n\t * well as the default creation target namespace.  This will be undone at\n\t * the end of this routine, or upon error.\n\t */\n\toverridePath = GetOverrideSearchPath(CurrentMemoryContext);\n\toverridePath->schemas = lcons_oid(namespaceId, overridePath->schemas);\n\t/* XXX should we clear overridePath->useTemp? */\n\tPushOverrideSearchPath(overridePath);\n\n\t/*\n\t * Report the new schema to possibly interested event triggers.  Note we\n\t * must do this here and not in ProcessUtilitySlow because otherwise the\n\t * objects created below are reported before the schema, which would be\n\t * wrong.\n\t */\n\tObjectAddressSet(address, NamespaceRelationId, namespaceId);\n\tEventTriggerCollectSimpleCommand(address, InvalidObjectAddress,\n\t\t\t\t\t\t\t\t\t (Node *) stmt);\n\n\t/*\n\t * Examine the list of commands embedded in the CREATE SCHEMA command, and\n\t * reorganize them into a sequentially executable order with no forward\n\t * references.  Note that the result is still a list of raw parsetrees ---\n\t * we cannot, in general, run parse analysis on one statement until we\n\t * have actually executed the prior ones.\n\t */\n\tparsetree_list = transformCreateSchemaStmt(stmt);\n\n\t/*\n\t * Execute each command contained in the CREATE SCHEMA.  Since the grammar\n\t * allows only utility commands in CREATE SCHEMA, there is no need to pass\n\t * them through parse_analyze() or the rewriter; we can just hand them\n\t * straight to ProcessUtility.\n\t */\n\tforeach(parsetree_item, parsetree_list)\n\t{\n\t\tNode\t   *stmt = (Node *) lfirst(parsetree_item);\n\t\tPlannedStmt *wrapper;\n\n\t\t/* need to make a wrapper PlannedStmt */\n\t\twrapper = makeNode(PlannedStmt);\n\t\twrapper->commandType = CMD_UTILITY;\n\t\twrapper->canSetTag = false;\n\t\twrapper->utilityStmt = stmt;\n\t\twrapper->stmt_location = stmt_location;\n\t\twrapper->stmt_len = stmt_len;\n\n\t\t/* do this step */\n\t\tProcessUtility(wrapper,\n\t\t\t\t\t   queryString,\n\t\t\t\t\t   PROCESS_UTILITY_SUBCOMMAND,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   None_Receiver,\n\t\t\t\t\t   NULL);\n\n\t\t/* make sure later steps can see the object created here */\n\t\tCommandCounterIncrement();\n\t}\n\n\t/* Reset search path to normal state */\n\tPopOverrideSearchPath();\n\n\t/* Reset current user and security context */\n\tSetUserIdAndSecContext(saved_uid, save_sec_context);\n\n\treturn namespaceId;\n}", "target": 1, "cwe": ["CWE-94"], "project": "postgres", "commit_id": "5919bb5a5989cda232ac3d1f8b9d90f337be2077", "hash": 127565127813893533717214175365271973040, "size": 162, "message": "In extensions, don't replace objects not belonging to the extension.\n\nPreviously, if an extension script did CREATE OR REPLACE and there was\nan existing object not belonging to the extension, it would overwrite\nthe object and adopt it into the extension.  This is problematic, first\nbecause the overwrite is probably unintentional, and second because we\ndidn't change the object's ownership.  Thus a hostile user could create\nan object in advance of an expected CREATE EXTENSION command, and would\nthen have ownership rights on an extension object, which could be\nmodified for trojan-horse-type attacks.\n\nHence, forbid CREATE OR REPLACE of an existing object unless it already\nbelongs to the extension.  (Note that we've always forbidden replacing\nan object that belongs to some other extension; only the behavior for\npreviously-free-standing objects changes here.)\n\nFor the same reason, also fail CREATE IF NOT EXISTS when there is\nan existing object that doesn't belong to the extension.\n\nOur thanks to Sven Klemm for reporting this problem.\n\nSecurity: CVE-2022-2625", "idx": 657}
{"func": "void check_file_actlst(int *ifd, char *dfile, struct activity *act[], unsigned int flags,\n\t\t       struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t       struct file_activity **file_actlst, unsigned int id_seq[],\n\t\t       int ignore, int *endian_mismatch, int *arch_64)\n{\n\tint i, j, k, p;\n\tstruct file_activity *fal;\n\tvoid *buffer = NULL;\n\n\t/* Open sa data file and read its magic structure */\n\tif (sa_open_read_magic(ifd, dfile, file_magic, ignore, endian_mismatch, TRUE) < 0)\n\t\t/*\n\t\t * Not current sysstat's format.\n\t\t * Return now so that sadf -H can display at least\n\t\t * file's version and magic number.\n\t\t */\n\t\treturn;\n\n\t/*\n\t * We know now that we have a *compatible* sysstat datafile format\n\t * (correct FORMAT_MAGIC value), and in this case, we should have\n\t * checked header_size value. Anyway, with a corrupted datafile,\n\t * this may not be the case. So check again.\n\t */\n\tif ((file_magic->header_size <= MIN_FILE_HEADER_SIZE) ||\n\t    (file_magic->header_size > MAX_FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: header_size=%u\\n\",\n\t\t\t__FUNCTION__, file_magic->header_size);\n#endif\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_header structure */\n\tSREALLOC(buffer, char, file_magic->header_size);\n\n\t/* Read sa data file standard header and allocate activity list */\n\tsa_fread(*ifd, buffer, (size_t) file_magic->header_size, HARD_SIZE, UEOF_STOP);\n\t/*\n\t * Data file header size (file_magic->header_size) may be greater or\n\t * smaller than FILE_HEADER_SIZE. Remap the fields of the file header\n\t * then copy its contents to the expected  structure.\n\t */\n\tremap_struct(hdr_types_nr, file_magic->hdr_types_nr, buffer,\n\t\t     file_magic->header_size, FILE_HEADER_SIZE, file_magic->header_size);\n\tmemcpy(file_hdr, buffer, FILE_HEADER_SIZE);\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Tell that data come from a 64 bit machine */\n\t*arch_64 = (file_hdr->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t/* Normalize endianness for file_hdr structure */\n\tif (*endian_mismatch) {\n\t\tswap_struct(hdr_types_nr, file_hdr, *arch_64);\n\t}\n\n\t/*\n\t * Sanity checks.\n\t * NB: Compare against MAX_NR_ACT and not NR_ACT because\n\t * we are maybe reading a datafile from a future sysstat version\n\t * with more activities than known today.\n\t */\n\tif ((file_hdr->sa_act_nr > MAX_NR_ACT) ||\n\t    (file_hdr->act_size > MAX_FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr->rec_size > MAX_RECORD_HEADER_SIZE) ||\n\t    (MAP_SIZE(file_hdr->act_types_nr) > file_hdr->act_size) ||\n\t    (MAP_SIZE(file_hdr->rec_types_nr) > file_hdr->rec_size)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: sa_act_nr=%d act_size=%u rec_size=%u map_size(act)=%u map_size(rec)=%u\\n\",\n\t\t\t__FUNCTION__, file_hdr->sa_act_nr, file_hdr->act_size, file_hdr->rec_size,\n\t\t\tMAP_SIZE(file_hdr->act_types_nr), MAP_SIZE(file_hdr->rec_types_nr));\n#endif\n\t\t/* Maybe a \"false positive\" sysstat datafile? */\n\t\tgoto format_error;\n\t}\n\n\tSREALLOC(buffer, char, file_hdr->act_size);\n\tSREALLOC(*file_actlst, struct file_activity, FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tfal = *file_actlst;\n\n\t/* Read activity list */\n\tj = 0;\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, fal++) {\n\n\t\t/* Read current file_activity structure from file */\n\t\tsa_fread(*ifd, buffer, (size_t) file_hdr->act_size, HARD_SIZE, UEOF_STOP);\n\t\t/*\n\t\t* Data file_activity size (file_hdr->act_size) may be greater or\n\t\t* smaller than FILE_ACTIVITY_SIZE. Remap the fields of the file's structure\n\t\t* then copy its contents to the expected structure.\n\t\t*/\n\t\tif (remap_struct(act_types_nr, file_hdr->act_types_nr, buffer,\n\t\t\t     file_hdr->act_size, FILE_ACTIVITY_SIZE, file_hdr->act_size) < 0)\n\t\t\tgoto format_error;\n\t\tmemcpy(fal, buffer, FILE_ACTIVITY_SIZE);\n\n\t\t/* Normalize endianness for file_activity structures */\n\t\tif (*endian_mismatch) {\n\t\t\tswap_struct(act_types_nr, fal, *arch_64);\n\t\t}\n\n\t\t/*\n\t\t * Every activity, known or unknown, should have\n\t\t * at least one item and sub-item, and a positive size value.\n\t\t * Also check that the number of items and sub-items\n\t\t * doesn't exceed a max value. This is necessary\n\t\t * because we will use @nr and @nr2 to\n\t\t * allocate memory to read the file contents. So we\n\t\t * must make sure the file is not corrupted.\n\t\t * NB: Another check will be made below for known\n\t\t * activities which have each a specific max value.\n\t\t */\n\t\tif ((fal->nr < 1) || (fal->nr2 < 1) ||\n\t\t    (fal->nr > NR_MAX) || (fal->nr2 > NR2_MAX) ||\n\t\t    (fal->size <= 0)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr2=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, fal->nr2);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif ((p = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND)) < 0)\n\t\t\t/* Unknown activity */\n\t\t\tcontinue;\n\n\t\tif (act[p]->magic != fal->magic) {\n\t\t\t/* Bad magical number */\n\t\t\tif (ignore) {\n\t\t\t\t/*\n\t\t\t\t * This is how sadf -H knows that this\n\t\t\t\t * activity has an unknown format.\n\t\t\t\t */\n\t\t\t\tact[p]->magic = ACTIVITY_MAGIC_UNKNOWN;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check max value for known activities */\n\t\tif (fal->nr > act[p]->nr_max) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr_max=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, act[p]->nr_max);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\t/*\n\t\t * Number of fields of each type (\"long long\", or \"long\"\n\t\t * or \"int\") composing the structure with statistics may\n\t\t * only increase with new sysstat versions. Here, we may\n\t\t * be reading a file created by current sysstat version,\n\t\t * or by an older or a newer version.\n\t\t */\n\t\tif (!(((fal->types_nr[0] >= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] >= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] >= act[p]->gtypes_nr[2]))\n\t\t     ||\n\t\t     ((fal->types_nr[0] <= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] <= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] <= act[p]->gtypes_nr[2]))) && !ignore) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d file=%d,%d,%d activity=%d,%d,%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->types_nr[0], fal->types_nr[1], fal->types_nr[2],\n\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2]);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif (MAP_SIZE(fal->types_nr) > fal->size) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: id=%d size=%u map_size=%u\\n\",\n\t\t\t__FUNCTION__, fal->id, fal->size, MAP_SIZE(fal->types_nr));\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tact[p]->ftypes_nr[k] = fal->types_nr[k];\n\t\t}\n\n\t\tif (fal->size > act[p]->msize) {\n\t\t\tact[p]->msize = fal->size;\n\t\t}\n\n\t\tact[p]->nr_ini = fal->nr;\n\t\tact[p]->nr2    = fal->nr2;\n\t\tact[p]->fsize  = fal->size;\n\t\t/*\n\t\t * This is a known activity with a known format\n\t\t * (magical number). Only such activities will be displayed.\n\t\t * (Well, this may also be an unknown format if we have entered sadf -H.)\n\t\t */\n\t\tid_seq[j++] = fal->id;\n\t}\n\n\twhile (j < NR_ACT) {\n\t\tid_seq[j++] = 0;\n\t}\n\n\tfree(buffer);\n\n\t/* Check that at least one activity selected by the user is available in file */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!IS_SELECTED(act[i]->options))\n\t\t\tcontinue;\n\n\t\t/* Here is a selected activity: Does it exist in file? */\n\t\tfal = *file_actlst;\n\t\tfor (j = 0; j < file_hdr->sa_act_nr; j++, fal++) {\n\t\t\tif (act[i]->id == fal->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == file_hdr->sa_act_nr) {\n\t\t\t/* No: Unselect it */\n\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n\n\t/*\n\t * None of selected activities exist in file: Abort.\n\t * NB: Error is ignored if we only want to display\n\t * datafile header (sadf -H).\n\t */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES) && !DISPLAY_HDR_ONLY(flags)) {\n\t\tfprintf(stderr, _(\"Requested activities not available in file %s\\n\"),\n\t\t\tdfile);\n\t\tclose(*ifd);\n\t\texit(1);\n\t}\n\n\treturn;\n\nformat_error:\n\tif (buffer) {\n\t\tfree(buffer);\n\t}\n\thandle_invalid_sa_file(*ifd, file_magic, dfile, 0);\n}", "target": 1, "cwe": ["CWE-787"], "project": "sysstat", "commit_id": "edbf507678bf10914e9804ff8a06737fdcb2e781", "hash": 73943587436451678107290220056328750399, "size": 242, "message": "Fix #230: Memory corruption bug due to Integer Overflow in remap_struct()\n\n(See problem description in issue #230.)\nCheck that the number of fields (long long integers, long integers or\nintegers) as read from a system activity binary datafile multiplied by\nits alignment width doesn't overflow, i.e. the result must not be\nsmaller than the number of fields.\n\nReported-by: Ren Kimura\nSigned-off-by: Sebastien GODARD <sysstat@users.noreply.github.com>", "idx": 658}
{"func": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "linux", "commit_id": "6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91", "hash": 269104654433284809398730062468298853933, "size": 50, "message": "netfilter: x_tables: make sure e->next_offset covers remaining blob size\n\nOtherwise this function may read data beyond the ruleset blob.\n\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "idx": 659}
{"func": "s32 gf_media_avc_read_sps(const char *sps_data, u32 sps_size, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)\n{\n\tAVC_SPS *sps;\n\tu32 ChromaArrayType = 0;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\tGF_BitStream *bs;\n\tchar *sps_data_without_emulation_bytes = NULL;\n\tu32 sps_data_without_emulation_bytes_size = 0;\n\n\t/*SPS still contains emulation bytes*/\n\tsps_data_without_emulation_bytes = gf_malloc(sps_size*sizeof(char));\n\tsps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(sps_data, sps_data_without_emulation_bytes, sps_size);\n\tbs = gf_bs_new(sps_data_without_emulation_bytes, sps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t/*nal hdr*/ gf_bs_read_int(bs, 8);\n\n\tprofile_idc = gf_bs_read_int(bs, 8);\n\n\tpcomp = gf_bs_read_int(bs, 8);\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\tgoto exit;\n\n\tlevel_idc = gf_bs_read_int(bs, 8);\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = bs_get_ue(bs) + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif (sps_id >=32) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tif (sps_id < 0) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tchroma_format_idc = ChromaArrayType = 1;\n\tsps = &avc->sps[sps_id];\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\tgoto exit;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = bs_get_ue(bs);\n\t\tChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int(bs, 1);\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = bs_get_ue(bs);\n\t\tchroma_bd = bs_get_ue(bs);\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int(bs, 1);\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\tu32 k;\n\t\t\tfor (k=0; k<8; k++) {\n\t\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k<6 ? 16 : 64;\n\t\t\t\t\tfor (z=0; z<sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = bs_get_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = bs_get_ue(bs) + 4;\n\tsps->poc_type = bs_get_ue(bs);\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = bs_get_ue(bs) + 4;\n\t} else if(sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int(bs, 1);\n\t\tsps->offset_for_non_ref_pic = bs_get_se(bs);\n\t\tsps->offset_for_top_to_bottom_field = bs_get_se(bs);\n\t\tsps->poc_cycle_length = bs_get_ue(bs);\n\t\tfor(i=0; i<sps->poc_cycle_length; i++) sps->offset_for_ref_frame[i] = bs_get_se(bs);\n\t}\n\tif (sps->poc_type > 2) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tsps->max_num_ref_frames = bs_get_ue(bs); \n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int(bs, 1); \n\tmb_width = bs_get_ue(bs) + 1;\n\tmb_height= bs_get_ue(bs) + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int(bs, 1);\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2-sps->frame_mbs_only_flag) * mb_height * 16;\n\t\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 1); /*direct_8x8_inference_flag*/\n\t\n\tif (gf_bs_read_int(bs, 1)) { /*crop*/\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2, SubHeightC = 2;\n\t\t} else if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2, SubHeightC = 1;\n\t\t} else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1, SubHeightC = 1;\n\t\t}\n\n\t\tif (ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC==-1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2-sps->frame_mbs_only_flag;\n\t\t} else {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2-sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = bs_get_ue(bs); /*crop_left*/\n\t\tcr = bs_get_ue(bs); /*crop_right*/\n\t\tct = bs_get_ue(bs); /*crop_top*/\n\t\tcb = bs_get_ue(bs); /*crop_bottom*/\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t} \n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32) gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int(bs, 1);\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int(bs, 8);\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int(bs, 16); /*AR num*/\n\t\t\t\tsps->vui.par_den = gf_bs_read_int(bs, 16); /*AR den*/\n\t\t\t} else if (aspect_ratio_idc<14) {\n\t\t\t\tsps->vui.par_num = avc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif(sps->vui.overscan_info_present_flag)\t\t\n\t\t\tgf_bs_read_int(bs, 1);\t\t/* overscan_appropriate_flag */\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int(bs, 3);\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int(bs, 1);\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (sps->vui.colour_description_present_flag) { \n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int(bs, 8);  \n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int(bs, 8);  \n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int(bs, 8);  \n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int(bs, 1)) {\t/* chroma_location_info_present_flag */\n\t\t\tbs_get_ue(bs);\t\t\t\t/* chroma_sample_location_type_top_field */\n\t\t\tbs_get_ue(bs);\t\t\t\t/* chroma_sample_location_type_bottom_field */\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int(bs, 32);\n\t\t\tsps->vui.time_scale = gf_bs_read_int(bs, 32);\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int(bs, 1); \n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int(bs, 1);\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc==83) || (profile_idc==86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\t/*inter_layer_deblocking_filter_control_present_flag=*/\tgf_bs_read_int(bs, 1);\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int(bs, 2);\n\t\t\tif (ChromaArrayType == 1 || ChromaArrayType == 2) {\n\t\t\t\t/*chroma_phase_x_plus1_flag*/ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\tif( ChromaArrayType  ==  1 ) {\n\t\t\t\t/*chroma_phase_y_plus1*/ gf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif( ChromaArrayType > 0 ) {\n\t\t\t\t\t/*seq_ref_layer_chroma_phase_x_plus1_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t\t/*seq_ref_layer_chroma_phase_y_plus1*/gf_bs_read_int(bs, 2);\n\t\t\t\t}\n\t\t\t\t/*seq_scaled_ref_layer_left_offset*/ bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_top_offset*/bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_right_offset*/bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_bottom_offset*/bs_get_se(bs);\n\t\t\t}\n\t\t\tif (/*seq_tcoeff_level_prediction_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\t\t/*adaptive_tcoeff_level_prediction_flag*/ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\t/*slice_header_restriction_flag*/gf_bs_read_int(bs, 1);\n\n\t\t\t/*svc_vui_parameters_present*/\n\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\tu32 i, vui_ext_num_entries_minus1;\n\t\t\t\tvui_ext_num_entries_minus1 = bs_get_ue(bs);\n\n\t\t\t\tfor (i=0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\t/*u8 vui_ext_dependency_id =*/ gf_bs_read_int(bs, 3);\n\t\t\t\t\t/*u8 vui_ext_quality_id =*/ gf_bs_read_int(bs, 4);\n\t\t\t\t\t/*u8 vui_ext_temporal_id =*/ gf_bs_read_int(bs, 3);\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\t/*u32 vui_ext_num_units_in_tick = */gf_bs_read_int(bs, 32);\n\t\t\t\t\t\t/*u32 vui_ext_time_scale = */gf_bs_read_int(bs, 32);\n\t\t\t\t\t\t/*u8 vui_ext_fixed_frame_rate_flag = */gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif ( vui_ext_nal_hrd_parameters_present_flag ||  vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t/*vui_ext_low_delay_hrd_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\t/*vui_ext_pic_struct_present_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc==118) || (profile_idc==128)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] MVC not supported - skipping parsing end of Subset SPS\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\tgf_bs_del(bs);\n\tgf_free(sps_data_without_emulation_bytes);\n\treturn sps_id;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "gpac", "commit_id": "90dc7f853d31b0a4e9441cba97feccf36d8b69a4", "hash": 21241604308496262591204302336516846352, "size": 311, "message": "fix some exploitable overflows (#994, #997)", "idx": 660}
{"func": "*/\nstatic int send_client_reply_packet(MCPVIO_EXT *mpvio,\n                                    const uchar *data, int data_len)\n{\n  MYSQL *mysql= mpvio->mysql;\n  NET *net= &mysql->net;\n  char *buff, *end;\n  size_t buff_size;\n  size_t connect_attrs_len=\n    (mysql->server_capabilities & CLIENT_CONNECT_ATTRS &&\n     mysql->options.extension) ?\n    mysql->options.extension->connection_attributes_length : 0;\n\n  DBUG_ASSERT(connect_attrs_len < MAX_CONNECTION_ATTR_STORAGE_LENGTH);\n\n  \n  /*\n    see end= buff+32 below, fixed size of the packet is 32 bytes.\n     +9 because data is a length encoded binary where meta data size is max 9.\n  */\n  buff_size= 33 + USERNAME_LENGTH + data_len + 9 + NAME_LEN + NAME_LEN + connect_attrs_len + 9;\n  buff= my_alloca(buff_size);\n\n  mysql->client_flag|= mysql->options.client_flag;\n  mysql->client_flag|= CLIENT_CAPABILITIES;\n\n  if (mysql->client_flag & CLIENT_MULTI_STATEMENTS)\n    mysql->client_flag|= CLIENT_MULTI_RESULTS;\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (mysql->options.ssl_key || mysql->options.ssl_cert ||\n      mysql->options.ssl_ca || mysql->options.ssl_capath ||\n      mysql->options.ssl_cipher ||\n      (mysql->options.extension && mysql->options.extension->ssl_crl) || \n      (mysql->options.extension && mysql->options.extension->ssl_crlpath))\n    mysql->options.use_ssl= 1;\n  if (mysql->options.use_ssl)\n    mysql->client_flag|= CLIENT_SSL;\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY*/\n  if (mpvio->db)\n    mysql->client_flag|= CLIENT_CONNECT_WITH_DB;\n  else\n    mysql->client_flag&= ~CLIENT_CONNECT_WITH_DB;\n\n  /* Remove options that server doesn't support */\n  mysql->client_flag= mysql->client_flag &\n                       (~(CLIENT_COMPRESS | CLIENT_SSL | CLIENT_PROTOCOL_41) \n                       | mysql->server_capabilities);\n\n#ifndef HAVE_COMPRESS\n  mysql->client_flag&= ~CLIENT_COMPRESS;\n#endif\n\n  if (mysql->client_flag & CLIENT_PROTOCOL_41)\n  {\n    /* 4.1 server and 4.1 client has a 32 byte option flag */\n    int4store(buff,mysql->client_flag);\n    int4store(buff+4, net->max_packet_size);\n    buff[8]= (char) mysql->charset->number;\n    memset(buff+9, 0, 32-9);\n    end= buff+32;\n  }\n  else\n  {\n    int2store(buff, mysql->client_flag);\n    int3store(buff+2, net->max_packet_size);\n    end= buff+5;\n  }\n#ifdef HAVE_OPENSSL\n  if (mysql->client_flag & CLIENT_SSL)\n  {\n    /* Do the SSL layering. */\n    struct st_mysql_options *options= &mysql->options;\n    struct st_VioSSLFd *ssl_fd;\n    enum enum_ssl_init_error ssl_init_error;\n    const char *cert_error;\n    unsigned long ssl_error;\n\n    /*\n      Send mysql->client_flag, max_packet_size - unencrypted otherwise\n      the server does not know we want to do SSL\n    */\n    MYSQL_TRACE(SEND_SSL_REQUEST, mysql, (end - buff, (const unsigned char*)buff));\n    if (my_net_write(net, (uchar*)buff, (size_t) (end-buff)) || net_flush(net))\n    {\n      set_mysql_extended_error(mysql, CR_SERVER_LOST, unknown_sqlstate,\n                               ER(CR_SERVER_LOST_EXTENDED),\n                               \"sending connection information to server\",\n                               errno);\n      goto error;\n    }\n\n    MYSQL_TRACE_STAGE(mysql, SSL_NEGOTIATION);\n\n    /* Create the VioSSLConnectorFd - init SSL and load certs */\n    if (!(ssl_fd= new_VioSSLConnectorFd(options->ssl_key,\n                                        options->ssl_cert,\n                                        options->ssl_ca,\n                                        options->ssl_capath,\n                                        options->ssl_cipher,\n                                        &ssl_init_error,\n                                        options->extension ? \n                                        options->extension->ssl_crl : NULL,\n                                        options->extension ? \n                                        options->extension->ssl_crlpath : NULL)))\n    {\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR), sslGetErrString(ssl_init_error));\n      goto error;\n    }\n    mysql->connector_fd= (unsigned char *) ssl_fd;\n\n    /* Connect to the server */\n    DBUG_PRINT(\"info\", (\"IO layer change in progress...\"));\n    MYSQL_TRACE(SSL_CONNECT, mysql, ());\n    if (sslconnect(ssl_fd, net->vio,\n                   (long) (mysql->options.connect_timeout), &ssl_error))\n    {    \n      char buf[512];\n      ERR_error_string_n(ssl_error, buf, 512);\n      buf[511]= 0;\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR),\n                               buf);\n      goto error;\n    }    \n    DBUG_PRINT(\"info\", (\"IO layer change done!\"));\n\n    /* Verify server cert */\n    if ((mysql->client_flag & CLIENT_SSL_VERIFY_SERVER_CERT) &&\n        ssl_verify_server_cert(net->vio, mysql->host, &cert_error))\n    {\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR), cert_error);\n      goto error;\n    }\n\n    MYSQL_TRACE(SSL_CONNECTED, mysql, ());\n    MYSQL_TRACE_STAGE(mysql, AUTHENTICATE);\n  }\n#endif /* HAVE_OPENSSL */\n\n  DBUG_PRINT(\"info\",(\"Server version = '%s'  capabilites: %lu  status: %u  client_flag: %lu\",\n\t\t     mysql->server_version, mysql->server_capabilities,\n\t\t     mysql->server_status, mysql->client_flag));\n\n  compile_time_assert(MYSQL_USERNAME_LENGTH == USERNAME_LENGTH);\n\n  /* This needs to be changed as it's not useful with big packets */\n  if (mysql->user[0])\n    strmake(end, mysql->user, USERNAME_LENGTH);\n  else\n    read_user_name(end);\n\n  /* We have to handle different version of handshake here */\n  DBUG_PRINT(\"info\",(\"user: %s\",end));\n  end= strend(end) + 1;\n  if (data_len)\n  {\n    if (mysql->server_capabilities & CLIENT_SECURE_CONNECTION)\n    {\n      /* \n        Since the older versions of server do not have\n        CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA capability,\n        a check is performed on this before sending auth data.\n        If lenenc support is not available, the data is sent\n        in the format of first byte representing the length of\n        the string followed by the actual string.\n      */\n      if (mysql->server_capabilities & CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA)\n        end= write_length_encoded_string4(end, (char *)(buff + buff_size),\n                                         (char *) data,\n                                         (char *)(data + data_len));\n      else\n        end= write_string(end, (char *)(buff + buff_size),\n                         (char *) data,\n                         (char *)(data + data_len));\n      if (end == NULL)\n        goto error;\n    }\n    else\n    {\n      DBUG_ASSERT(data_len == SCRAMBLE_LENGTH_323 + 1); /* incl. \\0 at the end */\n      memcpy(end, data, data_len);\n      end+= data_len;\n    }\n  }\n  else\n    *end++= 0;\n\n  /* Add database if needed */\n  if (mpvio->db && (mysql->server_capabilities & CLIENT_CONNECT_WITH_DB))\n  {\n    end= strmake(end, mpvio->db, NAME_LEN) + 1;\n    mysql->db= my_strdup(key_memory_MYSQL,\n                         mpvio->db, MYF(MY_WME));\n  }\n\n  if (mysql->server_capabilities & CLIENT_PLUGIN_AUTH)\n    end= strmake(end, mpvio->plugin->name, NAME_LEN) + 1;\n\n  end= (char *) send_client_connect_attrs(mysql, (uchar *) end);\n\n  /* Write authentication package */\n  MYSQL_TRACE(SEND_AUTH_RESPONSE, mysql, (end-buff, (const unsigned char*)buff));\n  if (my_net_write(net, (uchar*) buff, (size_t) (end-buff)) || net_flush(net))\n  {\n    set_mysql_extended_error(mysql, CR_SERVER_LOST, unknown_sqlstate,\n                             ER(CR_SERVER_LOST_EXTENDED),\n                             \"sending authentication information\",\n                             errno);\n    goto error;\n  }\n  MYSQL_TRACE(PACKET_SENT, mysql, (end-buff));\n  my_afree(buff);\n  return 0;\n  \nerror:\n  my_afree(buff);\n  return 1;", "target": 1, "cwe": ["CWE-284", "CWE-295"], "project": "mysql-server", "commit_id": "3bd5589e1a5a93f9c224badf983cd65c45215390", "hash": 87125330563843705774515810645844245186, "size": 220, "message": "WL#6791 : Redefine client --ssl option to imply enforced encryption\n\n# Changed the meaning of the --ssl=1 option of all client binaries\nto mean force ssl, not try ssl and fail over to eunecrypted\n# Added a new MYSQL_OPT_SSL_ENFORCE mysql_options()\noption to specify that an ssl connection is required.\n# Added a new macro SSL_SET_OPTIONS() to the client\nSSL handling headers that sets all the relevant SSL options at \nonce.\n# Revamped all of the current native clients to use the new macro\n# Removed some Windows line endings.\n# Added proper handling of the new option into the ssl helper\nheaders.\n# If SSL is mandatory assume that the media is secure enough \nfor the sha256 plugin to do unencrypted password exchange even\nbefore establishing a connection.\n# Set the default ssl cipher to DHE-RSA-AES256-SHA if none is \nspecified.\n# updated test cases that require a non-default cipher to spawn \na mysql command line tool binary since mysqltest has no support\nfor specifying ciphers.\n# updated the replication slave connection code to always enforce\nSSL if any of the SSL config options is present.\n# test cases added and updated.\n# added a mysql_get_option() API to return mysql_options() \nvalues. Used the new API inside the sha256 plugin.\n# Fixed compilation warnings because of unused variables.\n# Fixed test failures (mysql_ssl and bug13115401)\n# Fixed whitespace issues.\n# Fully implemented the mysql_get_option() function.\n# Added a test case for mysql_get_option()\n# fixed some trailing whitespace issues\n# fixed some uint/int warnings in mysql_client_test.c\n# removed shared memory option from non-windows get_options\n tests\n# moved MYSQL_OPT_LOCAL_INFILE to the uint options", "idx": 661}
{"func": "R_API int r_socket_block_time (RSocket *s, int block, int sec, int usec) {\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-78"], "project": "radare2", "commit_id": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9", "hash": 190401134457476355028995502435346726820, "size": 3, "message": "Fix command injection on PDB download (#16966)\n\n* Fix r_sys_mkdirp with absolute path on Windows\r\n* Fix build with --with-openssl\r\n* Use RBuffer in r_socket_http_answer()\r\n* r_socket_http_answer: Fix read for big responses\r\n* Implement r_str_escape_sh()\r\n* Cleanup r_socket_connect() on Windows\r\n* Fix socket being created without a protocol\r\n* Fix socket connect with SSL ##socket\r\n* Use select() in r_socket_ready()\r\n* Fix read failing if received only protocol answer\r\n* Fix double-free\r\n* r_socket_http_get: Fail if req. SSL with no support\r\n* Follow redirects in r_socket_http_answer()\r\n* Fix r_socket_http_get result length with R2_CURL=1\r\n* Also follow redirects\r\n* Avoid using curl for downloading PDBs\r\n* Use r_socket_http_get() on UNIXs\r\n* Use WinINet API on Windows for r_socket_http_get()\r\n* Fix command injection\r\n* Fix r_sys_cmd_str_full output for binary data\r\n* Validate GUID on PDB download\r\n* Pass depth to socket_http_get_recursive()\r\n* Remove 'r_' and '__' from static function names\r\n* Fix is_valid_guid\r\n* Fix for comments", "idx": 662}
{"func": "static char *get_pid_environ_val(pid_t pid,char *val){\n  int temp_size = 500;\n  char *temp = malloc(temp_size);\n  \n  int i=0;\n  int foundit=0;\n  FILE *fp;\n\n  sprintf(temp,\"/proc/%d/environ\",pid);\n\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n\n  \n  for(;;){\n    \n    if (i >= temp_size) {\n      temp_size *= 2;\n      temp = realloc(temp, temp_size);\n    }\n      \n    temp[i]=fgetc(fp);    \n\n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "das_watchdog", "commit_id": "bd20bb02e75e2c0483832b52f2577253febfb690", "hash": 266256142573941520290650182862084246665, "size": 52, "message": "Fix memory overflow if the name of an environment is larger than 500 characters. Bug found by Adam Sampson.", "idx": 663}
{"func": "DECLAREcpFunc(cpContig2SeparateByRow)\n{\n\ttsize_t scanlinesizein = TIFFScanlineSize(in);\n\ttsize_t scanlinesizeout = TIFFScanlineSize(out);\n\ttdata_t inbuf;\n\ttdata_t outbuf;\n\tregister uint8 *inp, *outp;\n\tregister uint32 n;\n\tuint32 row;\n\ttsample_t s;\n\n\tinbuf = _TIFFmalloc(scanlinesizein);\n\toutbuf = _TIFFmalloc(scanlinesizeout);\n\tif (!inbuf || !outbuf)\n\t\tgoto bad;\n\t_TIFFmemset(inbuf, 0, scanlinesizein);\n\t_TIFFmemset(outbuf, 0, scanlinesizeout);\n\t/* unpack channels */\n\tfor (s = 0; s < spp; s++) {\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tinp = ((uint8*)inbuf) + s;\n\t\t\toutp = (uint8*)outbuf;\n\t\t\tfor (n = imagewidth; n-- > 0;) {\n\t\t\t\t*outp++ = *inp;\n\t\t\t\tinp += spp;\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, s) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 1;\nbad:\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "libtiff", "commit_id": "5c080298d59efa53264d7248bbe3a04660db6ef7", "hash": 125983744713426331598427924996443152104, "size": 49, "message": "* tools/tiffcp.c: error out cleanly in cpContig2SeparateByRow and\ncpSeparate2ContigByRow if BitsPerSample != 8 to avoid heap based overflow.\nFixes http://bugzilla.maptools.org/show_bug.cgi?id=2656 and\nhttp://bugzilla.maptools.org/show_bug.cgi?id=2657", "idx": 664}
{"func": "set_unused_field_bp(unsigned char *bp, int from, int to)\n{\n\tmemset(bp + from, 0, to - from + 1);\n}", "target": 0, "cwe": ["CWE-190"], "project": "libarchive", "commit_id": "3014e19820ea53c15c90f9d447ca3e668a0b76c6", "hash": 21595770835865045417930294580904968877, "size": 4, "message": "Issue 711:  Be more careful about verifying filename lengths when writing ISO9660 archives\n\n* Don't cast size_t to int, since this can lead to overflow\n  on machines where sizeof(int) < sizeof(size_t)\n* Check a + b > limit by writing it as\n    a > limit || b > limit || a + b > limit\n  to avoid problems when a + b wraps around.", "idx": 665}
{"func": "static int ntop_check_profile_syntax(lua_State* vm) {\n  char *filter;\n  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);\n  NetworkInterface *iface = ntop_interface->getFirst();\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  filter = (char*)lua_tostring(vm, 1);\n\n  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);\n\n  return(CONST_LUA_OK);\n}", "target": 0, "cwe": ["CWE-254"], "project": "ntopng", "commit_id": "2e0620be3410f5e22c9aa47e261bc5a12be692c6", "hash": 200091932685835225544102310521674704916, "size": 14, "message": "Added security fix to avoid escalating privileges to non-privileged users\nMany thanks to Dolev Farhi for reporting it", "idx": 666}
{"func": "void WebContents::IncrementCapturerCount(gin::Arguments* args) {\n  gfx::Size size;\n  bool stay_hidden = false;\n  bool stay_awake = false;\n\n  // get size arguments if they exist\n  args->GetNext(&size);\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n  // get stayAwake arguments if they exist\n  args->GetNext(&stay_awake);\n\n  ignore_result(\n      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));\n}", "target": 0, "cwe": [], "project": "electron", "commit_id": "ea1f402417022c59c0794e97c87e6be2553989e7", "hash": 211391752042065665942619192271469891036, "size": 15, "message": "fix: ensure ElectronBrowser mojo service is only bound to appropriate render frames (#33323) (#33350)\n\n* fix: ensure ElectronBrowser mojo service is only bound to authorized render frames\r\n\r\nNotes: no-notes\r\n\r\n* refactor: extract electron API IPC to its own mojo interface\r\n\r\n* fix: just check main frame not primary main frame", "idx": 667}
{"func": "f_assert_fails(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*cmd;\n    garray_T\tga;\n    int\t\tsave_trylevel = trylevel;\n    int\t\tcalled_emsg_before = called_emsg;\n    char\t*wrong_arg_msg = NULL;\n\n    if (check_for_string_or_number_arg(argvars, 0) == FAIL\n\t    || check_for_opt_string_or_list_arg(argvars, 1) == FAIL\n\t    || (argvars[1].v_type != VAR_UNKNOWN\n\t\t&& (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_number_arg(argvars, 3) == FAIL\n\t\t\t|| (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_string_arg(argvars, 4) == FAIL)))))\n\treturn;\n\n    cmd = tv_get_string_chk(&argvars[0]);\n\n    // trylevel must be zero for a \":throw\" command to be considered failed\n    trylevel = 0;\n    suppress_errthrow = TRUE;\n    in_assert_fails = TRUE;\n\n    do_cmdline_cmd(cmd);\n    if (called_emsg == called_emsg_before)\n    {\n\tprepare_assert_error(&ga);\n\tga_concat(&ga, (char_u *)\"command did not fail: \");\n\tassert_append_cmd_or_arg(&ga, argvars, cmd);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n    else if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tchar_u\tbuf[NUMBUFLEN];\n\tchar_u\t*expected;\n\tchar_u\t*expected_str = NULL;\n\tint\terror_found = FALSE;\n\tint\terror_found_index = 1;\n\tchar_u\t*actual = emsg_assert_fails_msg == NULL ? (char_u *)\"[unknown]\"\n\t\t\t\t\t\t       : emsg_assert_fails_msg;\n\n\tif (argvars[1].v_type == VAR_STRING)\n\t{\n\t    expected = tv_get_string_buf_chk(&argvars[1], buf);\n\t    error_found = expected == NULL\n\t\t\t   || strstr((char *)actual, (char *)expected) == NULL;\n\t}\n\telse if (argvars[1].v_type == VAR_LIST)\n\t{\n\t    list_T\t*list = argvars[1].vval.v_list;\n\t    typval_T\t*tv;\n\n\t    if (list == NULL || list->lv_len < 1 || list->lv_len > 2)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_second_arg;\n\t\tgoto theend;\n\t    }\n\t    CHECK_LIST_MATERIALIZE(list);\n\t    tv = &list->lv_first->li_tv;\n\t    expected = tv_get_string_buf_chk(tv, buf);\n\t    if (!pattern_match(expected, actual, FALSE))\n\t    {\n\t\terror_found = TRUE;\n\t\texpected_str = expected;\n\t    }\n\t    else if (list->lv_len == 2)\n\t    {\n\t\ttv = &list->lv_u.mat.lv_last->li_tv;\n\t\tactual = get_vim_var_str(VV_ERRMSG);\n\t\texpected = tv_get_string_buf_chk(tv, buf);\n\t\tif (!pattern_match(expected, actual, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    expected_str = expected;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    wrong_arg_msg = e_assert_fails_second_arg;\n\t    goto theend;\n\t}\n\n\tif (!error_found && argvars[2].v_type != VAR_UNKNOWN\n\t\t&& argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    if (argvars[3].v_type != VAR_NUMBER)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_fourth_argument;\n\t\tgoto theend;\n\t    }\n\t    else if (argvars[3].vval.v_number >= 0\n\t\t\t && argvars[3].vval.v_number != emsg_assert_fails_lnum)\n\t    {\n\t\terror_found = TRUE;\n\t\terror_found_index = 3;\n\t    }\n\t    if (!error_found && argvars[4].v_type != VAR_UNKNOWN)\n\t    {\n\t\tif (argvars[4].v_type != VAR_STRING)\n\t\t{\n\t\t    wrong_arg_msg = e_assert_fails_fifth_argument;\n\t\t    goto theend;\n\t\t}\n\t\telse if (argvars[4].vval.v_string != NULL\n\t\t    && !pattern_match(argvars[4].vval.v_string,\n\t\t\t\t\t     emsg_assert_fails_context, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    error_found_index = 4;\n\t\t}\n\t    }\n\t}\n\n\tif (error_found)\n\t{\n\t    typval_T actual_tv;\n\n\t    prepare_assert_error(&ga);\n\t    if (error_found_index == 3)\n\t    {\n\t\tactual_tv.v_type = VAR_NUMBER;\n\t\tactual_tv.vval.v_number = emsg_assert_fails_lnum;\n\t    }\n\t    else if (error_found_index == 4)\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = emsg_assert_fails_context;\n\t    }\n\t    else\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = actual;\n\t    }\n\t    fill_assert_error(&ga, &argvars[2], expected_str,\n\t\t\t&argvars[error_found_index], &actual_tv, ASSERT_OTHER);\n\t    ga_concat(&ga, (char_u *)\": \");\n\t    assert_append_cmd_or_arg(&ga, argvars, cmd);\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    rettv->vval.v_number = 1;\n\t}\n    }\n\ntheend:\n    trylevel = save_trylevel;\n    suppress_errthrow = FALSE;\n    in_assert_fails = FALSE;\n    did_emsg = FALSE;\n    got_int = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    msg_scrolled = 0;\n    lines_left = Rows;\n    VIM_CLEAR(emsg_assert_fails_msg);\n    set_vim_var_string(VV_ERRMSG, NULL, 0);\n    if (wrong_arg_msg != NULL)\n\temsg(_(wrong_arg_msg));\n}", "target": 1, "cwe": ["CWE-416"], "project": "vim", "commit_id": "249e1b903a9c0460d618f6dcc59aeb8c03b24b20", "hash": 51898859643219304264539733358305123992, "size": 163, "message": "patch 9.0.0213: using freed memory with error in assert argument\n\nProblem:    Using freed memory with error in assert argument.\nSolution:   Make a copy of the error.", "idx": 668}
{"func": "static void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32)) {\n\t\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile (i < npages) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}", "target": 1, "cwe": ["CWE-125"], "project": "linux", "commit_id": "a66477b0efe511d98dde3e4aaeb189790e6f0a39", "hash": 48976220653008913683960405836814580290, "size": 112, "message": "drm/ttm: fix out-of-bounds read in ttm_put_pages() v2\n\nWhen ttm_put_pages() tries to figure out whether it's dealing with\ntransparent hugepages, it just reads past the bounds of the pages array\nwithout a check.\n\nv2: simplify the test if enough pages are left in the array (Christian).\n\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Christian König <christian.koenig@amd.com>\nFixes: 5c42c64f7d54 (\"drm/ttm: fix the fix for huge compound pages\")\nCc: stable@vger.kernel.org\nReviewed-by: Michel Dänzer <michel.daenzer@amd.com>\nReviewed-by: Junwei Zhang <Jerry.Zhang@amd.com>\nReviewed-by: Huang Rui <ray.huang@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>", "idx": 669}
{"func": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 0, "cwe": ["CWE-476", "CWE-119"], "project": "libgit2", "commit_id": "2fdef641fd0dd2828bd948234ae86de75221a11a", "hash": 16158530877760215512241611571190018370, "size": 53, "message": "smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.", "idx": 670}
{"func": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\n\tRETURN_TRUE;\n}", "target": 1, "cwe": ["CWE-125"], "project": "php-src", "commit_id": "97eff7eb57fc2320c267a949cffd622c38712484", "hash": 335689454883955903250589188063313909420, "size": 23, "message": "Fix bug #72241: get_icu_value_internal out-of-bounds read", "idx": 671}
{"func": "static int __kprobes notifier_call_chain(struct notifier_block **nl,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference(*nl);\n\twhile (nb) {\n\t\tnext_nb = rcu_dereference(nb->next);\n\t\tret = nb->notifier_call(nb, val, v);\n\t\tif ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t}\n\treturn ret;\n}", "target": 0, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "9926e4c74300c4b31dee007298c6475d33369df0", "hash": 267755464566175358524527729199595519751, "size": 16, "message": "CPU time limit patch / setrlimit(RLIMIT_CPU, 0) cheat fix\n\nAs discovered here today, the change in Kernel 2.6.17 intended to inhibit\nusers from setting RLIMIT_CPU to 0 (as that is equivalent to unlimited) by\n\"cheating\" and setting it to 1 in such a case, does not make a difference,\nas the check is done in the wrong place (too late), and only applies to the\nprofiling code.\n\nOn all systems I checked running kernels above 2.6.17, no matter what the\nhard and soft CPU time limits were before, a user could escape them by\nissuing in the shell (sh/bash/zsh) \"ulimit -t 0\", and then the user's\nprocess was not ever killed.\n\nAttached is a trivial patch to fix that.  Simply moving the check to a\nslightly earlier location (specifically, before the line that actually\nassigns the limit - *old_rlim = new_rlim), does the trick.\n\nDo note that at least the zsh (but not ash, dash, or bash) shell has the\nproblem of \"caching\" the limits set by the ulimit command, so when running\nzsh the fix will not immediately be evident - after entering \"ulimit -t 0\",\n\"ulimit -a\" will show \"-t: cpu time (seconds) 0\", even though the actual\nlimit as returned by getrlimit(...) will be 1.  It can be verified by\nopening a subshell (which will not have the values of the parent shell in\ncache) and checking in it, or just by running a CPU intensive command like\n\"echo '65536^1048576' | bc\" and verifying that it dumps core after one\nsecond.\n\nRegardless of whether that is a misfeature in the shell, perhaps it would\nbe better to return -EINVAL from setrlimit in such a case instead of\ncheating and setting to 1, as that does not really reflect the actual state\nof the process anymore.  I do not however know what the ground for that\ndecision was in the original 2.6.17 change, and whether there would be any\n\"backward\" compatibility issues, so I preferred not to touch that right\nnow.\n\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 672}
{"func": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux", "commit_id": "0da9dfdd2cd9889201bc6f6f43580c99165cd087", "hash": 229422052620087086813145012122323183347, "size": 83, "message": "keys: fix race with concurrent install_user_keyrings()\n\nThis fixes CVE-2013-1792.\n\nThere is a race in install_user_keyrings() that can cause a NULL pointer\ndereference when called concurrently for the same user if the uid and\nuid-session keyrings are not yet created.  It might be possible for an\nunprivileged user to trigger this by calling keyctl() from userspace in\nparallel immediately after logging in.\n\nAssume that we have two threads both executing lookup_user_key(), both\nlooking for KEY_SPEC_USER_SESSION_KEYRING.\n\n\tTHREAD A\t\t\tTHREAD B\n\t===============================\t===============================\n\t\t\t\t\t==>call install_user_keyrings();\n\tif (!cred->user->session_keyring)\n\t==>call install_user_keyrings()\n\t\t\t\t\t...\n\t\t\t\t\tuser->uid_keyring = uid_keyring;\n\tif (user->uid_keyring)\n\t\treturn 0;\n\t<==\n\tkey = cred->user->session_keyring [== NULL]\n\t\t\t\t\tuser->session_keyring = session_keyring;\n\tatomic_inc(&key->usage); [oops]\n\nAt the point thread A dereferences cred->user->session_keyring, thread B\nhasn't updated user->session_keyring yet, but thread A assumes it is\npopulated because install_user_keyrings() returned ok.\n\nThe race window is really small but can be exploited if, for example,\nthread B is interrupted or preempted after initializing uid_keyring, but\nbefore doing setting session_keyring.\n\nThis couldn't be reproduced on a stock kernel.  However, after placing\nsystemtap probe on 'user->session_keyring = session_keyring;' that\nintroduced some delay, the kernel could be crashed reliably.\n\nFix this by checking both pointers before deciding whether to return.\nAlternatively, the test could be done away with entirely as it is checked\ninside the mutex - but since the mutex is global, that may not be the best\nway.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nReported-by: Mateusz Guzik <mguzik@redhat.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: James Morris <james.l.morris@oracle.com>", "idx": 673}
{"func": "ex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = p_ic;\n\t    p = ml_get_curline();\n\t    if (vim_regexec(&regmatch, p, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);\n\t    else\n\t\temsg(_(e_nomatch));\n\t    vim_regfree(regmatch.regprog);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}", "target": 1, "cwe": ["CWE-416"], "project": "vim", "commit_id": "e031fe90cf2e375ce861ff5e5e281e4ad229ebb9", "hash": 248522548650268829622828572187932737898, "size": 36, "message": "patch 8.2.3741: using freed memory in open command\n\nProblem:    Using freed memory in open command.\nSolution:   Make a copy of the current line.", "idx": 674}
{"func": "int32 MkvWriter::Position(int64 position) {\n  if (!file_)\n    return -1;\n\n#ifdef _MSC_VER\n  return _fseeki64(file_, position, SEEK_SET);\n#else\n  return fseeko(file_, static_cast<off_t>(position), SEEK_SET);\n#endif\n}", "target": 1, "cwe": ["CWE-20"], "project": "libvpx", "commit_id": "f00890eecdf8365ea125ac16769a83aa6b68792d", "hash": 108108903007906788771380888714609633340, "size": 10, "message": "update libwebm to libwebm-1.0.0.27-352-g6ab9fcf\n\nhttps://chromium.googlesource.com/webm/libwebm/+log/af81f26..6ab9fcf\n\nChange-Id: I9d56e1fbaba9b96404b4fbabefddc1a85b79c25d", "idx": 675}
{"func": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\tu32 dst = insn->dst_reg;\n\tint ret;\n\n\tif (insn_bitness == 32) {\n\t\t/* Relevant for 32-bit RSH: Information can propagate towards\n\t\t * LSB, so it isn't sufficient to only truncate the output to\n\t\t * 32 bits.\n\t\t */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tif ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (!src_known &&\n\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tret = sanitize_val_alu(env, insn);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tscalar_min_max_add(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tret = sanitize_val_alu(env, insn);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tscalar_min_max_sub(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tscalar_min_max_mul(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_and(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_or(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_lsh(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_rsh(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_ARSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_arsh(dst_reg, &src_reg, insn_bitness);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t}\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}", "target": 0, "cwe": [], "project": "linux", "commit_id": "294f2fc6da27620a506e6c050241655459ccd6bd", "hash": 201029413509759936437749590618667202456, "size": 126, "message": "bpf: Verifer, adjust_scalar_min_max_vals to always call update_reg_bounds()\n\nCurrently, for all op verification we call __red_deduce_bounds() and\n__red_bound_offset() but we only call __update_reg_bounds() in bitwise\nops. However, we could benefit from calling __update_reg_bounds() in\nBPF_ADD, BPF_SUB, and BPF_MUL cases as well.\n\nFor example, a register with state 'R1_w=invP0' when we subtract from\nit,\n\n w1 -= 2\n\nBefore coerce we will now have an smin_value=S64_MIN, smax_value=U64_MAX\nand unsigned bounds umin_value=0, umax_value=U64_MAX. These will then\nbe clamped to S32_MIN, U32_MAX values by coerce in the case of alu32 op\nas done in above example. However tnum will be a constant because the\nALU op is done on a constant.\n\nWithout update_reg_bounds() we have a scenario where tnum is a const\nbut our unsigned bounds do not reflect this. By calling update_reg_bounds\nafter coerce to 32bit we further refine the umin_value to U64_MAX in the\nalu64 case or U32_MAX in the alu32 case above.\n\nSigned-off-by: John Fastabend <john.fastabend@gmail.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nLink: https://lore.kernel.org/bpf/158507151689.15666.566796274289413203.stgit@john-Precision-5820-Tower", "idx": 676}
{"func": "free_key_ctx (struct key_ctx *ctx)\n{\n  if (ctx->cipher)\n    {\n      cipher_ctx_cleanup(ctx->cipher);\n      free(ctx->cipher);\n      ctx->cipher = NULL;\n    }\n  if (ctx->hmac)\n    {\n      hmac_ctx_cleanup(ctx->hmac);\n      free(ctx->hmac);\n      ctx->hmac = NULL;\n    }\n}", "target": 0, "cwe": ["CWE-200"], "project": "openvpn", "commit_id": "11d21349a4e7e38a025849479b36ace7c2eec2ee", "hash": 50549365373884871895088499624071080654, "size": 15, "message": "Use constant time memcmp when comparing HMACs in openvpn_decrypt.\n\nSigned-off-by: Steffan Karger <steffan.karger@fox-it.com>\nAcked-by: Gert Doering <gert@greenie.muc.de>\nSigned-off-by: Gert Doering <gert@greenie.muc.de>", "idx": 677}
{"func": "main (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  cleanup_free char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, &argv);\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\"Creating root mount point\\n\"));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user\");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\"/proc\", O_RDONLY | O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\"Can't open /proc\");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n     We first try in /run, and if that fails, try in /tmp. */\n  base_path = xasprintf (\"/run/user/%d/.bubblewrap\", real_uid);\n  if (mkdir (base_path, 0755) && errno != EEXIST)\n    {\n      free (base_path);\n      base_path = xasprintf (\"/tmp/.bubblewrap-%d\", real_uid);\n      if (mkdir (base_path, 0755) && errno != EEXIST)\n        die_with_error (\"Creating root mountpoint failed\");\n    }\n\n  __debug__ ((\"creating new namespace\\n\"));\n\n  if (opt_unshare_pid)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\"/proc/self/ns/cgroup\", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs ();\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);\n          size_t len = strlen (output);\n          if (write (opt_info_fd, output, len) != len)\n            die_with_error (\"Write to info_fd\");\n          close (opt_info_fd);\n        }\n\n      monitor_child (event_fd);\n      exit (0); /* Should not be reached, but better safe... */\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net && loopback_setup () != 0)\n    die (\"Can't create loopback device\");\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n  /* We create a subdir \"$base_path/newroot\" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n\n  if (mkdir (\"newroot\", 0755))\n    die_with_error (\"Creating newroot failed\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs ();\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid))\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* Now make /newroot the real root */\n  if (chdir (\"/newroot\") != 0)\n    die_with_error (\"chdir newroot\");\n  if (chroot (\"/newroot\") != 0)\n    die_with_error (\"chroot /newroot\");\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir /\");\n\n  /* All privileged ops are done now, so drop it */\n  drop_privs ();\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      read (opt_block_fd, b, 1);\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      cleanup_free char *seccomp_data = NULL;\n      size_t seccomp_len;\n      struct sock_fprog prog;\n\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\"Can't read seccomp data\");\n\n      if (seccomp_len % 8 != 0)\n        die (\"Invalid seccomp data, must be multiple of 8\");\n\n      prog.len = seccomp_len / 8;\n      prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n\n      if (prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) != 0)\n        die_with_error (\"prctl(PR_SET_SECCOMP)\");\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  __debug__ ((\"forking for child\\n\"));\n\n  if (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1)\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid);\n        }\n    }\n\n  __debug__ ((\"launch executable %s\\n\", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  if (opt_sync_fd != -1)\n    close (opt_sync_fd);\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\"label_exec %s\", argv[0]);\n\n  if (execvp (argv[0], argv) == -1)\n    die_with_error (\"execvp %s\", argv[0]);\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-20", "CWE-703"], "project": "bubblewrap", "commit_id": "d7fc532c42f0e9bf427923bab85433282b3e5117", "hash": 156421971494626779959555607056575520724, "size": 493, "message": "Call setsid() before executing sandboxed code (CVE-2017-5226)\n\nThis prevents the sandboxed code from getting a controlling tty,\nwhich in turn prevents it from accessing the TIOCSTI ioctl and hence\nfaking terminal input.\n\nFixes: #142\n\nCloses: #143\nApproved by: cgwalters", "idx": 678}
{"func": "u_save_line(undoline_T *ul, linenr_T lnum)\n{\n    char_u *line = ml_get(lnum);\n\n    if (curbuf->b_ml.ml_line_len == 0)\n    {\n\tul->ul_len = 1;\n\tul->ul_line = vim_strsave((char_u *)\"\");\n    }\n    else\n    {\n\t// This uses the length in the memline, thus text properties are\n\t// included.\n\tul->ul_len = curbuf->b_ml.ml_line_len;\n\tul->ul_line = vim_memsave(line, ul->ul_len);\n    }\n    return ul->ul_line == NULL ? FAIL : OK;\n}", "target": 0, "cwe": ["CWE-125", "CWE-787"], "project": "vim", "commit_id": "8d02ce1ed75d008c34a5c9aaa51b67cbb9d33baa", "hash": 312068254296854816130862396941844277886, "size": 18, "message": "patch 8.2.4217: illegal memory access when undo makes Visual area invalid\n\nProblem:    Illegal memory access when undo makes Visual area invalid.\nSolution:   Correct the Visual area after undo.", "idx": 679}
{"func": "aiff_read_header (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt)\n{\tSSND_CHUNK\tssnd_fmt ;\n\tAIFF_PRIVATE *paiff ;\n\tBUF_UNION\tubuf ;\n\tuint32_t\tchunk_size = 0, FORMsize, SSNDsize, bytesread, mark_count = 0 ;\n\tint\t\t\tk, found_chunk = 0, done = 0, error = 0 ;\n\tchar\t\t*cptr ;\n\tint\t\t\tinstr_found = 0, mark_found = 0 ;\n\n\tif (psf->filelength > SF_PLATFORM_S64 (0xffffffff))\n\t\tpsf_log_printf (psf, \"Warning : filelength > 0xffffffff. This is bad!!!!\\n\") ;\n\n\tif ((paiff = psf->container_data) == NULL)\n\t\treturn SFE_INTERNAL ;\n\n\tpaiff->comm_offset = 0 ;\n\tpaiff->ssnd_offset = 0 ;\n\n\t/* Set position to start of file to begin reading header. */\n\tpsf_binheader_readf (psf, \"p\", 0) ;\n\n\tmemset (comm_fmt, 0, sizeof (COMM_CHUNK)) ;\n\n\t/* Until recently AIF* file were all BIG endian. */\n\tpsf->endian = SF_ENDIAN_BIG ;\n\n\t/*\tAIFF files can apparently have their chunks in any order. However, they\n\t**\tmust have a FORM chunk. Approach here is to read all the chunks one by\n\t**\tone and then check for the mandatory chunks at the end.\n\t*/\n\twhile (! done)\n\t{\tunsigned\tmarker ;\n\t\tsize_t jump = chunk_size & 1 ;\n\n\t\tmarker = chunk_size = 0 ;\n\t\tpsf_binheader_readf (psf, \"Ejm4\", jump, &marker, &chunk_size) ;\n\t\tif (marker == 0)\n\t\t{\tsf_count_t pos = psf_ftell (psf) ;\n\t\t\tpsf_log_printf (psf, \"Have 0 marker at position %D (0x%x).\\n\", pos, pos) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (psf->file.mode == SFM_RDWR && (found_chunk & HAVE_SSND))\n\t\t\treturn SFE_AIFF_RW_SSND_NOT_LAST ;\n\n\t\tpsf_store_read_chunk_u32 (&psf->rchunks, marker, psf_ftell (psf), chunk_size) ;\n\n\t\tswitch (marker)\n\t\t{\tcase FORM_MARKER :\n\t\t\t\t\tif (found_chunk)\n\t\t\t\t\t\treturn SFE_AIFF_NO_FORM ;\n\n\t\t\t\t\tFORMsize = chunk_size ;\n\n\t\t\t\t\tfound_chunk |= HAVE_FORM ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"m\", &marker) ;\n\t\t\t\t\tswitch (marker)\n\t\t\t\t\t{\tcase AIFC_MARKER :\n\t\t\t\t\t\tcase AIFF_MARKER :\n\t\t\t\t\t\t\tfound_chunk |= (marker == AIFC_MARKER) ? (HAVE_AIFC | HAVE_AIFF) : HAVE_AIFF ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf->fileoffset > 0 && psf->filelength > FORMsize + 8)\n\t\t\t\t\t{\t/* Set file length. */\n\t\t\t\t\t\tpsf->filelength = FORMsize + 8 ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"FORM : %u\\n %M\\n\", FORMsize, marker) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (FORMsize != psf->filelength - 2 * SIGNED_SIZEOF (chunk_size))\n\t\t\t\t\t{\tchunk_size = psf->filelength - 2 * sizeof (chunk_size) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"FORM : %u (should be %u)\\n %M\\n\", FORMsize, chunk_size, marker) ;\n\t\t\t\t\t\tFORMsize = chunk_size ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \"FORM : %u\\n %M\\n\", FORMsize, marker) ;\n\t\t\t\t\t/* Set this to 0, so we don't jump a byte when parsing the next marker. */\n\t\t\t\t\tchunk_size = 0 ;\n\t\t\t\t\tbreak ;\n\n\n\t\t\tcase COMM_MARKER :\n\t\t\t\t\tpaiff->comm_offset = psf_ftell (psf) - 8 ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tcomm_fmt->size = chunk_size ;\n\t\t\t\t\tif ((error = aiff_read_comm_chunk (psf, comm_fmt)) != 0)\n\t\t\t\t\t\treturn error ;\n\n\t\t\t\t\tfound_chunk |= HAVE_COMM ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase PEAK_MARKER :\n\t\t\t\t\t/* Must have COMM chunk before PEAK chunk. */\n\t\t\t\t\tif ((found_chunk & (HAVE_FORM | HAVE_AIFF | HAVE_COMM)) != (HAVE_FORM | HAVE_AIFF | HAVE_COMM))\n\t\t\t\t\t\treturn SFE_AIFF_PEAK_B4_COMM ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"%M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\tif (chunk_size != AIFF_PEAK_CHUNK_SIZE (psf->sf.channels))\n\t\t\t\t\t{\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** File PEAK chunk too big.\\n\") ;\n\t\t\t\t\t\treturn SFE_WAV_BAD_PEAK ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif ((psf->peak_info = peak_info_calloc (psf->sf.channels)) == NULL)\n\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t/* read in rest of PEAK chunk. */\n\t\t\t\t\tpsf_binheader_readf (psf, \"E44\", &(psf->peak_info->version), &(psf->peak_info->timestamp)) ;\n\n\t\t\t\t\tif (psf->peak_info->version != 1)\n\t\t\t\t\t\tpsf_log_printf (psf, \"  version    : %d *** (should be version 1)\\n\", psf->peak_info->version) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \"  version    : %d\\n\", psf->peak_info->version) ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"  time stamp : %d\\n\", psf->peak_info->timestamp) ;\n\t\t\t\t\tpsf_log_printf (psf, \"    Ch   Position       Value\\n\") ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tfor (k = 0 ; k < psf->sf.channels ; k++)\n\t\t\t\t\t{\tfloat value ;\n\t\t\t\t\t\tuint32_t position ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"Ef4\", &value, &position) ;\n\t\t\t\t\t\tpsf->peak_info->peaks [k].value = value ;\n\t\t\t\t\t\tpsf->peak_info->peaks [k].position = position ;\n\n\t\t\t\t\t\tsnprintf (cptr, sizeof (ubuf.scbuf), \"    %2d   %-12\" PRId64 \"   %g\\n\",\n\t\t\t\t\t\t\t\tk, psf->peak_info->peaks [k].position, psf->peak_info->peaks [k].value) ;\n\t\t\t\t\t\tcptr [sizeof (ubuf.scbuf) - 1] = 0 ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"%s\", cptr) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tpsf->peak_info->peak_loc = ((found_chunk & HAVE_SSND) == 0) ? SF_PEAK_START : SF_PEAK_END ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase SSND_MARKER :\n\t\t\t\t\tif ((found_chunk & HAVE_AIFC) && (found_chunk & HAVE_FVER) == 0)\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** Valid AIFC files should have an FVER chunk.\\n\") ;\n\n\t\t\t\t\tpaiff->ssnd_offset = psf_ftell (psf) - 8 ;\n\t\t\t\t\tSSNDsize = chunk_size ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"E44\", &(ssnd_fmt.offset), &(ssnd_fmt.blocksize)) ;\n\n\t\t\t\t\tpsf->datalength = SSNDsize - sizeof (ssnd_fmt) ;\n\t\t\t\t\tpsf->dataoffset = psf_ftell (psf) ;\n\n\t\t\t\t\tif (psf->datalength > psf->filelength - psf->dataoffset || psf->datalength < 0)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" SSND : %u (should be %D)\\n\", SSNDsize, psf->filelength - psf->dataoffset + sizeof (SSND_CHUNK)) ;\n\t\t\t\t\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \" SSND : %u\\n\", SSNDsize) ;\n\n\t\t\t\t\tif (ssnd_fmt.offset == 0 || psf->dataoffset + ssnd_fmt.offset == ssnd_fmt.blocksize)\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Offset     : %u\\n\", ssnd_fmt.offset) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Block Size : %u\\n\", ssnd_fmt.blocksize) ;\n\n\t\t\t\t\t\tpsf->dataoffset += ssnd_fmt.offset ;\n\t\t\t\t\t\tpsf->datalength -= ssnd_fmt.offset ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Offset     : %u\\n\", ssnd_fmt.offset) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Block Size : %u ???\\n\", ssnd_fmt.blocksize) ;\n\t\t\t\t\t\tpsf->dataoffset += ssnd_fmt.offset ;\n\t\t\t\t\t\tpsf->datalength -= ssnd_fmt.offset ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\t/* Only set dataend if there really is data at the end. */\n\t\t\t\t\tif (psf->datalength + psf->dataoffset < psf->filelength)\n\t\t\t\t\t\tpsf->dataend = psf->datalength + psf->dataoffset ;\n\n\t\t\t\t\tfound_chunk |= HAVE_SSND ;\n\n\t\t\t\t\tif (! psf->sf.seekable)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t/* Seek to end of SSND chunk. */\n\t\t\t\t\tpsf_fseek (psf, psf->dataoffset + psf->datalength, SEEK_SET) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase c_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf))\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\n\t\t\t\t\tpsf_sanitize_string (cptr, chunk_size) ;\n\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_COPYRIGHT, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase AUTH_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 1)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_ARTIST, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase COMT_MARKER :\n\t\t\t\t{\tuint16_t count, id, len ;\n\t\t\t\t\tuint32_t timestamp, bytes ;\n\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tbytes = chunk_size ;\n\t\t\t\t\tbytes -= psf_binheader_readf (psf, \"E2\", &count) ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n  count  : %d\\n\", marker, chunk_size, count) ;\n\n\t\t\t\t\tfor (k = 0 ; k < count ; k++)\n\t\t\t\t\t{\tbytes -= psf_binheader_readf (psf, \"E422\", &timestamp, &id, &len) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"   time   : 0x%x\\n   marker : %x\\n   length : %d\\n\", timestamp, id, len) ;\n\n\t\t\t\t\t\tif (len + 1 > SIGNED_SIZEOF (ubuf.scbuf))\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"\\nError : string length (%d) too big.\\n\", len) ;\n\t\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\t\tbytes -= psf_binheader_readf (psf, \"b\", cptr, len) ;\n\t\t\t\t\t\tcptr [len] = 0 ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"   string : %s\\n\", cptr) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (bytes > 0)\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", bytes) ;\n\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase APPL_MARKER :\n\t\t\t\t{\tunsigned appl_marker ;\n\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 1)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %u (too big, skipping)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (chunk_size < 4)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too small, skipping)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"mb\", &appl_marker, cptr, chunk_size + (chunk_size & 1) - 4) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\n\t\t\t\t\tfor (k = 0 ; k < (int) chunk_size ; k++)\n\t\t\t\t\t\tif (! psf_isprint (cptr [k]))\n\t\t\t\t\t\t{\tcptr [k] = 0 ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n  AppSig : %M\\n  Name   : %s\\n\", marker, chunk_size, appl_marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_SOFTWARE, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase NAME_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 2)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_TITLE, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase ANNO_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 2)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_COMMENT, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase INST_MARKER :\n\t\t\t\t\tif (chunk_size != SIZEOF_INST_CHUNK)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (should be %d)\\n\", marker, chunk_size, SIZEOF_INST_CHUNK) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\t{\tuint8_t bytes [6] ;\n\t\t\t\t\t\tint16_t gain ;\n\n\t\t\t\t\t\tif (psf->instrument == NULL && (psf->instrument = psf_instrument_alloc ()) == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"b\", bytes, 6) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Base Note : %u\\n  Detune    : %u\\n\"\n\t\t\t\t\t\t\t\t\t\t\t\"  Low  Note : %u\\n  High Note : %u\\n\"\n\t\t\t\t\t\t\t\t\t\t\t\"  Low  Vel. : %u\\n  High Vel. : %u\\n\",\n\t\t\t\t\t\t\t\t\t\t\tbytes [0], bytes [1], bytes [2], bytes [3], bytes [4], bytes [5]) ;\n\t\t\t\t\t\tpsf->instrument->basenote = bytes [0] ;\n\t\t\t\t\t\tpsf->instrument->detune = bytes [1] ;\n\t\t\t\t\t\tpsf->instrument->key_lo = bytes [2] ;\n\t\t\t\t\t\tpsf->instrument->key_hi = bytes [3] ;\n\t\t\t\t\t\tpsf->instrument->velocity_lo = bytes [4] ;\n\t\t\t\t\t\tpsf->instrument->velocity_hi = bytes [5] ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"E2\", &gain) ;\n\t\t\t\t\t\tpsf->instrument->gain = gain ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Gain (dB) : %d\\n\", gain) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t{\tint16_t\tmode ; /* 0 - no loop, 1 - forward looping, 2 - backward looping */\n\t\t\t\t\t\tconst char\t*loop_mode ;\n\t\t\t\t\t\tuint16_t begin, end ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"E222\", &mode, &begin, &end) ;\n\t\t\t\t\t\tloop_mode = get_loop_mode_str (mode) ;\n\t\t\t\t\t\tmode = get_loop_mode (mode) ;\n\t\t\t\t\t\tif (mode == SF_LOOP_NONE)\n\t\t\t\t\t\t{\tpsf->instrument->loop_count = 0 ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].mode = SF_LOOP_NONE ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\tpsf->instrument->loop_count = 1 ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].mode = SF_LOOP_FORWARD ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].start = begin ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].end = end ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].count = 0 ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Sustain\\n   mode  : %d => %s\\n   begin : %u\\n   end   : %u\\n\",\n\t\t\t\t\t\t\t\t\t\t\tmode, loop_mode, begin, end) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"E222\", &mode, &begin, &end) ;\n\t\t\t\t\t\tloop_mode = get_loop_mode_str (mode) ;\n\t\t\t\t\t\tmode = get_loop_mode (mode) ;\n\t\t\t\t\t\tif (mode == SF_LOOP_NONE)\n\t\t\t\t\t\t\tpsf->instrument->loops [1].mode = SF_LOOP_NONE ;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\tpsf->instrument->loop_count += 1 ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].mode = SF_LOOP_FORWARD ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].start = begin ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].end = end ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].count = 0 ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Release\\n   mode  : %d => %s\\n   begin : %u\\n   end   : %u\\n\",\n\t\t\t\t\t\t\t\t\t\tmode, loop_mode, begin, end) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tinstr_found++ ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase basc_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \" basc : %u\\n\", chunk_size) ;\n\n\t\t\t\t\tif ((error = aiff_read_basc_chunk (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase MARK_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\t{\tuint16_t mark_id, n = 0 ;\n\t\t\t\t\t\tuint32_t position ;\n\n\t\t\t\t\t\tbytesread = psf_binheader_readf (psf, \"E2\", &n) ;\n\t\t\t\t\t\tmark_count = n ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Count : %u\\n\", mark_count) ;\n\t\t\t\t\t\tif (paiff->markstr != NULL)\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"*** Second MARK chunk found. Throwing away the first.\\n\") ;\n\t\t\t\t\t\t\tfree (paiff->markstr) ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tpaiff->markstr = calloc (mark_count, sizeof (MARK_ID_POS)) ;\n\t\t\t\t\t\tif (paiff->markstr == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tif (mark_count > 1000)\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"  More than 1000 markers, skipping!\\n\") ;\n\t\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size - bytesread) ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tif ((psf->cues = psf_cues_alloc (mark_count)) == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tfor (n = 0 ; n < mark_count && bytesread < chunk_size ; n++)\n\t\t\t\t\t\t{\tuint32_t pstr_len ;\n\t\t\t\t\t\t\tuint8_t ch ;\n\n\t\t\t\t\t\t\tbytesread += psf_binheader_readf (psf, \"E241\", &mark_id, &position, &ch) ;\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"   Mark ID  : %u\\n   Position : %u\\n\", mark_id, position) ;\n\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].indx = mark_id ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].position = 0 ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].fcc_chunk = MAKE_MARKER ('d', 'a', 't', 'a') ; /* always data */\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].chunk_start = 0 ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].block_start = 0 ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].sample_offset = position ;\n\n\t\t\t\t\t\t\tpstr_len = (ch & 1) ? ch : ch + 1 ;\n\n\t\t\t\t\t\t\tif (pstr_len < sizeof (ubuf.scbuf) - 1)\n\t\t\t\t\t\t\t{\tbytesread += psf_binheader_readf (psf, \"b\", ubuf.scbuf, pstr_len) ;\n\t\t\t\t\t\t\t\tubuf.scbuf [pstr_len] = 0 ;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\tuint32_t read_len = pstr_len - (sizeof (ubuf.scbuf) - 1) ;\n\t\t\t\t\t\t\t\tbytesread += psf_binheader_readf (psf, \"bj\", ubuf.scbuf, read_len, pstr_len - read_len) ;\n\t\t\t\t\t\t\t\tubuf.scbuf [sizeof (ubuf.scbuf) - 1] = 0 ;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"   Name     : %s\\n\", ubuf.scbuf) ;\n\n\t\t\t\t\t\t\tpsf_strlcpy (psf->cues->cue_points [n].name, sizeof (psf->cues->cue_points [n].name), ubuf.cbuf) ;\n\n\t\t\t\t\t\t\tpaiff->markstr [n].markerID = mark_id ;\n\t\t\t\t\t\t\tpaiff->markstr [n].position = position ;\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t**\tTODO if ubuf.scbuf is equal to\n\t\t\t\t\t\t\t**\teither Beg_loop, Beg loop or beg loop and spam\n\t\t\t\t\t\t\t**\tif (psf->instrument == NULL && (psf->instrument = psf_instrument_alloc ()) == NULL)\n\t\t\t\t\t\t\t**\t\treturn SFE_MALLOC_FAILED ;\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tmark_found++ ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size - bytesread) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase FVER_MARKER :\n\t\t\t\t\tfound_chunk |= HAVE_FVER ;\n\t\t\t\t\t/* Falls through. */\n\n\t\t\tcase SFX_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase NONE_MARKER :\n\t\t\t\t\t/* Fix for broken AIFC files with incorrect COMM chunk length. */\n\t\t\t\t\tchunk_size = (chunk_size >> 24) - 3 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", make_size_t (chunk_size)) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase CHAN_MARKER :\n\t\t\t\t\tif (chunk_size < 12)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (should be >= 12)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\n\t\t\t\t\tif ((error = aiff_read_chanmap (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\t\tif (chunk_size >= 0xffff0000)\n\t\t\t\t\t{\tdone = SF_TRUE ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\\n\", marker, psf_ftell (psf) - 8, chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf_isprint ((marker >> 24) & 0xFF) && psf_isprint ((marker >> 16) & 0xFF)\n\t\t\t\t\t\t&& psf_isprint ((marker >> 8) & 0xFF) && psf_isprint (marker & 0xFF))\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %u (unknown marker)\\n\", marker, chunk_size) ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf_ftell (psf) & 0x03)\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Unknown chunk marker at position %D. Resynching.\\n\", psf_ftell (psf) - 8) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", -3) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tpsf_log_printf (psf, \"*** Unknown chunk marker %X at position %D. Exiting parser.\\n\", marker, psf_ftell (psf)) ;\n\t\t\t\t\tdone = SF_TRUE ;\n\t\t\t\t\tbreak ;\n\t\t\t} ;\t/* switch (marker) */\n\n\t\tif (chunk_size >= psf->filelength)\n\t\t{\tpsf_log_printf (psf, \"*** Chunk size %u > file length %D. Exiting parser.\\n\", chunk_size, psf->filelength) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif ((! psf->sf.seekable) && (found_chunk & HAVE_SSND))\n\t\t\tbreak ;\n\n\t\tif (psf_ftell (psf) >= psf->filelength - (2 * SIGNED_SIZEOF (int32_t)))\n\t\t\tbreak ;\n\t\t} ; /* while (1) */\n\n\tif (instr_found && mark_found)\n\t{\tint ji, str_index ;\n\t\t/* Next loop will convert markers to loop positions for internal handling */\n\t\tfor (ji = 0 ; ji < psf->instrument->loop_count ; ji ++)\n\t\t{\tif (ji < ARRAY_LEN (psf->instrument->loops))\n\t\t\t{\tpsf->instrument->loops [ji].start = marker_to_position (paiff->markstr, psf->instrument->loops [ji].start, mark_count) ;\n\t\t\t\tpsf->instrument->loops [ji].end = marker_to_position (paiff->markstr, psf->instrument->loops [ji].end, mark_count) ;\n\t\t\t\tpsf->instrument->loops [ji].mode = SF_LOOP_FORWARD ;\n\t\t\t\t} ;\n\t\t\t} ;\n\n\t\t/* The markers that correspond to loop positions can now be removed from cues struct */\n\t\tif (psf->cues->cue_count > (uint32_t) (psf->instrument->loop_count * 2))\n\t\t{\tuint32_t j ;\n\n\t\t\tfor (j = 0 ; j < psf->cues->cue_count - (uint32_t) (psf->instrument->loop_count * 2) ; j ++)\n\t\t\t{\t/* This simply copies the information in cues above loop positions and writes it at current count instead */\n\t\t\t\tpsf->cues->cue_points [j].indx = psf->cues->cue_points [j + psf->instrument->loop_count * 2].indx ;\n\t\t\t\tpsf->cues->cue_points [j].position = psf->cues->cue_points [j + psf->instrument->loop_count * 2].position ;\n\t\t\t\tpsf->cues->cue_points [j].fcc_chunk = psf->cues->cue_points [j + psf->instrument->loop_count * 2].fcc_chunk ;\n\t\t\t\tpsf->cues->cue_points [j].chunk_start = psf->cues->cue_points [j + psf->instrument->loop_count * 2].chunk_start ;\n\t\t\t\tpsf->cues->cue_points [j].block_start = psf->cues->cue_points [j + psf->instrument->loop_count * 2].block_start ;\n\t\t\t\tpsf->cues->cue_points [j].sample_offset = psf->cues->cue_points [j + psf->instrument->loop_count * 2].sample_offset ;\n\t\t\t\tfor (str_index = 0 ; str_index < 256 ; str_index++)\n\t\t\t\t\tpsf->cues->cue_points [j].name [str_index] = psf->cues->cue_points [j + psf->instrument->loop_count * 2].name [str_index] ;\n\t\t\t\t} ;\n\t\t\tpsf->cues->cue_count -= psf->instrument->loop_count * 2 ;\n\t\t\t} else\n\t\t\t{\t/* All the cues were in fact loop positions so we can actually remove the cues altogether */\n\t\t\t\tfree (psf->cues) ;\n\t\t\t\tpsf->cues = NULL ;\n\t\t\t\t}\n\t\t} ;\n\n\tif (psf->sf.channels < 1)\n\t\treturn SFE_CHANNEL_COUNT_ZERO ;\n\n\tif (psf->sf.channels >= SF_MAX_CHANNELS)\n\t\treturn SFE_CHANNEL_COUNT ;\n\n\tif (! (found_chunk & HAVE_FORM))\n\t\treturn SFE_AIFF_NO_FORM ;\n\n\tif (! (found_chunk & HAVE_AIFF))\n\t\treturn SFE_AIFF_COMM_NO_FORM ;\n\n\tif (! (found_chunk & HAVE_COMM))\n\t\treturn SFE_AIFF_SSND_NO_COMM ;\n\n\tif (! psf->dataoffset)\n\t\treturn SFE_AIFF_NO_DATA ;\n\n\treturn 0 ;\n} /* aiff_read_header */", "target": 1, "cwe": ["CWE-476"], "project": "libsndfile", "commit_id": "6f3266277bed16525f0ac2f0f03ff4626f1923e5", "hash": 120856099206646598015741385112026656452, "size": 573, "message": "Fix max channel count bug\n\nThe code was allowing files to be written with a channel count of exactly\n`SF_MAX_CHANNELS` but was failing to read some file formats with the same\nchannel count.", "idx": 680}
{"func": "void init_re(void)\n{\n  /*\n    Filter for queries that can be run using the\n    MySQL Prepared Statements C API\n  */\n  const char *ps_re_str =\n    \"^(\"\n    \"[[:space:]]*REPLACE[[:space:]]|\"\n    \"[[:space:]]*INSERT[[:space:]]|\"\n    \"[[:space:]]*UPDATE[[:space:]]|\"\n    \"[[:space:]]*DELETE[[:space:]]|\"\n    \"[[:space:]]*SELECT[[:space:]]|\"\n    \"[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|\"\n    \"[[:space:]]*DO[[:space:]]|\"\n    \"[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|\"\n    \"[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|\"\n    \"[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|\"\n    \"[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])\";\n\n  /*\n    Filter for queries that can be run using the\n    Stored procedures\n  */\n  const char *sp_re_str =ps_re_str;\n\n  /*\n    Filter for queries that can be run as views\n  */\n  const char *view_re_str =\n    \"^(\"\n    \"[[:space:]]*SELECT[[:space:]])\";\n\n  init_re_comp(&ps_re, ps_re_str);\n  init_re_comp(&sp_re, sp_re_str);\n  init_re_comp(&view_re, view_re_str);\n}", "target": 0, "cwe": ["CWE-295"], "project": "mysql-server", "commit_id": "b3e9211e48a3fb586e88b0270a175d2348935424", "hash": 289559073486709693474754710114224645822, "size": 37, "message": "WL#9072:  Backport WL#8785 to 5.5", "idx": 681}
{"func": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto error;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\n\nerror:\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-400", "CWE-401"], "project": "linux", "commit_id": "a2cdd07488e666aa93a49a3fc9c9b1299e27ef3c", "hash": 163893258625798126224542460214587208622, "size": 28, "message": "rtl8xxxu: prevent leaking urb\n\nIn rtl8xxxu_submit_int_urb if usb_submit_urb fails the allocated urb\nshould be released.\n\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nReviewed-by: Chris Chiu <chiu@endlessm.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>", "idx": 682}
{"func": "do_mouse(\n    oparg_T\t*oap,\t\t// operator argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n    int\t\tdir,\t\t// Direction to 'put' if necessary\n    long\tcount,\n    int\t\tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n{\n    static int\tdo_always = FALSE;\t// ignore 'mouse' setting next time\n    static int\tgot_click = FALSE;\t// got a click some time back\n\n    int\t\twhich_button;\t// MOUSE_LEFT, _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it's a drag or release event\n    int\t\tis_drag = FALSE;  // If TRUE it's a drag event\n    int\t\tjump_flags = 0;\t// flags for jump_to_mouse()\n    pos_T\tstart_visual;\n    int\t\tmoved;\t\t// Has cursor moved?\n    int\t\tin_status_line;\t// mouse in status line\n    static int\tin_tab_line = FALSE; // mouse clicked in tab line\n    int\t\tin_sep_line;\t// mouse in vertical separator line\n    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n#endif\n    win_T\t*old_curwin = curwin;\n    static pos_T orig_cursor;\n    colnr_T\tleftcol, rightcol;\n    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active = VIsual_active;\n    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n#if defined(FEAT_FOLDING)\n    save_cursor = curwin->w_cursor;\n#endif\n\n    // When GUI is active, always recognize mouse events, otherwise:\n    // - Ignore mouse event in normal mode if 'mouse' doesn't include 'n'.\n    // - Ignore mouse event in visual mode if 'mouse' doesn't include 'v'.\n    // - For command line and insert mode 'mouse' is checked before calling\n    //\t do_mouse().\n    if (do_always)\n\tdo_always = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n#endif\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\t\t    return FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is the same mouse event then use that\n\t    // one. Speeds up dragging the status line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\t    // below need to come before the next character, do not do this\n\t    // when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() != NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\tvungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n#endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped dragging the status or separator line.  The pointer is\n    // most likely still on the status or separator line.\n    if (!is_drag && drag_status_line)\n    {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n    }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n    else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag and release events, as well as\n    // multiple clicks and the middle mouse button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\".\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button that is held down, ignore\n    // drag/release events.\n    if (!is_click && which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't know what the user wanted\n\t    // to do. Go back to normal mode: Clear the operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t    {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual was active, yank the highlighted text and put it\n\t    // before the mouse pointer position.\n\t    // In Select mode replace the highlighted text with the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"+p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert mode doesn't move the mouse, just insert the\n\t// contents of a register.  '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t    if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n    // Check for clicking in the tab page line.\n    if (mouse_row == 0 && firstwin->w_winrow > 0)\n    {\n\tif (is_drag)\n\t{\n\t    if (in_tab_line)\n\t    {\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\ttabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\t\t\t\t\t\t\t\t? c1 - 1 : c1);\n\t    }\n\t    return FALSE;\n\t}\n\n\t// click in a tab selects that tab page\n\tif (is_click\n# ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n# endif\n\t\t&& mouse_col < Columns)\n\t{\n\t    in_tab_line = TRUE;\n\t    c1 = TabPageIdxs[mouse_col];\n\t    if (c1 >= 0)\n\t    {\n\t\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t{\n\t\t    // double click opens new page\n\t\t    end_visual_mode_keep_button();\n\t\t    tabpage_new();\n\t\t    tabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Go to specified tab page, or next one if not clicking\n\t\t    // on a label.\n\t\t    goto_tabpage(c1);\n\n\t\t    // It's like clicking on the status line of a window.\n\t\t    if (curwin != old_curwin)\n\t\t\tend_visual_mode_keep_button();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ttabpage_T\t*tp;\n\n\t\t// Close the current or specified tab page.\n\t\tif (c1 == -999)\n\t\t    tp = curtab;\n\t\telse\n\t\t    tp = find_tabpage(-c1);\n\t\tif (tp == curtab)\n\t\t{\n\t\t    if (first_tabpage->tp_next != NULL)\n\t\t\ttabpage_close(FALSE);\n\t\t}\n\t\telse if (tp != NULL)\n\t\t    tabpage_close_other(tp, FALSE);\n\t    }\n\t}\n\treturn TRUE;\n    }\n    else if (is_drag && in_tab_line)\n    {\n\tc1 = TabPageIdxs[mouse_col];\n\ttabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\treturn FALSE;\n    }\n\n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n    // right button up   -> pop-up menu\n    // shift-left button -> right button\n    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore right button release events, only shows the popup\n\t\t    // menu on the button down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore right button down and drag mouse events.  Windows\n\t\t    // only shows the popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n# endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n# endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore right button release events, only shows the popup\n\t\t// menu on the button down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem, \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t    // selection or the current window (might have false\n\t\t    // negative here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t{\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol, &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags, NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t// ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) != 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t// cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending, ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive), which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags & IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping to another window, clear a pending operator.  That's a bit\n    // friendlier than beeping and not jumping to that window.\n    if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum, 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n    }\n#endif\n\n    // Set global flag that we are extending the Visual area with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window, scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\tscroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\t// right click in visual mode\n    {\n       // When ALT is pressed make Visual mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t// that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col = leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the click is before the start of visual, change the start.\n\t    // If the click is after the end of visual, change the end.  If\n\t    // the click is inside the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t    if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col - curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\telse\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t// closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t// closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t    VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT) && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click: Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname = '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\tif (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t}\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where the paste started, so in edit() Insstart can be set\n\t// to this position\n\tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname, NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n    // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse click searches for the next occurrence of the word under\n    // the mouse pointer\n    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT) || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\tif (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual = curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\tVIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode = Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end may still be the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t    if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white space) is\n\t\t// not a word character, try finding a match and select a (),\n\t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t    {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor, orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t    find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    // If Visual mode changed show it later.\n    if ((!VIsual_active && old_active && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\n    return moved;\n}", "target": 1, "cwe": ["CWE-476", "CWE-703"], "project": "vim", "commit_id": "80525751c5ce9ed82c41d83faf9ef38667bf61b1", "hash": 159266025064479013943001437579885155483, "size": 829, "message": "patch 9.0.0259: crash with mouse click when not initialized\n\nProblem:    Crash with mouse click when not initialized.\nSolution:   Check TabPageIdxs[] is not NULL.", "idx": 683}
{"func": "static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size   = avio_rl64(pb);\n    int ret;\n\n    if (size > INT64_MAX)\n        return AVERROR_INVALIDDATA;\n\n    if (asf->is_header)\n        asf->unknown_size = size;\n    asf->is_header = 0;\n    if (!g->is_subobject) {\n        if (!(ret = strcmp(g->name, \"Header Extension\")))\n            avio_skip(pb, 22); // skip reserved fields and Data Size\n        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,\n                                            asf->unknown_size)) < 0)\n            return ret;\n    } else {\n        if (size < 24) {\n            av_log(s, AV_LOG_ERROR, \"Too small size %\"PRIu64\" (< 24).\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n        avio_skip(pb, size - 24);\n    }\n\n    return 0;\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "FFmpeg", "commit_id": "2b46ebdbff1d8dec7a3d8ea280a612b91a582869", "hash": 239136065595120022586825139713359864203, "size": 29, "message": "avformat/asfdec_o: Check size_bmp more fully\n\nFixes: integer overflow and out of array access\nFixes: asfo-crash-46080c4341572a7137a162331af77f6ded45cbd7\n\nFound-by: Paul Ch <paulcher@icloud.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>", "idx": 684}
{"func": "static int ext4_find_unwritten_pgoff(struct inode *inode,\n\t\t\t\t     int whence,\n\t\t\t\t     struct ext4_map_blocks *map,\n\t\t\t\t     loff_t *offset)\n{\n\tstruct pagevec pvec;\n\tunsigned int blkbits;\n\tpgoff_t index;\n\tpgoff_t end;\n\tloff_t endoff;\n\tloff_t startoff;\n\tloff_t lastoff;\n\tint found = 0;\n\n\tblkbits = inode->i_sb->s_blocksize_bits;\n\tstartoff = *offset;\n\tlastoff = startoff;\n\tendoff = (loff_t)(map->m_lblk + map->m_len) << blkbits;\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\n\tpagevec_init(&pvec, 0);\n\tdo {\n\t\tint i, num;\n\t\tunsigned long nr_pages;\n\n\t\tnum = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  (pgoff_t)num);\n\t\tif (nr_pages == 0) {\n\t\t\tif (whence == SEEK_DATA)\n\t\t\t\tbreak;\n\n\t\t\tBUG_ON(whence != SEEK_HOLE);\n\t\t\t/*\n\t\t\t * If this is the first time to go into the loop and\n\t\t\t * offset is not beyond the end offset, it will be a\n\t\t\t * hole at this offset\n\t\t\t */\n\t\t\tif (lastoff == startoff || lastoff < endoff)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this is the first time to go into the loop and\n\t\t * offset is smaller than the first page offset, it will be a\n\t\t * hole at this offset.\n\t\t */\n\t\tif (lastoff == startoff && whence == SEEK_HOLE &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\t/*\n\t\t\t * If the current offset is not beyond the end of given\n\t\t\t * range, it will be a hole.\n\t\t\t */\n\t\t\tif (lastoff < endoff && whence == SEEK_HOLE &&\n\t\t\t    page->index > end) {\n\t\t\t\tfound = 1;\n\t\t\t\t*offset = lastoff;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (page_has_buffers(page)) {\n\t\t\t\tlastoff = page_offset(page);\n\t\t\t\tbh = head = page_buffers(page);\n\t\t\t\tdo {\n\t\t\t\t\tif (buffer_uptodate(bh) ||\n\t\t\t\t\t    buffer_unwritten(bh)) {\n\t\t\t\t\t\tif (whence == SEEK_DATA)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (whence == SEEK_HOLE)\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\t*offset = max_t(loff_t,\n\t\t\t\t\t\t\tstartoff, lastoff);\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tlastoff += bh->b_size;\n\t\t\t\t\tbh = bh->b_this_page;\n\t\t\t\t} while (bh != head);\n\t\t\t}\n\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The no. of pages is less than our desired, that would be a\n\t\t * hole in there.\n\t\t */\n\t\tif (nr_pages < num && whence == SEEK_HOLE) {\n\t\t\tfound = 1;\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}", "target": 0, "cwe": ["CWE-362"], "project": "linux", "commit_id": "ea3d7209ca01da209cda6f0dea8be9cc4b7a933b", "hash": 192487168054876627240025160493032425930, "size": 128, "message": "ext4: fix races between page faults and hole punching\n\nCurrently, page faults and hole punching are completely unsynchronized.\nThis can result in page fault faulting in a page into a range that we\nare punching after truncate_pagecache_range() has been called and thus\nwe can end up with a page mapped to disk blocks that will be shortly\nfreed. Filesystem corruption will shortly follow. Note that the same\nrace is avoided for truncate by checking page fault offset against\ni_size but there isn't similar mechanism available for punching holes.\n\nFix the problem by creating new rw semaphore i_mmap_sem in inode and\ngrab it for writing over truncate, hole punching, and other functions\nremoving blocks from extent tree and for read over page faults. We\ncannot easily use i_data_sem for this since that ranks below transaction\nstart and we need something ranking above it so that it can be held over\nthe whole truncate / hole punching operation. Also remove various\nworkarounds we had in the code to reduce race window when page fault\ncould have created pages with stale mapping information.\n\nSigned-off-by: Jan Kara <jack@suse.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>", "idx": 685}
{"func": "PHP_FUNCTION(pcntl_strerror)\n{\n        long error;\n\n        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &error) == FAILURE) {\n                RETURN_FALSE;\n        }\n\n        RETURN_STRING(strerror(error), 1);\n}", "target": 0, "cwe": ["CWE-19"], "project": "php-src", "commit_id": "be9b2a95adb504abd5acdc092d770444ad6f6854", "hash": 15747118927455477825707149018568402722, "size": 10, "message": "Fixed bug #69418 - more s->p fixes for filenames", "idx": 686}
{"func": "static ssize_t size_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%uK\\n\", this_leaf->size >> 10);\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "aa838896d87af561a33ecefea1caa4c15a68bc47", "hash": 64342802851453582212187170479078992282, "size": 7, "message": "drivers core: Use sysfs_emit and sysfs_emit_at for show(device *...) functions\n\nConvert the various sprintf fmaily calls in sysfs device show functions\nto sysfs_emit and sysfs_emit_at for PAGE_SIZE buffer safety.\n\nDone with:\n\n$ spatch -sp-file sysfs_emit_dev.cocci --in-place --max-width=80 .\n\nAnd cocci script:\n\n$ cat sysfs_emit_dev.cocci\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tstrcpy(buf, chr);\n+\tsysfs_emit(buf, chr);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n-\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n+\tlen += sysfs_emit_at(buf, len,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t...\n-\tstrcpy(buf, chr);\n-\treturn strlen(buf);\n+\treturn sysfs_emit(buf, chr);\n}\n\nSigned-off-by: Joe Perches <joe@perches.com>\nLink: https://lore.kernel.org/r/3d033c33056d88bbe34d4ddb62afd05ee166ab9a.1600285923.git.joe@perches.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 687}
{"func": "TEE_Result tee_obj_attr_from_binary(struct tee_obj *o, const void *data,\n\t\t\t\t    size_t data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tif (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,\n\t\t\t\t\t\t\t &offs))\n\t\t\treturn TEE_ERROR_CORRUPT_OBJECT;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "optee_os", "commit_id": "a637243270fc1faae16de059091795c32d86e65e", "hash": 275811365310351745631391185962456109676, "size": 25, "message": "svc: check for allocation overflow in crypto calls\n\nWithout checking for overflow there is a risk of allocating a buffer\nwith size smaller than anticipated and as a consequence of that it might\nlead to a heap based overflow with attacker controlled data written\noutside the boundaries of the buffer.\n\nFixes: OP-TEE-2018-0010: \"Integer overflow in crypto system calls (x2)\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>", "idx": 688}
{"func": "static ssize_t mon_text_read_u(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\n\tep = mon_text_read_wait(rp, file);\n\tif (IS_ERR(ep))\n\t\treturn PTR_ERR(ep);\n\tmutex_lock(&rp->printf_lock);\n\tptr.cnt = 0;\n\tptr.pbuf = rp->printf_buf;\n\tptr.limit = rp->printf_size;\n\n\tmon_text_read_head_u(rp, &ptr, ep);\n\tif (ep->type == 'E') {\n\t\tmon_text_read_statset(rp, &ptr, ep);\n\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\n\t\tmon_text_read_isostat(rp, &ptr, ep);\n\t\tmon_text_read_isodesc(rp, &ptr, ep);\n\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {\n\t\tmon_text_read_intstat(rp, &ptr, ep);\n\t} else {\n\t\tmon_text_read_statset(rp, &ptr, ep);\n\t}\n\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t    \" %d\", ep->length);\n\tmon_text_read_data(rp, &ptr, ep);\n\n\tif (copy_to_user(buf, rp->printf_buf, ptr.cnt))\n\t\tptr.cnt = -EFAULT;\n\tmutex_unlock(&rp->printf_lock);\n\tkmem_cache_free(rp->e_slab, ep);\n\treturn ptr.cnt;\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "a5f596830e27e15f7a0ecd6be55e433d776986d8", "hash": 274632692912206536547546301444220039477, "size": 36, "message": "usb: usbmon: Read text within supplied buffer size\n\nThis change fixes buffer overflows and silent data corruption with the\nusbmon device driver text file read operations.\n\nSigned-off-by: Fredrik Noring <noring@nocrew.org>\nSigned-off-by: Pete Zaitcev <zaitcev@redhat.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 689}
{"func": "int make_http_soap_request(zval        *this_ptr,\n                           zend_string *buf,\n                           char        *location,\n                           char        *soapaction,\n                           int          soap_version,\n                           zval        *return_value)\n{\n\tzend_string *request;\n\tsmart_str soap_headers = {0};\n\tsmart_str soap_headers_z = {0};\n\tint err;\n\tphp_url *phpurl = NULL;\n\tphp_stream *stream;\n\tzval *trace, *tmp;\n\tint use_proxy = 0;\n\tint use_ssl;\n\tzend_string *http_body;\n\tchar *content_type, *http_version, *cookie_itt;\n\tint http_close;\n\tzend_string *http_headers;\n\tchar *connection;\n\tint http_1_1;\n\tint http_status;\n\tint content_type_xml = 0;\n\tzend_long redirect_max = 20;\n\tchar *content_encoding;\n\tchar *http_msg = NULL;\n\tzend_bool old_allow_url_fopen;\n\tphp_stream_context *context = NULL;\n\tzend_bool has_authorization = 0;\n\tzend_bool has_proxy_authorization = 0;\n\tzend_bool has_cookies = 0;\n\n\tif (this_ptr == NULL || Z_TYPE_P(this_ptr) != IS_OBJECT) {\n\t\treturn FALSE;\n\t}\n\n\trequest = buf;\n\t/* Compress request */\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"compression\", sizeof(\"compression\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\tint level = Z_LVAL_P(tmp) & 0x0f;\n\t\tint kind  = Z_LVAL_P(tmp) & SOAP_COMPRESSION_DEFLATE;\n\n\t\tif (level > 9) {level = 9;}\n\n\t  if ((Z_LVAL_P(tmp) & SOAP_COMPRESSION_ACCEPT) != 0) {\n\t\t\tsmart_str_append_const(&soap_headers_z,\"Accept-Encoding: gzip, deflate\\r\\n\");\n\t  }\n\t  if (level > 0) {\n\t\t\tzval func;\n\t\t\tzval retval;\n\t\t\tzval params[3];\n\t\t\tint n;\n\n\t\t\tZVAL_STR_COPY(&params[0], buf);\n\t\t\tZVAL_LONG(&params[1], level);\n\t\t\tif (kind == SOAP_COMPRESSION_DEFLATE) {\n\t\t\t\tn = 2;\n\t\t\t\tZVAL_STRING(&func, \"gzcompress\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: deflate\\r\\n\");\n\t\t\t} else {\n\t\t\t\tn = 3;\n\t\t\t\tZVAL_STRING(&func, \"gzencode\");\n\t\t\t\tsmart_str_append_const(&soap_headers_z,\"Content-Encoding: gzip\\r\\n\");\n\t\t\t\tZVAL_LONG(&params[2], 0x1f);\n\t\t\t}\n\t\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, n, params) == SUCCESS &&\n\t\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\trequest = Z_STR(retval);\n\t\t\t} else {\n\t\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\t\tzval_ptr_dtor(&func);\n\t\t\t\tif (request != buf) {\n\t\t\t\t\tzend_string_release(request);\n\t\t\t\t}\n\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t  }\n\t}\n\n\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1)) != NULL) {\n\t\tphp_stream_from_zval_no_verify(stream,tmp);\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1)) != NULL && Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\tuse_proxy = Z_LVAL_P(tmp);\n\t\t}\n\t} else {\n\t\tstream = NULL;\n\t}\n\n\tif (location != NULL && location[0] != '\\000') {\n\t\tphpurl = php_url_parse(location);\n\t}\n\n\tif (NULL != (tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr),\n\t\t\t\"_stream_context\", sizeof(\"_stream_context\")-1))) {\n\t\tcontext = php_stream_context_from_zval(tmp, 0);\n\t}\n\n\tif (context &&\n\t\t(tmp = php_stream_context_get_option(context, \"http\", \"max_redirects\")) != NULL) {\n\t\tif (Z_TYPE_P(tmp) != IS_STRING || !is_numeric_string(Z_STRVAL_P(tmp), Z_STRLEN_P(tmp), &redirect_max, NULL, 1)) {\n\t\t\tif (Z_TYPE_P(tmp) == IS_LONG)\n\t\t\t\tredirect_max = Z_LVAL_P(tmp);\n\t\t}\n\t}\n\ntry_again:\n\tif (phpurl == NULL || phpurl->host == NULL) {\n\t  if (phpurl != NULL) {php_url_free(phpurl);}\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unable to parse URL\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tuse_ssl = 0;\n\tif (phpurl->scheme != NULL && strcmp(phpurl->scheme, \"https\") == 0) {\n\t\tuse_ssl = 1;\n\t} else if (phpurl->scheme == NULL || strcmp(phpurl->scheme, \"http\") != 0) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown protocol. Only http and https are allowed.\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tif (use_ssl && php_stream_locate_url_wrapper(\"https://\", NULL, STREAM_LOCATE_WRAPPERS_ONLY) == NULL) {\n\t\tphp_url_free(phpurl);\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"SSL support is not available in this build\", NULL, NULL);\n\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (phpurl->port == 0) {\n\t\tphpurl->port = use_ssl ? 443 : 80;\n\t}\n\n\t/* Check if request to the same host */\n\tif (stream != NULL) {\n\t  php_url *orig;\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1)) != NULL &&\n\t\t    (orig = (php_url *) zend_fetch_resource_ex(tmp, \"httpurl\", le_url)) != NULL &&\n\t\t    ((use_proxy && !use_ssl) ||\n\t\t     (((use_ssl && orig->scheme != NULL && strcmp(orig->scheme, \"https\") == 0) ||\n\t\t      (!use_ssl && orig->scheme == NULL) ||\n\t\t      (!use_ssl && strcmp(orig->scheme, \"https\") != 0)) &&\n\t\t     strcmp(orig->host, phpurl->host) == 0 &&\n\t\t     orig->port == phpurl->port))) {\n    } else {\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tstream = NULL;\n\t\t\tuse_proxy = 0;\n    }\n\t}\n\n\t/* Check if keep-alive connection is still opened */\n\tif (stream != NULL && php_stream_eof(stream)) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t\tuse_proxy = 0;\n\t}\n\n\tif (!stream) {\n\t\tstream = http_connect(this_ptr, phpurl, use_ssl, context, &use_proxy);\n\t\tif (stream) {\n\t\t\tphp_stream_auto_cleanup(stream);\n\t\t\tadd_property_resource(this_ptr, \"httpsocket\", stream->res);\n\t\t\tGC_REFCOUNT(stream->res)++;\n\t\t\tadd_property_long(this_ptr, \"_use_proxy\", use_proxy);\n\t\t} else {\n\t\t\tphp_url_free(phpurl);\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Could not connect to host\", NULL, NULL);\n\t\t\tPG(allow_url_fopen) = old_allow_url_fopen;\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\n\tif (stream) {\n\t\tzval *cookies, *login, *password;\n\t\tzend_resource *ret = zend_register_resource(phpurl, le_url);\n\n\t\tadd_property_resource(this_ptr, \"httpurl\", ret);\n\t\tGC_REFCOUNT(ret)++;\n\t\t/*zend_list_addref(ret);*/\n\n\t\tif (context &&\n\t\t    (tmp = php_stream_context_get_option(context, \"http\", \"protocol_version\")) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_DOUBLE &&\n\t\t    Z_DVAL_P(tmp) == 1.0) {\n\t\t\thttp_1_1 = 0;\n\t\t} else {\n\t\t\thttp_1_1 = 1;\n\t\t}\n\n\t\tsmart_str_append_const(&soap_headers, \"POST \");\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->scheme);\n\t\t\tsmart_str_append_const(&soap_headers, \"://\");\n\t\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (phpurl->path) {\n\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t} else {\n\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t}\n\t\tif (phpurl->query) {\n\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t}\n\t\tif (phpurl->fragment) {\n\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t}\n\t\tif (http_1_1) {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.1\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \" HTTP/1.0\\r\\n\");\n\t\t}\n\t\tsmart_str_append_const(&soap_headers, \"Host: \");\n\t\tsmart_str_appends(&soap_headers, phpurl->host);\n\t\tif (phpurl->port != (use_ssl?443:80)) {\n\t\t\tsmart_str_appendc(&soap_headers, ':');\n\t\t\tsmart_str_append_unsigned(&soap_headers, phpurl->port);\n\t\t}\n\t\tif (!http_1_1 ||\n\t\t\t((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_keep_alive\", sizeof(\"_keep_alive\")-1)) != NULL &&\n\t\t\t (Z_TYPE_P(tmp) == IS_FALSE || (Z_TYPE_P(tmp) == IS_LONG && Z_LVAL_P(tmp) == 0)))) {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: close\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\"\n\t\t\t\t\"Connection: Keep-Alive\\r\\n\");\n\t\t}\n\t\tif ((tmp = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_user_agent\", sizeof(\"_user_agent\")-1)) != NULL &&\n\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (context &&\n\t\t           (tmp = php_stream_context_get_option(context, \"http\", \"user_agent\")) != NULL &&\n\t\t           Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\tif (Z_STRLEN_P(tmp) > 0) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t} else if (FG(user_agent)) {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: \");\n\t\t\tsmart_str_appends(&soap_headers, FG(user_agent));\n\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers, \"User-Agent: PHP-SOAP/\"PHP_VERSION\"\\r\\n\");\n\t\t}\n\n\t\tsmart_str_append_smart_str(&soap_headers, &soap_headers_z);\n\n\t\tif (soap_version == SOAP_1_2) {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: application/soap+xml; charset=utf-8\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers,\"; action=\\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers,\"\\\"\");\n\t\t\t}\n\t\t\tsmart_str_append_const(&soap_headers,\"\\r\\n\");\n\t\t} else {\n\t\t\tsmart_str_append_const(&soap_headers,\"Content-Type: text/xml; charset=utf-8\\r\\n\");\n\t\t\tif (soapaction) {\n\t\t\t\tsmart_str_append_const(&soap_headers, \"SOAPAction: \\\"\");\n\t\t\t\tsmart_str_appends(&soap_headers, soapaction);\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tsmart_str_append_const(&soap_headers,\"Content-Length: \");\n\t\tsmart_str_append_long(&soap_headers, request->len);\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\n\t\t/* HTTP Authentication */\n\t\tif ((login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING) {\n\t\t\tzval *digest;\n\n\t\t\thas_authorization = 1;\n\t\t\tif ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) != NULL) {\n\t\t\t\tif (Z_TYPE_P(digest) == IS_ARRAY) {\n\t\t\t\t\tchar          HA1[33], HA2[33], response[33], cnonce[33], nc[9];\n\t\t\t\t\tPHP_MD5_CTX   md5ctx;\n\t\t\t\t\tunsigned char hash[16];\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tsnprintf(cnonce, sizeof(cnonce), ZEND_LONG_FMT, php_rand());\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, strlen(cnonce));\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(cnonce, hash);\n\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nc\", sizeof(\"nc\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_LONG) {\n\t\t\t\t\t\tZ_LVAL_P(tmp)++;\n\t\t\t\t\t\tsnprintf(nc, sizeof(nc), \"%08ld\", Z_LVAL_P(tmp));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd_assoc_long(digest, \"nc\", 1);\n\t\t\t\t\t\tstrcpy(nc, \"00000001\");\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_P(tmp) == sizeof(\"md5-sess\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_P(tmp), \"md5-sess\") == 0) {\n\t\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\t\tmake_digest(HA1, hash);\n\t\t\t\t\t}\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"POST:\", sizeof(\"POST:\")-1);\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->path, strlen(phpurl->path));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"/\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"?\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)phpurl->query, strlen(phpurl->query));\n\t\t\t\t\t}\n\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n/*\n\t\t\t\t\tif (zend_hash_find(Z_ARRVAL_PP(digest), \"qop\", sizeof(\"qop\"), (void **)&tmp) == SUCCESS &&\n\t\t\t\t\t    Z_TYPE_PP(tmp) == IS_STRING &&\n\t\t\t\t\t    Z_STRLEN_PP(tmp) == sizeof(\"auth-int\")-1 &&\n\t\t\t\t\t    stricmp(Z_STRVAL_PP(tmp), \"auth-int\") == 0) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, \":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, HEntity, HASHHEXLEN);\n\t\t\t\t\t}\n*/\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(HA2, hash);\n\n\t\t\t\t\tPHP_MD5Init(&md5ctx);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA1, 32);\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)nc, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)cnonce, 8);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\"auth\", sizeof(\"auth\")-1);\n\t\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)\":\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tPHP_MD5Update(&md5ctx, (unsigned char*)HA2, 32);\n\t\t\t\t\tPHP_MD5Final(hash, &md5ctx);\n\t\t\t\t\tmake_digest(response, hash);\n\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Digest username=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"realm\", sizeof(\"realm\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", realm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"nonce\", sizeof(\"nonce\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", uri=\\\"\");\n\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->path);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '/');\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->query) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '?');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->query);\n\t\t\t\t\t}\n\t\t\t\t\tif (phpurl->fragment) {\n\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '#');\n\t\t\t\t\t\tsmart_str_appends(&soap_headers, phpurl->fragment);\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"qop\", sizeof(\"qop\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t/* TODO: Support for qop=\"auth-int\" */\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", qop=\\\"auth\");\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", nc=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, nc, 8);\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", cnonce=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, cnonce, 8);\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", response=\\\"\");\n\t\t\t\t\tsmart_str_appendl(&soap_headers, response, 32);\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"opaque\", sizeof(\"opaque\")-1)) != NULL &&\n\t\t\t\t\t    Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", opaque=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tif ((tmp = zend_hash_str_find(Z_ARRVAL_P(digest), \"algorithm\", sizeof(\"algorithm\")-1)) != NULL &&\n\t\t\t\t\t\tZ_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\", algorithm=\\\"\");\n\t\t\t\t\t\tsmart_str_appendl(&soap_headers, Z_STRVAL_P(tmp), Z_STRLEN_P(tmp));\n\t\t\t\t\t}\n\t\t\t\t\tsmart_str_append_const(&soap_headers, \"\\\"\\r\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzend_string *buf;\n\n\t\t\t\tsmart_str auth = {0};\n\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(login), Z_STRLEN_P(login));\n\t\t\t\tsmart_str_appendc(&auth, ':');\n\t\t\t\tif ((password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\t\t\tsmart_str_appendl(&auth, Z_STRVAL_P(password), Z_STRLEN_P(password));\n\t\t\t\t}\n\t\t\t\tsmart_str_0(&auth);\n\t\t\t\tbuf = php_base64_encode((unsigned char*)ZSTR_VAL(auth.s), ZSTR_LEN(auth.s));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Authorization: Basic \");\n\t\t\t\tsmart_str_appendl(&soap_headers, (char*)ZSTR_VAL(buf), ZSTR_LEN(buf));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t\tzend_string_release(buf);\n\t\t\t\tsmart_str_free(&auth);\n\t\t\t}\n\t\t}\n\n\t\t/* Proxy HTTP Authentication */\n\t\tif (use_proxy && !use_ssl) {\n\t\t\thas_proxy_authorization = proxy_authentication(this_ptr, &soap_headers);\n\t\t}\n\n\t\t/* Send cookies along with request */\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) != NULL &&\n\t\t    Z_TYPE_P(cookies) == IS_ARRAY) {\n\t\t\tzval *data;\n\t\t\tzend_string *key;\n\t\t\tint i, n;\n\n\t\t\thas_cookies = 1;\n\t\t\tn = zend_hash_num_elements(Z_ARRVAL_P(cookies));\n\t\t\tif (n > 0) {\n\t\t\t\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(cookies));\n\t\t\t\tsmart_str_append_const(&soap_headers, \"Cookie: \");\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tzend_ulong numindx;\n\t\t\t\t\tint res = zend_hash_get_current_key(Z_ARRVAL_P(cookies), &key, &numindx);\n\t\t\t\t\tdata = zend_hash_get_current_data(Z_ARRVAL_P(cookies));\n\t\t\t\t\t\n\t\t\t\t\tif (res == HASH_KEY_IS_STRING && Z_TYPE_P(data) == IS_ARRAY) {\n\t\t\t\t\t  zval *value;\n\n\t\t\t\t\t\tif ((value = zend_hash_index_find(Z_ARRVAL_P(data), 0)) != NULL &&\n\t\t\t\t\t\t    Z_TYPE_P(value) == IS_STRING) {\n\t\t\t\t\t\t  zval *tmp;\n\t\t\t\t\t\t  if (((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 1)) == NULL ||\n\t\t\t\t\t\t       strncmp(phpurl->path?phpurl->path:\"/\",Z_STRVAL_P(tmp),Z_STRLEN_P(tmp)) == 0) &&\n\t\t\t\t\t\t      ((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 2)) == NULL ||\n\t\t\t\t\t\t       in_domain(phpurl->host,Z_STRVAL_P(tmp))) &&\n\t\t\t\t\t\t      (use_ssl || (tmp = zend_hash_index_find(Z_ARRVAL_P(data), 3)) == NULL)) {\n\t\t\t\t\t\t\t\tsmart_str_append(&soap_headers, key);\n\t\t\t\t\t\t\t\tsmart_str_appendc(&soap_headers, '=');\n\t\t\t\t\t\t\t\tsmart_str_append(&soap_headers, Z_STR_P(value));\n\t\t\t\t\t\t\t\tsmart_str_appendc(&soap_headers, ';');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward(Z_ARRVAL_P(cookies));\n\t\t\t\t}\n\t\t\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\t\t}\n\t\t}\n\n\t\thttp_context_headers(context, has_authorization, has_proxy_authorization, has_cookies, &soap_headers);\n\n\t\tsmart_str_append_const(&soap_headers, \"\\r\\n\");\n\t\tsmart_str_0(&soap_headers);\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_stringl(this_ptr, \"__last_request_headers\", ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\t}\n\t\tsmart_str_appendl(&soap_headers, request->val, request->len);\n\t\tsmart_str_0(&soap_headers);\n\n\t\terr = php_stream_write(stream, ZSTR_VAL(soap_headers.s), ZSTR_LEN(soap_headers.s));\n\t\tif (err != ZSTR_LEN(soap_headers.s)) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpurl\", sizeof(\"httpurl\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed Sending HTTP SOAP request\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\t\tsmart_str_free(&soap_headers);\n\t} else {\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Failed to create stream??\", NULL, NULL);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (!return_value) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn TRUE;\n\t}\n\n\tdo {\n\t\thttp_headers = get_http_headers(stream);\n\t\tif (!http_headers) {\n\t\t\tif (request != buf) {\n\t\t\t\tzend_string_release(request);\n\t\t\t}\n\t\t\tphp_stream_close(stream);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http headers\", NULL, NULL);\n\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((trace = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"trace\", sizeof(\"trace\")-1)) != NULL &&\n\t\t    (Z_TYPE_P(trace) == IS_TRUE || (Z_TYPE_P(trace) == IS_LONG && Z_LVAL_P(trace) != 0))) {\n\t\t\tadd_property_str(this_ptr, \"__last_response_headers\", zend_string_copy(http_headers));\n\t\t}\n\n\t\t/* Check to see what HTTP status was sent */\n\t\thttp_1_1 = 0;\n\t\thttp_status = 0;\n\t\thttp_version = get_http_header_value(ZSTR_VAL(http_headers), \"HTTP/\");\n\t\tif (http_version) {\n\t\t\tchar *tmp;\n\n\t\t\tif (!strncmp(http_version,\"1.1\", 3)) {\n\t\t\t\thttp_1_1 = 1;\n\t\t\t}\n\n\t\t\ttmp = strstr(http_version,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\thttp_status = atoi(tmp);\n\t\t\t}\n\t\t\ttmp = strstr(tmp,\" \");\n\t\t\tif (tmp != NULL) {\n\t\t\t\ttmp++;\n\t\t\t\tif (http_msg) {\n\t\t\t\t\tefree(http_msg);\n\t\t\t\t}\n\t\t\t\thttp_msg = estrdup(tmp);\n\t\t\t}\n\t\t\tefree(http_version);\n\n\t\t\t/* Try and get headers again */\n\t\t\tif (http_status == 100) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t}\n\t\t}\n\t} while (http_status == 100);\n\n\t/* Grab and send back every cookie */\n\n\t/* Not going to worry about Path: because\n\t   we shouldn't be changing urls so path dont\n\t   matter too much\n\t*/\n\tcookie_itt = strstr(ZSTR_VAL(http_headers), \"Set-Cookie: \");\n\twhile (cookie_itt) {\n\t\tchar *cookie;\n\t\tchar *eqpos, *sempos;\n\t\tzval *cookies;\n\n\t\tif ((cookies = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1)) == NULL ||\n\t\t    Z_TYPE_P(cookies) != IS_ARRAY) {\n\t\t\tzval tmp_cookies;\n\t\t\tarray_init(&tmp_cookies);\n\t\t\tcookies = zend_hash_str_update(Z_OBJPROP_P(this_ptr), \"_cookies\", sizeof(\"_cookies\")-1, &tmp_cookies);\n\t\t}\n\n\t\tcookie = get_http_header_value(cookie_itt,\"Set-Cookie: \");\n\n\t\teqpos = strstr(cookie, \"=\");\n\t\tsempos = strstr(cookie, \";\");\n\t\tif (eqpos != NULL && (sempos == NULL || sempos > eqpos)) {\n\t\t\tsmart_str name = {0};\n\t\t\tint cookie_len;\n\t\t\tzval zcookie;\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tcookie_len = sempos-(eqpos+1);\n\t\t\t} else {\n\t\t\t\tcookie_len = strlen(cookie)-(eqpos-cookie)-1;\n\t\t\t}\n\n\t\t\tsmart_str_appendl(&name, cookie, eqpos - cookie);\n\t\t\tsmart_str_0(&name);\n\n\t\t\tarray_init(&zcookie);\n\t\t\tadd_index_stringl(&zcookie, 0, eqpos + 1, cookie_len);\n\n\t\t\tif (sempos != NULL) {\n\t\t\t\tchar *options = cookie + cookie_len+1;\n\t\t\t\twhile (*options) {\n\t\t\t\t\twhile (*options == ' ') {options++;}\n\t\t\t\t\tsempos = strstr(options, \";\");\n\t\t\t\t\tif (strstr(options,\"path=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"path=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 1, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"domain=\") == options) {\n\t\t\t\t\t\teqpos = options + sizeof(\"domain=\")-1;\n\t\t\t\t\t\tadd_index_stringl(&zcookie, 2, eqpos, sempos?(sempos-eqpos):strlen(eqpos));\n\t\t\t\t\t} else if (strstr(options,\"secure\") == options) {\n\t\t\t\t\t\tadd_index_bool(&zcookie, 3, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (sempos != NULL) {\n\t\t\t\t\t\toptions = sempos+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t  break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 1)) {\n\t\t\t\tchar *t = phpurl->path?phpurl->path:\"/\";\n\t\t\t\tchar *c = strrchr(t, '/');\n\t\t\t\tif (c) {\n\t\t\t\t\tadd_index_stringl(&zcookie, 1, t, c-t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!zend_hash_index_exists(Z_ARRVAL(zcookie), 2)) {\n\t\t\t\tadd_index_string(&zcookie, 2, phpurl->host);\n\t\t\t}\n\n\t\t\tzend_symtable_update(Z_ARRVAL_P(cookies), name.s, &zcookie);\n\t\t\tsmart_str_free(&name);\n\t\t}\n\n\t\tcookie_itt = strstr(cookie_itt + sizeof(\"Set-Cookie: \"), \"Set-Cookie: \");\n\t\tefree(cookie);\n\t}\n\n\t/* See if the server requested a close */\n\tif (http_1_1) {\n\t\thttp_close = FALSE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == FALSE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"close\", sizeof(\"close\")-1) == 0) {\n\t\t\t\t\thttp_close = TRUE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thttp_close = TRUE;\n\t\tif (use_proxy && !use_ssl) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Proxy-Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t\tif (http_close == TRUE) {\n\t\t\tconnection = get_http_header_value(ZSTR_VAL(http_headers), \"Connection: \");\n\t\t\tif (connection) {\n\t\t\t\tif (strncasecmp(connection, \"Keep-Alive\", sizeof(\"Keep-Alive\")-1) == 0) {\n\t\t\t\t\thttp_close = FALSE;\n\t\t\t\t}\n\t\t\t\tefree(connection);\n\t\t\t}\n\t\t}\n\t}\n\n\n\thttp_body = get_http_body(stream, http_close, ZSTR_VAL(http_headers));\n\tif (!http_body) {\n\t\tif (request != buf) {\n\t\t\tzend_string_release(request);\n\t\t}\n\t\tphp_stream_close(stream);\n\t\tzend_string_release(http_headers);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Error Fetching http body, No Content-Length, connection closed or chunked data\", NULL, NULL);\n\t\tif (http_msg) {\n\t\t\tefree(http_msg);\n\t\t}\n\t\tsmart_str_free(&soap_headers_z);\n\t\treturn FALSE;\n\t}\n\n\tif (request != buf) {\n\t\tzend_string_release(request);\n\t}\n\n\tif (http_close) {\n\t\tphp_stream_close(stream);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"httpsocket\", sizeof(\"httpsocket\")-1);\n\t\tzend_hash_str_del(Z_OBJPROP_P(this_ptr), \"_use_proxy\", sizeof(\"_use_proxy\")-1);\n\t\tstream = NULL;\n\t}\n\n\t/* Process HTTP status codes */\n\tif (http_status >= 300 && http_status < 400) {\n\t\tchar *loc;\n\n\t\tif ((loc = get_http_header_value(ZSTR_VAL(http_headers), \"Location: \")) != NULL) {\n\t\t\tphp_url *new_url  = php_url_parse(loc);\n\n\t\t\tif (new_url != NULL) {\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\t\t\t\tefree(loc);\n\t\t\t\tif (new_url->scheme == NULL && new_url->path != NULL) {\n\t\t\t\t\tnew_url->scheme = phpurl->scheme ? estrdup(phpurl->scheme) : NULL;\n\t\t\t\t\tnew_url->host = phpurl->host ? estrdup(phpurl->host) : NULL;\n\t\t\t\t\tnew_url->port = phpurl->port;\n\t\t\t\t\tif (new_url->path && new_url->path[0] != '/') {\n\t\t\t\t\t\tif (phpurl->path) {\n\t\t\t\t\t\t\tchar *t = phpurl->path;\n\t\t\t\t\t\t\tchar *p = strrchr(t, '/');\n\t\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\t\tchar *s = emalloc((p - t) + strlen(new_url->path) + 2);\n\t\t\t\t\t\t\t\tstrncpy(s, t, (p - t) + 1);\n\t\t\t\t\t\t\t\ts[(p - t) + 1] = 0;\n\t\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *s = emalloc(strlen(new_url->path) + 2);\n\t\t\t\t\t\t\ts[0] = '/'; s[1] = 0;\n\t\t\t\t\t\t\tstrcat(s, new_url->path);\n\t\t\t\t\t\t\tefree(new_url->path);\n\t\t\t\t\t\t\tnew_url->path = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tif (--redirect_max < 1) {\n\t\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Redirection limit reached, aborting\", NULL, NULL);\n\t\t\t\t\tsmart_str_free(&soap_headers_z);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t} else if (http_status == 401) {\n\t\t/* Digest authentication */\n\t\tzval *digest, *login, *password;\n\t\tchar *auth = get_http_header_value(ZSTR_VAL(http_headers), \"WWW-Authenticate: \");\n\n\t\tif (auth &&\n\t\t\t\tstrstr(auth, \"Digest\") == auth &&\n\t\t    ((digest = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_digest\", sizeof(\"_digest\")-1)) == NULL ||\n\t\t     Z_TYPE_P(digest) != IS_ARRAY) &&\n\t\t    (login = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_login\", sizeof(\"_login\")-1)) != NULL &&\n\t\t    Z_TYPE_P(login) == IS_STRING &&\n\t\t    (password = zend_hash_str_find(Z_OBJPROP_P(this_ptr), \"_password\", sizeof(\"_password\")-1)) != NULL &&\n\t\t    Z_TYPE_P(password) == IS_STRING) {\n\t\t\tchar *s;\n\t\t\tzval digest;\n\n\t\t\tZVAL_UNDEF(&digest);\n\t\t\ts = auth + sizeof(\"Digest\")-1;\n\t\t\twhile (*s != '\\0') {\n\t\t\t\tchar *name, *val;\n\t\t\t\twhile (*s == ' ') ++s;\n\t\t\t\tname = s;\n\t\t\t\twhile (*s != '\\0' && *s != '=') ++s;\n\t\t\t\tif (*s == '=') {\n\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t++s;\n\t\t\t\t\tif (*s == '\"') {\n\t\t\t\t\t\t++s;\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != '\"') ++s;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = s;\n\t\t\t\t\t\twhile (*s != '\\0' && *s != ' ' && *s != ',') ++s;\n\t\t\t\t\t}\n\t\t\t\t\tif (*s != '\\0') {\n\t\t\t\t\t\tif (*s != ',') {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t\twhile (*s != '\\0' && *s != ',') ++s;\n\t\t\t\t\t\t\tif (*s != '\\0') ++s;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*s = '\\0';\n\t\t\t\t\t\t\t++s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_TYPE(digest) == IS_UNDEF) {\n\t\t\t\t\t\tarray_init(&digest);\n\t\t\t\t\t}\n\t\t\t\t\tadd_assoc_string(&digest, name, val);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Z_TYPE(digest) != IS_UNDEF) {\n\t\t\t\tphp_url *new_url  = emalloc(sizeof(php_url));\n\n\t\t\t\tZ_DELREF(digest);\n\t\t\t\tadd_property_zval_ex(this_ptr, \"_digest\", sizeof(\"_digest\")-1, &digest);\n\n\t\t\t\t*new_url = *phpurl;\n\t\t\t\tif (phpurl->scheme) phpurl->scheme = estrdup(phpurl->scheme);\n\t\t\t\tif (phpurl->user) phpurl->user = estrdup(phpurl->user);\n\t\t\t\tif (phpurl->pass) phpurl->pass = estrdup(phpurl->pass);\n\t\t\t\tif (phpurl->host) phpurl->host = estrdup(phpurl->host);\n\t\t\t\tif (phpurl->path) phpurl->path = estrdup(phpurl->path);\n\t\t\t\tif (phpurl->query) phpurl->query = estrdup(phpurl->query);\n\t\t\t\tif (phpurl->fragment) phpurl->fragment = estrdup(phpurl->fragment);\n\t\t\t\tphpurl = new_url;\n\n\t\t\t\tefree(auth);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tzend_string_release(http_body);\n\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t\tif (auth) efree(auth);\n\t}\n\tsmart_str_free(&soap_headers_z);\n\n\t/* Check and see if the server even sent a xml document */\n\tcontent_type = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Type: \");\n\tif (content_type) {\n\t\tchar *pos = NULL;\n\t\tint cmplen;\n\t\tpos = strstr(content_type,\";\");\n\t\tif (pos != NULL) {\n\t\t\tcmplen = pos - content_type;\n\t\t} else {\n\t\t\tcmplen = strlen(content_type);\n\t\t}\n\t\tif (strncmp(content_type, \"text/xml\", cmplen) == 0 ||\n\t\t    strncmp(content_type, \"application/soap+xml\", cmplen) == 0) {\n\t\t\tcontent_type_xml = 1;\n/*\n\t\t\tif (strncmp(http_body, \"<?xml\", 5)) {\n\t\t\t\tzval *err;\n\t\t\t\tMAKE_STD_ZVAL(err);\n\t\t\t\tZVAL_STRINGL(err, http_body, http_body_size, 1);\n\t\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Didn't receive an xml document\", NULL, err);\n\t\t\t\tefree(content_type);\n\t\t\t\tzend_string_release(http_headers);\n\t\t\t\tefree(http_body);\n\t\t\t\treturn FALSE;\n\t\t\t}\n*/\n\t\t}\n\t\tefree(content_type);\n\t}\n\n\t/* Decompress response */\n\tcontent_encoding = get_http_header_value(ZSTR_VAL(http_headers), \"Content-Encoding: \");\n\tif (content_encoding) {\n\t\tzval func;\n\t\tzval retval;\n\t\tzval params[1];\n\n\t\tif ((strcmp(content_encoding,\"gzip\") == 0 ||\n\t\t     strcmp(content_encoding,\"x-gzip\") == 0) &&\n\t\t     zend_hash_str_exists(EG(function_table), \"gzinflate\", sizeof(\"gzinflate\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzinflate\");\n\t\t\tZVAL_STRINGL(&params[0], http_body->val+10, http_body->len-10);\n\t\t} else if (strcmp(content_encoding,\"deflate\") == 0 &&\n\t\t           zend_hash_str_exists(EG(function_table), \"gzuncompress\", sizeof(\"gzuncompress\")-1)) {\n\t\t\tZVAL_STRING(&func, \"gzuncompress\");\n\t\t\tZVAL_STR_COPY(&params[0], http_body);\n\t\t} else {\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Unknown Content-Encoding\", NULL, NULL);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (call_user_function(CG(function_table), (zval*)NULL, &func, &retval, 1, params) == SUCCESS &&\n\t\t    Z_TYPE(retval) == IS_STRING) {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tzend_string_release(http_body);\n\t\t\tZVAL_COPY_VALUE(return_value, &retval);\n\t\t} else {\n\t\t\tzval_ptr_dtor(&params[0]);\n\t\t\tzval_ptr_dtor(&func);\n\t\t\tefree(content_encoding);\n\t\t\tzend_string_release(http_headers);\n\t\t\tzend_string_release(http_body);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", \"Can't uncompress compressed response\", NULL, NULL);\n\t\t\tif (http_msg) {\n\t\t\t\tefree(http_msg);\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tefree(content_encoding);\n\t} else {\n\t\tZVAL_STR(return_value, http_body);\n\t}\n\n\tzend_string_release(http_headers);\n\n\tif (http_status >= 400) {\n\t\tint error = 0;\n\n\t\tif (Z_STRLEN_P(return_value) == 0) {\n\t\t\terror = 1;\n\t\t} else if (Z_STRLEN_P(return_value) > 0) {\n\t\t\tif (!content_type_xml) {\n\t\t\t\tchar *s = Z_STRVAL_P(return_value);\n\n\t\t\t\twhile (*s != '\\0' && *s < ' ') {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif (strncmp(s, \"<?xml\", 5)) {\n\t\t\t\t\terror = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tzval_ptr_dtor(return_value);\n\t\t\tZVAL_UNDEF(return_value);\n\t\t\tadd_soap_fault(this_ptr, \"HTTP\", http_msg, NULL, NULL);\n\t\t\tefree(http_msg);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (http_msg) {\n\t\tefree(http_msg);\n\t}\n\n\treturn TRUE;\n}", "target": 1, "cwe": ["CWE-20"], "project": "php-src", "commit_id": "eaf4e77190d402ea014207e9a7d5da1a4f3727ba", "hash": 16680681654451252473423707060664857637, "size": 1007, "message": "Fix bug #71610: Type Confusion Vulnerability - SOAP / make_http_soap_request()", "idx": 690}
{"func": "_gnutls_x509_verify_certificate (const gnutls_x509_crt_t * certificate_list,\n\t\t\t\t int clist_size,\n\t\t\t\t const gnutls_x509_crt_t * trusted_cas,\n\t\t\t\t int tcas_size,\n\t\t\t\t const gnutls_x509_crl_t * CRLs,\n\t\t\t\t int crls_size, unsigned int flags)\n{\n  int i = 0, ret;\n  unsigned int status = 0, output;\n\n  if (clist_size > 1)\n    {\n      /* Check if the last certificate in the path is self signed.\n       * In that case ignore it (a certificate is trusted only if it\n       * leads to a trusted party by us, not the server's).\n       *\n       * This prevents from verifying self signed certificates against\n       * themselves. This (although not bad) caused verification\n       * failures on some root self signed certificates that use the\n       * MD2 algorithm.\n       */\n      if (gnutls_x509_crt_check_issuer (certificate_list[clist_size - 1],\n\t\t\t\t    certificate_list[clist_size - 1]) > 0)\n\t{\n\t  clist_size--;\n\t}\n    }\n\n  /* We want to shorten the chain by removing the cert that matches\n   * one of the certs we trust and all the certs after that i.e. if\n   * cert chain is A signed-by B signed-by C signed-by D (signed-by\n   * self-signed E but already removed above), and we trust B, remove\n   * B, C and D.  We must leave the first cert on chain. */\n  if (clist_size > 1 && !(flags & GNUTLS_VERIFY_DO_NOT_ALLOW_SAME))\n    {\n      for (i = 1; i < clist_size; i++)\n\t{\n\t  int j;\n\n\t  for (j = 0; j < tcas_size; j++)\n\t    {\n\t      if (check_if_same_cert (certificate_list[i],\n\t\t\t\t      trusted_cas[j]) == 0)\n\t\t{\n\t\t  clist_size = i;\n\t\t  break;\n\t\t}\n\t    }\n\t  /* clist_size may have been changed which gets out of loop */\n\t}\n    }\n\n  /* Verify the last certificate in the certificate path\n   * against the trusted CA certificate list.\n   *\n   * If no CAs are present returns CERT_INVALID. Thus works\n   * in self signed etc certificates.\n   */\n  ret = _gnutls_verify_certificate2 (certificate_list[clist_size - 1],\n\t\t\t\t     trusted_cas, tcas_size, flags, &output);\n  if (ret == 0)\n    {\n      /* if the last certificate in the certificate\n       * list is invalid, then the certificate is not\n       * trusted.\n       */\n      gnutls_assert ();\n      status |= output;\n      status |= GNUTLS_CERT_INVALID;\n      return status;\n    }\n\n  /* Check for revoked certificates in the chain\n   */\n#ifdef ENABLE_PKI\n  for (i = 0; i < clist_size; i++)\n    {\n      ret = gnutls_x509_crt_check_revocation (certificate_list[i],\n\t\t\t\t\t      CRLs, crls_size);\n      if (ret == 1)\n\t{\t\t\t/* revoked */\n\t  status |= GNUTLS_CERT_REVOKED;\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }\n#endif\n\n  /* Verify the certificate path (chain)\n   */\n  for (i = clist_size - 1; i > 0; i--)\n    {\n      if (i - 1 < 0)\n\tbreak;\n\n      /* note that here we disable this V1 CA flag. So that no version 1\n       * certificates can exist in a supplied chain.\n       */\n      if (!(flags & GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT))\n\tflags ^= GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT;\n      if ((ret =\n\t   _gnutls_verify_certificate2 (certificate_list[i - 1],\n\t\t\t\t\t&certificate_list[i], 1, flags,\n\t\t\t\t\tNULL)) == 0)\n\t{\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-264"], "project": "gnutls", "commit_id": "c8dcbedd1fdc312f5b1a70fcfbc1afe235d800cd", "hash": 30262692539226410936543845333988857426, "size": 112, "message": "Corrected bit disable (was flipping instead).\nInitialy reported by Daniel Kahn Gillmor on 9/1/2008. Many thanks to\nmoog@sysdev.oucs.ox.ac.uk for bringing this into my attention.", "idx": 691}
{"func": "CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)\n{\n    return pthread_self();\n}", "target": 0, "cwe": ["CWE-330"], "project": "openssl", "commit_id": "1b0fe00e2704b5e20334a16d3c9099d1ba2ef1be", "hash": 103913031238305652564677313762580290966, "size": 4, "message": "drbg: ensure fork-safety without using a pthread_atfork handler\n\nWhen the new OpenSSL CSPRNG was introduced in version 1.1.1,\nit was announced in the release notes that it would be fork-safe,\nwhich the old CSPRNG hadn't been.\n\nThe fork-safety was implemented using a fork count, which was\nincremented by a pthread_atfork handler. Initially, this handler\nwas enabled by default. Unfortunately, the default behaviour\nhad to be changed for other reasons in commit b5319bdbd095, so\nthe new OpenSSL CSPRNG failed to keep its promise.\n\nThis commit restores the fork-safety using a different approach.\nIt replaces the fork count by a fork id, which coincides with\nthe process id on UNIX-like operating systems and is zero on other\noperating systems. It is used to detect when an automatic reseed\nafter a fork is necessary.\n\nTo prevent a future regression, it also adds a test to verify that\nthe child reseeds after fork.\n\nCVE-2019-1549\n\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9802)", "idx": 692}
{"func": "compressed_to_ciphertext (gnutls_session_t session,\n                               uint8_t * cipher_data, int cipher_size,\n                               gnutls_datum_t *compressed,\n                               content_type_t type, \n                               record_parameters_st * params)\n{\n  uint8_t * tag_ptr = NULL;\n  uint8_t pad;\n  int length, length_to_encrypt, ret;\n  uint8_t preamble[MAX_PREAMBLE_SIZE];\n  int preamble_size;\n  int tag_size = _gnutls_auth_cipher_tag_len (&params->write.cipher_state);\n  int blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n  unsigned block_algo =\n    _gnutls_cipher_is_block (params->cipher_algorithm);\n  uint8_t *data_ptr;\n  int ver = gnutls_protocol_get_version (session);\n  int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n  int auth_cipher = _gnutls_auth_cipher_is_aead(&params->write.cipher_state);\n  int random_pad;\n  \n  /* We don't use long padding if requested or if we are in DTLS.\n   */\n  if (session->internals.priorities.no_padding == 0 && (!IS_DTLS(session)))\n    random_pad = 1;\n  else\n    random_pad = 0;\n  \n  _gnutls_hard_log(\"ENC[%p]: cipher: %s, MAC: %s, Epoch: %u\\n\",\n    session, gnutls_cipher_get_name(params->cipher_algorithm), gnutls_mac_get_name(params->mac_algorithm),\n    (unsigned int)params->epoch);\n\n  preamble_size =\n    make_preamble (UINT64DATA\n                   (params->write.sequence_number),\n                   type, compressed->size, ver, preamble);\n\n  /* Calculate the encrypted length (padding etc.)\n   */\n  length_to_encrypt = length =\n    calc_enc_length (session, compressed->size, tag_size, &pad,\n                     random_pad, block_algo, auth_cipher, blocksize);\n  if (length < 0)\n    {\n      return gnutls_assert_val(length);\n    }\n\n  /* copy the encrypted data to cipher_data.\n   */\n  if (cipher_size < length)\n    {\n      return gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n    }\n\n  data_ptr = cipher_data;\n\n  if (explicit_iv)\n    {\n\n      if (block_algo == CIPHER_BLOCK)\n        {\n          /* copy the random IV.\n           */\n          ret = _gnutls_rnd (GNUTLS_RND_NONCE, data_ptr, blocksize);\n          if (ret < 0)\n            return gnutls_assert_val(ret);\n\n          _gnutls_auth_cipher_setiv(&params->write.cipher_state, data_ptr, blocksize);\n\n          data_ptr += blocksize;\n          cipher_data += blocksize;\n          length_to_encrypt -= blocksize;\n        }\n      else if (auth_cipher)\n        {\n          uint8_t nonce[blocksize];\n\n          /* Values in AEAD are pretty fixed in TLS 1.2 for 128-bit block\n           */\n          if (params->write.IV.data == NULL || params->write.IV.size != AEAD_IMPLICIT_DATA_SIZE)\n            return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n\n          /* Instead of generating a new nonce on every packet, we use the\n           * write.sequence_number (It is a MAY on RFC 5288).\n           */\n          memcpy(nonce, params->write.IV.data, params->write.IV.size);\n          memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], UINT64DATA(params->write.sequence_number), 8);\n\n          _gnutls_auth_cipher_setiv(&params->write.cipher_state, nonce, AEAD_IMPLICIT_DATA_SIZE+AEAD_EXPLICIT_DATA_SIZE);\n\n          /* copy the explicit part */\n          memcpy(data_ptr, &nonce[AEAD_IMPLICIT_DATA_SIZE], AEAD_EXPLICIT_DATA_SIZE);\n\n          data_ptr += AEAD_EXPLICIT_DATA_SIZE;\n          cipher_data += AEAD_EXPLICIT_DATA_SIZE;\n          /* In AEAD ciphers we don't encrypt the tag \n           */\n          length_to_encrypt -= AEAD_EXPLICIT_DATA_SIZE + tag_size;\n        }\n    }\n  else\n    {\n      /* AEAD ciphers have an explicit IV. Shouldn't be used otherwise.\n       */\n      if (auth_cipher) return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n    }\n\n  memcpy (data_ptr, compressed->data, compressed->size);\n  data_ptr += compressed->size;\n\n  if (tag_size > 0)\n    {\n      tag_ptr = data_ptr;\n      data_ptr += tag_size;\n    }\n  if (block_algo == CIPHER_BLOCK && pad > 0)\n    {\n      memset (data_ptr, pad - 1, pad);\n    }\n\n  /* add the authenticate data */\n  ret = _gnutls_auth_cipher_add_auth(&params->write.cipher_state, preamble, preamble_size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  /* Actual encryption (inplace).\n   */\n  ret =\n    _gnutls_auth_cipher_encrypt2_tag (&params->write.cipher_state,\n        cipher_data, length_to_encrypt, \n        cipher_data, cipher_size,\n        tag_ptr, tag_size, compressed->size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-310"], "project": "gnutls", "commit_id": "b495740f2ff66550ca9395b3fda3ea32c3acb185", "hash": 240626911650660587828314023794230799062, "size": 137, "message": "changes in packet parsing.", "idx": 693}
{"func": "static void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wait);\n\tspin_lock(&inode_hash_lock);\n}", "target": 0, "cwe": ["CWE-284", "CWE-264"], "project": "linux", "commit_id": "23adbe12ef7d3d4195e80800ab36b37bee28cd03", "hash": 218452242908722492358168146418521136514, "size": 12, "message": "fs,userns: Change inode_capable to capable_wrt_inode_uidgid\n\nThe kernel has no concept of capabilities with respect to inodes; inodes\nexist independently of namespaces.  For example, inode_capable(inode,\nCAP_LINUX_IMMUTABLE) would be nonsense.\n\nThis patch changes inode_capable to check for uid and gid mappings and\nrenames it to capable_wrt_inode_uidgid, which should make it more\nobvious what it does.\n\nFixes CVE-2014-4014.\n\nCc: Theodore Ts'o <tytso@mit.edu>\nCc: Serge Hallyn <serge.hallyn@ubuntu.com>\nCc: \"Eric W. Biederman\" <ebiederm@xmission.com>\nCc: Dave Chinner <david@fromorbit.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 694}
{"func": "void HBasicBlock::Verify() {\n  // Check that every block is finished.\n  ASSERT(IsFinished());\n  ASSERT(block_id() >= 0);\n\n  // Check that the incoming edges are in edge split form.\n  if (predecessors_.length() > 1) {\n    for (int i = 0; i < predecessors_.length(); ++i) {\n      ASSERT(predecessors_[i]->end()->SecondSuccessor() == NULL);\n    }\n  }\n}", "target": 0, "cwe": [], "project": "node", "commit_id": "fd80a31e0697d6317ce8c2d289575399f4e06d21", "hash": 8138361073505076488531245082583519727, "size": 12, "message": "deps: backport 5f836c from v8 upstream\n\nOriginal commit message:\n\n    Fix Hydrogen bounds check elimination\n\n    When combining bounds checks, they must all be moved before the first load/store\n    that they are guarding.\n\n    BUG=chromium:344186\n    LOG=y\n    R=svenpanne@chromium.org\n\n    Review URL: https://codereview.chromium.org/172093002\n\n    git-svn-id: https://v8.googlecode.com/svn/branches/bleeding_edge@19475 ce2b1a6d-e550-0410-aec6-3dcde31c8c00\n\nfix #8070", "idx": 695}
{"func": "fetch_name_with_level(OnigCodePoint start_code, UChar** src, UChar* end,\n\t\t      UChar** rname_end, ScanEnv* env,\n\t\t      int* rback_num, int* rlevel)\n{\n  int r, sign, is_num, exist_level;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n  is_num = exist_level = 0;\n  sign = 1;\n  pnum_head = *src;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  r = 0;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else if (!ONIGENC_IS_CODE_NAME(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n    PFETCH(c);\n    if (c == end_code || c == ')' || c == '+' || c == '-') {\n      if (is_num == 2) r = ONIGERR_INVALID_GROUP_NAME;\n      break;\n    }\n\n    if (is_num != 0) {\n      if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n\tis_num = 1;\n      }\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_NAME(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0 && c != end_code) {\n    if (c == '+' || c == '-') {\n      int level;\n      int flag = (c == '-' ? -1 : 1);\n\n      PFETCH(c);\n      if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto err;\n      PUNFETCH;\n      level = onig_scan_unsigned_number(&p, end, enc);\n      if (level < 0) return ONIGERR_TOO_BIG_NUMBER;\n      *rlevel = (level * flag);\n      exist_level = 1;\n\n      PFETCH(c);\n      if (c == end_code)\n\tgoto end;\n    }\n\n  err:\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n end:\n  if (r == 0) {\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) goto err;\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return (exist_level ? 1 : 0);\n  }\n  else {\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}", "target": 1, "cwe": ["CWE-125"], "project": "Onigmo", "commit_id": "29e7e6aedebafd5efbbd90655c8e0d495035d7b4", "hash": 229184723723862716491902223936223279051, "size": 107, "message": "bug: Fix out of bounds read\n\nAdd boundary check before PFETCH.\n\nBased on the following commits on https://github.com/kkos/oniguruma ,\nbut not the same.\n\n* 68c395576813b3f9812427f94d272bcffaca316c\n* dc0a23eb16961f98d2a5a2128d18bd4602058a10\n* 5186c7c706a7f280110e6a0b060f87d0f7d790ce\n* 562bf4825b301693180c674994bf708b28b00592\n* 162cf9124ba3bfaa21d53ebc506f3d9354bfa99b", "idx": 696}
{"func": "static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,\n\t\t\t\t  struct hfi1_user_sdma_comp_q *cq,\n\t\t\t\t  u16 idx, enum hfi1_sdma_comp_state state,\n\t\t\t\t  int ret)\n{\n\tif (state == ERROR)\n\t\tcq->comps[idx].errcode = -ret;\n\tsmp_wmb(); /* make sure errcode is visible first */\n\tcq->comps[idx].status = state;\n\ttrace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,\n\t\t\t\t\tidx, state, ret);\n}", "target": 0, "cwe": ["CWE-416"], "project": "linux", "commit_id": "3d2a9d642512c21a12d19b9250e7a835dcb41a79", "hash": 6313160244644533447240699038290606338, "size": 12, "message": "IB/hfi1: Ensure correct mm is used at all times\n\nTwo earlier bug fixes have created a security problem in the hfi1\ndriver. One fix aimed to solve an issue where current->mm was not valid\nwhen closing the hfi1 cdev. It attempted to do this by saving a cached\nvalue of the current->mm pointer at file open time. This is a problem if\nanother process with access to the FD calls in via write() or ioctl() to\npin pages via the hfi driver. The other fix tried to solve a use after\nfree by taking a reference on the mm.\n\nTo fix this correctly we use the existing cached value of the mm in the\nmmu notifier. Now we can check in the insert, evict, etc. routines that\ncurrent->mm matched what the notifier was registered for. If not, then\ndon't allow access. The register of the mmu notifier will save the mm\npointer.\n\nSince in do_exit() the exit_mm() is called before exit_files(), which\nwould call our close routine a reference is needed on the mm. We rely on\nthe mmgrab done by the registration of the notifier, whereas before it was\nexplicit. The mmu notifier deregistration happens when the user context is\ntorn down, the creation of which triggered the registration.\n\nAlso of note is we do not do any explicit work to protect the interval\ntree notifier. It doesn't seem that this is going to be needed since we\naren't actually doing anything with current->mm. The interval tree\nnotifier stuff still has a FIXME noted from a previous commit that will be\naddressed in a follow on patch.\n\nCc: <stable@vger.kernel.org>\nFixes: e0cf75deab81 (\"IB/hfi1: Fix mm_struct use after free\")\nFixes: 3faa3d9a308e (\"IB/hfi1: Make use of mm consistent\")\nLink: https://lore.kernel.org/r/20201125210112.104301.51331.stgit@awfm-01.aw.intel.com\nSuggested-by: Jann Horn <jannh@google.com>\nReported-by: Jason Gunthorpe <jgg@nvidia.com>\nReviewed-by: Ira Weiny <ira.weiny@intel.com>\nReviewed-by: Mike Marciniszyn <mike.marciniszyn@cornelisnetworks.com>\nSigned-off-by: Dennis Dalessandro <dennis.dalessandro@cornelisnetworks.com>\nSigned-off-by: Jason Gunthorpe <jgg@nvidia.com>", "idx": 697}
{"func": "void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {\n\n  // ensure java/ packages only loaded by boot or platform builtin loaders\n  check_prohibited_package(name(), loader_data, CHECK);\n\n  TempNewSymbol pkg_name = package_from_name(name(), CHECK);\n\n  if (pkg_name != NULL && loader_data != NULL) {\n\n    // Find in class loader's package entry table.\n    _package_entry = loader_data->packages()->lookup_only(pkg_name);\n\n    // If the package name is not found in the loader's package\n    // entry table, it is an indication that the package has not\n    // been defined. Consider it defined within the unnamed module.\n    if (_package_entry == NULL) {\n      ResourceMark rm;\n\n      if (!ModuleEntryTable::javabase_defined()) {\n        // Before java.base is defined during bootstrapping, define all packages in\n        // the java.base module.  If a non-java.base package is erroneously placed\n        // in the java.base module it will be caught later when java.base\n        // is defined by ModuleEntryTable::verify_javabase_packages check.\n        assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME \" module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n      } else {\n        assert(loader_data->unnamed_module() != NULL, \"unnamed module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name,\n                                                         loader_data->unnamed_module());\n      }\n\n      // A package should have been successfully created\n      assert(_package_entry != NULL, \"Package entry for class %s not found, loader %s\",\n             name()->as_C_string(), loader_data->loader_name_and_id());\n    }\n\n    if (log_is_enabled(Debug, module)) {\n      ResourceMark rm;\n      ModuleEntry* m = _package_entry->module();\n      log_trace(module)(\"Setting package: class: %s, package: %s, loader: %s, module: %s\",\n                        external_name(),\n                        pkg_name->as_C_string(),\n                        loader_data->loader_name_and_id(),\n                        (m->is_named() ? m->name()->as_C_string() : UNNAMED_MODULE));\n    }\n  } else {\n    ResourceMark rm;\n    log_trace(module)(\"Setting package: class: %s, package: unnamed, loader: %s, module: %s\",\n                      external_name(),\n                      (loader_data != NULL) ? loader_data->loader_name_and_id() : \"NULL\",\n                      UNNAMED_MODULE);\n  }\n}", "target": 0, "cwe": [], "project": "jdk11u-dev", "commit_id": "41825fa33d605f8501164f9296572e4378e8183b", "hash": 322100181124454672762883261839659062695, "size": 53, "message": "8270386: Better verification of scan methods\n\nReviewed-by: mbaesken\nBackport-of: ac329cef45979bd0159ecd1347e36f7129bb2ce4", "idx": 698}
{"func": "SWTPM_NVRAM_LoadData(unsigned char **data,     /* freed by caller */\n                     uint32_t *length,\n                     uint32_t tpm_number,\n                     const char *name)\n{\n    TPM_RESULT    rc = 0;\n    long          lrc;\n    size_t        src;\n    int           irc;\n    FILE          *file = NULL;\n    char          filename[FILENAME_MAX]; /* rooted file name from name */\n    unsigned char *decrypt_data = NULL;\n    uint32_t      decrypt_length;\n    uint32_t      dataoffset = 0;\n    uint8_t       hdrversion = 0;\n    uint16_t      hdrflags;\n\n    TPM_DEBUG(\" SWTPM_NVRAM_LoadData: From file %s\\n\", name);\n    *data = NULL;\n    *length = 0;\n    /* open the file */\n    if (rc == 0) {\n        /* map name to the rooted filename */\n        rc = SWTPM_NVRAM_GetFilenameForName(filename, sizeof(filename),\n                                            tpm_number, name, false);\n    }\n\n    if (rc == 0) {\n        TPM_DEBUG(\"  SWTPM_NVRAM_LoadData: Opening file %s\\n\", filename);\n        file = fopen(filename, \"rb\");                           /* closed @1 */\n        if (file == NULL) {     /* if failure, determine cause */\n            if (errno == ENOENT) {\n                TPM_DEBUG(\"SWTPM_NVRAM_LoadData: No such file %s\\n\",\n                         filename);\n                rc = TPM_RETRY;         /* first time start up */\n            }\n            else {\n                logprintf(STDERR_FILENO,\n                          \"SWTPM_NVRAM_LoadData: Error (fatal) opening \"\n                          \"%s for read, %s\\n\", filename, strerror(errno));\n                rc = TPM_FAIL;\n            }\n        }\n    }\n\n    if (rc == 0) {\n        if (fchmod(fileno(file), tpmstate_get_mode()) < 0) {\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Could not fchmod %s : %s\\n\",\n                      filename, strerror(errno));\n            rc = TPM_FAIL;\n        }\n    }\n\n    /* determine the file length */\n    if (rc == 0) {\n        irc = fseek(file, 0L, SEEK_END);        /* seek to end of file */\n        if (irc == -1L) {\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Error (fatal) fseek'ing %s, %s\\n\",\n                      filename, strerror(errno));\n            rc = TPM_FAIL;\n        }\n    }\n    if (rc == 0) {\n        lrc = ftell(file);                      /* get position in the stream */\n        if (lrc == -1L) {\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Error (fatal) ftell'ing %s, %s\\n\",\n                      filename, strerror(errno));\n            rc = TPM_FAIL;\n        }\n        else {\n            *length = (uint32_t)lrc;              /* save the length */\n        }\n    }\n    if (rc == 0) {\n        irc = fseek(file, 0L, SEEK_SET);        /* seek back to the beginning of the file */\n        if (irc == -1L) {\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Error (fatal) fseek'ing %s, %s\\n\",\n                      filename, strerror(errno));\n            rc = TPM_FAIL;\n        }\n    }\n    /* allocate a buffer for the actual data */\n    if ((rc == 0) && *length != 0) {\n        TPM_DEBUG(\" SWTPM_NVRAM_LoadData: Reading %u bytes of data\\n\", *length);\n        *data = malloc(*length);\n        if (!*data) {\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Error (fatal) allocating %u \"\n                      \"bytes\\n\", *length);\n            rc = TPM_FAIL;\n        }\n    }\n    /* read the contents of the file into the data buffer */\n    if ((rc == 0) && *length != 0) {\n        src = fread(*data, 1, *length, file);\n        if (src != *length) {\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Error (fatal), data read of %u \"\n                      \"only read %lu\\n\", *length, (unsigned long)src);\n            rc = TPM_FAIL;\n        }\n    }\n    /* close the file */\n    if (file != NULL) {\n        TPM_DEBUG(\" SWTPM_NVRAM_LoadData: Closing file %s\\n\", filename);\n        irc = fclose(file);             /* @1 */\n        if (irc != 0) {\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Error (fatal) closing file %s\\n\",\n                      filename);\n            rc = TPM_FAIL;\n        }\n        else {\n            TPM_DEBUG(\" SWTPM_NVRAM_LoadData: Closed file %s\\n\", filename);\n        }\n    }\n\n    if (rc == 0) {\n        /* this function needs to return the plain data -- no tlv headers */\n\n        /* try to get a header from it -- old files may not have one */\n        irc = SWTPM_NVRAM_CheckHeader(*data, *length, &dataoffset,\n                                      &hdrflags, &hdrversion, true);\n        /* valid header -- this one can only be version 2 or later */\n        if (irc) {\n            hdrversion = 1; /* no header -- payload was written like vers. 1 */\n            hdrflags = 0;\n        }\n\n        rc = SWTPM_NVRAM_GetDecryptedData(&filekey,\n                                          &decrypt_data, &decrypt_length,\n                                          *data + dataoffset,\n                                          *length - dataoffset,\n                                          TAG_ENCRYPTED_DATA, TAG_DATA,\n                                          hdrversion,\n                                          TAG_IVEC_ENCRYPTED_DATA,\n                                          hdrflags,\n                                          BLOB_FLAG_ENCRYPTED_256BIT_KEY);\n        TPM_DEBUG(\" SWTPM_NVRAM_LoadData: SWTPM_NVRAM_GetDecryptedData rc = %d\\n\",\n                  rc);\n        if (rc != 0)\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Error from SWTPM_NVRAM_GetDecryptedData \"\n                      \"rc = %d\\n\", rc);\n\n        if (rc == 0) {\n            TPM_DEBUG(\" SWTPM_NVRAM_LoadData: Decrypted %u bytes of \"\n                      \"data to %u bytes.\\n\",\n                      *length, decrypt_length);\n            free(*data);\n            *data = decrypt_data;\n            *length = decrypt_length;\n        }\n    }\n\n    if (rc != 0) {\n        free(*data);\n        *data = NULL;\n    }\n\n    return rc;\n}", "target": 1, "cwe": [], "project": "swtpm", "commit_id": "2212f25466089937a0ef3f5d44507a2b157c12aa", "hash": 189824624147282067655497416534531961181, "size": 166, "message": "swtpm: Use open() (not fopen()) when accessing statefile (CVE-2020-28407)\n\nThis patch addresses CVE-2020-28407.\n\nUse the open() call rather than the fopen() call when accessing\nthe statefile and make sure we do not follow symlinks using O_NOFOLLOW.\n\nThe modification does not allow an attacker to create a symbolic link\nwith the name of the temporary file (TMP2-00.permall for TPM 2) and\nhave this point to a valueable file and swtpm ends up overwriting the\nfile. The success of the attack depends on the attacker having access\nto the TPM's state directory (--tpmstate dir=...).\n\nSigned-off-by: Stefan Berger <stefanb@linux.ibm.com>", "idx": 699}
{"func": "BGD_DECLARE(gdImagePtr) gdImageClone (gdImagePtr src) {\n\tgdImagePtr dst;\n\tregister int i, x;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(src->sx , src->sy);\n\t} else {\n\t\tdst = gdImageCreate(src->sx , src->sy);\n\t}\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (src->trueColor == 0) {\n\t\tdst->colorsTotal = src->colorsTotal;\n\t\tfor (i = 0; i < gdMaxColors; i++) {\n\t\t\tdst->red[i]   = src->red[i];\n\t\t\tdst->green[i] = src->green[i];\n\t\t\tdst->blue[i]  = src->blue[i];\n\t\t\tdst->alpha[i] = src->alpha[i];\n\t\t\tdst->open[i]  = src->open[i];\n\t\t}\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->pixels[i][x] = src->pixels[i][x];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->tpixels[i][x] = src->tpixels[i][x];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (src->styleLength > 0) {\n\t\tdst->styleLength = src->styleLength;\n\t\tdst->stylePos    = src->stylePos;\n\t\tfor (i = 0; i < src->styleLength; i++) {\n\t\t\tdst->style[i] = src->style[i];\n\t\t}\n\t}\n\n\tdst->interlace   = src->interlace;\n\n\tdst->alphaBlendingFlag = src->alphaBlendingFlag;\n\tdst->saveAlphaFlag     = src->saveAlphaFlag;\n\tdst->AA                = src->AA;\n\tdst->AA_color          = src->AA_color;\n\tdst->AA_dont_blend     = src->AA_dont_blend;\n\n\tdst->cx1 = src->cx1;\n\tdst->cy1 = src->cy1;\n\tdst->cx2 = src->cx2;\n\tdst->cy2 = src->cy2;\n\n\tdst->res_x = src->res_x;\n\tdst->res_y = src->res_y;\n\n\tdst->paletteQuantizationMethod     = src->paletteQuantizationMethod;\n\tdst->paletteQuantizationSpeed      = src->paletteQuantizationSpeed;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\n\tdst->interpolation_id = src->interpolation_id;\n\tdst->interpolation    = src->interpolation;\n\n\tif (src->brush) {\n\t\tdst->brush = gdImageClone(src->brush);\n\t}\n\n\tif (src->tile) {\n\t\tdst->tile = gdImageClone(src->tile);\n\t}\n\n\tif (src->style) {\n\t\tgdImageSetStyle(dst, src->style, src->styleLength);\n\t}\n\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tdst->brushColorMap[i] = src->brushColorMap[i];\n\t\tdst->tileColorMap[i] = src->tileColorMap[i];\n\t}\n\n\tif (src->polyAllocated > 0) {\n\t\tdst->polyAllocated = src->polyAllocated;\n\t\tfor (i = 0; i < src->polyAllocated; i++) {\n\t\t\tdst->polyInts[i] = src->polyInts[i];\n\t\t}\n\t}\n\n\treturn dst;\n}", "target": 1, "cwe": ["CWE-476"], "project": "libgd", "commit_id": "a93eac0e843148dc2d631c3ba80af17e9c8c860f", "hash": 66196013709543052570569488306511280811, "size": 94, "message": "Fix potential NULL pointer dereference in gdImageClone()", "idx": 700}
{"func": "void aes_crypt_ecb( aes_context *ctx,\n                    int mode,\n                    const unsigned char input[16],\n                    unsigned char output[16] )\n{\n    int i;\n    unsigned long *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\n#if defined(XYSSL_PADLOCK_C) && defined(XYSSL_HAVE_X86)\n    if( padlock_supports( PADLOCK_ACE ) )\n    {\n        if( padlock_xcryptecb( ctx, mode, input, output ) == 0 )\n            return;\n    }\n#endif\n\n    RK = ctx->rk;\n\n    GET_ULONG_LE( X0, input,  0 ); X0 ^= *RK++;\n    GET_ULONG_LE( X1, input,  4 ); X1 ^= *RK++;\n    GET_ULONG_LE( X2, input,  8 ); X2 ^= *RK++;\n    GET_ULONG_LE( X3, input, 12 ); X3 ^= *RK++;\n\n    if( mode == AES_DECRYPT )\n    {\n        for( i = (ctx->nr >> 1) - 1; i > 0; i-- )\n        {\n            AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n            AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n        }\n\n        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n        X0 = *RK++ ^ ( RSb[ ( Y0       ) & 0xFF ]       ) ^\n                     ( RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^\n                     ( RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^\n                     ( ((unsigned int)RSb[ ( Y1 >> 24 ) & 0xFF ]) << 24 );\n\n        X1 = *RK++ ^ ( RSb[ ( Y1       ) & 0xFF ]       ) ^\n                     ( RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^\n                     ( RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^\n                     ( ((unsigned int)RSb[ ( Y2 >> 24 ) & 0xFF ]) << 24 );\n\n        X2 = *RK++ ^ ( RSb[ ( Y2       ) & 0xFF ]       ) ^\n                     ( RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^\n                     ( RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^\n                     ( ((unsigned int)RSb[ ( Y3 >> 24 ) & 0xFF ]) << 24 );\n\n        X3 = *RK++ ^ ( RSb[ ( Y3       ) & 0xFF ]       ) ^\n                     ( RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^\n                     ( RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^\n                     ( ((unsigned int)RSb[ ( Y0 >> 24 ) & 0xFF ]) << 24 );\n    }\n    else /* AES_ENCRYPT */\n    {\n        for( i = (ctx->nr >> 1) - 1; i > 0; i-- )\n        {\n            AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n            AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n        }\n\n        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n        X0 = *RK++ ^ ( FSb[ ( Y0       ) & 0xFF ]       ) ^\n                     ( FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^\n                     ( FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^\n                     ( ((unsigned int)FSb[ ( Y3 >> 24 ) & 0xFF ]) << 24 );\n\n        X1 = *RK++ ^ ( FSb[ ( Y1       ) & 0xFF ]       ) ^\n                     ( FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^\n                     ( FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^\n                     ( ((unsigned int)FSb[ ( Y0 >> 24 ) & 0xFF ]) << 24 );\n\n        X2 = *RK++ ^ ( FSb[ ( Y2       ) & 0xFF ]       ) ^\n                     ( FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^\n                     ( FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^\n                     ( ((unsigned int)FSb[ ( Y1 >> 24 ) & 0xFF ]) << 24 );\n\n        X3 = *RK++ ^ ( FSb[ ( Y3       ) & 0xFF ]       ) ^\n                     ( FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^\n                     ( FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^\n                     ( ((unsigned int)FSb[ ( Y2 >> 24 ) & 0xFF ]) << 24 );\n    }\n\n    PUT_ULONG_LE( X0, output,  0 );\n    PUT_ULONG_LE( X1, output,  4 );\n    PUT_ULONG_LE( X2, output,  8 );\n    PUT_ULONG_LE( X3, output, 12 );\n}", "target": 1, "cwe": [], "project": "ghostpdl", "commit_id": "8e9ce5016db968b40e4ec255a3005f2786cce45f", "hash": 280696181287364853818053006888941925625, "size": 89, "message": "Bug 699665 \"memory corruption in aesdecode\"\n\nThe specimen file calls aesdecode without specifying the key to be\nused, though it does manage to do enough work with the PDF interpreter\nroutines to get access to aesdecode (which isn't normally available).\n\nThis causes us to read uninitialised memory, which can (and often does)\nlead to a segmentation fault.\n\nIn this commit we set the key to NULL explicitly during intialisation\nand then check it before we read it. If its NULL we just return.\n\nIt seems bizarre that we don't return error codes, we should probably\nlook into that at some point, but this prevents the code trying to\nread uninitialised memory.", "idx": 701}
{"func": "int htc_send(struct htc_target *target, struct sk_buff *skb)\n{\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\treturn htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);\n}", "target": 0, "cwe": ["CWE-400", "CWE-401"], "project": "linux", "commit_id": "853acf7caf10b828102d92d05b5c101666a6142b", "hash": 312218230749351455489922463256589978713, "size": 7, "message": "ath9k_htc: release allocated buffer if timed out\n\nIn htc_config_pipe_credits, htc_setup_complete, and htc_connect_service\nif time out happens, the allocated buffer needs to be released.\nOtherwise there will be memory leak.\n\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>", "idx": 702}
{"func": "void\nmono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tg_assert (mb);\n\n\tif (mb->mhandle)\n\t\tmono_runtime_free_method (\n\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);", "target": 1, "cwe": ["CWE-399", "CWE-264"], "project": "mono", "commit_id": "3f8ee42b8c867d9a4c18c22657840d072cca5c3a", "hash": 106898839939321849372319975475858145139, "size": 8, "message": "Don't use finalization to cleanup dynamic methods.\n\n        * reflection.c: Use a reference queue to cleanup\n        dynamic methods instead of finalization.\n\n        * runtime.c: Shutdown the dynamic method queue\n        before runtime cleanup begins.\n\n        * DynamicMethod.cs: No longer finalizable.\n\n        * icall-def.h: Remove unused dynamic method icall.\n\n        Fixes #660422\n\n    Implement a reference queue API.\n\n        * gc.c: A reference queue allows one to queue\n        callbcks for when objects are collected.\n        It allows for safe cleanup of objects that can\n        only be done when it is effectively collected.\n        The major difference with regular finalization\n        is that the collector makes sure the object\n        was collected - and can't be resurrected.\n\n        * gc-internal.h: Export entrypoints for the\n        new API.", "idx": 703}
{"func": "BrokenSyncWithServer(XIC xic)\n{\n    CARD32 dummy;\n    XGetICValues(xic, XNFilterEvents, &dummy, NULL);\n}", "target": 0, "cwe": ["CWE-190"], "project": "libx11", "commit_id": "1a566c9e00e5f35c1f9e7f3d741a02e5170852b2", "hash": 101088629813819113641386544151088674885, "size": 5, "message": "Zero out buffers in functions\n\nIt looks like uninitialized stack or heap memory can leak\nout via padding bytes.\n\nSigned-off-by: Matthieu Herrb <matthieu@herrb.eu>\nReviewed-by: Matthieu Herrb <matthieu@herrb.eu>", "idx": 704}
{"func": "static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct cpu *cpu = container_of(dev, struct cpu, dev);\n\tssize_t rc;\n\tunsigned long long addr;\n\tint cpunum;\n\n\tcpunum = cpu->dev.id;\n\n\t/*\n\t * Might be reading other cpu's data based on which cpu read thread\n\t * has been scheduled. But cpu data (memory) is allocated once during\n\t * boot up and this data does not change there after. Hence this\n\t * operation should be safe. No locking required.\n\t */\n\taddr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));\n\trc = sprintf(buf, \"%Lx\\n\", addr);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "aa838896d87af561a33ecefea1caa4c15a68bc47", "hash": 43907821723267695673370168648092126372, "size": 20, "message": "drivers core: Use sysfs_emit and sysfs_emit_at for show(device *...) functions\n\nConvert the various sprintf fmaily calls in sysfs device show functions\nto sysfs_emit and sysfs_emit_at for PAGE_SIZE buffer safety.\n\nDone with:\n\n$ spatch -sp-file sysfs_emit_dev.cocci --in-place --max-width=80 .\n\nAnd cocci script:\n\n$ cat sysfs_emit_dev.cocci\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tstrcpy(buf, chr);\n+\tsysfs_emit(buf, chr);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n-\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n+\tlen += sysfs_emit_at(buf, len,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t...\n-\tstrcpy(buf, chr);\n-\treturn strlen(buf);\n+\treturn sysfs_emit(buf, chr);\n}\n\nSigned-off-by: Joe Perches <joe@perches.com>\nLink: https://lore.kernel.org/r/3d033c33056d88bbe34d4ddb62afd05ee166ab9a.1600285923.git.joe@perches.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 705}
{"func": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params =\n      reinterpret_cast<const TfLiteGatherParams*>(node->builtin_data);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* positions;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputPositions, &positions));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (positions->type == kTfLiteInt32) {\n    switch (input->type) {\n      case kTfLiteFloat32:\n        return Gather<float, int32_t>(*params, input, positions, output);\n      case kTfLiteUInt8:\n        return Gather<uint8_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt8:\n        return Gather<int8_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt16:\n        return Gather<int16_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt32:\n        return Gather<int32_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt64:\n        return Gather<int64_t, int32_t>(*params, input, positions, output);\n      case kTfLiteBool:\n        return Gather<bool, int32_t>(*params, input, positions, output);\n      case kTfLiteString:\n        return GatherStrings<int32_t>(context, input, positions, output);\n      default:\n        context->ReportError(context, \"Type '%s' is not supported by gather.\",\n                             TfLiteTypeGetName(input->type));\n        return kTfLiteError;\n    }\n  }\n  if (positions->type == kTfLiteInt64) {\n    switch (input->type) {\n      case kTfLiteFloat32:\n        return Gather<float, int64_t>(*params, input, positions, output);\n      case kTfLiteUInt8:\n        return Gather<uint8_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt8:\n        return Gather<int8_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt16:\n        return Gather<int16_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt32:\n        return Gather<int32_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt64:\n        return Gather<int64_t, int64_t>(*params, input, positions, output);\n      case kTfLiteBool:\n        return Gather<bool, int64_t>(*params, input, positions, output);\n      case kTfLiteString:\n        return GatherStrings<int64_t>(context, input, positions, output);\n      default:\n        context->ReportError(context, \"Type '%s' is not supported by gather.\",\n                             TfLiteTypeGetName(input->type));\n        return kTfLiteError;\n    }\n  }\n  context->ReportError(context,\n                       \"Positions of type '%s' are not supported by gather.\",\n                       TfLiteTypeGetName(positions->type));\n  return kTfLiteError;\n}", "target": 1, "cwe": ["CWE-703", "CWE-125"], "project": "tensorflow", "commit_id": "eb921122119a6b6e470ee98b89e65d721663179d", "hash": 160741082237820179832256045915711132149, "size": 65, "message": "Prevent heap OOB read in TFLite's `gather.cc`.\n\nPassing negative indices is illegal but there was a missing check so that resulted in OOB accesses.\n\nPiperOrigin-RevId: 387231300\nChange-Id: I3111b54b2f232638d795be17efc46abe4ede6bf8", "idx": 706}
{"func": "  bool IsSupported(const NodeDef* node) const override {\n    return IsAnySparseSegmentReduction(*node);\n  }", "target": 0, "cwe": ["CWE-476"], "project": "tensorflow", "commit_id": "e6340f0665d53716ef3197ada88936c2a5f7a2d3", "hash": 180758896254904532004405683056986678919, "size": 3, "message": "Handle a special grappler case resulting in crash.\n\nIt might happen that a malformed input could be used to trick Grappler into trying to optimize a node with no inputs. This, in turn, would produce a null pointer dereference and a segfault.\n\nPiperOrigin-RevId: 369242852\nChange-Id: I2e5cbe7aec243d34a6d60220ac8ac9b16f136f6b", "idx": 707}
{"func": "static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "project": "jasper", "commit_id": "5dbe57e4808bea4b83a97e2f4aaf8c91ab6fdecb", "hash": 48161187569654599586129200003178065009, "size": 25, "message": "CVE-2014-9029", "idx": 708}
{"func": "compare_tor_addr_to_addr_policy(const tor_addr_t *addr, uint16_t port,\n                                const smartlist_t *policy)\n{\n  if (!policy) {\n    /* no policy? accept all. */\n    return ADDR_POLICY_ACCEPTED;\n  } else if (tor_addr_is_null(addr)) {\n    tor_assert(port != 0);\n    return compare_unknown_tor_addr_to_addr_policy(port, policy);\n  } else if (port == 0) {\n    return compare_known_tor_addr_to_addr_policy_noport(addr, policy);\n  } else {\n    return compare_known_tor_addr_to_addr_policy(addr, port, policy);\n  }\n}", "target": 1, "cwe": [], "project": "tor", "commit_id": "62d96284f7e0f81c40d5df7e53dd7b4dfe7e56a5", "hash": 168375241997598366898234723142875287286, "size": 15, "message": "Do not assert when comparing a null address/port against a policy\n\nThis can create a remote crash opportunity for/against directory\nauthorities.", "idx": 709}
{"func": "    inline CmdLine::CmdLine() :\n        port(DefaultDBPort), rest(false), jsonp(false), indexBuildRetry(true), quiet(false),\n        noTableScan(false), prealloc(true), preallocj(true), smallfiles(sizeof(int*) == 4),\n        configsvr(false), quota(false), quotaFiles(8), cpu(false),\n        durOptions(0), objcheck(false), oplogSize(0), defaultProfile(0),\n        slowMS(100), defaultLocalThresholdMillis(15), pretouch(0), moveParanoia( true ),\n        syncdelay(60), noUnixSocket(false), doFork(0), socket(\"/tmp\"), maxConns(DEFAULT_MAX_CONN),\n        logAppend(false), logWithSyslog(false)\n    {\n        started = time(0);\n\n        journalCommitInterval = 0; // 0 means use default\n        dur = false;\n#if defined(_DURABLEDEFAULTON)\n        dur = true;\n#endif\n        if( sizeof(void*) == 8 )\n            dur = true;\n#if defined(_DURABLEDEFAULTOFF)\n        dur = false;\n#endif\n\n#ifdef MONGO_SSL\n        sslOnNormalPorts = false;\n#endif\n    }", "target": 1, "cwe": ["CWE-20"], "project": "mongo", "commit_id": "f9817a6cf64bdba8e1e1cef30a798110df746b58", "hash": 218853864294162605548385491519438899050, "size": 26, "message": "SERVER-7769 - turn objcheck on by default and use new fast bson validate", "idx": 710}
{"func": "void SSL_set_accept_state(SSL *s)\n\t{\n\ts->server=1;\n\ts->shutdown=0;\n\ts->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;\n\ts->handshake_func=s->method->ssl_accept;\n\t/* clear the current cipher */\n\tssl_clear_cipher_ctx(s);\n\t}", "target": 0, "cwe": ["CWE-310"], "project": "openssl", "commit_id": "c6a876473cbff0fd323c8abcaace98ee2d21863d", "hash": 201041724246975012810022635253699595127, "size": 9, "message": "Support TLS_FALLBACK_SCSV.\n\nReviewed-by: Stephen Henson <steve@openssl.org>", "idx": 711}
{"func": "static void defer_open(struct share_mode_lock *lck,\n\t\t       struct timeval request_time,\n\t\t       struct timeval timeout,\n\t\t       struct smb_request *req,\n\t\t       struct deferred_open_record *state)\n{\n\tstruct deferred_open_record *open_rec;\n\n\tDEBUG(10,(\"defer_open_sharing_error: time [%u.%06u] adding deferred \"\n\t\t  \"open entry for mid %llu\\n\",\n\t\t  (unsigned int)request_time.tv_sec,\n\t\t  (unsigned int)request_time.tv_usec,\n\t\t  (unsigned long long)req->mid));\n\n\topen_rec = talloc(NULL, struct deferred_open_record);\n\tif (open_rec == NULL) {\n\t\tTALLOC_FREE(lck);\n\t\texit_server(\"talloc failed\");\n\t}\n\n\t*open_rec = *state;\n\n\tif (lck) {\n\t\tstruct defer_open_state *watch_state;\n\t\tstruct tevent_req *watch_req;\n\t\tbool ret;\n\n\t\twatch_state = talloc(open_rec, struct defer_open_state);\n\t\tif (watch_state == NULL) {\n\t\t\texit_server(\"talloc failed\");\n\t\t}\n\t\twatch_state->xconn = req->xconn;\n\t\twatch_state->mid = req->mid;\n\n\t\tDEBUG(10, (\"defering mid %llu\\n\",\n\t\t\t   (unsigned long long)req->mid));\n\n\t\twatch_req = dbwrap_watched_watch_send(\n\t\t\twatch_state, req->sconn->ev_ctx, lck->data->record,\n\t\t\t(struct server_id){0});\n\t\tif (watch_req == NULL) {\n\t\t\texit_server(\"Could not watch share mode record\");\n\t\t}\n\t\ttevent_req_set_callback(watch_req, defer_open_done,\n\t\t\t\t\twatch_state);\n\n\t\tret = tevent_req_set_endtime(\n\t\t\twatch_req, req->sconn->ev_ctx,\n\t\t\ttimeval_sum(&request_time, &timeout));\n\t\tSMB_ASSERT(ret);\n\t}\n\n\tif (!push_deferred_open_message_smb(req, request_time, timeout,\n\t\t\t\t\t    state->id, open_rec)) {\n\t\tTALLOC_FREE(lck);\n\t\texit_server(\"push_deferred_open_message_smb failed\");\n\t}\n}", "target": 0, "cwe": ["CWE-835"], "project": "samba", "commit_id": "10c3e3923022485c720f322ca4f0aca5d7501310", "hash": 126022895441211375693479329856112629233, "size": 58, "message": "s3: smbd: Don't loop infinitely on bad-symlink resolution.\n\nIn the FILE_OPEN_IF case we have O_CREAT, but not\nO_EXCL. Previously we went into a loop trying first\n~(O_CREAT|O_EXCL), and if that returned ENOENT\ntry (O_CREAT|O_EXCL). We kept looping indefinately\nuntil we got an error, or the file was created or\nopened.\n\nThe big problem here is dangling symlinks. Opening\nwithout O_NOFOLLOW means both bad symlink\nand missing path return -1, ENOENT from open(). As POSIX\nis pathname based it's not possible to tell\nthe difference between these two cases in a\nnon-racy way, so change to try only two attempts before\ngiving up.\n\nWe don't have this problem for the O_NOFOLLOW\ncase as we just return NT_STATUS_OBJECT_PATH_NOT_FOUND\nmapped from the ELOOP POSIX error and immediately\nreturned.\n\nUnroll the loop logic to two tries instead.\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=12572\n\nPair-programmed-with: Ralph Boehme <slow@samba.org>\n\nSigned-off-by: Jeremy Allison <jra@samba.org>\nSigned-off-by: Ralph Boehme <slow@samba.org>\nReviewed-by: Ralph Boehme <slow@samba.org>", "idx": 712}
{"func": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    if (thp == NULL) {\n        /* Default advertisement. */\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}", "target": 1, "cwe": ["CWE-200"], "project": "tang", "commit_id": "e82459fda10f0630c3414ed2afbc6320bb9ea7c9", "hash": 236897491384146822955753114215520486623, "size": 16, "message": "keys: move signing part out of find_by_thp() and to find_jws() (#81)\n\nHandle just signing keys in find_jws(), to make sure we are\r\nresponding only to proper queries.\r\n\r\nTests were also failing to detect this issue and were updated\r\naccordingly.\r\n\r\nIssue discovered by Twitter Kernel and OS team during a source\r\ncode audit while evaluating Tang/Clevis for their needs.\r\n\r\nFixes CVE-2021-4076", "idx": 713}
{"func": "static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n\n  PixelInfo\n    *color_1,\n    *color_2;\n\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}", "target": 1, "cwe": ["CWE-190"], "project": "ImageMagick", "commit_id": "d44f8a35558951a21367d306a42e5a097f3a43fe", "hash": 121912148049890612319778043235182836016, "size": 15, "message": "https://github.com/ImageMagick/ImageMagick/issues/1720", "idx": 714}
{"func": "void Scanner::lex_c_comment()\n{\nloop:\n\n#line 3708 \"src/parse/lex.cc\"\n{\n\tunsigned char yych;\n\tif ((lim - cur) < 2) { if (!fill(2)) { error(\"unexpected end of input\"); exit(1); } }\n\tyych = (unsigned char)*cur;\n\tif (yych <= '\\f') {\n\t\tif (yych <= 0x00) goto yy554;\n\t\tif (yych == '\\n') goto yy558;\n\t\tgoto yy556;\n\t} else {\n\t\tif (yych <= '\\r') goto yy560;\n\t\tif (yych == '*') goto yy561;\n\t\tgoto yy556;\n\t}\nyy554:\n\t++cur;\n#line 722 \"../src/parse/lex.re\"\n\t{ fail_if_eof(); goto loop; }\n#line 3726 \"src/parse/lex.cc\"\nyy556:\n\t++cur;\nyy557:\n#line 723 \"../src/parse/lex.re\"\n\t{ goto loop; }\n#line 3732 \"src/parse/lex.cc\"\nyy558:\n\t++cur;\n#line 721 \"../src/parse/lex.re\"\n\t{ next_line(); goto loop; }\n#line 3737 \"src/parse/lex.cc\"\nyy560:\n\tyych = (unsigned char)*++cur;\n\tif (yych == '\\n') goto yy558;\n\tgoto yy557;\nyy561:\n\tyych = (unsigned char)*++cur;\n\tif (yych != '/') goto yy557;\n\t++cur;\n#line 720 \"../src/parse/lex.re\"\n\t{ return; }\n#line 3748 \"src/parse/lex.cc\"\n}\n#line 724 \"../src/parse/lex.re\"\n\n}", "target": 1, "cwe": ["CWE-787"], "project": "re2c", "commit_id": "039c18949190c5de5397eba504d2c75dad2ea9ca", "hash": 339197659838763135913760691524688782860, "size": 49, "message": "Emit an error when repetition lower bound exceeds upper bound.\n\nHistorically this was allowed and re2c swapped the bounds. However, it\nmost likely indicates an error in user code and there is only a single\noccurrence in the tests (and the test in an artificial one), so although\nthe change is backwards incompatible there is low chance of breaking\nreal-world code.\n\nThis fixes second test case in the bug #394 \"Stack overflow due to\nrecursion in src/dfa/dead_rules.cc\" (the actual fix is to limit DFA size\nbut the test also has counted repetition with swapped bounds).", "idx": 715}
{"func": "void sha1_final(unsigned char *md, SHACTX c) {\n  SHA1_Final(md, c);\n  SAFE_FREE(c);\n}", "target": 0, "cwe": ["CWE-310"], "project": "libssh", "commit_id": "e99246246b4061f7e71463f8806b9dcad65affa0", "hash": 133003542506273203490807394169414184162, "size": 4, "message": "security: fix for vulnerability CVE-2014-0017\n\nWhen accepting a new connection, a forking server based on libssh forks\nand the child process handles the request. The RAND_bytes() function of\nopenssl doesn't reset its state after the fork, but simply adds the\ncurrent process id (getpid) to the PRNG state, which is not guaranteed\nto be unique.\nThis can cause several children to end up with same PRNG state which is\na security issue.", "idx": 716}
{"func": "static void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\n\tspin_lock_init(&port->dev_list_lock);\n}", "target": 1, "cwe": ["CWE-284"], "project": "linux", "commit_id": "0558f33c06bb910e2879e355192227a8e8f0219d", "hash": 233077552265743623278146491313536497531, "size": 14, "message": "scsi: libsas: direct call probe and destruct\n\nIn commit 87c8331fcf72 (\"[SCSI] libsas: prevent domain rediscovery\ncompeting with ata error handling\") introduced disco mutex to prevent\nrediscovery competing with ata error handling and put the whole\nrevalidation in the mutex. But the rphy add/remove needs to wait for the\nerror handling which also grabs the disco mutex. This may leads to dead\nlock.So the probe and destruct event were introduce to do the rphy\nadd/remove asynchronously and out of the lock.\n\nThe asynchronously processed workers makes the whole discovery process\nnot atomic, the other events may interrupt the process. For example,\nif a loss of signal event inserted before the probe event, the\nsas_deform_port() is called and the port will be deleted.\n\nAnd sas_port_delete() may run before the destruct event, but the\nport-x:x is the top parent of end device or expander. This leads to\na kernel WARNING such as:\n\n[   82.042979] sysfs group 'power' not found for kobject 'phy-1:0:22'\n[   82.042983] ------------[ cut here ]------------\n[   82.042986] WARNING: CPU: 54 PID: 1714 at fs/sysfs/group.c:237\nsysfs_remove_group+0x94/0xa0\n[   82.043059] Call trace:\n[   82.043082] [<ffff0000082e7624>] sysfs_remove_group+0x94/0xa0\n[   82.043085] [<ffff00000864e320>] dpm_sysfs_remove+0x60/0x70\n[   82.043086] [<ffff00000863ee10>] device_del+0x138/0x308\n[   82.043089] [<ffff00000869a2d0>] sas_phy_delete+0x38/0x60\n[   82.043091] [<ffff00000869a86c>] do_sas_phy_delete+0x6c/0x80\n[   82.043093] [<ffff00000863dc20>] device_for_each_child+0x58/0xa0\n[   82.043095] [<ffff000008696f80>] sas_remove_children+0x40/0x50\n[   82.043100] [<ffff00000869d1bc>] sas_destruct_devices+0x64/0xa0\n[   82.043102] [<ffff0000080e93bc>] process_one_work+0x1fc/0x4b0\n[   82.043104] [<ffff0000080e96c0>] worker_thread+0x50/0x490\n[   82.043105] [<ffff0000080f0364>] kthread+0xfc/0x128\n[   82.043107] [<ffff0000080836c0>] ret_from_fork+0x10/0x50\n\nMake probe and destruct a direct call in the disco and revalidate function,\nbut put them outside the lock. The whole discovery or revalidate won't\nbe interrupted by other events. And the DISCE_PROBE and DISCE_DESTRUCT\nevent are deleted as a result of the direct call.\n\nIntroduce a new list to destruct the sas_port and put the port delete after\nthe destruct. This makes sure the right order of destroying the sysfs\nkobject and fix the warning above.\n\nIn sas_ex_revalidate_domain() have a loop to find all broadcasted\ndevice, and sometimes we have a chance to find the same expander twice.\nBecause the sas_port will be deleted at the end of the whole revalidate\nprocess, sas_port with the same name cannot be added before this.\nOtherwise the sysfs will complain of creating duplicate filename. Since\nthe LLDD will send broadcast for every device change, we can only\nprocess one expander's revalidation.\n\n[mkp: kbuild test robot warning]\n\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nCC: John Garry <john.garry@huawei.com>\nCC: Johannes Thumshirn <jthumshirn@suse.de>\nCC: Ewan Milne <emilne@redhat.com>\nCC: Christoph Hellwig <hch@lst.de>\nCC: Tomas Henzl <thenzl@redhat.com>\nCC: Dan Williams <dan.j.williams@intel.com>\nReviewed-by: Hannes Reinecke <hare@suse.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>", "idx": 717}
{"func": "const char *crypto_default_geniv(const struct crypto_alg *alg)\n{\n\tif (((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\n\t     CRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :\n\t\t\t\t\t alg->cra_ablkcipher.ivsize) !=\n\t    alg->cra_blocksize)\n\t\treturn \"chainiv\";\n\n\treturn alg->cra_flags & CRYPTO_ALG_ASYNC ?\n\t       \"eseqiv\" : skcipher_default_geniv;\n}", "target": 0, "cwe": ["CWE-310"], "project": "linux", "commit_id": "9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6", "hash": 267664396122867931515637052211167248512, "size": 11, "message": "crypto: user - fix info leaks in report API\n\nThree errors resulting in kernel memory disclosure:\n\n1/ The structures used for the netlink based crypto algorithm report API\nare located on the stack. As snprintf() does not fill the remainder of\nthe buffer with null bytes, those stack bytes will be disclosed to users\nof the API. Switch to strncpy() to fix this.\n\n2/ crypto_report_one() does not initialize all field of struct\ncrypto_user_alg. Fix this to fix the heap info leak.\n\n3/ For the module name we should copy only as many bytes as\nmodule_name() returns -- not as much as the destination buffer could\nhold. But the current code does not and therefore copies random data\nfrom behind the end of the module name, as the module name is always\nshorter than CRYPTO_MAX_ALG_NAME.\n\nAlso switch to use strncpy() to copy the algorithm's name and\ndriver_name. They are strings, after all.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>", "idx": 718}
{"func": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}", "target": 1, "cwe": ["CWE-122"], "project": "vim", "commit_id": "a062006b9de0b2947ab5fb376c6e67ef92a8cd69", "hash": 50861159610133694982233083024002607438, "size": 47, "message": "patch 8.2.3610: crash when ModeChanged triggered too early\n\nProblem:    Crash when ModeChanged triggered too early.\nSolution:   Trigger ModeChanged after setting VIsual.", "idx": 719}
{"func": "void ass_flush_events(ASS_Track *track)\n{\n    if (track->events) {\n        int eid;\n        for (eid = 0; eid < track->n_events; eid++)\n            ass_free_event(track, eid);\n        track->n_events = 0;\n    }\n    free(track->parser_priv->read_order_bitmap);\n    track->parser_priv->read_order_bitmap = NULL;\n    track->parser_priv->read_order_elems = 0;\n}", "target": 0, "cwe": ["CWE-369", "CWE-787"], "project": "libass", "commit_id": "017137471d0043e0321e377ed8da48e45a3ec632", "hash": 253381254529120212883953955329855106424, "size": 12, "message": "decode_font: fix subtraction broken by change to unsigned type\n\nThis caused a one-byte buffer overwrite and an assertion failure.\n\nRegression in commit 910211f1c0078e37546f73e95306724358b89be2.\n\nDiscovered by OSS-Fuzz.\n\nFixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26674.\nFixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26678.", "idx": 720}
{"func": "void AsyncConnection::reset_recv_state()\n{\n  // clean up state internal variables and states\n  if (state >= STATE_CONNECTING_SEND_CONNECT_MSG &&\n      state <= STATE_CONNECTING_READY) {\n    delete authorizer;\n    authorizer = NULL;\n    got_bad_auth = false;\n  }\n\n  if (state > STATE_OPEN_MESSAGE_THROTTLE_MESSAGE &&\n      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH\n      && policy.throttler_messages) {\n    ldout(async_msgr->cct, 10) << __func__ << \" releasing \" << 1\n                               << \" message to policy throttler \"\n                               << policy.throttler_messages->get_current() << \"/\"\n                               << policy.throttler_messages->get_max() << dendl;\n    policy.throttler_messages->put();\n  }\n  if (state > STATE_OPEN_MESSAGE_THROTTLE_BYTES &&\n      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {\n    if (policy.throttler_bytes) {\n      ldout(async_msgr->cct, 10) << __func__ << \" releasing \" << cur_msg_size\n                                 << \" bytes to policy throttler \"\n                                 << policy.throttler_bytes->get_current() << \"/\"\n                                 << policy.throttler_bytes->get_max() << dendl;\n      policy.throttler_bytes->put(cur_msg_size);\n    }\n  }\n  if (state > STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE &&\n      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {\n    ldout(async_msgr->cct, 10) << __func__ << \" releasing \" << cur_msg_size\n                               << \" bytes to dispatch_queue throttler \"\n                               << dispatch_queue->dispatch_throttler.get_current() << \"/\"\n                               << dispatch_queue->dispatch_throttler.get_max() << dendl;\n    dispatch_queue->dispatch_throttle_release(cur_msg_size);\n  }\n}", "target": 0, "cwe": ["CWE-287", "CWE-284"], "project": "ceph", "commit_id": "5ead97120e07054d80623dada90a5cc764c28468", "hash": 292932513796828371087267648883137452497, "size": 38, "message": "auth/cephx: add authorizer challenge\n\nAllow the accepting side of a connection to reject an initial authorizer\nwith a random challenge.  The connecting side then has to respond with an\nupdated authorizer proving they are able to decrypt the service's challenge\nand that the new authorizer was produced for this specific connection\ninstance.\n\nThe accepting side requires this challenge and response unconditionally\nif the client side advertises they have the feature bit.  Servers wishing\nto require this improved level of authentication simply have to require\nthe appropriate feature.\n\nSigned-off-by: Sage Weil <sage@redhat.com>\n(cherry picked from commit f80b848d3f830eb6dba50123e04385173fa4540b)\n\n# Conflicts:\n#\tsrc/auth/Auth.h\n#\tsrc/auth/cephx/CephxProtocol.cc\n#\tsrc/auth/cephx/CephxProtocol.h\n#\tsrc/auth/none/AuthNoneProtocol.h\n#\tsrc/msg/Dispatcher.h\n#\tsrc/msg/async/AsyncConnection.cc\n\n- const_iterator\n- ::decode vs decode\n- AsyncConnection ctor arg noise\n- get_random_bytes(), not cct->random()", "idx": 721}
{"func": "int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative)\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}", "target": 1, "cwe": ["CWE-476", "CWE-284"], "project": "linux", "commit_id": "d9092f52d7e61dd1557f2db2400ddb430e85937e", "hash": 190016248246993320212777373221059544715, "size": 268, "message": "kvm: x86: Check memopp before dereference (CVE-2016-8630)\n\nCommit 41061cdb98 (\"KVM: emulate: do not initialize memopp\") removes a\ncheck for non-NULL under incorrect assumptions. An undefined instruction\nwith a ModR/M byte with Mod=0 and R/M-5 (e.g. 0xc7 0x15) will attempt\nto dereference a null pointer here.\n\nFixes: 41061cdb98a0bec464278b4db8e894a3121671f5\nMessage-Id: <1477592752-126650-2-git-send-email-osh@google.com>\nSigned-off-by: Owen Hofmann <osh@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 722}
{"func": "static int handle_vmx_instruction(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}", "target": 0, "cwe": ["CWE-787"], "project": "linux", "commit_id": "04c4f2ee3f68c9a4bf1653d15f1a9a435ae33f7a", "hash": 327210390072936371498640801690170952390, "size": 5, "message": "KVM: VMX: Don't use vcpu->run->internal.ndata as an array index\n\n__vmx_handle_exit() uses vcpu->run->internal.ndata as an index for\nan array access.  Since vcpu->run is (can be) mapped to a user address\nspace with a writer permission, the 'ndata' could be updated by the\nuser process at anytime (the user process can set it to outside the\nbounds of the array).\nSo, it is not safe that __vmx_handle_exit() uses the 'ndata' that way.\n\nFixes: 1aa561b1a4c0 (\"kvm: x86: Add \"last CPU\" to some KVM_EXIT information\")\nSigned-off-by: Reiji Watanabe <reijiw@google.com>\nReviewed-by: Jim Mattson <jmattson@google.com>\nMessage-Id: <20210413154739.490299-1-reijiw@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 723}
{"func": "TiledInputFile::numYTiles (int ly) const\n{\n    if (ly < 0 || ly >= _data->numYLevels)\n    {\n        THROW (IEX_NAMESPACE::ArgExc, \"Error calling numYTiles() on image \"\n\t\t\t    \"file \\\"\" << _data->_streamData->is->fileName() << \"\\\" \"\n\t\t\t    \"(Argument is not in valid range).\");\n    }\n    \n    return _data->numYTiles[ly];\n}", "target": 0, "cwe": ["CWE-125"], "project": "openexr", "commit_id": "e79d2296496a50826a15c667bf92bdc5a05518b4", "hash": 197614721681477684944149838064105234870, "size": 11, "message": "fix memory leaks and invalid memory accesses\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>", "idx": 724}
{"func": "static uint16_t nvme_zone_mgmt_recv(NvmeCtrl *n, NvmeRequest *req)\n{\n    NvmeCmd *cmd = (NvmeCmd *)&req->cmd;\n    NvmeNamespace *ns = req->ns;\n    /* cdw12 is zero-based number of dwords to return. Convert to bytes */\n    uint32_t data_size = (le32_to_cpu(cmd->cdw12) + 1) << 2;\n    uint32_t dw13 = le32_to_cpu(cmd->cdw13);\n    uint32_t zone_idx, zra, zrasf, partial;\n    uint64_t max_zones, nr_zones = 0;\n    uint16_t status;\n    uint64_t slba;\n    NvmeZoneDescr *z;\n    NvmeZone *zone;\n    NvmeZoneReportHeader *header;\n    void *buf, *buf_p;\n    size_t zone_entry_sz;\n    int i;\n\n    req->status = NVME_SUCCESS;\n\n    status = nvme_get_mgmt_zone_slba_idx(ns, cmd, &slba, &zone_idx);\n    if (status) {\n        return status;\n    }\n\n    zra = dw13 & 0xff;\n    if (zra != NVME_ZONE_REPORT && zra != NVME_ZONE_REPORT_EXTENDED) {\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n    if (zra == NVME_ZONE_REPORT_EXTENDED && !ns->params.zd_extension_size) {\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n\n    zrasf = (dw13 >> 8) & 0xff;\n    if (zrasf > NVME_ZONE_REPORT_OFFLINE) {\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n\n    if (data_size < sizeof(NvmeZoneReportHeader)) {\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n\n    status = nvme_check_mdts(n, data_size);\n    if (status) {\n        return status;\n    }\n\n    partial = (dw13 >> 16) & 0x01;\n\n    zone_entry_sz = sizeof(NvmeZoneDescr);\n    if (zra == NVME_ZONE_REPORT_EXTENDED) {\n        zone_entry_sz += ns->params.zd_extension_size;\n    }\n\n    max_zones = (data_size - sizeof(NvmeZoneReportHeader)) / zone_entry_sz;\n    buf = g_malloc0(data_size);\n\n    zone = &ns->zone_array[zone_idx];\n    for (i = zone_idx; i < ns->num_zones; i++) {\n        if (partial && nr_zones >= max_zones) {\n            break;\n        }\n        if (nvme_zone_matches_filter(zrasf, zone++)) {\n            nr_zones++;\n        }\n    }\n    header = (NvmeZoneReportHeader *)buf;\n    header->nr_zones = cpu_to_le64(nr_zones);\n\n    buf_p = buf + sizeof(NvmeZoneReportHeader);\n    for (; zone_idx < ns->num_zones && max_zones > 0; zone_idx++) {\n        zone = &ns->zone_array[zone_idx];\n        if (nvme_zone_matches_filter(zrasf, zone)) {\n            z = (NvmeZoneDescr *)buf_p;\n            buf_p += sizeof(NvmeZoneDescr);\n\n            z->zt = zone->d.zt;\n            z->zs = zone->d.zs;\n            z->zcap = cpu_to_le64(zone->d.zcap);\n            z->zslba = cpu_to_le64(zone->d.zslba);\n            z->za = zone->d.za;\n\n            if (nvme_wp_is_valid(zone)) {\n                z->wp = cpu_to_le64(zone->d.wp);\n            } else {\n                z->wp = cpu_to_le64(~0ULL);\n            }\n\n            if (zra == NVME_ZONE_REPORT_EXTENDED) {\n                if (zone->d.za & NVME_ZA_ZD_EXT_VALID) {\n                    memcpy(buf_p, nvme_get_zd_extension(ns, zone_idx),\n                           ns->params.zd_extension_size);\n                }\n                buf_p += ns->params.zd_extension_size;\n            }\n\n            max_zones--;\n        }\n    }\n\n    status = nvme_c2h(n, (uint8_t *)buf, data_size, req);\n\n    g_free(buf);\n\n    return status;\n}", "target": 0, "cwe": [], "project": "qemu", "commit_id": "736b01642d85be832385063f278fe7cd4ffb5221", "hash": 146180910041862501789712420186142410121, "size": 106, "message": "hw/nvme: fix CVE-2021-3929\n\nThis fixes CVE-2021-3929 \"locally\" by denying DMA to the iomem of the\ndevice itself. This still allows DMA to MMIO regions of other devices\n(e.g. doing P2P DMA to the controller memory buffer of another NVMe\ndevice).\n\nFixes: CVE-2021-3929\nReported-by: Qiuhao Li <Qiuhao.Li@outlook.com>\nReviewed-by: Keith Busch <kbusch@kernel.org>\nReviewed-by: Philippe Mathieu-Daudé <f4bug@amsat.org>\nSigned-off-by: Klaus Jensen <k.jensen@samsung.com>", "idx": 725}
{"func": "inline bool add_gorder_to_list(THD *thd, Item *item, bool asc)\n{\n  return thd->lex->current_select->add_gorder_to_list(thd, item, asc);\n}", "target": 0, "cwe": ["CWE-416"], "project": "server", "commit_id": "4681b6f2d8c82b4ec5cf115e83698251963d80d5", "hash": 282150600046297394378778042802367774545, "size": 4, "message": "MDEV-26281 ASAN use-after-poison when complex conversion is involved in blob\n\nthe bug was that in_vector array in Item_func_in was allocated in the\nstatement arena, not in the table->expr_arena.\n\nrevert part of the 5acd391e8b2d. Instead, change the arena correctly\nin fix_all_session_vcol_exprs().\n\nRemove TABLE_ARENA, that was introduced in 5acd391e8b2d to force\nitem tree changes to be rolled back (because they were allocated in the\nwrong arena and didn't persist. now they do)", "idx": 726}
{"func": "slapi_config_register_callback(int operation,\n                               int flags,\n                               const char *base,\n                               int scope,\n                               const char *filter,\n                               dseCallbackFn fn,\n                               void *fn_arg)\n{\n    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);\n}", "target": 0, "cwe": ["CWE-200", "CWE-203"], "project": "389-ds-base", "commit_id": "b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32", "hash": 259692758822115672929969766054693134490, "size": 10, "message": "Issue 4609 - CVE - info disclosure when authenticating\n\nDescription:  If you bind as a user that does not exist.  Error 49 is returned\n              instead of error 32.  As error 32 discloses that the entry does\n              not exist.  When you bind as an entry that does not have userpassword\n              set then error 48 (inappropriate auth) is returned, but this\n              discloses that the entry does indeed exist.  Instead we should\n              always return error 49, even if the password is not set in the\n              entry.  This way we do not disclose to an attacker if the Bind\n              DN exists or not.\n\nRelates: https://github.com/389ds/389-ds-base/issues/4609\n\nReviewed by: tbordaz(Thanks!)", "idx": 727}
{"func": "int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\n\t{\n\tint al,i,j,ret;\n\tunsigned int n;\n\tSSL3_RECORD *rr;\n\tvoid (*cb)(const SSL *ssl,int type2,int val)=NULL;\n\n\tif (s->s3->rbuf.buf == NULL) /* Not initialized yet */\n\t\tif (!ssl3_setup_buffers(s))\n\t\t\treturn(-1);\n\n\tif ((type && (type != SSL3_RT_APPLICATION_DATA) && \n\t\t(type != SSL3_RT_HANDSHAKE)) ||\n\t    (peek && (type != SSL3_RT_APPLICATION_DATA)))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);\n\t\treturn -1;\n\t\t}\n\n\t/* check whether there's a handshake message (client hello?) waiting */\n\tif ( (ret = have_handshake_fragment(s, type, buf, len, peek)))\n\t\treturn ret;\n\n\t/* Now s->d1->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Continue handshake if it had to be interrupted to read\n\t * app data with SCTP.\n\t */\n\tif ((!s->in_handshake && SSL_in_init(s)) ||\n\t    (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t     (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK) &&\n\t     s->s3->in_read_app_data != 2))\n#else\n\tif (!s->in_handshake && SSL_in_init(s))\n#endif\n\t\t{\n\t\t/* type == SSL3_RT_APPLICATION_DATA */\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\t\t}\n\nstart:\n\ts->rwstate=SSL_NOTHING;\n\n\t/*-\n\t * s->s3->rrec.type\t    - is the type of record\n\t * s->s3->rrec.data,    - data\n\t * s->s3->rrec.off,     - offset into 'data' for next read\n\t * s->s3->rrec.length,  - number of bytes. \n\t */\n\trr = &(s->s3->rrec);\n\n\t/* We are not handshaking and have no data yet,\n\t * so process data buffered during the last handshake\n\t * in advance, if any.\n\t */\n\tif (s->state == SSL_ST_OK && rr->length == 0)\n\t\t{\n\t\tpitem *item;\n\t\titem = pqueue_pop(s->d1->buffered_app_data.q);\n\t\tif (item)\n\t\t\t{\n#ifndef OPENSSL_NO_SCTP\n\t\t\t/* Restore bio_dgram_sctp_rcvinfo struct */\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)))\n\t\t\t\t{\n\t\t\t\tDTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *) item->data;\n\t\t\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t\t\t\t}\n#endif\n\n\t\t\tdtls1_copy_record(s, item);\n\n\t\t\tOPENSSL_free(item->data);\n\t\t\tpitem_free(item);\n\t\t\t}\n\t\t}\n\n\t/* Check for timeout */\n\tif (dtls1_handle_timeout(s) > 0)\n\t\tgoto start;\n\n\t/* get new packet if necessary */\n\tif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))\n\t\t{\n\t\tret=dtls1_get_record(s);\n\t\tif (ret <= 0) \n\t\t\t{\n\t\t\tret = dtls1_read_failed(s, ret);\n\t\t\t/* anything other than a timeout is an error */\n\t\t\tif (ret <= 0)  \n\t\t\t\treturn(ret);\n\t\t\telse\n\t\t\t\tgoto start;\n\t\t\t}\n\t\t}\n\n\tif (s->d1->listen && rr->type != SSL3_RT_HANDSHAKE)\n\t\t{\n\t\trr->length = 0;\n\t\tgoto start;\n\t\t}\n\n\t/* we now have a packet which can be read and processed */\n\n\tif (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n\t                               * reset by ssl3_get_finished */\n\t\t&& (rr->type != SSL3_RT_HANDSHAKE))\n\t\t{\n\t\t/* We now have application data between CCS and Finished.\n\t\t * Most likely the packets were reordered on their way, so\n\t\t * buffer the application data for later processing rather\n\t\t * than dropping the connection.\n\t\t */\n\t\tdtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num);\n\t\trr->length = 0;\n\t\tgoto start;\n\t\t}\n\n\t/* If the other end has shut down, throw anything we read away\n\t * (even in 'peek' mode) */\n\tif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\n\t\t{\n\t\trr->length=0;\n\t\ts->rwstate=SSL_NOTHING;\n\t\treturn(0);\n\t\t}\n\n\n\tif (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */\n\t\t{\n\t\t/* make sure that we are not getting application data when we\n\t\t * are doing a handshake for the first time */\n\t\tif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n\t\t\t(s->enc_read_ctx == NULL))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (len <= 0) return(len);\n\n\t\tif ((unsigned int)len > rr->length)\n\t\t\tn = rr->length;\n\t\telse\n\t\t\tn = (unsigned int)len;\n\n\t\tmemcpy(buf,&(rr->data[rr->off]),n);\n\t\tif (!peek)\n\t\t\t{\n\t\t\trr->length-=n;\n\t\t\trr->off+=n;\n\t\t\tif (rr->length == 0)\n\t\t\t\t{\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t\trr->off=0;\n\t\t\t\t}\n\t\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t\t\t/* We were about to renegotiate but had to read\n\t\t\t * belated application data first, so retry.\n\t\t\t */\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t\t\t    rr->type == SSL3_RT_APPLICATION_DATA &&\n\t\t\t    (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK))\n\t\t\t\t{\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\t}\n\n\t\t\t/* We might had to delay a close_notify alert because\n\t\t\t * of reordered app data. If there was an alert and there\n\t\t\t * is no message to read anymore, finally set shutdown.\n\t\t\t */\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t\t\t    s->d1->shutdown_received && !BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))\n\t\t\t\t{\n\t\t\t\ts->shutdown |= SSL_RECEIVED_SHUTDOWN;\n\t\t\t\treturn(0);\n\t\t\t\t}\n#endif\t\t\t\n\t\treturn(n);\n\t\t}\n\n\n\t/* If we get here, then type != rr->type; if we have a handshake\n\t * message, then it was unexpected (Hello Request or Client Hello). */\n\n\t/* In case of record types for which we have 'fragment' storage,\n\t * fill that so that we can process the data at a fixed place.\n\t */\n\t\t{\n\t\tunsigned int k, dest_maxlen = 0;\n\t\tunsigned char *dest = NULL;\n\t\tunsigned int *dest_len = NULL;\n\n\t\tif (rr->type == SSL3_RT_HANDSHAKE)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof s->d1->handshake_fragment;\n\t\t\tdest = s->d1->handshake_fragment;\n\t\t\tdest_len = &s->d1->handshake_fragment_len;\n\t\t\t}\n\t\telse if (rr->type == SSL3_RT_ALERT)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof(s->d1->alert_fragment);\n\t\t\tdest = s->d1->alert_fragment;\n\t\t\tdest_len = &s->d1->alert_fragment_len;\n\t\t\t}\n#ifndef OPENSSL_NO_HEARTBEATS\n\t\telse if (rr->type == TLS1_RT_HEARTBEAT)\n\t\t\t{\n\t\t\tdtls1_process_heartbeat(s);\n\n\t\t\t/* Exit and notify application to read again */\n\t\t\trr->length = 0;\n\t\t\ts->rwstate=SSL_READING;\n\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\treturn(-1);\n\t\t\t}\n#endif\n\t\t/* else it's a CCS message, or application data or wrong */\n\t\telse if (rr->type != SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\t\t{\n\t\t\t/* Application data while renegotiating\n\t\t\t * is allowed. Try again reading.\n\t\t\t */\n\t\t\tif (rr->type == SSL3_RT_APPLICATION_DATA)\n\t\t\t\t{\n\t\t\t\tBIO *bio;\n\t\t\t\ts->s3->in_read_app_data=2;\n\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\n\t\t\t/* Not certain if this is the right error handling */\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (dest_maxlen > 0)\n\t\t\t{\n            /* XDTLS:  In a pathalogical case, the Client Hello\n             *  may be fragmented--don't always expect dest_maxlen bytes */\n\t\t\tif ( rr->length < dest_maxlen)\n\t\t\t\t{\n#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE\n\t\t\t\t/*\n\t\t\t\t * for normal alerts rr->length is 2, while\n\t\t\t\t * dest_maxlen is 7 if we were to handle this\n\t\t\t\t * non-existing alert...\n\t\t\t\t */\n\t\t\t\tFIX ME\n#endif\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t\trr->length = 0;\n\t\t\t\tgoto start;\n\t\t\t\t}\n\n\t\t\t/* now move 'n' bytes: */\n\t\t\tfor ( k = 0; k < dest_maxlen; k++)\n\t\t\t\t{\n\t\t\t\tdest[k] = rr->data[rr->off++];\n\t\t\t\trr->length--;\n\t\t\t\t}\n\t\t\t*dest_len = dest_maxlen;\n\t\t\t}\n\t\t}\n\n\t/* s->d1->handshake_fragment_len == 12  iff  rr->type == SSL3_RT_HANDSHAKE;\n\t * s->d1->alert_fragment_len == 7      iff  rr->type == SSL3_RT_ALERT.\n\t * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) */\n\n\t/* If we are a client, check for an incoming 'Hello Request': */\n\tif ((!s->server) &&\n\t\t(s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&\n\t\t(s->d1->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n\t\t(s->session != NULL) && (s->session->cipher != NULL))\n\t\t{\n\t\ts->d1->handshake_fragment_len = 0;\n\n\t\tif ((s->d1->handshake_fragment[1] != 0) ||\n\t\t\t(s->d1->handshake_fragment[2] != 0) ||\n\t\t\t(s->d1->handshake_fragment[3] != 0))\n\t\t\t{\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* no need to check sequence number on HELLO REQUEST messages */\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, \n\t\t\t\ts->d1->handshake_fragment, 4, s, s->msg_callback_arg);\n\n\t\tif (SSL_is_init_finished(s) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n\t\t\t!s->s3->renegotiate)\n\t\t\t{\n\t\t\ts->d1->handshake_read_seq++;\n\t\t\ts->new_session = 1;\n\t\t\tssl3_renegotiate(s);\n\t\t\tif (ssl3_renegotiate_check(s))\n\t\t\t\t{\n\t\t\t\ti=s->handshake_func(s);\n\t\t\t\tif (i < 0) return(i);\n\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\t\t\treturn(-1);\n\t\t\t\t\t}\n\n\t\t\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t\t\t{\n\t\t\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t\t\t{\n\t\t\t\t\t\tBIO *bio;\n\t\t\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t/* we either finished a handshake or ignored the request,\n\t\t * now try again to obtain the (application) data we were asked for */\n\t\tgoto start;\n\t\t}\n\n\tif (s->d1->alert_fragment_len >= DTLS1_AL_HEADER_LENGTH)\n\t\t{\n\t\tint alert_level = s->d1->alert_fragment[0];\n\t\tint alert_descr = s->d1->alert_fragment[1];\n\n\t\ts->d1->alert_fragment_len = 0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_ALERT, \n\t\t\t\ts->d1->alert_fragment, 2, s, s->msg_callback_arg);\n\n\t\tif (s->info_callback != NULL)\n\t\t\tcb=s->info_callback;\n\t\telse if (s->ctx->info_callback != NULL)\n\t\t\tcb=s->ctx->info_callback;\n\n\t\tif (cb != NULL)\n\t\t\t{\n\t\t\tj = (alert_level << 8) | alert_descr;\n\t\t\tcb(s, SSL_CB_READ_ALERT, j);\n\t\t\t}\n\n\t\tif (alert_level == 1) /* warning */\n\t\t\t{\n\t\t\ts->s3->warn_alert = alert_descr;\n\t\t\tif (alert_descr == SSL_AD_CLOSE_NOTIFY)\n\t\t\t\t{\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\t/* With SCTP and streams the socket may deliver app data\n\t\t\t\t * after a close_notify alert. We have to check this\n\t\t\t\t * first so that nothing gets discarded.\n\t\t\t\t */\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t\t\t\t\tBIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->shutdown_received = 1;\n\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n#endif\n\t\t\t\ts->shutdown |= SSL_RECEIVED_SHUTDOWN;\n\t\t\t\treturn(0);\n\t\t\t\t}\n#if 0\n            /* XXX: this is a possible improvement in the future */\n\t\t\t/* now check if it's a missing record */\n\t\t\tif (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)\n\t\t\t\t{\n\t\t\t\tunsigned short seq;\n\t\t\t\tunsigned int frag_off;\n\t\t\t\tunsigned char *p = &(s->d1->alert_fragment[2]);\n\n\t\t\t\tn2s(p, seq);\n\t\t\t\tn2l3(p, frag_off);\n\n\t\t\t\tdtls1_retransmit_message(s,\n\t\t\t\t\t\t\t\t\t\t dtls1_get_queue_priority(frag->msg_header.seq, 0),\n\t\t\t\t\t\t\t\t\t\t frag_off, &found);\n\t\t\t\tif ( ! found  && SSL_in_init(s))\n\t\t\t\t\t{\n\t\t\t\t\t/* fprintf( stderr,\"in init = %d\\n\", SSL_in_init(s)); */\n\t\t\t\t\t/* requested a message not yet sent, \n\t\t\t\t\t   send an alert ourselves */\n\t\t\t\t\tssl3_send_alert(s,SSL3_AL_WARNING,\n\t\t\t\t\t\tDTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\telse if (alert_level == 2) /* fatal */\n\t\t\t{\n\t\t\tchar tmp[16];\n\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->s3->fatal_alert = alert_descr;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n\t\t\tBIO_snprintf(tmp,sizeof tmp,\"%d\",alert_descr);\n\t\t\tERR_add_error_data(2,\"SSL alert number \",tmp);\n\t\t\ts->shutdown|=SSL_RECEIVED_SHUTDOWN;\n\t\t\tSSL_CTX_remove_session(s->ctx,s->session);\n\t\t\treturn(0);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tgoto start;\n\t\t}\n\n\tif (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */\n\t\t{\n\t\ts->rwstate=SSL_NOTHING;\n\t\trr->length=0;\n\t\treturn(0);\n\t\t}\n\n\tif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\t{\n\t\tstruct ccs_header_st ccs_hdr;\n\t\tunsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH;\n\n\t\tdtls1_get_ccs_header(rr->data, &ccs_hdr);\n\n\t\tif (s->version == DTLS1_BAD_VER)\n\t\t\tccs_hdr_len = 3;\n\n\t\t/* 'Change Cipher Spec' is just a single byte, so we know\n\t\t * exactly what the record payload has to look like */\n\t\t/* XDTLS: check that epoch is consistent */\n\t\tif (\t(rr->length != ccs_hdr_len) || \n\t\t\t(rr->off != 0) || (rr->data[0] != SSL3_MT_CCS))\n\t\t\t{\n\t\t\ti=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\trr->length=0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, \n\t\t\t\trr->data, 1, s, s->msg_callback_arg);\n\n\t\t/* We can't process a CCS now, because previous handshake\n\t\t * messages are still missing, so just drop it.\n\t\t */\n\t\tif (!s->d1->change_cipher_spec_ok)\n\t\t\t{\n\t\t\tgoto start;\n\t\t\t}\n\n\t\ts->d1->change_cipher_spec_ok = 0;\n\n\t\ts->s3->change_cipher_spec=1;\n\t\tif (!ssl3_do_change_cipher_spec(s))\n\t\t\tgoto err;\n\n\t\t/* do this whenever CCS is processed */\n\t\tdtls1_reset_seq_numbers(s, SSL3_CC_READ);\n\n\t\tif (s->version == DTLS1_BAD_VER)\n\t\t\ts->d1->handshake_read_seq++;\n\n#ifndef OPENSSL_NO_SCTP\n\t\t/* Remember that a CCS has been received,\n\t\t * so that an old key of SCTP-Auth can be\n\t\t * deleted when a CCS is sent. Will be ignored\n\t\t * if no SCTP is used\n\t\t */\n\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD, 1, NULL);\n#endif\n\n\t\tgoto start;\n\t\t}\n\n\t/* Unexpected handshake message (Client Hello, or protocol violation) */\n\tif ((s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) && \n\t\t!s->in_handshake)\n\t\t{\n\t\tstruct hm_header_st msg_hdr;\n\t\t\n\t\t/* this may just be a stale retransmit */\n\t\tdtls1_get_message_header(rr->data, &msg_hdr);\n\t\tif( rr->epoch != s->d1->r_epoch)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n\n\t\t/* If we are server, we may have a repeated FINISHED of the\n\t\t * client here, then retransmit our CCS and FINISHED.\n\t\t */\n\t\tif (msg_hdr.type == SSL3_MT_FINISHED)\n\t\t\t{\n\t\t\tif (dtls1_check_timeout_num(s) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tdtls1_retransmit_buffered_messages(s);\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n\n\t\tif (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))\n\t\t\t{\n#if 0 /* worked only because C operator preferences are not as expected (and\n       * because this is not really needed for clients except for detecting\n       * protocol violations): */\n\t\t\ts->state=SSL_ST_BEFORE|(s->server)\n\t\t\t\t?SSL_ST_ACCEPT\n\t\t\t\t:SSL_ST_CONNECT;\n#else\n\t\t\ts->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#endif\n\t\t\ts->renegotiate=1;\n\t\t\ts->new_session=1;\n\t\t\t}\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\n\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t{\n\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t{\n\t\t\t\tBIO *bio;\n\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\t\tgoto start;\n\t\t}\n\n\tswitch (rr->type)\n\t\t{\n\tdefault:\n#ifndef OPENSSL_NO_TLS\n\t\t/* TLS just ignores unknown message types */\n\t\tif (s->version == TLS1_VERSION)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n#endif\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\tgoto f_err;\n\tcase SSL3_RT_CHANGE_CIPHER_SPEC:\n\tcase SSL3_RT_ALERT:\n\tcase SSL3_RT_HANDSHAKE:\n\t\t/* we already handled all of these, with the possible exception\n\t\t * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that\n\t\t * should not happen when type != rr->type */\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,ERR_R_INTERNAL_ERROR);\n\t\tgoto f_err;\n\tcase SSL3_RT_APPLICATION_DATA:\n\t\t/* At this point, we were expecting handshake data,\n\t\t * but have application data.  If the library was\n\t\t * running inside ssl3_read() (i.e. in_read_app_data\n\t\t * is set) and it makes sense to read application data\n\t\t * at this point (session renegotiation not yet started),\n\t\t * we will indulge it.\n\t\t */\n\t\tif (s->s3->in_read_app_data &&\n\t\t\t(s->s3->total_renegotiations != 0) &&\n\t\t\t((\n\t\t\t\t(s->state & SSL_ST_CONNECT) &&\n\t\t\t\t(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\n\t\t\t\t(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\n\t\t\t\t) || (\n\t\t\t\t\t(s->state & SSL_ST_ACCEPT) &&\n\t\t\t\t\t(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\n\t\t\t\t\t(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t{\n\t\t\ts->s3->in_read_app_data=2;\n\t\t\treturn(-1);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\t/* not reached */\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(-1);\n\t}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "openssl", "commit_id": "103b171d8fc282ef435f8de9afbf7782e312961f", "hash": 298886895740323046186476664569139458558, "size": 639, "message": "A memory leak can occur in dtls1_buffer_record if either of the calls to\nssl3_setup_buffers or pqueue_insert fail. The former will fail if there is a\nmalloc failure, whilst the latter will fail if attempting to add a duplicate\nrecord to the queue. This should never happen because duplicate records should\nbe detected and dropped before any attempt to add them to the queue.\nUnfortunately records that arrive that are for the next epoch are not being\nrecorded correctly, and therefore replays are not being detected.\nAdditionally, these \"should not happen\" failures that can occur in\ndtls1_buffer_record are not being treated as fatal and therefore an attacker\ncould exploit this by sending repeated replay records for the next epoch,\neventually causing a DoS through memory exhaustion.\n\nThanks to Chris Mueller for reporting this issue and providing initial\nanalysis and a patch. Further analysis and the final patch was performed by\nMatt Caswell from the OpenSSL development team.\n\nCVE-2015-0206\n\nReviewed-by: Dr Stephen Henson <steve@openssl.org>", "idx": 728}
{"func": "value_check_lock(int lock, char_u *name, int use_gettext)\n{\n    if (lock & VAR_LOCKED)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_value_is_locked));\n\telse\n\t    semsg(_(e_value_is_locked_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    if (lock & VAR_FIXED)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_change_value));\n\telse\n\t    semsg(_(e_cannot_change_value_of_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}", "target": 0, "cwe": ["CWE-476"], "project": "vim", "commit_id": "0f6e28f686dbb59ab3b562408ab9b2234797b9b1", "hash": 187551255116478806856133129654338970337, "size": 22, "message": "patch 8.2.4428: crash when switching tabpage while in the cmdline window\n\nProblem:    Crash when switching tabpage while in the cmdline window.\nSolution:   Disallow switching tabpage when in the cmdline window.", "idx": 729}
{"func": "int ssh_scp_push_file(ssh_scp scp, const char *filename, size_t size, int mode){\n\treturn ssh_scp_push_file64(scp, filename, (uint64_t) size, mode);\n}", "target": 1, "cwe": [], "project": "libssh", "commit_id": "4aea835974996b2deb011024c53f4ff4329a95b5", "hash": 65560746232969330678728682827015105436, "size": 3, "message": "CVE-2019-14889: scp: Reformat scp.c\n\nFixes T181\n\nSigned-off-by: Anderson Toshiyuki Sasaki <ansasaki@redhat.com>\nReviewed-by: Andreas Schneider <asn@cryptomilk.org>\n(cherry picked from commit 42c727d0c186a1e2fa84a31ab40e16e58b404ab3)", "idx": 730}
{"func": "vrrp_state_handler(vector_t *strvec)\n{\n\tchar *str = strvec_slot(strvec, 1);\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (!strcmp(str, \"MASTER\"))\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n\telse if (!strcmp(str, \"BACKUP\"))\n\t{\n\t\tif (vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) state previously set as MASTER - ignoring BACKUP\", vrrp->iname);\n\t\telse\n\t\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n\telse {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) unknown state '%s', defaulting to BACKUP\", vrrp->iname, str);\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n}", "target": 0, "cwe": ["CWE-59", "CWE-61"], "project": "keepalived", "commit_id": "04f2d32871bb3b11d7dc024039952f2fe2750306", "hash": 314095713981357269331361513281350485553, "size": 19, "message": "When opening files for write, ensure they aren't symbolic links\n\nIssue #1048 identified that if, for example, a non privileged user\ncreated a symbolic link from /etc/keepalvied.data to /etc/passwd,\nwriting to /etc/keepalived.data (which could be invoked via DBus)\nwould cause /etc/passwd to be overwritten.\n\nThis commit stops keepalived writing to pathnames where the ultimate\ncomponent is a symbolic link, by setting O_NOFOLLOW whenever opening\na file for writing.\n\nThis might break some setups, where, for example, /etc/keepalived.data\nwas a symbolic link to /home/fred/keepalived.data. If this was the case,\ninstead create a symbolic link from /home/fred/keepalived.data to\n/tmp/keepalived.data, so that the file is still accessible via\n/home/fred/keepalived.data.\n\nThere doesn't appear to be a way around this backward incompatibility,\nsince even checking if the pathname is a symbolic link prior to opening\nfor writing would create a race condition.\n\nSigned-off-by: Quentin Armitage <quentin@armitage.org.uk>", "idx": 731}
{"func": "static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){\n  int rc = sqlite3_reset(pStmt);\n  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;\n}", "target": 0, "cwe": ["CWE-125"], "project": "sqlite", "commit_id": "e41fd72acc7a06ce5a6a7d28154db1ffe8ba37a8", "hash": 141981968126367207126974752189575906987, "size": 4, "message": "Enhance the rtreenode() function of rtree (used for testing) so that it\nuses the newer sqlite3_str object for better performance and improved\nerror reporting.\n\nFossilOrigin-Name: 90acdbfce9c088582d5165589f7eac462b00062bbfffacdcc786eb9cf3ea5377", "idx": 732}
{"func": "static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n\t\t\t      struct files_struct *fsp,\n\t\t\t      TALLOC_CTX *ctx,\n\t\t\t      uint32_t function,\n\t\t\t      uint16_t req_flags, /* Needed for UNICODE ... */\n\t\t\t      const uint8_t *_in_data,\n\t\t\t      uint32_t in_len,\n\t\t\t      uint8_t **_out_data,\n\t\t\t      uint32_t max_out_len,\n\t\t\t      uint32_t *out_len)\n{\n\tconst char *in_data = (const char *)_in_data;\n\tchar **out_data = (char **)_out_data;\n\n\tswitch (function) {\n\tcase FSCTL_SET_SPARSE:\n\t{\n\t\tbool set_sparse = true;\n\t\tNTSTATUS status;\n\n\t\tif (in_len >= 1 && in_data[0] == 0) {\n\t\t\tset_sparse = false;\n\t\t}\n\n\t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n\t\t\n\t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n\t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n\t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse, \n\t\t       nt_errstr(status)));\n\n\t\treturn status;\n\t}\n\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tunsigned char objid[16];\n\t\tchar *return_data = NULL;\n\n\t\t/* This should return the object-id on this file.\n\t\t * I think I'll make this be the inode+dev. JRA.\n\t\t */\n\n\t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n\t\t\t  fsp_fnum_dbg(fsp)));\n\n\t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n\t\t/* Hmmm, will this cause problems if less data asked for? */\n\t\treturn_data = talloc_array(ctx, char, 64);\n\t\tif (return_data == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\t/* For backwards compatibility only store the dev/inode. */\n\t\tpush_file_id_16(return_data, &fsp->file_id);\n\t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n\t\tpush_file_id_16(return_data+32, &fsp->file_id);\n\t\t*out_data = return_data;\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\t/* Fail it with STATUS_NOT_A_REPARSE_POINT */\n\t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\n\tcase FSCTL_SET_REPARSE_POINT:\n\t{\n\t\t/* Fail it with STATUS_NOT_A_REPARSE_POINT */\n\t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\n\tcase FSCTL_GET_SHADOW_COPY_DATA:\n\t{\n\t\t/*\n\t\t * This is called to retrieve the number of Shadow Copies (a.k.a. snapshots)\n\t\t * and return their volume names.  If max_data_count is 16, then it is just\n\t\t * asking for the number of volumes and length of the combined names.\n\t\t *\n\t\t * pdata is the data allocated by our caller, but that uses\n\t\t * total_data_count (which is 0 in our case) rather than max_data_count.\n\t\t * Allocate the correct amount and return the pointer to let\n\t\t * it be deallocated when we return.\n\t\t */\n\t\tstruct shadow_copy_data *shadow_data = NULL;\n\t\tbool labels = False;\n\t\tuint32 labels_data_count = 0;\n\t\tuint32 i;\n\t\tchar *cur_pdata = NULL;\n\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tif (max_out_len > 16) {\n\t\t\tlabels = True;\n\t\t}\n\n\t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n\t\tif (shadow_data == NULL) {\n\t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\t/*\n\t\t * Call the VFS routine to actually do the work.\n\t\t */\n\t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t}\n\n\t\tlabels_data_count = (shadow_data->num_volumes * 2 * \n\t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n\n\t\tif (!labels) {\n\t\t\t*out_len = 16;\n\t\t} else {\n\t\t\t*out_len = 12 + labels_data_count + 4;\n\t\t}\n\n\t\tif (max_out_len < *out_len) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n\t\t\t\tmax_out_len, *out_len));\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n\t\t}\n\n\t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n\t\tif (cur_pdata == NULL) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\t*out_data = cur_pdata;\n\n\t\t/* num_volumes 4 bytes */\n\t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n\n\t\tif (labels) {\n\t\t\t/* num_labels 4 bytes */\n\t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n\t\t}\n\n\t\t/* needed_data_count 4 bytes */\n\t\tSIVAL(cur_pdata, 8, labels_data_count + 4);\n\n\t\tcur_pdata += 12;\n\n\t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n\t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n\t\tif (labels && shadow_data->labels) {\n\t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n\t\t\t\tsrvstr_push(cur_pdata, req_flags,\n\t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n\t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n\t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n\t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n\t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n\t\t\t}\n\t\t}\n\n\t\tTALLOC_FREE(shadow_data);\n\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_FIND_FILES_BY_SID:\n\t{\n\t\t/* pretend this succeeded -\n\t\t *\n\t\t * we have to send back a list with all files owned by this SID\n\t\t *\n\t\t * but I have to check that --metze\n\t\t */\n\t\tstruct dom_sid sid;\n\t\tuid_t uid;\n\t\tsize_t sid_len;\n\n\t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n\t\t\t   fsp_fnum_dbg(fsp)));\n\n\t\tif (in_len < 8) {\n\t\t\t/* NT_STATUS_BUFFER_TOO_SMALL maybe? */\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n\n\t\t/* unknown 4 bytes: this is not the length of the sid :-(  */\n\t\t/*unknown = IVAL(pdata,0);*/\n\n\t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n\n\t\tif (!sid_to_uid(&sid, &uid)) {\n\t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n\t\t\t\t sid_string_dbg(&sid),\n\t\t\t\t (unsigned long)sid_len));\n\t\t\tuid = (-1);\n\t\t}\n\n\t\t/* we can take a look at the find source :-)\n\t\t *\n\t\t * find ./ -uid $uid  -name '*'   is what we need here\n\t\t *\n\t\t *\n\t\t * and send 4bytes len and then NULL terminated unicode strings\n\t\t * for each file\n\t\t *\n\t\t * but I don't know how to deal with the paged results\n\t\t * (maybe we can hang the result anywhere in the fsp struct)\n\t\t *\n\t\t * but I don't know how to deal with the paged results\n\t\t * (maybe we can hang the result anywhere in the fsp struct)\n\t\t *\n\t\t * we don't send all files at once\n\t\t * and at the next we should *not* start from the beginning,\n\t\t * so we have to cache the result\n\t\t *\n\t\t * --metze\n\t\t */\n\n\t\t/* this works for now... */\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t{\n\t\t/* FIXME: This is just a dummy reply, telling that all of the\n\t\t * file is allocated. MKS cp needs that.\n\t\t * Adding the real allocated ranges via FIEMAP on Linux\n\t\t * and SEEK_DATA/SEEK_HOLE on Solaris is needed to make\n\t\t * this FSCTL correct for sparse files.\n\t\t */\n\t\tNTSTATUS status;\n\t\tuint64_t offset, length;\n\t\tchar *out_data_tmp = NULL;\n\n\t\tif (in_len != 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n\t\t\t\tin_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\toffset = BVAL(in_data,0);\n\t\tlength = BVAL(in_data,8);\n\n\t\tif (offset + length < offset) {\n\t\t\t/* No 64-bit integer wrap. */\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\t/* Shouldn't this be SMB_VFS_STAT ... ? */\n\t\tstatus = vfs_stat_fsp(fsp);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\n\t\t*out_len = 16;\n\t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n\t\tif (out_data_tmp == NULL) {\n\t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n\t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n\t\t\t\tlength == 0) {\n\t\t\tmemset(out_data_tmp, 0, *out_len);\n\t\t} else {\n\t\t\tuint64_t end = offset + length;\n\t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n\t\t\tSBVAL(out_data_tmp, 0, 0);\n\t\t\tSBVAL(out_data_tmp, 8, end);\n\t\t}\n\n\t\t*out_data = out_data_tmp;\n\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_IS_VOLUME_DIRTY:\n\t{\n\t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n\t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n\t\t/*\n\t\t * http://msdn.microsoft.com/en-us/library/cc232128%28PROT.10%29.aspx\n\t\t * says we have to respond with NT_STATUS_INVALID_PARAMETER\n\t\t */\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\tdefault:\n\t\t/* \n\t\t * Only print once ... unfortunately there could be lots of\n\t\t * different FSCTLs that are called.\n\t\t */\n\t\tif (!vfswrap_logged_ioctl_message) {\n\t\t\tvfswrap_logged_ioctl_message = true;\n\t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n\t\t\t__func__, function));\n\t\t}\n\t}\n\n\treturn NT_STATUS_NOT_SUPPORTED;\n}", "target": 1, "cwe": ["CWE-665"], "project": "samba", "commit_id": "eb50fb8f3bf670bd7d1cf8fd4368ef4a73083696", "hash": 36864430679636639714404842179779335208, "size": 330, "message": "FSCTL_GET_SHADOW_COPY_DATA: Don't return 4 extra bytes at end\n\nlabels_data_count already accounts for the unicode null character at the\nend of the array. There is no need in adding space for it again.\n\nSigned-off-by: Christof Schmitt <christof.schmitt@us.ibm.com>\nReviewed-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Simo Sorce <idra@samba.org>\n\nAutobuild-User(master): Jeremy Allison <jra@samba.org>\nAutobuild-Date(master): Tue Aug  6 04:03:17 CEST 2013 on sn-devel-104", "idx": 733}
{"func": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\n\twait_for_completion(&fcomp.comp);\n\n\t/* Fill the fc_host_statistics structure */\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1, "cwe": ["CWE-400", "CWE-401"], "project": "linux", "commit_id": "0e62395da2bd5166d7c9e14cbc7503b256a34cb0", "hash": 276831105069953521205119097095926483692, "size": 46, "message": "scsi: bfa: release allocated memory in case of error\n\nIn bfad_im_get_stats if bfa_port_get_stats fails, allocated memory needs to\nbe released.\n\nLink: https://lore.kernel.org/r/20190910234417.22151-1-navid.emamdoost@gmail.com\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>", "idx": 734}
{"func": "R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1, "cwe": ["CWE-400", "CWE-703"], "project": "radare2", "commit_id": "634b886e84a5c568d243e744becc6b3223e089cf", "hash": 222127049619397972864895193911599096701, "size": 12, "message": "Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash\n\n* Reported by lazymio\n* Reproducer: AAA4AAAAAB4=", "idx": 735}
{"func": "napi_status napi_get_value_string_utf16(napi_env env,\n                                        napi_value value,\n                                        char16_t* buf,\n                                        size_t bufsize,\n                                        size_t* result) {\n  CHECK_ENV(env);\n  CHECK_ARG(env, value);\n\n  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);\n\n  if (!buf) {\n    CHECK_ARG(env, result);\n    // V8 assumes UTF-16 length is the same as the number of characters.\n    *result = val.As<v8::String>()->Length();\n  } else {\n    int copied = val.As<v8::String>()->Write(env->isolate,\n                                             reinterpret_cast<uint16_t*>(buf),\n                                             0,\n                                             bufsize - 1,\n                                             v8::String::NO_NULL_TERMINATION);\n\n    buf[copied] = '\\0';\n    if (result != nullptr) {\n      *result = copied;\n    }\n  }\n\n  return napi_clear_last_error(env);\n}", "target": 1, "cwe": ["CWE-191"], "project": "node", "commit_id": "656260b4b65fec3b10f6da3fdc9f11fb941aafb5", "hash": 222455572268380335498650943459739014339, "size": 30, "message": "napi: fix memory corruption vulnerability\n\nFixes: https://hackerone.com/reports/784186\nCVE-ID: CVE-2020-8174\nPR-URL: https://github.com/nodejs-private/node-private/pull/195\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Gabriel Schulhof <gabriel.schulhof@intel.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Rich Trott <rtrott@gmail.com>", "idx": 736}
{"func": "gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n  guint avail;\n  GstFlowReturn res = GST_FLOW_OK;\n\n  GstFlxDec *flxdec;\n  FlxHeader *flxh;\n\n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n\n  gst_adapter_push (flxdec->adapter, buf);\n  avail = gst_adapter_available (flxdec->adapter);\n\n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n    if (avail >= FlxHeaderSize) {\n      const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n      GstCaps *templ;\n\n      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n      gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n\n      flxh = &flxdec->hdr;\n\n      /* check header */\n      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n\n      GST_LOG (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames    :  %d\", flxh->frames);\n      GST_LOG (\"width     :  %d\", flxh->width);\n      GST_LOG (\"height    :  %d\", flxh->height);\n      GST_LOG (\"depth     :  %d\", flxh->depth);\n      GST_LOG (\"speed     :  %d\", flxh->speed);\n\n      flxdec->next_time = 0;\n\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time = JIFFIE * flxh->speed;\n      } else if (flxh->speed == 0) {\n        flxdec->frame_time = GST_SECOND / 70;\n      } else {\n        flxdec->frame_time = flxh->speed * GST_MSECOND;\n      }\n\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS (flxdec->duration));\n\n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n      caps = gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\", G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint) GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n\n      gst_pad_set_caps (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n\n      if (flxh->depth <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new (flxh->width, flxh->height);\n\n      if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n\n      flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n\n      /* create delta and output frame */\n      flxdec->frame_data = g_malloc (flxdec->size);\n      flxdec->delta_data = g_malloc (flxdec->size);\n\n      flxdec->state = GST_FLXDEC_PLAYING;\n    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n\n    /* while we have enough data in the adapter */\n    while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n      const guint8 *data;\n      GstMapInfo map;\n\n      chunk = NULL;\n      data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n      gst_adapter_unmap (flxdec->adapter);\n\n      switch (flxfh.id) {\n        case FLX_FRAME_TYPE:\n          /* check if we have the complete frame */\n          if (avail < flxfh.size)\n            goto need_more_data;\n\n          /* flush header */\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n\n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n            break;\n\n          /* create 32 bits output frame */\n//          res = gst_pad_alloc_buffer_and_set_caps (flxdec->srcpad,\n//              GST_BUFFER_OFFSET_NONE,\n//              flxdec->size * 4, GST_PAD_CAPS (flxdec->srcpad), &out);\n//          if (res != GST_FLOW_OK)\n//            break;\n\n          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n\n          /* decode chunks */\n          if (!flx_decode_chunks (flxdec,\n                  ((FlxFrameType *) chunk)->chunks,\n                  chunk + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n            return GST_FLOW_ERROR;\n          }\n\n          /* save copy of the current frame for possible delta. */\n          memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);\n\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n          /* convert current frame. */\n          flx_colorspace_convert (flxdec->converter, flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out, &map);\n\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n          flxdec->next_time += flxdec->frame_time;\n\n          res = gst_pad_push (flxdec->srcpad, out);\n          break;\n        default:\n          /* check if we have the complete frame */\n          if (avail < flxfh.size)\n            goto need_more_data;\n\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n          break;\n      }\n\n      g_free (chunk);\n\n      avail = gst_adapter_available (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\n\n  /* ERRORS */\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n        (\"not a flx file (type %x)\", flxh->type));\n    gst_object_unref (flxdec);\n    return GST_FLOW_ERROR;\n  }\n}", "target": 1, "cwe": ["CWE-125"], "project": "gst-plugins-good", "commit_id": "b31c504645a814c59d91d49e4fe218acaf93f4ca", "hash": 48691489020202845899087038842205903747, "size": 174, "message": "flxdec: Don't unref() parent in the chain function\n\nWe don't own the reference here, it is owned by the caller and given to\nus for the scope of this function. Leftover mistake from 0.10 porting.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=774897", "idx": 737}
{"func": "zzip_mem_disk_findfile(ZZIP_MEM_DISK* dir, \n                       char* filename, ZZIP_DISK_ENTRY* after,\n\t\t       zzip_strcmp_fn_t compare) {\n    return zzip_disk_findfile(dir->disk, filename, after, compare); }", "target": 1, "cwe": ["CWE-119"], "project": "zziplib", "commit_id": "596d9dfce2624e849417d4301e8d67935608aa5e", "hash": 122363931075704777400759270264843014510, "size": 4, "message": "memdisk\n (.)", "idx": 738}
{"func": "struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)\n{\n\treturn head->next;\n}", "target": 1, "cwe": ["CWE-665"], "project": "tip", "commit_id": "511885d7061eda3eb1faf3f57dcc936ff75863f1", "hash": 192534851203297663002374438491012954019, "size": 4, "message": "lib/timerqueue: Rely on rbtree semantics for next timer\n\nSimplify the timerqueue code by using cached rbtrees and rely on the tree\nleftmost node semantics to get the timer with earliest expiration time.\nThis is a drop in conversion, and therefore semantics remain untouched.\n\nThe runtime overhead of cached rbtrees is be pretty much the same as the\ncurrent head->next method, noting that when removing the leftmost node,\na common operation for the timerqueue, the rb_next(leftmost) is O(1) as\nwell, so the next timer will either be the right node or its parent.\nTherefore no extra pointer chasing. Finally, the size of the struct\ntimerqueue_head remains the same.\n\nPasses several hours of rcutorture.\n\nSigned-off-by: Davidlohr Bueso <dbueso@suse.de>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nLink: https://lkml.kernel.org/r/20190724152323.bojciei3muvfxalm@linux-r8p5", "idx": 739}
{"func": "SAPI_API SAPI_TREAT_DATA_FUNC(php_default_treat_data)\n{\n\tchar *res = NULL, *var, *val, *separator = NULL;\n\tconst char *c_var;\n\tzval *array_ptr;\n\tint free_buffer = 0;\n\tchar *strtok_buf = NULL;\n\tlong count = 0;\n\t\n\tswitch (arg) {\n\t\tcase PARSE_POST:\n\t\tcase PARSE_GET:\n\t\tcase PARSE_COOKIE:\n\t\t\tALLOC_ZVAL(array_ptr);\n\t\t\tarray_init(array_ptr);\n\t\t\tINIT_PZVAL(array_ptr);\n\t\t\tswitch (arg) {\n\t\t\t\tcase PARSE_POST:\n\t\t\t\t\tif (PG(http_globals)[TRACK_VARS_POST]) {\n\t\t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_POST]);\n\t\t\t\t\t}\n\t\t\t\t\tPG(http_globals)[TRACK_VARS_POST] = array_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARSE_GET:\n\t\t\t\t\tif (PG(http_globals)[TRACK_VARS_GET]) {\n\t\t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);\n\t\t\t\t\t}\n\t\t\t\t\tPG(http_globals)[TRACK_VARS_GET] = array_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARSE_COOKIE:\n\t\t\t\t\tif (PG(http_globals)[TRACK_VARS_COOKIE]) {\n\t\t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_COOKIE]);\n\t\t\t\t\t}\n\t\t\t\t\tPG(http_globals)[TRACK_VARS_COOKIE] = array_ptr;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarray_ptr = destArray;\n\t\t\tbreak;\n\t}\n\n\tif (arg == PARSE_POST) {\n\t\tsapi_handle_post(array_ptr TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tif (arg == PARSE_GET) {\t\t/* GET data */\n\t\tc_var = SG(request_info).query_string;\n\t\tif (c_var && *c_var) {\n\t\t\tres = (char *) estrdup(c_var);\n\t\t\tfree_buffer = 1;\n\t\t} else {\n\t\t\tfree_buffer = 0;\n\t\t}\n\t} else if (arg == PARSE_COOKIE) {\t\t/* Cookie data */\n\t\tc_var = SG(request_info).cookie_data;\n\t\tif (c_var && *c_var) {\n\t\t\tres = (char *) estrdup(c_var);\n\t\t\tfree_buffer = 1;\n\t\t} else {\n\t\t\tfree_buffer = 0;\n\t\t}\n\t} else if (arg == PARSE_STRING) {\t\t/* String data */\n\t\tres = str;\n\t\tfree_buffer = 1;\n\t}\n\n\tif (!res) {\n\t\treturn;\n\t}\n\n\tswitch (arg) {\n\t\tcase PARSE_GET:\n\t\tcase PARSE_STRING:\n\t\t\tseparator = (char *) estrdup(PG(arg_separator).input);\n\t\t\tbreak;\n\t\tcase PARSE_COOKIE:\n\t\t\tseparator = \";\\0\";\n\t\t\tbreak;\n\t}\n\t\n\tvar = php_strtok_r(res, separator, &strtok_buf);\n\t\n\twhile (var) {\n\t\tval = strchr(var, '=');\n\n\t\tif (arg == PARSE_COOKIE) {\n\t\t\t/* Remove leading spaces from cookie names, needed for multi-cookie header where ; can be followed by a space */\n\t\t\twhile (isspace(*var)) {\n\t\t\t\tvar++;\n\t\t\t}\n\t\t\tif (var == val || *var == '\\0') {\n\t\t\t\tgoto next_cookie;\n\t\t\t}\n\t\t}\n\n\t\tif (++count > PG(max_input_vars)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Input variables exceeded %ld. To increase the limit change max_input_vars in php.ini.\", PG(max_input_vars));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val) { /* have a value */\n\t\t\tint val_len;\n\t\t\tunsigned int new_val_len;\n\n\t\t\t*val++ = '\\0';\n\t\t\tphp_url_decode(var, strlen(var));\n\t\t\tval_len = php_url_decode(val, strlen(val));\n\t\t\tval = estrndup(val, val_len);\n\t\t\tif (sapi_module.input_filter(arg, var, &val, val_len, &new_val_len TSRMLS_CC)) {\n\t\t\t\tphp_register_variable_safe(var, val, new_val_len, array_ptr TSRMLS_CC);\n\t\t\t}\n\t\t\tefree(val);\n\t\t} else {\n\t\t\tint val_len;\n\t\t\tunsigned int new_val_len;\n\n\t\t\tphp_url_decode(var, strlen(var));\n\t\t\tval_len = 0;\n\t\t\tval = estrndup(\"\", val_len);\n\t\t\tif (sapi_module.input_filter(arg, var, &val, val_len, &new_val_len TSRMLS_CC)) {\n\t\t\t\tphp_register_variable_safe(var, val, new_val_len, array_ptr TSRMLS_CC);\n\t\t\t}\n\t\t\tefree(val);\n\t\t}\nnext_cookie:\n\t\tvar = php_strtok_r(NULL, separator, &strtok_buf);\n\t}\n\n\tif (arg != PARSE_COOKIE) {\n\t\tefree(separator);\n\t}\n\n\tif (free_buffer) {\n\t\tefree(res);\n\t}\n}", "target": 1, "cwe": ["CWE-601"], "project": "php-src", "commit_id": "98b9dfaec95e6f910f125ed172cdbd25abd006ec", "hash": 16366583096882192108304389916623114753, "size": 138, "message": "Fix for HTTP_PROXY issue.\n\nThe following changes are made:\n- _SERVER/_ENV only has HTTP_PROXY if the local environment has it,\n  and only one from the environment.\n- getenv('HTTP_PROXY') only returns one from the local environment\n- getenv has optional second parameter, telling it to only consider\n  local environment", "idx": 740}
{"func": "bool is_valid_log_name(const char *name, size_t len)\n{\n  if (len > 3)\n  {\n    const char *tail= name + len - 4;\n    if (my_strcasecmp(system_charset_info, tail, \".ini\") == 0 ||\n        my_strcasecmp(system_charset_info, tail, \".cnf\") == 0)\n    {\n      return false;\n    }\n  }\n  return true;\n}", "target": 0, "cwe": ["CWE-264"], "project": "mysql-server", "commit_id": "48bd8b16fe382be302c6f0b45931be5aa6f29a0e", "hash": 155156969145348357440629038738434578439, "size": 13, "message": "Bug#24388753: PRIVILEGE ESCALATION USING MYSQLD_SAFE\n\n[This is the 5.5/5.6 version of the bugfix].\n\nThe problem was that it was possible to write log files ending\nin .ini/.cnf that later could be parsed as an options file.\nThis made it possible for users to specify startup options\nwithout the permissions to do so.\n\nThis patch fixes the problem by disallowing general query log\nand slow query log to be written to files ending in .ini and .cnf.", "idx": 741}
{"func": "inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)\n{\n\tif (y > SIZE_MAX - x) {\n\t\t*result = 0;\n\t\treturn false;\n\t}\n\t*result = x + y;\n\treturn true;\n}", "target": 1, "cwe": ["CWE-119"], "project": "jasper", "commit_id": "65536647d380571d1a9a6c91fa03775fb5bbd256", "hash": 322049129199532099001768179826327785541, "size": 9, "message": "A new experimental memory allocator has been introduced.  The allocator\nis experimental in the sense that its API is not considered stable and\nthe allocator may change or disappear entirely in future versions of\nthe code.  This new allocator tracks how much memory is being used by\njas_malloc and friends.  A maximum upper bound on the memory usage can be\nset via the experimental API provided and a default value can be set at\nbuild time as well.  Such functionality may be useful in run-time\nenvironments where the user wants to be able to limit the amount of\nmemory used by JasPer.  This allocator is not used by default.\nNote: This feature needs C11 functionality.\nNote: The memory allocator is not thread safe in its current form.\n\nA new --memory-limit CLI option has been added to the jasper, imginfo,\nimgcmp, and jiv programs.  The option is only available when the code is\nbuilt with the new memory allocator.\n\nThe support for my old debug memory allocator from the 1990s has been\npurged from the code.  The debug memory allocator is probably not\na very useful thing with the advent of GCC/Clang code sanitizers.\n\nThe safe size_t integer functions no longer set their result upon failure.\nA safe subtract operation was also added.", "idx": 742}
{"func": "static int ecryptfs_read_headers_virt(char *page_virt,\n\t\t\t\t      struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t      struct dentry *ecryptfs_dentry,\n\t\t\t\t      int validate_header_size)\n{\n\tint rc = 0;\n\tint offset;\n\tint bytes_read;\n\n\tecryptfs_set_default_sizes(crypt_stat);\n\tcrypt_stat->mount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\trc = contains_ecryptfs_marker(page_virt + offset);\n\tif (rc == 0) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n\trc = ecryptfs_process_flags(crypt_stat, (page_virt + offset),\n\t\t\t\t    &bytes_read);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error processing flags\\n\");\n\t\tgoto out;\n\t}\n\tif (crypt_stat->file_version > ECRYPTFS_SUPPORTED_FILE_VERSION) {\n\t\tecryptfs_printk(KERN_WARNING, \"File version is [%d]; only \"\n\t\t\t\t\"file version [%d] is supported by this \"\n\t\t\t\t\"version of eCryptfs\\n\",\n\t\t\t\tcrypt_stat->file_version,\n\t\t\t\tECRYPTFS_SUPPORTED_FILE_VERSION);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += bytes_read;\n\tif (crypt_stat->file_version >= 1) {\n\t\trc = parse_header_metadata(crypt_stat, (page_virt + offset),\n\t\t\t\t\t   &bytes_read, validate_header_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_WARNING, \"Error reading header \"\n\t\t\t\t\t\"metadata; rc = [%d]\\n\", rc);\n\t\t}\n\t\toffset += bytes_read;\n\t} else\n\t\tset_default_header_data(crypt_stat);\n\trc = ecryptfs_parse_packet_set(crypt_stat, (page_virt + offset),\n\t\t\t\t       ecryptfs_dentry);\nout:\n\treturn rc;\n}", "target": 0, "cwe": ["CWE-189"], "project": "linux-2.6", "commit_id": "8faece5f906725c10e7a1f6caf84452abadbdc7b", "hash": 94352889297738886537565816820315029505, "size": 50, "message": "eCryptfs: Allocate a variable number of pages for file headers\n\nWhen allocating the memory used to store the eCryptfs header contents, a\nsingle, zeroed page was being allocated with get_zeroed_page().\nHowever, the size of an eCryptfs header is either PAGE_CACHE_SIZE or\nECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE (8192), whichever is larger, and is\nstored in the file's private_data->crypt_stat->num_header_bytes_at_front\nfield.\n\necryptfs_write_metadata_to_contents() was using\nnum_header_bytes_at_front to decide how many bytes should be written to\nthe lower filesystem for the file header.  Unfortunately, at least 8K\nwas being written from the page, despite the chance of the single,\nzeroed page being smaller than 8K.  This resulted in random areas of\nkernel memory being written between the 0x1000 and 0x1FFF bytes offsets\nin the eCryptfs file headers if PAGE_SIZE was 4K.\n\nThis patch allocates a variable number of pages, calculated with\nnum_header_bytes_at_front, and passes the number of allocated pages\nalong to ecryptfs_write_metadata_to_contents().\n\nThanks to Florian Streibelt for reporting the data leak and working with\nme to find the problem.  2.6.28 is the only kernel release with this\nvulnerability.  Corresponds to CVE-2009-0787\n\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>\nAcked-by: Dustin Kirkland <kirkland@canonical.com>\nReviewed-by: Eric Sandeen <sandeen@redhat.com>\nReviewed-by: Eugene Teo <eugeneteo@kernel.sg>\nCc: Greg KH <greg@kroah.com>\nCc: dann frazier <dannf@dannf.org>\nCc: Serge E. Hallyn <serue@us.ibm.com>\nCc: Florian Streibelt <florian@f-streibelt.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 743}
{"func": "static __latent_entropy struct task_struct *copy_process(\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace,\n\t\t\t\t\tint node,\n\t\t\t\t\tstruct kernel_clone_args *args)\n{\n\tint pidfd = -1, retval;\n\tstruct task_struct *p;\n\tstruct multiprocess_signals delayed;\n\tstruct file *pidfile = NULL;\n\tu64 clone_flags = args->flags;\n\tstruct nsproxy *nsp = current->nsproxy;\n\n\t/*\n\t * Don't allow sharing the root directory with processes in a different\n\t * namespace\n\t */\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If the new process will be in a different pid or user namespace\n\t * do not allow it to share a thread group with the forking task.\n\t */\n\tif (clone_flags & CLONE_THREAD) {\n\t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n\t\t    (task_active_pid_ns(current) != nsp->pid_ns_for_children))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * If the new process will be in a different time namespace\n\t * do not allow it to share VM or a thread group with the forking task.\n\t */\n\tif (clone_flags & (CLONE_THREAD | CLONE_VM)) {\n\t\tif (nsp->time_ns != nsp->time_ns_for_children)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (clone_flags & CLONE_PIDFD) {\n\t\t/*\n\t\t * - CLONE_DETACHED is blocked so that we can potentially\n\t\t *   reuse it later for CLONE_PIDFD.\n\t\t * - CLONE_THREAD is blocked until someone really needs it.\n\t\t */\n\t\tif (clone_flags & (CLONE_DETACHED | CLONE_THREAD))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * Force any signals received before this point to be delivered\n\t * before the fork happens.  Collect up signals sent to multiple\n\t * processes that happen during the fork and delay them so that\n\t * they appear to happen after the fork.\n\t */\n\tsigemptyset(&delayed.signal);\n\tINIT_HLIST_NODE(&delayed.node);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (!(clone_flags & CLONE_THREAD))\n\t\thlist_add_head(&delayed.node, &current->signal->multiprocess);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\tretval = -ERESTARTNOINTR;\n\tif (signal_pending(current))\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current, node);\n\tif (!p)\n\t\tgoto fork_out;\n\n\t/*\n\t * This _must_ happen before we call free_task(), i.e. before we jump\n\t * to any of the bad_fork_* labels. This is to avoid freeing\n\t * p->set_child_tid which is (ab)used as a kthread's data pointer for\n\t * kernel threads (PF_KTHREAD).\n\t */\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_free;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (data_race(nr_threads >= max_threads))\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#ifdef CONFIG_IO_URING\n\tp->io_uring = NULL;\n#endif\n\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_PSI\n\tp->psi_flags = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cputimers_init(&p->posix_cputimers);\n\n\tp->io_context = NULL;\n\taudit_set_context(p, NULL);\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_threadgroup_lock;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n\tseqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tmemset(&p->irqtrace, 0, sizeof(p->irqtrace));\n\tp->irqtrace.hardirq_disable_ip\t= _THIS_IP_;\n\tp->irqtrace.softirq_enable_ip\t= _THIS_IP_;\n\tp->softirqs_enabled\t\t= 1;\n\tp->softirq_context\t\t= 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_init_task(p);\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t/* copy all the process information */\n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_signal;\n\tretval = copy_namespaces(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_mm;\n\tretval = copy_io(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(clone_flags, args->stack, args->stack_size, p, args->tls);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tstackleak_task_init(p);\n\n\tif (pid != &init_struct_pid) {\n\t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children, args->set_tid,\n\t\t\t\targs->set_tid_size);\n\t\tif (IS_ERR(pid)) {\n\t\t\tretval = PTR_ERR(pid);\n\t\t\tgoto bad_fork_cleanup_thread;\n\t\t}\n\t}\n\n\t/*\n\t * This has to happen after we've potentially unshared the file\n\t * descriptor table (so that the pidfd doesn't leak into the child\n\t * if the fd table isn't shared).\n\t */\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tretval = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n\t\tif (retval < 0)\n\t\t\tgoto bad_fork_free_pid;\n\n\t\tpidfd = retval;\n\n\t\tpidfile = anon_inode_getfile(\"[pidfd]\", &pidfd_fops, pid,\n\t\t\t\t\t      O_RDWR | O_CLOEXEC);\n\t\tif (IS_ERR(pidfile)) {\n\t\t\tput_unused_fd(pidfd);\n\t\t\tretval = PTR_ERR(pidfile);\n\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t\tget_pid(pid);\t/* held by pidfile now */\n\n\t\tretval = put_user(pidfd, args->pidfd);\n\t\tif (retval)\n\t\t\tgoto bad_fork_put_pidfd;\n\t}\n\n#ifdef CONFIG_BLOCK\n\tp->plug = NULL;\n#endif\n\tfutex_init_task(p);\n\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tsas_ss_reset(p);\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_tsk_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->pid = pid_nr(pid);\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->exit_signal = -1;\n\t\tp->group_leader = current->group_leader;\n\t\tp->tgid = current->tgid;\n\t} else {\n\t\tif (clone_flags & CLONE_PARENT)\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t\telse\n\t\t\tp->exit_signal = args->exit_signal;\n\t\tp->group_leader = p;\n\t\tp->tgid = p->pid;\n\t}\n\n\tp->nr_dirtied = 0;\n\tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n\tp->dirty_paused_when = 0;\n\n\tp->pdeath_signal = 0;\n\tINIT_LIST_HEAD(&p->thread_group);\n\tp->task_works = NULL;\n\n\t/*\n\t * Ensure that the cgroup subsystem policies allow the new process to be\n\t * forked. It should be noted that the new process's css_set can be changed\n\t * between here and cgroup_post_fork() if an organisation operation is in\n\t * progress.\n\t */\n\tretval = cgroup_can_fork(p, args);\n\tif (retval)\n\t\tgoto bad_fork_put_pidfd;\n\n\t/*\n\t * From this point on we must avoid any synchronous user-space\n\t * communication until we take the tasklist-lock. In particular, we do\n\t * not want user-space to be able to predict the process start-time by\n\t * stalling fork(2) after we recorded the start_time but before it is\n\t * visible to the system.\n\t */\n\n\tp->start_time = ktime_get_ns();\n\tp->start_boottime = ktime_get_boottime_ns();\n\n\t/*\n\t * Make it visible to the rest of the system, but dont wake it up yet.\n\t * Need tasklist lock for parent etc handling!\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t}\n\n\tklp_copy_process(p);\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Copy seccomp details explicitly here, in case they were changed\n\t * before holding sighand lock.\n\t */\n\tcopy_seccomp(p);\n\n\trseq_fork(p, clone_flags);\n\n\t/* Don't start children in a dying pid namespace */\n\tif (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {\n\t\tretval = -ENOMEM;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* Let kill terminate clone/fork in the middle */\n\tif (fatal_signal_pending(current)) {\n\t\tretval = -EINTR;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* past the last point of failure */\n\tif (pidfile)\n\t\tfd_install(pidfd, pidfile);\n\n\tinit_task_pid_links(p);\n\tif (likely(p->pid)) {\n\t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n\t\tinit_task_pid(p, PIDTYPE_PID, pid);\n\t\tif (thread_group_leader(p)) {\n\t\t\tinit_task_pid(p, PIDTYPE_TGID, pid);\n\t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n\n\t\t\tif (is_child_reaper(pid)) {\n\t\t\t\tns_of_pid(pid)->child_reaper = p;\n\t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n\t\t\t}\n\t\t\tp->signal->shared_pending.signal = delayed.signal;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\t/*\n\t\t\t * Inherit has_child_subreaper flag under the same\n\t\t\t * tasklist_lock with adding child to the process tree\n\t\t\t * for propagate_has_child_subreaper optimization.\n\t\t\t */\n\t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n\t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\tattach_pid(p, PIDTYPE_TGID);\n\t\t\tattach_pid(p, PIDTYPE_PGID);\n\t\t\tattach_pid(p, PIDTYPE_SID);\n\t\t\t__this_cpu_inc(process_counts);\n\t\t} else {\n\t\t\tcurrent->signal->nr_threads++;\n\t\t\tatomic_inc(&current->signal->live);\n\t\t\trefcount_inc(&current->signal->sigcnt);\n\t\t\ttask_join_group_stop(p);\n\t\t\tlist_add_tail_rcu(&p->thread_group,\n\t\t\t\t\t  &p->group_leader->thread_group);\n\t\t\tlist_add_tail_rcu(&p->thread_node,\n\t\t\t\t\t  &p->signal->thread_head);\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID);\n\t\tnr_threads++;\n\t}\n\ttotal_forks++;\n\thlist_del_init(&delayed.node);\n\tspin_unlock(&current->sighand->siglock);\n\tsyscall_tracepoint_update(p);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_fork_connector(p);\n\tsched_post_fork(p);\n\tcgroup_post_fork(p, args);\n\tperf_event_fork(p);\n\n\ttrace_task_newtask(p, clone_flags);\n\tuprobe_copy_process(p, clone_flags);\n\n\tcopy_oom_score_adj(clone_flags, p);\n\n\treturn p;\n\nbad_fork_cancel_cgroup:\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tcgroup_cancel_fork(p, args);\nbad_fork_put_pidfd:\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tfput(pidfile);\n\t\tput_unused_fd(pidfd);\n\t}\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_thread:\n\texit_thread(p);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm) {\n\t\tmm_clear_owner(p->mm, p);\n\t\tmmput(p->mm);\n\t}\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_perf:\n\tperf_event_free_task(p);\nbad_fork_cleanup_policy:\n\tlockdep_free_task(p);\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_threadgroup_lock:\n#endif\n\tdelayacct_tsk_free(p);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\texit_creds(p);\nbad_fork_free:\n\tp->state = TASK_DEAD;\n\tput_task_stack(p);\n\tdelayed_free_task(p);\nfork_out:\n\tspin_lock_irq(&current->sighand->siglock);\n\thlist_del_init(&delayed.node);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn ERR_PTR(retval);\n}", "target": 1, "cwe": ["CWE-665", "CWE-362"], "project": "linux", "commit_id": "b4e00444cab4c3f3fec876dc0cccc8cbb0d1a948", "hash": 173143261973963860691601241949264591134, "size": 533, "message": "fork: fix copy_process(CLONE_PARENT) race with the exiting ->real_parent\n\ncurrent->group_leader->exit_signal may change during copy_process() if\ncurrent->real_parent exits.\n\nMove the assignment inside tasklist_lock to avoid the race.\n\nSigned-off-by: Eddy Wu <eddy_wu@trendmicro.com>\nAcked-by: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 744}
{"func": "TPMI_ALG_SYM_OBJECT_Unmarshal(TPMI_ALG_SYM_OBJECT *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_AES\n\t  case TPM_ALG_AES:\n#endif\n#if ALG_SM4\n\t  case TPM_ALG_SM4:\t\t\n#endif\n#if ALG_CAMELLIA\n\t  case TPM_ALG_CAMELLIA:\t\n#endif\n#if ALG_TDES\t\t// libtpms added begin\n          case TPM_ALG_TDES:\n#endif\t\t\t// iibtpms added end\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_SYMMETRIC;\n\t}\n    }\n    return rc;\n}", "target": 1, "cwe": ["CWE-787"], "project": "libtpms", "commit_id": "5cc98a62dc6f204dcf5b87c2ee83ac742a6a319b", "hash": 276840427385071910894544550717555747305, "size": 32, "message": "tpm2: Restore original value if unmarshalled value was illegal\n\nRestore the original value of the memory location where data from\na stream was unmarshalled and the unmarshalled value was found to\nbe illegal. The goal is to not keep illegal values in memory.\n\nSigned-off-by: Stefan Berger <stefanb@linux.ibm.com>", "idx": 745}
{"func": "\nstatic void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype,\n\t\t\t\t\tbool opt_stats)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));\n\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tserr->opt_stats = opt_stats;\n\tserr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\n\terr = sock_queue_err_skb(sk, skb);\n\n\tif (err)\n\t\tkfree_skb(skb);", "target": 0, "cwe": ["CWE-20"], "project": "linux", "commit_id": "2b16f048729bf35e6c28a40cbfad07239f9dcd90", "hash": 209708120465626242294655054261310769251, "size": 29, "message": "net: create skb_gso_validate_mac_len()\n\nIf you take a GSO skb, and split it into packets, will the MAC\nlength (L2 + L3 + L4 headers + payload) of those packets be small\nenough to fit within a given length?\n\nMove skb_gso_mac_seglen() to skbuff.h with other related functions\nlike skb_gso_network_seglen() so we can use it, and then create\nskb_gso_validate_mac_len to do the full calculation.\n\nSigned-off-by: Daniel Axtens <dja@axtens.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 746}
{"func": "escapes(cp, tp)\nconst char\t*cp;\nchar *tp;\n{\n    while (*cp) {\n\tint\tcval = 0, meta = 0;\n\n\tif (*cp == '\\\\' && cp[1] && index(\"mM\", cp[1]) && cp[2]) {\n\t\tmeta = 1;\n\t\tcp += 2;\n\t}\n\tif (*cp == '\\\\' && cp[1] && index(\"0123456789xXoO\", cp[1]) && cp[2]) {\n\t    NEARDATA const char hex[] = \"00112233445566778899aAbBcCdDeEfF\";\n\t    const char *dp;\n\t    int dcount = 0;\n\n\t    cp++;\n\t    if (*cp == 'x' || *cp == 'X')\n\t\tfor (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)\n\t\t    cval = (cval * 16) + ((int)(dp - hex) / 2);\n\t    else if (*cp == 'o' || *cp == 'O')\n\t\tfor (++cp; *cp && (index(\"01234567\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 8) + (*cp - '0');\n\t    else\n\t\tfor (; *cp && (index(\"0123456789\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 10) + (*cp - '0');\n\t} else if (*cp == '\\\\' && cp[1]) {\t/* C-style character escapes */\n\t    switch (*++cp) {\n\t    case '\\\\': cval = '\\\\'; break;\n\t    case 'n': cval = '\\n'; break;\n\t    case 't': cval = '\\t'; break;\n\t    case 'b': cval = '\\b'; break;\n\t    case 'r': cval = '\\r'; break;\n\t    default: cval = *cp;\n\t    }\n\t    cp++;\n\t} else if (*cp == '^' && cp[1]) { /* expand control-character syntax */\n\t    cval = (*++cp & 0x1f);\n\t    cp++;\n\t} else\n\t    cval = *cp++;\n\n\tif (meta)\n\t    cval |= 0x80;\n\t*tp++ = cval;\n    }\n    *tp = '\\0';\n}", "target": 1, "cwe": ["CWE-269"], "project": "NetHack", "commit_id": "612755bfb5c412079795c68ba392df5d93874ed8", "hash": 331882839961033303386759701136254392643, "size": 48, "message": "escapes() revamp\n\n     Partial rewrite of escapes(), mostly changing its if-then-else\nlogic so that end-of-string can be checked once instead for each case.\nThe previous version had a bug if the input string ended with backslash\nand one decimal digit (due to being lumped together with the handling\nfor trailing \\X or \\O).", "idx": 747}
{"func": "cmsToneCurve* ComputeKToLstar(cmsContext            ContextID,\r\n                               cmsUInt32Number       nPoints,\r\n                               cmsUInt32Number       nProfiles,\r\n                               const cmsUInt32Number Intents[],\r\n                               const cmsHPROFILE     hProfiles[],\r\n                               const cmsBool         BPC[],\r\n                               const cmsFloat64Number AdaptationStates[],\r\n                               cmsUInt32Number dwFlags)\r\n{\r\n    cmsToneCurve* out = NULL;\r\n    cmsUInt32Number i;\r\n    cmsHTRANSFORM xform;\r\n    cmsCIELab Lab;\r\n    cmsFloat32Number cmyk[4];\r\n    cmsFloat32Number* SampledPoints;\r\n\r\n    xform = _cmsChain2Lab(ContextID, nProfiles, TYPE_CMYK_FLT, TYPE_Lab_DBL, Intents, hProfiles, BPC, AdaptationStates, dwFlags);\r\n    if (xform == NULL) return NULL;\r\n\r\n    SampledPoints = (cmsFloat32Number*) _cmsCalloc(ContextID, nPoints, sizeof(cmsFloat32Number));\r\n    if (SampledPoints  == NULL) goto Error;\r\n\r\n    for (i=0; i < nPoints; i++) {\r\n\r\n        cmyk[0] = 0;\r\n        cmyk[1] = 0;\r\n        cmyk[2] = 0;\r\n        cmyk[3] = (cmsFloat32Number) ((i * 100.0) / (nPoints-1));\r\n\r\n        cmsDoTransform(xform, cmyk, &Lab, 1);\r\n        SampledPoints[i]= (cmsFloat32Number) (1.0 - Lab.L / 100.0); // Negate K for easier operation\r\n    }\r\n\r\n    out = cmsBuildTabulatedToneCurveFloat(ContextID, nPoints, SampledPoints);\r\n\r\nError:\r\n\r\n    cmsDeleteTransform(xform);\r\n    if (SampledPoints) _cmsFree(ContextID, SampledPoints);\r\n\r\n    return out;\r\n}\r", "target": 0, "cwe": [], "project": "Little-CMS", "commit_id": "41d222df1bc6188131a8f46c32eab0a4d4cdf1b6", "hash": 297243087894345048855568670002220527631, "size": 42, "message": "Memory squeezing fix: lcms2 cmsPipeline construction\n\nWhen creating a new pipeline, lcms would often try to allocate a stage\nand pass it to cmsPipelineInsertStage without checking whether the\nallocation succeeded. cmsPipelineInsertStage would then assert (or crash)\nif it had not.\n\nThe fix here is to change cmsPipelineInsertStage to check and return\nan error value. All calling code is then checked to test this return\nvalue and cope.", "idx": 748}
{"func": "\tswitch (yych) {\n\t\tcase 'a': goto yy35;\n\t\tdefault: goto yy33;\n\t}", "target": 1, "cwe": ["CWE-787"], "project": "re2c", "commit_id": "039c18949190c5de5397eba504d2c75dad2ea9ca", "hash": 234837714712407323629807739818264252042, "size": 4, "message": "Emit an error when repetition lower bound exceeds upper bound.\n\nHistorically this was allowed and re2c swapped the bounds. However, it\nmost likely indicates an error in user code and there is only a single\noccurrence in the tests (and the test in an artificial one), so although\nthe change is backwards incompatible there is low chance of breaking\nreal-world code.\n\nThis fixes second test case in the bug #394 \"Stack overflow due to\nrecursion in src/dfa/dead_rules.cc\" (the actual fix is to limit DFA size\nbut the test also has counted repetition with swapped bounds).", "idx": 749}
{"func": "tree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\n\t\t    struct extent_buffer *eb, u64 time_seq)\n{\n\tstruct extent_buffer *eb_rewin;\n\tstruct tree_mod_elem *tm;\n\n\tif (!time_seq)\n\t\treturn eb;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn eb;\n\n\ttm = tree_mod_log_search(fs_info, eb->start, time_seq);\n\tif (!tm)\n\t\treturn eb;\n\n\tbtrfs_set_path_blocking(path);\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\n\tif (tm->op == MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tBUG_ON(tm->slot != 0);\n\t\teb_rewin = alloc_dummy_extent_buffer(eb->start,\n\t\t\t\t\t\tfs_info->tree_root->nodesize);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t\tbtrfs_set_header_bytenr(eb_rewin, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb_rewin,\n\t\t\t\t\t     btrfs_header_backref_rev(eb));\n\t\tbtrfs_set_header_owner(eb_rewin, btrfs_header_owner(eb));\n\t\tbtrfs_set_header_level(eb_rewin, btrfs_header_level(eb));\n\t} else {\n\t\teb_rewin = btrfs_clone_extent_buffer(eb);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbtrfs_clear_path_blocking(path, NULL, BTRFS_READ_LOCK);\n\tbtrfs_tree_read_unlock_blocking(eb);\n\tfree_extent_buffer(eb);\n\n\textent_buffer_get(eb_rewin);\n\tbtrfs_tree_read_lock(eb_rewin);\n\t__tree_mod_log_rewind(fs_info, eb_rewin, time_seq, tm);\n\tWARN_ON(btrfs_header_nritems(eb_rewin) >\n\t\tBTRFS_NODEPTRS_PER_BLOCK(fs_info->tree_root));\n\n\treturn eb_rewin;\n}", "target": 0, "cwe": ["CWE-416", "CWE-362"], "project": "linux", "commit_id": "5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339", "hash": 290833977879265526140650529078764288767, "size": 54, "message": "Btrfs: make xattr replace operations atomic\n\nReplacing a xattr consists of doing a lookup for its existing value, delete\nthe current value from the respective leaf, release the search path and then\nfinally insert the new value. This leaves a time window where readers (getxattr,\nlistxattrs) won't see any value for the xattr. Xattrs are used to store ACLs,\nso this has security implications.\n\nThis change also fixes 2 other existing issues which were:\n\n*) Deleting the old xattr value without verifying first if the new xattr will\n   fit in the existing leaf item (in case multiple xattrs are packed in the\n   same item due to name hash collision);\n\n*) Returning -EEXIST when the flag XATTR_CREATE is given and the xattr doesn't\n   exist but we have have an existing item that packs muliple xattrs with\n   the same name hash as the input xattr. In this case we should return ENOSPC.\n\nA test case for xfstests follows soon.\n\nThanks to Alexandre Oliva for reporting the non-atomicity of the xattr replace\nimplementation.\n\nReported-by: Alexandre Oliva <oliva@gnu.org>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: Chris Mason <clm@fb.com>", "idx": 750}
{"func": "int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\treturn 64;\n}", "target": 0, "cwe": ["CWE-415"], "project": "FreeRDP", "commit_id": "67c2aa52b2ae0341d469071d1bc8aab91f8d2ed8", "hash": 145949936619821269337418664827068196737, "size": 4, "message": "Fixed #6013: Check new length is > 0", "idx": 751}
{"func": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, int aligned)\n{\n\tint buffers = 0, error = 0;\n\n\tdown_read(&current->mm->mmap_sem);\n\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\n\t\terror = -EFAULT;\n\t\tif (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (unlikely(!base))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get this base offset and number of pages, then map\n\t\t * in the user pages.\n\t\t */\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\n\t\t/*\n\t\t * If asked for alignment, the offset must be zero and the\n\t\t * length a multiple of the PAGE_SIZE.\n\t\t */\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > PIPE_BUFFERS - buffers)\n\t\t\tnpages = PIPE_BUFFERS - buffers;\n\n\t\terror = get_user_pages(current, current->mm,\n\t\t\t\t       (unsigned long) base, npages, 0, 0,\n\t\t\t\t       &pages[buffers], NULL);\n\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Fill this contiguous range into the partial page map.\n\t\t */\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\n\t\t/*\n\t\t * We didn't complete this iov, stop here since it probably\n\t\t * means we have to move some of this into a pipe to\n\t\t * be able to continue.\n\t\t */\n\t\tif (len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Don't continue if we mapped fewer pages than we asked for,\n\t\t * or if we mapped the max number of pages that we have\n\t\t * room for.\n\t\t */\n\t\tif (error < npages || buffers == PIPE_BUFFERS)\n\t\t\tbreak;\n\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\n\tup_read(&current->mm->mmap_sem);\n\n\tif (buffers)\n\t\treturn buffers;\n\n\treturn error;\n}", "target": 1, "cwe": ["CWE-94"], "project": "linux-2.6", "commit_id": "712a30e63c8066ed84385b12edbfb804f49cbc44", "hash": 235267654020111867894816915382074891733, "size": 98, "message": "splice: fix user pointer access in get_iovec_page_array()\n\nCommit 8811930dc74a503415b35c4a79d14fb0b408a361 (\"splice: missing user\npointer access verification\") added the proper access_ok() calls to\ncopy_from_user_mmap_sem() which ensures we can copy the struct iovecs\nfrom userspace to the kernel.\n\nBut we also must check whether we can access the actual memory region\npointed to by the struct iovec to fix the access checks properly.\n\nSigned-off-by: Bastian Blank <waldi@debian.org>\nAcked-by: Oliver Pinter <oliver.pntr@gmail.com>\nCc: Jens Axboe <jens.axboe@oracle.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Pekka Enberg <penberg@cs.helsinki.fi>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 752}
{"func": "static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)\n{\n  return h * ((w * lodepng_get_bpp(color) + 7) / 8);\n}", "target": 0, "cwe": ["CWE-401"], "project": "FreeRDP", "commit_id": "9fee4ae076b1ec97b97efb79ece08d1dab4df29a", "hash": 303598992870137825402005839400265851876, "size": 4, "message": "Fixed #5645: realloc return handling", "idx": 753}
{"func": "static inline unsigned int ScaleQuantumToLong(const Quantum quantum)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((unsigned int) (65537UL*quantum));\n#else\n  if (quantum <= 0.0)\n    return(0UL);\n  if ((65537.0*quantum) >= 4294967295.0)\n    return(4294967295U);\n  return((unsigned int) (65537.0*quantum+0.5));\n#endif\n}", "target": 1, "cwe": ["CWE-190"], "project": "ImageMagick", "commit_id": "95d4e94e0353e503b71a53f5e6fad173c7c70c90", "hash": 160102360387542874392604161248437247130, "size": 12, "message": "https://github.com/ImageMagick/ImageMagick/issues/1751", "idx": 754}
{"func": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n\n    len = s->dma_left;\n    if (s->do_cmd) {\n        trace_esp_do_dma(s->cmdlen, len);\n        s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n        return;\n    }\n    if (s->async_len == 0) {\n        /* Defer until data is available.  */\n        return;\n    }\n    if (len > s->async_len) {\n        len = s->async_len;\n    }\n    to_device = (s->ti_size < 0);\n    if (to_device) {\n        s->dma_memory_read(s->dma_opaque, s->async_buf, len);\n    } else {\n        s->dma_memory_write(s->dma_opaque, s->async_buf, len);\n    }\n    s->dma_left -= len;\n    s->async_buf += len;\n    s->async_len -= len;\n    if (to_device)\n        s->ti_size += len;\n    else\n        s->ti_size -= len;\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        /* If there is still data to be read from the device then\n           complete the DMA operation immediately.  Otherwise defer\n           until the scsi layer has completed.  */\n        if (to_device || s->dma_left != 0 || s->ti_size == 0) {\n            return;\n        }\n    }\n\n    /* Partially filled a scsi buffer. Complete immediately.  */\n    esp_dma_done(s);\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "926cde5f3e4d2504ed161ed0cb771ac7cad6fd11", "hash": 329259981673682323809106020172254290812, "size": 44, "message": "scsi: esp: make cmdbuf big enough for maximum CDB size\n\nWhile doing DMA read into ESP command buffer 's->cmdbuf', it could\nwrite past the 's->cmdbuf' area, if it was transferring more than 16\nbytes.  Increase the command buffer size to 32, which is maximum when\n's->do_cmd' is set, and add a check on 'len' to avoid OOB access.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 755}
{"func": "control_notify_input(struct client *c, struct window_pane *wp,\n    struct evbuffer *input)\n{\n\tu_char\t\t*buf;\n\tsize_t\t\t len;\n\tstruct evbuffer *message;\n\tu_int\t\t i;\n\n\tif (c->session == NULL)\n\t    return;\n\n\tbuf = EVBUFFER_DATA(input);\n\tlen = EVBUFFER_LENGTH(input);\n\n\t/*\n\t * Only write input if the window pane is linked to a window belonging\n\t * to the client's session.\n\t */\n\tif (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {\n\t\tmessage = evbuffer_new();\n\t\tevbuffer_add_printf(message, \"%%output %%%u \", wp->id);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (buf[i] < ' ' || buf[i] == '\\\\')\n\t\t\t    evbuffer_add_printf(message, \"\\\\%03o\", buf[i]);\n\t\t\telse\n\t\t\t    evbuffer_add_printf(message, \"%c\", buf[i]);\n\t\t}\n\t\tcontrol_write_buffer(c, message);\n\t\tevbuffer_free(message);\n\t}\n}", "target": 1, "cwe": [], "project": "src", "commit_id": "b32e1d34e10a0da806823f57f02a4ae6e93d756e", "hash": 74478391339525808688400170948540263906, "size": 31, "message": "evbuffer_new and bufferevent_new can both fail (when malloc fails) and\nreturn NULL. GitHub issue 1547.", "idx": 756}
{"func": "HandleUltraZipBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n  rfbZlibHeader hdr;\n  int i=0;\n  int toRead=0;\n  int inflateResult=0;\n  unsigned char *ptr=NULL;\n  lzo_uint uncompressedBytes = ry + (rw * 65535);\n  unsigned int numCacheRects = rx;\n\n  if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader))\n    return FALSE;\n\n  toRead = rfbClientSwap32IfLE(hdr.nBytes);\n\n  if (toRead==0) return TRUE;\n\n  if (uncompressedBytes==0)\n  {\n      rfbClientLog(\"ultrazip error: rectangle has 0 uncomressed bytes (%dy + (%dw * 65535)) (%d rectangles)\\n\", ry, rw, rx); \n      return FALSE;\n  }\n\n  /* First make sure we have a large enough raw buffer to hold the\n   * decompressed data.  In practice, with a fixed BPP, fixed frame\n   * buffer size and the first update containing the entire frame\n   * buffer, this buffer allocation should only happen once, on the\n   * first update.\n   */\n  if ( client->raw_buffer_size < (int)(uncompressedBytes + 500)) {\n    if ( client->raw_buffer != NULL ) {\n      free( client->raw_buffer );\n    }\n    client->raw_buffer_size = uncompressedBytes + 500;\n    /* buffer needs to be aligned on 4-byte boundaries */\n    if ((client->raw_buffer_size % 4)!=0)\n      client->raw_buffer_size += (4-(client->raw_buffer_size % 4));\n    client->raw_buffer = (char*) malloc( client->raw_buffer_size );\n  }\n\n \n  /* allocate enough space to store the incoming compressed packet */\n  if ( client->ultra_buffer_size < toRead ) {\n    if ( client->ultra_buffer != NULL ) {\n      free( client->ultra_buffer );\n    }\n    client->ultra_buffer_size = toRead;\n    client->ultra_buffer = (char*) malloc( client->ultra_buffer_size );\n  }\n\n  /* Fill the buffer, obtaining data from the server. */\n  if (!ReadFromRFBServer(client, client->ultra_buffer, toRead))\n      return FALSE;\n\n  /* uncompress the data */\n  uncompressedBytes = client->raw_buffer_size;\n  inflateResult = lzo1x_decompress_safe(\n              (lzo_byte *)client->ultra_buffer, toRead,\n              (lzo_byte *)client->raw_buffer, &uncompressedBytes, NULL);\n  if ( inflateResult != LZO_E_OK ) \n  {\n    rfbClientLog(\"ultra decompress returned error: %d\\n\",\n            inflateResult);\n    return FALSE;\n  }\n  \n  /* Put the uncompressed contents of the update on the screen. */\n  ptr = (unsigned char *)client->raw_buffer;\n  for (i=0; i<numCacheRects; i++)\n  {\n    unsigned short sx, sy, sw, sh;\n    unsigned int se;\n\n    memcpy((char *)&sx, ptr, 2); ptr += 2;\n    memcpy((char *)&sy, ptr, 2); ptr += 2;\n    memcpy((char *)&sw, ptr, 2); ptr += 2;\n    memcpy((char *)&sh, ptr, 2); ptr += 2;\n    memcpy((char *)&se, ptr, 4); ptr += 4;\n\n    sx = rfbClientSwap16IfLE(sx);\n    sy = rfbClientSwap16IfLE(sy);\n    sw = rfbClientSwap16IfLE(sw);\n    sh = rfbClientSwap16IfLE(sh);\n    se = rfbClientSwap32IfLE(se);\n\n    if (se == rfbEncodingRaw)\n    {\n        client->GotBitmap(client, (unsigned char *)ptr, sx, sy, sw, sh);\n        ptr += ((sw * sh) * (BPP / 8));\n    }\n  }  \n\n  return TRUE;\n}", "target": 1, "cwe": ["CWE-476"], "project": "libvncserver", "commit_id": "4a21bbd097ef7c44bb000c3bd0907f96a10e4ce7", "hash": 139742181932827091784892515388718806995, "size": 94, "message": "LibVNCClient: make sure Ultra decoding cannot dereference a null pointer\n\nCloses #254", "idx": 757}
{"func": "Status Examples::CreateSparseFeatureRepresentation(\n    const DeviceBase::CpuWorkerThreads& worker_threads, const int num_examples,\n    const int num_sparse_features, const ModelWeights& weights,\n    const OpInputList& sparse_example_indices_inputs,\n    const OpInputList& sparse_feature_indices_inputs,\n    const OpInputList& sparse_feature_values_inputs,\n    std::vector<Example>* const examples) {\n  mutex mu;\n  Status result;  // Guarded by mu\n  auto parse_partition = [&](const int64 begin, const int64 end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    for (int i = static_cast<int>(begin); i < end; ++i) {\n      auto example_indices =\n          sparse_example_indices_inputs[i].template flat<int64>();\n      auto feature_indices =\n          sparse_feature_indices_inputs[i].template flat<int64>();\n\n      // Parse features for each example. Features for a particular example\n      // are at the offsets (start_id, end_id]\n      int start_id = -1;\n      int end_id = 0;\n      for (int example_id = 0; example_id < num_examples; ++example_id) {\n        start_id = end_id;\n        while (end_id < example_indices.size() &&\n               example_indices(end_id) == example_id) {\n          ++end_id;\n        }\n        Example::SparseFeatures* const sparse_features =\n            &(*examples)[example_id].sparse_features_[i];\n        if (start_id < example_indices.size() &&\n            example_indices(start_id) == example_id) {\n          sparse_features->indices.reset(new UnalignedInt64Vector(\n              &(feature_indices(start_id)), end_id - start_id));\n          if (sparse_feature_values_inputs.size() > i) {\n            auto feature_weights =\n                sparse_feature_values_inputs[i].flat<float>();\n            sparse_features->values.reset(new UnalignedFloatVector(\n                &(feature_weights(start_id)), end_id - start_id));\n          }\n          // If features are non empty.\n          if (end_id - start_id > 0) {\n            // TODO(sibyl-Aix6ihai): Write this efficiently using vectorized\n            // operations from eigen.\n            for (int64 k = 0; k < sparse_features->indices->size(); ++k) {\n              const int64 feature_index = (*sparse_features->indices)(k);\n              if (!weights.SparseIndexValid(i, feature_index)) {\n                mutex_lock l(mu);\n                result = errors::InvalidArgument(\n                    \"Found sparse feature indices out of valid range: \",\n                    (*sparse_features->indices)(k));\n                return;\n              }\n            }\n          }\n        } else {\n          // Add a Tensor that has size 0.\n          sparse_features->indices.reset(\n              new UnalignedInt64Vector(&(feature_indices(0)), 0));\n          // If values exist for this feature group.\n          if (sparse_feature_values_inputs.size() > i) {\n            auto feature_weights =\n                sparse_feature_values_inputs[i].flat<float>();\n            sparse_features->values.reset(\n                new UnalignedFloatVector(&(feature_weights(0)), 0));\n          }\n        }\n      }\n    }\n  };\n  // For each column, the cost of parsing it is O(num_examples). We use\n  // num_examples here, as empirically Shard() creates the right amount of\n  // threads based on the problem size.\n  // TODO(sibyl-Aix6ihai): Tune this as a function of dataset size.\n  const int64 kCostPerUnit = num_examples;\n  Shard(worker_threads.num_threads, worker_threads.workers, num_sparse_features,\n        kCostPerUnit, parse_partition);\n  return result;\n}", "target": 1, "cwe": ["CWE-476"], "project": "tensorflow", "commit_id": "f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb", "hash": 313843667632355309435782049308247490832, "size": 79, "message": "Add several missing validations in SDCA\n\nPiperOrigin-RevId: 372172877\nChange-Id: Id366da962432e18dcbfac847d11e98488bebb70a", "idx": 758}
{"func": "TfLiteRegistration* Register_WHILE() {\n  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,\n                                 while_kernel::Prepare, while_kernel::Eval};\n  return &r;\n}", "target": 0, "cwe": ["CWE-125", "CWE-787"], "project": "tensorflow", "commit_id": "1970c2158b1ffa416d159d03c3370b9a462aee35", "hash": 256904645465597112931200893450732340887, "size": 5, "message": "[tflite]: Insert `nullptr` checks when obtaining tensors.\n\nAs part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.\n\nWe also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).\n\nPiperOrigin-RevId: 332521299\nChange-Id: I29af455bcb48d0b92e58132d951a3badbd772d56", "idx": 759}
{"func": "static int __init pppol2tp_init(void)\n{\n\tint err;\n\n\terr = register_pernet_device(&pppol2tp_net_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = proto_register(&pppol2tp_sk_proto, 0);\n\tif (err)\n\t\tgoto out_unregister_pppol2tp_pernet;\n\n\terr = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);\n\tif (err)\n\t\tgoto out_unregister_pppol2tp_proto;\n\n#ifdef CONFIG_L2TP_V3\n\terr = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);\n\tif (err)\n\t\tgoto out_unregister_pppox;\n#endif\n\n\tpr_info(\"PPPoL2TP kernel driver, %s\\n\", PPPOL2TP_DRV_VERSION);\n\nout:\n\treturn err;\n\n#ifdef CONFIG_L2TP_V3\nout_unregister_pppox:\n\tunregister_pppox_proto(PX_PROTO_OL2TP);\n#endif\nout_unregister_pppol2tp_proto:\n\tproto_unregister(&pppol2tp_sk_proto);\nout_unregister_pppol2tp_pernet:\n\tunregister_pernet_device(&pppol2tp_net_ops);\n\tgoto out;\n}", "target": 0, "cwe": ["CWE-416"], "project": "linux", "commit_id": "f026bc29a8e093edfbb2a77700454b285c97e8ad", "hash": 22341374293346894842449657275418201668, "size": 37, "message": "l2tp: pass tunnel pointer to ->session_create()\n\nUsing l2tp_tunnel_find() in pppol2tp_session_create() and\nl2tp_eth_create() is racy, because no reference is held on the\nreturned session. These functions are only used to implement the\n->session_create callback which is run by l2tp_nl_cmd_session_create().\nTherefore searching for the parent tunnel isn't necessary because\nl2tp_nl_cmd_session_create() already has a pointer to it and holds a\nreference.\n\nThis patch modifies ->session_create()'s prototype to directly pass the\nthe parent tunnel as parameter, thus avoiding searching for it in\npppol2tp_session_create() and l2tp_eth_create().\n\nSince we have to touch the ->session_create() call in\nl2tp_nl_cmd_session_create(), let's also remove the useless conditional:\nwe know that ->session_create isn't NULL at this point because it's\nalready been checked earlier in this same function.\n\nFinally, one might be tempted to think that the removed\nl2tp_tunnel_find() calls were harmless because they would return the\nsame tunnel as the one held by l2tp_nl_cmd_session_create() anyway.\nBut that tunnel might be removed and a new one created with same tunnel\nId before the l2tp_tunnel_find() call. In this case l2tp_tunnel_find()\nwould return the new tunnel which wouldn't be protected by the\nreference held by l2tp_nl_cmd_session_create().\n\nFixes: 309795f4bec2 (\"l2tp: Add netlink control API for L2TP\")\nFixes: d9e31d17ceba (\"l2tp: Add L2TP ethernet pseudowire support\")\nSigned-off-by: Guillaume Nault <g.nault@alphalink.fr>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 760}
{"func": "static int oidc_handle_session_management(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tchar *cmd = NULL;\n\tconst char *id_token_hint = NULL, *client_id = NULL, *check_session_iframe =\n\t\t\tNULL;\n\toidc_provider_t *provider = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_SESSION, &cmd);\n\tif (cmd == NULL) {\n\t\toidc_error(r, \"session management handler called with no command\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if this is a local logout during session management */\n\tif (apr_strnatcmp(\"logout\", cmd) == 0) {\n\t\toidc_debug(r,\n\t\t\t\t\"[session=logout] calling oidc_handle_logout_request because of session mgmt local logout call.\");\n\t\treturn oidc_handle_logout_request(r, c, session, c->default_slo_url);\n\t}\n\n\t/* see if this is a request for the OP iframe */\n\tif (apr_strnatcmp(\"iframe_op\", cmd) == 0) {\n\t\tcheck_session_iframe = oidc_session_get_check_session_iframe(r,\n\t\t\t\tsession);\n\t\tif (check_session_iframe != NULL) {\n\t\t\treturn oidc_handle_session_management_iframe_op(r, c, session,\n\t\t\t\t\tcheck_session_iframe);\n\t\t}\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request for the RP iframe */\n\tif (apr_strnatcmp(\"iframe_rp\", cmd) == 0) {\n\t\tclient_id = oidc_session_get_client_id(r, session);\n\t\tcheck_session_iframe = oidc_session_get_check_session_iframe(r,\n\t\t\t\tsession);\n\t\tif ((client_id != NULL) && (check_session_iframe != NULL)) {\n\t\t\treturn oidc_handle_session_management_iframe_rp(r, c, session,\n\t\t\t\t\tclient_id, check_session_iframe);\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"iframe_rp command issued but no client (%s) and/or no check_session_iframe (%s) set\",\n\t\t\t\tclient_id, check_session_iframe);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request check the login state with the OP */\n\tif (apr_strnatcmp(\"check\", cmd) == 0) {\n\t\tid_token_hint = oidc_session_get_idtoken(r, session);\n\t\toidc_get_provider_from_session(r, c, session, &provider);\n\t\tif ((session->remote_user != NULL) && (provider != NULL)) {\n\t\t\t/*\n\t\t\t * TODO: this doesn't work with per-path provided auth_request_params and scopes\n\t\t\t *       as oidc_dir_cfg_path_auth_request_params and oidc_dir_cfg_path_scope will pick\n\t\t\t *       those for the redirect_uri itself; do we need to store those as part of the\n\t\t\t *       session now?\n\t\t\t */\n\t\t\treturn oidc_authenticate_user(r, c, provider,\n\t\t\t\t\tapr_psprintf(r->pool, \"%s?session=iframe_rp\",\n\t\t\t\t\t\t\toidc_get_redirect_uri_iss(r, c, provider)), NULL,\n\t\t\t\t\t\t\tid_token_hint, \"none\",\n\t\t\t\t\t\t\toidc_dir_cfg_path_auth_request_params(r),\n\t\t\t\t\t\t\toidc_dir_cfg_path_scope(r));\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"[session=check] calling oidc_handle_logout_request because no session found.\");\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\n\t/* handle failure in fallthrough */\n\toidc_error(r, \"unknown command: %s\", cmd);\n\n\treturn HTTP_INTERNAL_SERVER_ERROR;\n}", "target": 0, "cwe": ["CWE-79"], "project": "mod_auth_openidc", "commit_id": "132a4111bf3791e76437619a66336dce2ce4c79b", "hash": 108736056484623666960688004547386192309, "size": 75, "message": "release 2.3.10.2: fix XSS vulnerability for poll parameter\n\nin OIDC Session Management RP iframe; CSNC-2019-001; thanks Mischa\nBachmann\n\nSigned-off-by: Hans Zandbelt <hans.zandbelt@zmartzone.eu>", "idx": 761}
{"func": "archive_read_format_lha_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *p;\n\tconst void *buff;\n\tssize_t bytes_avail, offset, window;\n\tsize_t next;\n\n\t/* If there's already a better bid than we can ever\n\t   make, don't bother testing. */\n\tif (best_bid > 30)\n\t\treturn (-1);\n\n\tif ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)\n\t\treturn (-1);\n\n\tif (lha_check_header_format(p) == 0)\n\t\treturn (30);\n\n\tif (p[0] == 'M' && p[1] == 'Z') {\n\t\t/* PE file */\n\t\toffset = 0;\n\t\twindow = 4096;\n\t\twhile (offset < (1024 * 20)) {\n\t\t\tbuff = __archive_read_ahead(a, offset + window,\n\t\t\t    &bytes_avail);\n\t\t\tif (buff == NULL) {\n\t\t\t\t/* Remaining bytes are less than window. */\n\t\t\t\twindow >>= 1;\n\t\t\t\tif (window < (H_SIZE + 3))\n\t\t\t\t\treturn (0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp = (const char *)buff + offset;\n\t\t\twhile (p + H_SIZE < (const char *)buff + bytes_avail) {\n\t\t\t\tif ((next = lha_check_header_format(p)) == 0)\n\t\t\t\t\treturn (30);\n\t\t\t\tp += next;\n\t\t\t}\n\t\t\toffset = p - (const char *)buff;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 0, "cwe": ["CWE-125"], "project": "libarchive", "commit_id": "98dcbbf0bf4854bf987557e55e55fff7abbf3ea9", "hash": 305976040907421822134370056645380415586, "size": 43, "message": "Fail with negative lha->compsize in lha_read_file_header_1()\nFixes a heap buffer overflow reported in Secunia SA74169", "idx": 762}
{"func": "uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)\n{\n\treturn LUKS2_hdr_and_areas_size_jobj(hdr->jobj);\n}", "target": 0, "cwe": ["CWE-787"], "project": "cryptsetup", "commit_id": "52f5cb8cedf22fb3e14c744814ec8af7614146c7", "hash": 268019398529950929408874230264475110266, "size": 4, "message": "Check segment gaps regardless of heap space.\n\nSegments are validated in hdr_validate_segments. Gaps in segment keys\nare detected when collecting offsets. But if an invalid segment is very\nlarge, larger than count, it could happen that cryptsetup is unable to\nallocate enough memory, not giving a clue about what actually is the\nproblem.\n\nTherefore check for gaps even if not enough memory is available. This\ngives much more information with debug output enabled.\n\nObviously cryptsetup still fails if segments are perfectly fine but not\nenough RAM available. But at that stage, the user knows that it's the\nfault of the system, not of an invalid segment.", "idx": 763}
{"func": "TEST_F(EncryptionUtilTest, sm4_test_by_case) {\n    std::string case_1 = \"P/Ub8/arZ22TW+rAT5sgYg==\"; // base64 for encrypted \"hello, doris\"\n    std::string source_1 = \"hello, doris\";\n    std::string case_2 = \"2I+UW9axOP2Tv35BGYgy+g==\"; // base64 for encrypted \"doris test\"\n    std::string source_2 = \"doris test\";\n\n    std::unique_ptr<char[]> encrypt_1(new char[case_1.length()]);\n    int length_1 = base64_decode(case_1.c_str(), case_1.length(), encrypt_1.get());\n    std::cout << encrypt_1.get();\n    std::unique_ptr<char[]> decrypted_1(new char[case_1.length()]);\n    int ret_code = EncryptionUtil::decrypt(SM4_128_ECB, (unsigned char*)encrypt_1.get(), length_1,\n                                           (unsigned char*)_aes_key.c_str(), _aes_key.length(),\n                                           nullptr, true, (unsigned char*)decrypted_1.get());\n    ASSERT_TRUE(ret_code > 0);\n    std::string decrypted_content_1(decrypted_1.get(), ret_code);\n    ASSERT_EQ(source_1, decrypted_content_1);\n\n    std::unique_ptr<char[]> encrypt_2(new char[case_2.length()]);\n    int length_2 = base64_decode(case_2.c_str(), case_2.length(), encrypt_2.get());\n    std::unique_ptr<char[]> decrypted_2(new char[case_2.length()]);\n    ret_code = EncryptionUtil::decrypt(SM4_128_ECB, (unsigned char*)encrypt_2.get(), length_2,\n                                       (unsigned char*)_aes_key.c_str(), _aes_key.length(), nullptr,\n                                       true, (unsigned char*)decrypted_2.get());\n    ASSERT_TRUE(ret_code > 0);\n    std::string decrypted_content_2(decrypted_2.get(), ret_code);\n    ASSERT_EQ(source_2, decrypted_content_2);\n}", "target": 1, "cwe": ["CWE-200"], "project": "incubator-doris", "commit_id": "246ac4e37aa4da6836b7850cb990f02d1c3725a3", "hash": 310373180946264951931832014599221651994, "size": 27, "message": "[fix] fix a bug of encryption function with iv  may return wrong result (#8277)", "idx": 764}
{"func": "DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp)\n{\n  int ph, nc, retval = 0;\n\n  if (height < 1 || subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    _throwg(\"tjPlaneHeight(): Invalid argument\");\n  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);\n  if (componentID < 0 || componentID >= nc)\n    _throwg(\"tjPlaneHeight(): Invalid argument\");\n\n  ph = PAD(height, tjMCUHeight[subsamp] / 8);\n  if (componentID == 0)\n    retval = ph;\n  else\n    retval = ph * 8 / tjMCUHeight[subsamp];\n\nbailout:\n  return retval;\n}", "target": 0, "cwe": ["CWE-787"], "project": "libjpeg-turbo", "commit_id": "3d9c64e9f8aa1ee954d1d0bb3390fc894bb84da3", "hash": 93291882705422243192783658345393165902, "size": 19, "message": "tjLoadImage(): Fix int overflow/segfault w/big BMP\n\nFixes #304", "idx": 765}
{"func": "(InitializerContext* const context) try {\n    User* user = new User(UserName(\"__system\", \"local\"));\n\n    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.\n    ActionSet allActions;\n    allActions.addAllActions();\n    PrivilegeVector privileges;\n    RoleGraph::generateUniversalPrivileges(&privileges);\n    user->addPrivileges(privileges);\n\n    if (mongodGlobalParams.whitelistedClusterNetwork) {\n        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;\n\n        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);\n        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));\n        auto restrictionDocument =\n            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));\n\n        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));\n\n        user->setRestrictions(std::move(clusterWhiteList));\n    }\n\n\n    internalSecurity.user = user;\n\n    return Status::OK();\n} catch (...) {", "target": 0, "cwe": ["CWE-613"], "project": "mongo", "commit_id": "db19e7ce84cfd702a4ba9983ee2ea5019f470f82", "hash": 325548365630294071059458344049080216406, "size": 28, "message": "SERVER-38984 Validate unique User ID on UserCache hit\n\n(cherry picked from commit e55d6e2292e5dbe2f97153251d8193d1cc89f5d7)", "idx": 766}
{"func": "vbf_stp_error(struct worker *wrk, struct busyobj *bo)\n{\n\tssize_t l, ll, o;\n\tdouble now;\n\tuint8_t *ptr;\n\tstruct vsb *synth_body;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\tAN(bo->fetch_objcore->flags & OC_F_BUSY);\n\tassert(bo->director_state == DIR_S_NULL);\n\n\twrk->stats->fetch_failed++;\n\n\tnow = W_TIM_real(wrk);\n\tVSLb_ts_busyobj(bo, \"Error\", now);\n\n\tif (bo->fetch_objcore->stobj->stevedore != NULL)\n\t\tObjFreeObj(bo->wrk, bo->fetch_objcore);\n\n\t// XXX: reset all beresp flags ?\n\n\tHTTP_Setup(bo->beresp, bo->ws, bo->vsl, SLT_BerespMethod);\n\thttp_PutResponse(bo->beresp, \"HTTP/1.1\", 503, \"Backend fetch failed\");\n\thttp_TimeHeader(bo->beresp, \"Date: \", now);\n\thttp_SetHeader(bo->beresp, \"Server: Varnish\");\n\n\tbo->fetch_objcore->t_origin = now;\n\tif (!VTAILQ_EMPTY(&bo->fetch_objcore->objhead->waitinglist)) {\n\t\t/*\n\t\t * If there is a waitinglist, it means that there is no\n\t\t * grace-able object, so cache the error return for a\n\t\t * short time, so the waiting list can drain, rather than\n\t\t * each objcore on the waiting list sequentially attempt\n\t\t * to fetch from the backend.\n\t\t */\n\t\tbo->fetch_objcore->ttl = 1;\n\t\tbo->fetch_objcore->grace = 5;\n\t\tbo->fetch_objcore->keep = 5;\n\t} else {\n\t\tbo->fetch_objcore->ttl = 0;\n\t\tbo->fetch_objcore->grace = 0;\n\t\tbo->fetch_objcore->keep = 0;\n\t}\n\n\tsynth_body = VSB_new_auto();\n\tAN(synth_body);\n\n\tVCL_backend_error_method(bo->vcl, wrk, NULL, bo, synth_body);\n\n\tAZ(VSB_finish(synth_body));\n\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL) {\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tif (wrk->handling == VCL_RET_RETRY) {\n\t\tVSB_destroy(&synth_body);\n\t\tif (bo->retries++ < cache_param->max_retries)\n\t\t\treturn (F_STP_RETRY);\n\t\tVSLb(bo->vsl, SLT_VCL_Error, \"Too many retries, failing\");\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\tbo->vfc->bo = bo;\n\tbo->vfc->wrk = bo->wrk;\n\tbo->vfc->oc = bo->fetch_objcore;\n\tbo->vfc->http = bo->beresp;\n\tbo->vfc->esi_req = bo->bereq;\n\n\tif (vbf_beresp2obj(bo)) {\n\t\t(void)VFP_Error(bo->vfc, \"Could not get storage\");\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tll = VSB_len(synth_body);\n\to = 0;\n\twhile (ll > 0) {\n\t\tl = ll;\n\t\tif (VFP_GetStorage(bo->vfc, &l, &ptr) != VFP_OK)\n\t\t\tbreak;\n\t\tif (l > ll)\n\t\t\tl = ll;\n\t\tmemcpy(ptr, VSB_data(synth_body) + o, l);\n\t\tVFP_Extend(bo->vfc, l);\n\t\tll -= l;\n\t\to += l;\n\t}\n\tAZ(ObjSetU64(wrk, bo->fetch_objcore, OA_LEN, o));\n\tVSB_destroy(&synth_body);\n\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FINISHED);\n\treturn (F_STP_DONE);\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "varnish-cache", "commit_id": "176f8a075a963ffbfa56f1c460c15f6a1a6af5a7", "hash": 118042490469226058629220467258969214307, "size": 99, "message": "Avoid buffer read overflow on vcl_error and -sfile\n\nThe file stevedore may return a buffer larger than asked for when\nrequesting storage. Due to lack of check for this condition, the code\nto copy the synthetic error memory buffer from vcl_error would overrun\nthe buffer.\n\nPatch by @shamger\n\nFixes: #2429", "idx": 767}
{"func": "static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification)\n{\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\tvmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;\n\tvmcs12->exit_qualification = qualification;\n\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tto_vmx(vcpu)->nested.sync_shadow_vmcs = true;\n}", "target": 0, "cwe": [], "project": "kvm", "commit_id": "a642fc305053cc1c6e47e4f4df327895747ab485", "hash": 295178705525975329905828687962782227604, "size": 11, "message": "kvm: vmx: handle invvpid vm exit gracefully\n\nOn systems with invvpid instruction support (corresponding bit in\nIA32_VMX_EPT_VPID_CAP MSR is set) guest invocation of invvpid\ncauses vm exit, which is currently not handled and results in\npropagation of unknown exit to userspace.\n\nFix this by installing an invvpid vm exit handler.\n\nThis is CVE-2014-3646.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 768}
{"func": "int vncws_decode_frame(Buffer *input, uint8_t **payload,\n                           size_t *payload_size, size_t *frame_size)\n{\n    unsigned char opcode = 0, fin = 0, has_mask = 0;\n    size_t header_size = 0;\n    uint32_t *payload32;\n    WsHeader *header = (WsHeader *)input->buffer;\n    WsMask mask;\n    int i;\n\n    if (input->offset < WS_HEAD_MIN_LEN + 4) {\n        /* header not complete */\n        return 0;\n    }\n\n    fin = (header->b0 & 0x80) >> 7;\n    opcode = header->b0 & 0x0f;\n    has_mask = (header->b1 & 0x80) >> 7;\n    *payload_size = header->b1 & 0x7f;\n\n    if (opcode == WS_OPCODE_CLOSE) {\n        /* disconnect */\n        return -1;\n    }\n\n    /* Websocket frame sanity check:\n     * * Websocket fragmentation is not supported.\n     * * All  websockets frames sent by a client have to be masked.\n     * * Only binary encoding is supported.\n     */\n    if (!fin || !has_mask || opcode != WS_OPCODE_BINARY_FRAME) {\n        VNC_DEBUG(\"Received faulty/unsupported Websocket frame\\n\");\n        return -2;\n    }\n\n    if (*payload_size < 126) {\n        header_size = 6;\n        mask = header->u.m;\n    } else if (*payload_size == 126 && input->offset >= 8) {\n        *payload_size = be16_to_cpu(header->u.s16.l16);\n        header_size = 8;\n        mask = header->u.s16.m16;\n    } else if (*payload_size == 127 && input->offset >= 14) {\n        *payload_size = be64_to_cpu(header->u.s64.l64);\n        header_size = 14;\n        mask = header->u.s64.m64;\n    } else {\n        /* header not complete */\n        return 0;\n    }\n\n    *frame_size = header_size + *payload_size;\n\n    if (input->offset < *frame_size) {\n        /* frame not complete */\n        return 0;\n    }\n\n    *payload = input->buffer + header_size;\n\n    /* unmask frame */\n    /* process 1 frame (32 bit op) */\n    payload32 = (uint32_t *)(*payload);\n    for (i = 0; i < *payload_size / 4; i++) {\n        payload32[i] ^= mask.u;\n    }\n    /* process the remaining bytes (if any) */\n    for (i *= 4; i < *payload_size; i++) {\n        (*payload)[i] ^= mask.c[i % 4];\n    }\n\n    return 1;\n}", "target": 1, "cwe": [], "project": "qemu", "commit_id": "a2bebfd6e09d285aa793cae3fb0fc3a39a9fee6e", "hash": 185329195115329860716426008171546618077, "size": 73, "message": "CVE-2015-1779: incrementally decode websocket frames\n\nThe logic for decoding websocket frames wants to fully\ndecode the frame header and payload, before allowing the\nVNC server to see any of the payload data. There is no\nsize limit on websocket payloads, so this allows a\nmalicious network client to consume 2^64 bytes in memory\nin QEMU. It can trigger this denial of service before\nthe VNC server even performs any authentication.\n\nThe fix is to decode the header, and then incrementally\ndecode the payload data as it is needed. With this fix\nthe websocket decoder will allow at most 4k of data to\nbe buffered before decoding and processing payload.\n\nSigned-off-by: Daniel P. Berrange <berrange@redhat.com>\n\n[ kraxel: fix frequent spurious disconnects, suggested by Peter Maydell ]\n\n  @@ -361,7 +361,7 @@ int vncws_decode_frame_payload(Buffer *input,\n  -        *payload_size = input->offset;\n  +        *payload_size = *payload_remain;\n\n[ kraxel: fix 32bit build ]\n\n  @@ -306,7 +306,7 @@ struct VncState\n  -    uint64_t ws_payload_remain;\n  +    size_t ws_payload_remain;\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>", "idx": 769}
{"func": "static int filter_frame(AVFilterLink *inlink, AVFrame *buf)\n{\n    AVFilterContext    *ctx = inlink->dst;\n    FPSContext           *s = ctx->priv;\n    AVFilterLink   *outlink = ctx->outputs[0];\n    int64_t delta;\n    int i, ret;\n\n    s->frames_in++;\n    /* discard frames until we get the first timestamp */\n    if (s->pts == AV_NOPTS_VALUE) {\n        if (buf->pts != AV_NOPTS_VALUE) {\n            ret = write_to_fifo(s->fifo, buf);\n            if (ret < 0)\n                return ret;\n\n            if (s->start_time != DBL_MAX && s->start_time != AV_NOPTS_VALUE) {\n                double first_pts = s->start_time * AV_TIME_BASE;\n                first_pts = FFMIN(FFMAX(first_pts, INT64_MIN), INT64_MAX);\n                s->first_pts = s->pts = av_rescale_q(first_pts, AV_TIME_BASE_Q,\n                                                     inlink->time_base);\n                av_log(ctx, AV_LOG_VERBOSE, \"Set first pts to (in:%\"PRId64\" out:%\"PRId64\")\\n\",\n                       s->first_pts, av_rescale_q(first_pts, AV_TIME_BASE_Q,\n                                                  outlink->time_base));\n            } else {\n                s->first_pts = s->pts = buf->pts;\n            }\n        } else {\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n                   \"timestamp.\\n\");\n            av_frame_free(&buf);\n            s->drop++;\n        }\n        return 0;\n    }\n\n    /* now wait for the next timestamp */\n    if (buf->pts == AV_NOPTS_VALUE) {\n        return write_to_fifo(s->fifo, buf);\n    }\n\n    /* number of output frames */\n    delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,\n                             outlink->time_base, s->rounding);\n\n    if (delta < 1) {\n        /* drop the frame and everything buffered except the first */\n        AVFrame *tmp;\n        int drop = av_fifo_size(s->fifo)/sizeof(AVFrame*);\n\n        av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\n        s->drop += drop;\n\n        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n        flush_fifo(s->fifo);\n        ret = write_to_fifo(s->fifo, tmp);\n\n        av_frame_free(&buf);\n        return ret;\n    }\n\n    /* can output >= 1 frames */\n    for (i = 0; i < delta; i++) {\n        AVFrame *buf_out;\n        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n\n        /* duplicate the frame if needed */\n        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n            AVFrame *dup = av_frame_clone(buf_out);\n\n            av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\n            if (dup)\n                ret = write_to_fifo(s->fifo, dup);\n            else\n                ret = AVERROR(ENOMEM);\n\n            if (ret < 0) {\n                av_frame_free(&buf_out);\n                av_frame_free(&buf);\n                return ret;\n            }\n\n            s->dup++;\n        }\n\n        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n                                    outlink->time_base) + s->frames_out;\n\n        if ((ret = ff_filter_frame(outlink, buf_out)) < 0) {\n            av_frame_free(&buf);\n            return ret;\n        }\n\n        s->frames_out++;\n    }\n    flush_fifo(s->fifo);\n\n    ret = write_to_fifo(s->fifo, buf);\n    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n\n    return ret;\n}", "target": 1, "cwe": ["CWE-399"], "project": "FFmpeg", "commit_id": "cdd5df8189ff1537f7abe8defe971f80602cc2d2", "hash": 315806030910391855497257800166744135517, "size": 102, "message": "avfilter/vf_fps: make sure the fifo is not empty before using it\n\nFixes Ticket2905\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "idx": 770}
{"func": "int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,\n\t\t\tsize_t size, int flags)\n{\n\tif (!(sk->sk_route_caps & NETIF_F_SG))\n\t\treturn sock_no_sendpage_locked(sk, page, offset, size, flags);\n\n\ttcp_rate_check_app_limited(sk);  /* is sending application-limited? */\n\n\treturn do_tcp_sendpages(sk, page, offset, size, flags);\n}", "target": 0, "cwe": ["CWE-190"], "project": "net", "commit_id": "3b4929f65b0d8249f19a50245cd88ed1a2f78cff", "hash": 309581724382851206974690805614238388975, "size": 10, "message": "tcp: limit payload size of sacked skbs\n\nJonathan Looney reported that TCP can trigger the following crash\nin tcp_shifted_skb() :\n\n\tBUG_ON(tcp_skb_pcount(skb) < pcount);\n\nThis can happen if the remote peer has advertized the smallest\nMSS that linux TCP accepts : 48\n\nAn skb can hold 17 fragments, and each fragment can hold 32KB\non x86, or 64KB on PowerPC.\n\nThis means that the 16bit witdh of TCP_SKB_CB(skb)->tcp_gso_segs\ncan overflow.\n\nNote that tcp_sendmsg() builds skbs with less than 64KB\nof payload, so this problem needs SACK to be enabled.\nSACK blocks allow TCP to coalesce multiple skbs in the retransmit\nqueue, thus filling the 17 fragments to maximal capacity.\n\nCVE-2019-11477 -- u16 overflow of TCP_SKB_CB(skb)->tcp_gso_segs\n\nFixes: 832d11c5cd07 (\"tcp: Try to restore large SKBs while SACK processing\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Jonathan Looney <jtl@netflix.com>\nAcked-by: Neal Cardwell <ncardwell@google.com>\nReviewed-by: Tyler Hicks <tyhicks@canonical.com>\nCc: Yuchung Cheng <ycheng@google.com>\nCc: Bruce Curtis <brucec@netflix.com>\nCc: Jonathan Lemon <jonathan.lemon@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 771}
{"func": "static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\"Invalid HTTP content [%d]\", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content-type[%s]\", data.part[i].content_type);\n        END\n    }\n\n    if (data.part[i].content_id)\n        ogs_free(data.part[i].content_id);\n    if (data.part[i].content_type)\n        ogs_free(data.part[i].content_type);\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}", "target": 1, "cwe": ["CWE-476", "CWE-787"], "project": "open5gs", "commit_id": "d919b2744cd05abae043490f0a3dd1946c1ccb8c", "hash": 1501721343340553571347509753071934425, "size": 104, "message": "[AMF] fix the memory problem (#1247)\n\n1. memory corruption\n- Overflow num_of_part in SBI message\n2. null pointer dereference\n- n2InfoContent->ngap_ie_type", "idx": 772}
{"func": "virDomainNetNotifyActualDevice(virConnectPtr conn,\n                               virDomainDefPtr dom,\n                               virDomainNetDefPtr iface)\n{\n    virDomainNetType actualType = virDomainNetGetActualType(iface);\n\n    if (virDomainNetCreatePort(conn, dom, iface,\n                               VIR_NETWORK_PORT_CREATE_RECLAIM) < 0) {\n        return;\n    }\n\n    if (actualType == VIR_DOMAIN_NET_TYPE_NETWORK ||\n        actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        /*\n         * NB: we can't notify the guest of any MTU change anyway,\n         * so there is no point in trying to learn the actualMTU\n         * (final arg to virNetDevTapReattachBridge())\n         */\n        ignore_value(virNetDevTapReattachBridge(iface->ifname,\n                                                iface->data.network.actual->data.bridge.brname,\n                                                &iface->mac, dom->uuid,\n                                                virDomainNetGetActualVirtPortProfile(iface),\n                                                virDomainNetGetActualVlan(iface),\n                                                virDomainNetGetActualPortOptionsIsolated(iface),\n                                                iface->mtu, NULL));\n    }\n}", "target": 0, "cwe": ["CWE-212"], "project": "libvirt", "commit_id": "a5b064bf4b17a9884d7d361733737fb614ad8979", "hash": 245081680088478787081908693324461571397, "size": 27, "message": "conf: Don't format http cookies unless VIR_DOMAIN_DEF_FORMAT_SECURE is used\n\nStarting with 3b076391befc3fe72deb0c244ac6c2b4c100b410\n(v6.1.0-122-g3b076391be) we support http cookies. Since they may contain\nsomewhat sensitive information we should not format them into the XML\nunless VIR_DOMAIN_DEF_FORMAT_SECURE is asserted.\n\nReported-by: Han Han <hhan@redhat.com>\nSigned-off-by: Peter Krempa <pkrempa@redhat.com>\nReviewed-by: Erik Skultety <eskultet@redhat.com>", "idx": 773}
{"func": "static ssize_t pipe_get_pages(struct iov_iter *i,\n\t\t   struct page **pages, size_t maxsize, unsigned maxpages,\n\t\t   size_t *start)\n{\n\tunsigned int iter_head, npages;\n\tsize_t capacity;\n\n\tif (!sanity(i))\n\t\treturn -EFAULT;\n\n\tdata_start(i, &iter_head, start);\n\t/* Amount of free space: some of this one + all after this one */\n\tnpages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);\n\tcapacity = min(npages, maxpages) * PAGE_SIZE - *start;\n\n\treturn __pipe_get_pages(i, min(maxsize, capacity), pages, iter_head, start);\n}", "target": 0, "cwe": ["CWE-665", "CWE-284"], "project": "linux", "commit_id": "9d2231c5d74e13b2a0546fee6737ee4446017903", "hash": 240363389164609022778528797483246513153, "size": 17, "message": "lib/iov_iter: initialize \"flags\" in new pipe_buffer\n\nThe functions copy_page_to_iter_pipe() and push_pipe() can both\nallocate a new pipe_buffer, but the \"flags\" member initializer is\nmissing.\n\nFixes: 241699cd72a8 (\"new iov_iter flavour: pipe-backed\")\nTo: Alexander Viro <viro@zeniv.linux.org.uk>\nTo: linux-fsdevel@vger.kernel.org\nTo: linux-kernel@vger.kernel.org\nCc: stable@vger.kernel.org\nSigned-off-by: Max Kellermann <max.kellermann@ionos.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>", "idx": 774}
{"func": "TEST_F(ExpressionFloorTest, IntArg) {\n    assertEvaluates(Value(0), Value(0));\n    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));\n    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));\n}", "target": 0, "cwe": ["CWE-835"], "project": "mongo", "commit_id": "0a076417d1d7fba3632b73349a1fd29a83e68816", "hash": 126554872178089984444661056992842849250, "size": 5, "message": "SERVER-38070 fix infinite loop in agg expression", "idx": 775}
{"func": "static void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  // determine number of padding bytes required to ensure 4 byte alignment\n  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n\n  // 12 bytes for header, JSON content length, 8 bytes for JSON chunk info.\n  // Chunk data must be located at 4-byte boundary, which may require padding\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n\n  // JSON chunk info, then JSON data\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n\n  // Chunk must be multiplies of 4, so pad with spaces\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    // BIN chunk info, then BIN data\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    // Chunksize must be multiplies of 4, so pad with zeroes\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}", "target": 1, "cwe": ["CWE-20"], "project": "tinygltf", "commit_id": "52ff00a38447f06a17eab1caa2cf0730a119c751", "hash": 135689357842700156002865548792183752507, "size": 55, "message": "Do not expand file path since its not necessary for glTF asset path(URI) and for security reason(`wordexp`).", "idx": 776}
{"func": "static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n\tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n\tvoid *memory;\n\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}", "target": 0, "cwe": ["CWE-284", "CWE-264"], "project": "linux", "commit_id": "0ea1ec713f04bdfac343c9702b21cd3a7c711826", "hash": 159665873150077546843661453282835720871, "size": 12, "message": "ARM: dma-mapping: don't allow DMA mappings to be marked executable\n\nDMA mapping permissions were being derived from pgprot_kernel directly\nwithout using PAGE_KERNEL.  This causes them to be marked with executable\npermission, which is not what we want.  Fix this.\n\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>", "idx": 777}
{"func": "gostdsa_vko (const struct ecc_scalar *priv,\n\t\tconst struct ecc_point *pub,\n\t\tsize_t ukm_length, const uint8_t *ukm,\n\t\tuint8_t *out)\n{\n  const struct ecc_curve *ecc = priv->ecc;\n  unsigned bsize = (ecc_bit_size (ecc) + 7) / 8;\n  mp_size_t size = ecc->p.size;\n  mp_size_t itch = 4*size + ecc->mul_itch;\n  mp_limb_t *scratch;\n\n  if (itch < 5*size + ecc->h_to_a_itch)\n      itch = 5*size + ecc->h_to_a_itch;\n\n  assert (pub->ecc == ecc);\n  assert (priv->ecc == ecc);\n  assert (ukm_length <= bsize);\n\n  scratch = gmp_alloc_limbs (itch);\n\n#define UKM scratch\n#define TEMP (scratch + 3*size)\n#define XYZ scratch\n#define TEMP_Y (scratch + 4*size)\n\n  mpn_set_base256_le (UKM, size, ukm, ukm_length);\n\n  /* If ukm is 0, set it to 1, otherwise the result will be allways equal to 0,\n   * no matter what private and public keys are. See RFC 4357 referencing GOST\n   * R 34.10-2001 (RFC 5832) Section 6.1 step 2. */\n  if (mpn_zero_p (UKM, size))\n    UKM[0] = 1;\n\n  ecc_mod_mul (&ecc->q, TEMP, priv->p, UKM, TEMP); /* TEMP = UKM * priv */\n  ecc->mul (ecc, XYZ, TEMP, pub->p, scratch + 4*size); /* XYZ = UKM * priv * pub */\n  ecc->h_to_a (ecc, 0, TEMP, XYZ, scratch + 5*size); /* TEMP = XYZ */\n  mpn_get_base256_le (out, bsize, TEMP, size);\n  mpn_get_base256_le (out+bsize, bsize, TEMP_Y, size);\n  gmp_free_limbs (scratch, itch);\n}", "target": 1, "cwe": ["CWE-787"], "project": "nettle", "commit_id": "63f222c60b03470c0005aa9bc4296fbf585f68b9", "hash": 61914879089805788741435054850396856530, "size": 40, "message": "Fix canonical reduction in gostdsa_vko.\n\n* gostdsa-vko.c (gostdsa_vko): Use ecc_mod_mul_canonical to\ncompute the scalar used for ecc multiplication.\n\n(cherry picked from commit b30e0ca6d2b41579a5b6a010fc54065d790e8d55)", "idx": 778}
{"func": "set_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tacl_t\t\t acl;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tacl_flagset_t\t acl_flagset;\n\tint\t\t r;\n#endif\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tacl_type = ACL_TYPE_NFS4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tacl_set_tag_type(acl_entry, ACL_EVERYONE);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tr = 0;\n\t\tswitch (ae_type) {\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALLOW);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_DENY);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_AUDIT);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALARM);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\t// These don't translate directly into the system ACL.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#endif\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/*\n\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to get flagset from an NFSv4 \"\n\t\t\t\t    \"ACL entry\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tif (acl_clear_flags_np(acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to clear flags from an NFSv4 \"\n\t\t\t\t    \"ACL flagset\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tif (acl_add_flag_np(acl_flagset,\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0) {\n\t\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t\t    \"Failed to add flag to \"\n\t\t\t\t\t\t    \"NFSv4 ACL flagset\");\n\t\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\t\tgoto exit_free;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (acl_set_fd_np(fd, acl, acl_type) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t}\n#if HAVE_ACL_SET_LINK_NP\n\telse if (acl_set_link_np(name, acl_type, acl) != 0)\n#else\n\t/* FreeBSD older than 8.0 */\n\telse if (acl_set_file(name, acl_type, acl) != 0)\n#endif\n\t{\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}", "target": 1, "cwe": ["CWE-59", "CWE-61"], "project": "libarchive", "commit_id": "fba4f123cc456d2b2538f811bb831483bf336bad", "hash": 180427972994740648012465339332648855929, "size": 240, "message": "Fix handling of symbolic link ACLs\n\nOn Linux ACLs on symbolic links are not supported.\nWe must avoid calling acl_set_file() on symbolic links as their\ntargets are modified instead.\n\nWhile here, do not try to set default ACLs on non-directories.\n\nFixes #1565", "idx": 779}
{"func": "    char* skipSpaces( char* ptr )\n    {\n        bool is_eof = false;\n        bool is_completed = false;\n\n        while ( is_eof == false && is_completed == false )\n        {\n            switch ( *ptr )\n            {\n                /* comment */\n                case '/' : {\n                    ptr++;\n                    if ( *ptr == '\\0' )\n                    {\n                        ptr = fs->gets();\n                        if( !ptr || !*ptr ) { is_eof = true; break; }\n                    }\n\n                    if ( *ptr == '/' )\n                    {\n                        while ( *ptr != '\\n' && *ptr != '\\r' )\n                        {\n                            if ( *ptr == '\\0' )\n                            {\n                                ptr = fs->gets();\n                                if( !ptr || !*ptr ) { is_eof = true; break; }\n                            }\n                            else\n                            {\n                                ptr++;\n                            }\n                        }\n                    }\n                    else if ( *ptr == '*' )\n                    {\n                        ptr++;\n                        for (;;)\n                        {\n                            if ( *ptr == '\\0' )\n                            {\n                                ptr = fs->gets();\n                                if( !ptr || !*ptr ) { is_eof = true; break; }\n                            }\n                            else if ( *ptr == '*' )\n                            {\n                                ptr++;\n                                if ( *ptr == '\\0' )\n                                {\n                                    ptr = fs->gets();\n                                    if( !ptr || !*ptr ) { is_eof = true; break; }\n                                }\n                                if ( *ptr == '/' )\n                                {\n                                    ptr++;\n                                    break;\n                                }\n                            }\n                            else\n                            {\n                                ptr++;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        CV_PARSE_ERROR_CPP( \"Not supported escape character\" );\n                    }\n                } break;\n                    /* whitespace */\n                case '\\t':\n                case ' ' : {\n                    ptr++;\n                } break;\n                    /* newline || end mark */\n                case '\\0':\n                case '\\n':\n                case '\\r': {\n                    ptr = fs->gets();\n                    if( !ptr || !*ptr ) { is_eof = true; break; }\n                } break;\n                    /* other character */\n                default: {\n                    if( !cv_isprint(*ptr) )\n                        CV_PARSE_ERROR_CPP( \"Invalid character in the stream\" );\n                    is_completed = true;\n                } break;\n            }\n        }\n\n        if ( is_eof || !is_completed )\n        {\n            ptr = fs->bufferStart();\n            *ptr = '\\0';\n            fs->setEof();\n            if( !is_completed )\n                CV_PARSE_ERROR_CPP( \"Abort at parse time\" );\n        }\n\n        return ptr;\n    }", "target": 1, "cwe": ["CWE-476"], "project": "opencv", "commit_id": "5691d998ead1d9b0542bcfced36c2dceb3a59023", "hash": 67581024941615953919559818608178488231, "size": 100, "message": "core(persistence): added null ptr checks", "idx": 780}
{"func": "GError *add(char *label, char *server, char *username, char *secret) {\n\tGError *err = NULL;\n\n\tsecret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,\n\t\t\tserver, secret, NULL, &err,\n\t\t\t\"label\", label,\n\t\t\t\"server\", server,\n\t\t\t\"username\", username,\n\t\t\t\"docker_cli\", \"1\",\n\t\t\tNULL);\n\treturn err;\n}", "target": 0, "cwe": ["CWE-415"], "project": "docker-credential-helpers", "commit_id": "87c80bfba583eadc087810d17aa631ef4e405efc", "hash": 99439124724048633005593897606050909126, "size": 12, "message": "Fix a double free in the List functions\n\nThe code was set up so that it would free the individual items and the data\nin `freeListData`, but there was already a Go `defer` to free the data item,\nresulting in a double free.\n\nRemove the `free` in `freeListData` and leave the original one.\n\nIn addition, move the `defer` for freeing the list data before the error\ncheck, so that the data is also free in the error case. This just removes\na minor leak.\n\nThis vulnerability was discovered by:\nJasiel Spelman of Trend Micro Zero Day Initiative and Trend Micro Team Nebula\n\nSigned-off-by: Justin Cormack <justin.cormack@docker.com>", "idx": 781}
{"func": "TEST(BasicFlatBufferModel, TestWithNumThreads) {\n  TestErrorReporter reporter;\n  auto model = FlatBufferModel::BuildFromFile(\n      \"tensorflow/lite/testdata/test_model.bin\", &reporter);\n  ASSERT_TRUE(model);\n  TrivialResolver resolver(&dummy_reg);\n  InterpreterBuilder builder(*model, resolver);\n\n  std::unique_ptr<Interpreter> interpreter;\n  ASSERT_EQ(builder(&interpreter, /*num_threads=*/42), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);\n\n  interpreter.reset();\n  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);\n\n  interpreter.reset();\n  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);\n\n  ASSERT_EQ(reporter.num_calls(), 0);\n  interpreter.reset(new Interpreter);\n  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);\n  ASSERT_EQ(interpreter, nullptr);\n  ASSERT_EQ(reporter.num_calls(), 1);\n  ASSERT_PRED_FORMAT2(testing::IsSubstring,\n                      \"num_threads should be >= 0 or just -1\",\n                      reporter.error_messages());\n}", "target": 0, "cwe": ["CWE-703", "CWE-835"], "project": "tensorflow", "commit_id": "c6173f5fe66cdbab74f4f869311fe6aae2ba35f4", "hash": 147570642751304051162597432461762322366, "size": 32, "message": "TFLite: Error out when the graph has a recurion.\n\nRecursion is currently unsupported.\n\nPiperOrigin-RevId: 371708957\nChange-Id: I8dfad0d85cbfe08e39ae8ea7bad21254ddee5003", "idx": 782}
{"func": "R_API int r_core_esil_step_back(RCore *core) {\n\tRAnalEsil *esil = core->anal->esil;\n\tRListIter *tail;\n\tconst char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tut64 prev = 0;\n\tut64 end = r_reg_getv (core->anal->reg, name);\n\n\tif (!esil || !(tail = r_list_tail (esil->sessions))) {\n\t\treturn 0;\n\t}\n\tRAnalEsilSession *before = (RAnalEsilSession *) tail->data;\n\tif (!before) {\n\t\teprintf (\"Cannot find any previous state here\\n\");\n\t\treturn 0;\n\t}\n\teprintf (\"NOTE: step back in esil is setting an initial state and stepping into pc is the same.\\n\");\n\teprintf (\"NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\\n\");\n\teprintf (\"NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\\n\");\n\teprintf (\"Execute until 0x%08\"PFMT64x\"\\n\", end);\n\tr_anal_esil_session_set (esil, before);\n\tr_core_esil_step (core, end, NULL, &prev, false);\n\teprintf (\"Before 0x%08\"PFMT64x\"\\n\", prev);\n\tr_anal_esil_session_set (esil, before);\n\tr_core_esil_step (core, prev, NULL, NULL, false);\n\treturn 1;\n}", "target": 0, "cwe": ["CWE-703", "CWE-908"], "project": "radare2", "commit_id": "4d3811681a80f92a53e795f6a64c4b0fc2c8dd22", "hash": 182821787614447734680045274201962306506, "size": 26, "message": "Fix segfault in adf  (#16230)", "idx": 783}
{"func": "_gdata_service_query (GDataService *self, GDataAuthorizationDomain *domain, const gchar *feed_uri, GDataQuery *query,\n                      GCancellable *cancellable, GError **error)\n{\n\tSoupMessage *message;\n\tguint status;\n\tconst gchar *etag = NULL;\n\n\t/* Append the ETag header if possible */\n\tif (query != NULL)\n\t\tetag = gdata_query_get_etag (query);\n\n\t/* Build the message */\n\tif (query != NULL) {\n\t\tgchar *query_uri = gdata_query_get_query_uri (query, feed_uri);\n\t\tmessage = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, query_uri, etag, FALSE);\n\t\tg_free (query_uri);\n\t} else {\n\t\tmessage = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, feed_uri, etag, FALSE);\n\t}\n\n\t/* Note that cancellation only applies to network activity; not to the processing done afterwards */\n\tstatus = _gdata_service_send_message (self, message, cancellable, error);\n\n\tif (status == SOUP_STATUS_NOT_MODIFIED || status == SOUP_STATUS_CANCELLED) {\n\t\t/* Not modified (ETag has worked), or cancelled (in which case the error has been set) */\n\t\tg_object_unref (message);\n\t\treturn NULL;\n\t} else if (status != SOUP_STATUS_OK) {\n\t\t/* Error */\n\t\tGDataServiceClass *klass = GDATA_SERVICE_GET_CLASS (self);\n\t\tg_assert (klass->parse_error_response != NULL);\n\t\tklass->parse_error_response (self, GDATA_OPERATION_QUERY, status, message->reason_phrase, message->response_body->data,\n\t\t                             message->response_body->length, error);\n\t\tg_object_unref (message);\n\t\treturn NULL;\n\t}\n\n\treturn message;\n}", "target": 0, "cwe": ["CWE-20"], "project": "libgdata", "commit_id": "6799f2c525a584dc998821a6ce897e463dad7840", "hash": 273782639854899202886096894707699763617, "size": 39, "message": "core: Validate SSL certificates for all connections\n\nThis prevents MitM attacks which use spoofed SSL certificates.\n\nNote that this bumps our libsoup requirement to 2.37.91.\n\nCloses: https://bugzilla.gnome.org/show_bug.cgi?id=671535", "idx": 784}
{"func": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\n\tcp = (const u_char *)ext;\n\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\n\t\tif (cp == NULL) {\n\t\t\t/* Zero-length subitem */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tcpdump", "commit_id": "8dca25d26c7ca2caf6138267f6f17111212c156e", "hash": 97415850352925947678833197420058183108, "size": 39, "message": "CVE-2017-13690/IKEv2: Fix some bounds checks.\n\nUse a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2()\nand provide the correct length.\n\nWhile we're at it, remove the blank line between some checks and the\nUNALIGNED_MEMCPY()s they protect.\n\nAlso, note the places where we print the entire payload.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).", "idx": 785}
{"func": "MYSQL_STMT *open_cursor(const char *query)\n{\n  int rc;\n  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;\n\n  MYSQL_STMT *stmt= mysql_stmt_init(mysql);\n  rc= mysql_stmt_prepare(stmt, query, strlen(query));\n  check_execute(stmt, rc);\n\n  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);\n  return stmt;\n}", "target": 0, "cwe": ["CWE-284", "CWE-295"], "project": "mysql-server", "commit_id": "3bd5589e1a5a93f9c224badf983cd65c45215390", "hash": 131479950689073010134689586786935602765, "size": 12, "message": "WL#6791 : Redefine client --ssl option to imply enforced encryption\n\n# Changed the meaning of the --ssl=1 option of all client binaries\nto mean force ssl, not try ssl and fail over to eunecrypted\n# Added a new MYSQL_OPT_SSL_ENFORCE mysql_options()\noption to specify that an ssl connection is required.\n# Added a new macro SSL_SET_OPTIONS() to the client\nSSL handling headers that sets all the relevant SSL options at \nonce.\n# Revamped all of the current native clients to use the new macro\n# Removed some Windows line endings.\n# Added proper handling of the new option into the ssl helper\nheaders.\n# If SSL is mandatory assume that the media is secure enough \nfor the sha256 plugin to do unencrypted password exchange even\nbefore establishing a connection.\n# Set the default ssl cipher to DHE-RSA-AES256-SHA if none is \nspecified.\n# updated test cases that require a non-default cipher to spawn \na mysql command line tool binary since mysqltest has no support\nfor specifying ciphers.\n# updated the replication slave connection code to always enforce\nSSL if any of the SSL config options is present.\n# test cases added and updated.\n# added a mysql_get_option() API to return mysql_options() \nvalues. Used the new API inside the sha256 plugin.\n# Fixed compilation warnings because of unused variables.\n# Fixed test failures (mysql_ssl and bug13115401)\n# Fixed whitespace issues.\n# Fully implemented the mysql_get_option() function.\n# Added a test case for mysql_get_option()\n# fixed some trailing whitespace issues\n# fixed some uint/int warnings in mysql_client_test.c\n# removed shared memory option from non-windows get_options\n tests\n# moved MYSQL_OPT_LOCAL_INFILE to the uint options", "idx": 786}
{"func": "is_cgi(cupsd_client_t *con,\t\t/* I - Client connection */\n       const char     *filename,\t/* I - Real filename */\n       struct stat    *filestats,\t/* I - File information */\n       mime_type_t    *type)\t\t/* I - MIME type */\n{\n  const char\t*options;\t\t/* Options on URL */\n\n\n /*\n  * Get the options, if any...\n  */\n\n  if ((options = strchr(con->uri, '?')) != NULL)\n  {\n    options ++;\n    cupsdSetStringf(&(con->query_string), \"QUERY_STRING=%s\", options);\n  }\n\n /*\n  * Check for known types...\n  */\n\n  if (!type || _cups_strcasecmp(type->super, \"application\"))\n  {\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 0.\", filename, filestats, type ? type->super : \"unknown\", type ? type->type : \"unknown\");\n    return (0);\n  }\n\n  if (!_cups_strcasecmp(type->type, \"x-httpd-cgi\") &&\n      (filestats->st_mode & 0111))\n  {\n   /*\n    * \"application/x-httpd-cgi\" is a CGI script.\n    */\n\n    cupsdSetString(&con->command, filename);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s\", options);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#ifdef HAVE_JAVA\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-java\"))\n  {\n   /*\n    * \"application/x-httpd-java\" is a Java servlet.\n    */\n\n    cupsdSetString(&con->command, CUPS_JAVA);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_JAVA */\n#ifdef HAVE_PERL\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-perl\"))\n  {\n   /*\n    * \"application/x-httpd-perl\" is a Perl page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PERL);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PERL */\n#ifdef HAVE_PHP\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-php\"))\n  {\n   /*\n    * \"application/x-httpd-php\" is a PHP page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PHP);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PHP */\n#ifdef HAVE_PYTHON\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-python\"))\n  {\n   /*\n    * \"application/x-httpd-python\" is a Python page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PYTHON);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PYTHON */\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 0.\", filename, filestats, type->super, type->type);\n  return (0);\n}", "target": 0, "cwe": ["CWE-290"], "project": "cups", "commit_id": "afa80cb2b457bf8d64f775bed307588610476c41", "hash": 271018360941322203545604048314319936330, "size": 119, "message": "Don't treat \"localhost.localdomain\" as an allowed replacement for localhost, since it isn't.", "idx": 787}
{"func": "static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)\n{\n\treturn le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +\n\t       sizeof(struct RESTART_TABLE);\n}", "target": 0, "cwe": ["CWE-416"], "project": "linux", "commit_id": "f26967b9f7a830e228bb13fb41bd516ddd9d789d", "hash": 31541131822654100465240437265298400255, "size": 5, "message": "fs/ntfs3: Fix invalid free in log_replay\n\nlog_read_rst() returns ENOMEM error when there is not enough memory.\nIn this case, if info is returned without initialization,\nit attempts to kfree the uninitialized info->r_page pointer. This patch\nmoves the memset initialization code to before log_read_rst() is called.\n\nReported-by: Gerald Lee <sundaywind2004@gmail.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>\nSigned-off-by: Konstantin Komarov <almaz.alexandrovich@paragon-software.com>", "idx": 788}
{"func": "DefragIPv4NoDataTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int id = 12;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* This packet has an offset > 0, more frags set to 0 and no data. */\n    p = BuildTestPacket(id, 1, 0, 'A', 0);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should\n     * have been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}", "target": 1, "cwe": ["CWE-358"], "project": "suricata", "commit_id": "4a04f814b15762eb446a5ead4d69d021512df6f8", "hash": 153913303405528840273420082510074091452, "size": 37, "message": "defrag - take protocol into account during re-assembly\n\nThe IP protocol was not being used to match fragments with\ntheir packets allowing a carefully constructed packet\nwith a different protocol to be matched, allowing re-assembly\nto complete, creating a packet that would not be re-assembled\nby the destination host.", "idx": 789}
{"func": "doc_var_value(gqlDoc doc, const char *key) {\n    gqlVar\tvar;\n\n    // look in doc->vars and doc->op->vars\n    if (NULL != doc->op) {\n\tfor (var = doc->op->vars; NULL != var; var = var->next) {\n\t    if (0 == strcmp(key, var->name)) {\n\t\treturn var->value;\n\t    }\n\t}\n    }\n    for (var = doc->vars; NULL != var; var = var->next) {\n\tif (0 == strcmp(key, var->name)) {\n\t    return var->value;\n\t}\n    }\n    return NULL;\n}", "target": 0, "cwe": ["CWE-703"], "project": "agoo", "commit_id": "ecb72fa66f3d846b724b4fa1d7648669cebabe0c", "hash": 132917578496451847434867893992958447685, "size": 18, "message": "Protect against recursive fragment in schema\n\nReally a error on the developers part but this catches the error.", "idx": 790}
{"func": "relay_crypt(circuit_t *circ, cell_t *cell, cell_direction_t cell_direction,\n            crypt_path_t **layer_hint, char *recognized)\n{\n  relay_header_t rh;\n\n  tor_assert(circ);\n  tor_assert(cell);\n  tor_assert(recognized);\n  tor_assert(cell_direction == CELL_DIRECTION_IN ||\n             cell_direction == CELL_DIRECTION_OUT);\n\n  if (cell_direction == CELL_DIRECTION_IN) {\n    if (CIRCUIT_IS_ORIGIN(circ)) { /* We're at the beginning of the circuit.\n                                    * We'll want to do layered decrypts. */\n      crypt_path_t *thishop, *cpath = TO_ORIGIN_CIRCUIT(circ)->cpath;\n      thishop = cpath;\n      if (thishop->state != CPATH_STATE_OPEN) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"Relay cell before first created cell? Closing.\");\n        return -1;\n      }\n      do { /* Remember: cpath is in forward order, that is, first hop first. */\n        tor_assert(thishop);\n\n        if (relay_crypt_one_payload(thishop->b_crypto, cell->payload, 0) < 0)\n          return -1;\n\n        relay_header_unpack(&rh, cell->payload);\n        if (rh.recognized == 0) {\n          /* it's possibly recognized. have to check digest to be sure. */\n          if (relay_digest_matches(thishop->b_digest, cell)) {\n            *recognized = 1;\n            *layer_hint = thishop;\n            return 0;\n          }\n        }\n\n        thishop = thishop->next;\n      } while (thishop != cpath && thishop->state == CPATH_STATE_OPEN);\n      log_fn(LOG_PROTOCOL_WARN, LD_OR,\n             \"Incoming cell at client not recognized. Closing.\");\n      return -1;\n    } else { /* we're in the middle. Just one crypt. */\n      if (relay_crypt_one_payload(TO_OR_CIRCUIT(circ)->p_crypto,\n                                  cell->payload, 1) < 0)\n        return -1;\n//      log_fn(LOG_DEBUG,\"Skipping recognized check, because we're not \"\n//             \"the client.\");\n    }\n  } else /* cell_direction == CELL_DIRECTION_OUT */ {\n    /* we're in the middle. Just one crypt. */\n\n    if (relay_crypt_one_payload(TO_OR_CIRCUIT(circ)->n_crypto,\n                                cell->payload, 0) < 0)\n      return -1;\n\n    relay_header_unpack(&rh, cell->payload);\n    if (rh.recognized == 0) {\n      /* it's possibly recognized. have to check digest to be sure. */\n      if (relay_digest_matches(TO_OR_CIRCUIT(circ)->n_digest, cell)) {\n        *recognized = 1;\n        return 0;\n      }\n    }\n  }\n  return 0;\n}", "target": 0, "cwe": ["CWE-200", "CWE-617"], "project": "tor", "commit_id": "56a7c5bc15e0447203a491c1ee37de9939ad1dcd", "hash": 70677973686264337124701965604064297333, "size": 67, "message": "TROVE-2017-005: Fix assertion failure in connection_edge_process_relay_cell\n\nOn an hidden service rendezvous circuit, a BEGIN_DIR could be sent\n(maliciously) which would trigger a tor_assert() because\nconnection_edge_process_relay_cell() thought that the circuit is an\nor_circuit_t but is an origin circuit in reality.\n\nFixes #22494\n\nReported-by: Roger Dingledine <arma@torproject.org>\nSigned-off-by: David Goulet <dgoulet@torproject.org>", "idx": 791}
{"func": "bucket_insert (index_bucket *bucket,\n               CK_OBJECT_HANDLE handle)\n{\n\tunsigned int alloc;\n\tint at = 0;\n\n\tif (bucket->elem) {\n\t\tat = binary_search (bucket->elem, 0, bucket->num, handle);\n\t\tif (at < bucket->num && bucket->elem[at] == handle)\n\t\t\treturn;\n\t}\n\n\talloc = alloc_size (bucket->num);\n\tif (bucket->num + 1 > alloc) {\n\t\tCK_OBJECT_HANDLE *elem;\n\n\t\talloc = alloc ? alloc * 2 : 1;\n\t\treturn_if_fail (alloc != 0);\n\t\telem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));\n\t\treturn_if_fail (elem != NULL);\n\t\tbucket->elem = elem;\n\t}\n\n\treturn_if_fail (bucket->elem != NULL);\n\tmemmove (bucket->elem + at + 1, bucket->elem + at,\n\t         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));\n\tbucket->elem[at] = handle;\n\tbucket->num++;\n}", "target": 1, "cwe": ["CWE-190"], "project": "p11-kit", "commit_id": "5307a1d21a50cacd06f471a873a018d23ba4b963", "hash": 215437475606015762164417178051499664140, "size": 29, "message": "Check for arithmetic overflows before allocating", "idx": 792}
{"func": "const char *crypt_get_dir(void)\n{\n\treturn dm_get_dir();\n}", "target": 0, "cwe": ["CWE-345"], "project": "cryptsetup", "commit_id": "0113ac2d889c5322659ad0596d4cfc6da53e356c", "hash": 251500735792622050056122221547612723554, "size": 4, "message": "Fix CVE-2021-4122 - LUKS2 reencryption crash recovery attack\n\nFix possible attacks against data confidentiality through LUKS2 online\nreencryption extension crash recovery.\n\nAn attacker can modify on-disk metadata to simulate decryption in\nprogress with crashed (unfinished) reencryption step and persistently\ndecrypt part of the LUKS device.\n\nThis attack requires repeated physical access to the LUKS device but\nno knowledge of user passphrases.\n\nThe decryption step is performed after a valid user activates\nthe device with a correct passphrase and modified metadata.\nThere are no visible warnings for the user that such recovery happened\n(except using the luksDump command). The attack can also be reversed\nafterward (simulating crashed encryption from a plaintext) with\npossible modification of revealed plaintext.\n\nThe problem was caused by reusing a mechanism designed for actual\nreencryption operation without reassessing the security impact for new\nencryption and decryption operations. While the reencryption requires\ncalculating and verifying both key digests, no digest was needed to\ninitiate decryption recovery if the destination is plaintext (no\nencryption key). Also, some metadata (like encryption cipher) is not\nprotected, and an attacker could change it. Note that LUKS2 protects\nvisible metadata only when a random change occurs. It does not protect\nagainst intentional modification but such modification must not cause\na violation of data confidentiality.\n\nThe fix introduces additional digest protection of reencryption\nmetadata. The digest is calculated from known keys and critical\nreencryption metadata. Now an attacker cannot create correct metadata\ndigest without knowledge of a passphrase for used keyslots.\nFor more details, see LUKS2 On-Disk Format Specification version 1.1.0.", "idx": 793}
{"func": "bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)\n{\n  char *p = (char *)bits;\n  for (; *p; p++)\n    {\n      if (*p == '0' || *p == '1')\n        bit_write_B (dat, *p != '0');\n      else\n        {\n          fprintf (stderr, \"Invalid binary input %s\\n\", p);\n          return;\n        }\n    }\n}", "target": 0, "cwe": ["CWE-703", "CWE-125"], "project": "libredwg", "commit_id": "95cc9300430d35feb05b06a9badf678419463dbe", "hash": 296058153959145889086708437759624679780, "size": 14, "message": "encode: protect from stack under-flow\n\nFrom GH #178 fuzzing", "idx": 794}
{"func": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (byts[arridx] == 0 || n == (int)STATE_NOPREFIX)\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin))\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    ++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n\t    }\n\t}\n    }\n}", "target": 1, "cwe": ["CWE-457"], "project": "vim", "commit_id": "15d9890eee53afc61eb0a03b878a19cb5672f732", "hash": 24168664119882376985740609615416812135, "size": 1414, "message": "patch 8.2.3582: reading uninitialized memory when giving spell suggestions\n\nProblem:    Reading uninitialized memory when giving spell suggestions.\nSolution:   Check that preword is not empty.", "idx": 795}
{"func": "std::string Box_pitm::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << indent << \"item_ID: \" << m_item_ID << \"\\n\";\n\n  return sstr.str();\n}", "target": 0, "cwe": ["CWE-703"], "project": "libheif", "commit_id": "2710c930918609caaf0a664e9c7bc3dce05d5b58", "hash": 339659660236337222390634477571636015734, "size": 8, "message": "force fraction to a limited resolution to finally solve those pesky numerical edge cases", "idx": 796}
{"func": "TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    UINT32 i;\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal(&target->count, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->count > MAX_TAGGED_POLICIES) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {\n\trc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, size);\n    }\n    return rc;\n}", "target": 1, "cwe": ["CWE-787"], "project": "libtpms", "commit_id": "f16250b35aff6995e540143a9858c9cf0d1f9573", "hash": 95697219602822951661922893870409305920, "size": 18, "message": "tpm2: Reset TPM2B buffer sizes after test fails for valid buffer size\n\nReset the buffer size indicator in a TPM2B type of buffer after it failed\nthe test for the maximum buffer size it allows. This prevents having bad\nbuffer sizes in memory that can come to haunt us when writing the volatile\nstate for example.\n\nSigned-off-by: Stefan Berger <stefanb@linux.ibm.com>", "idx": 797}
{"func": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n\n\treturn err;\n}", "target": 1, "cwe": ["CWE-399", "CWE-703"], "project": "linux", "commit_id": "ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d", "hash": 307010547341394563541870317941533055087, "size": 15, "message": "Fix order of arguments to compat_put_time[spec|val]\n\nCommit 644595f89620 (\"compat: Handle COMPAT_USE_64BIT_TIME in\nnet/socket.c\") introduced a bug where the helper functions to take\neither a 64-bit or compat time[spec|val] got the arguments in the wrong\norder, passing the kernel stack pointer off as a user pointer (and vice\nversa).\n\nBecause of the user address range check, that in turn then causes an\nEFAULT due to the user pointer range checking failing for the kernel\naddress.  Incorrectly resuling in a failed system call for 32-bit\nprocesses with a 64-bit kernel.\n\nOn odder architectures like HP-PA (with separate user/kernel address\nspaces), it can be used read kernel memory.\n\nSigned-off-by: Mikulas Patocka <mpatocka@redhat.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 798}
{"func": "struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *data,\n\t\t\t\t\t       struct nfs_fh *mntfh)\n{\n\tstruct nfs_client *parent_client;\n\tstruct nfs_server *server, *parent_server;\n\tstruct nfs_fattr fattr;\n\tint error;\n\n\tdprintk(\"--> nfs4_create_referral_server()\\n\");\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tparent_server = NFS_SB(data->sb);\n\tparent_client = parent_server->nfs_client;\n\n\t/* Get a client representation.\n\t * Note: NFSv4 always uses TCP, */\n\terror = nfs4_set_client(server, data->hostname, data->addr,\n\t\t\tparent_client->cl_ipaddr,\n\t\t\tdata->authflavor,\n\t\t\tparent_server->client->cl_xprt->prot,\n\t\t\tparent_client->retrans_timeo,\n\t\t\tparent_client->retrans_count);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* Initialise the client representation from the parent server */\n\tnfs_server_copy_userdata(server, parent_server);\n\tserver->caps |= NFS_CAP_ATOMIC_OPEN;\n\n\terror = nfs_init_server_rpcclient(server, data->authflavor);\n\tif (error < 0)\n\t\tgoto error;\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\t/* Probe the root fh to retrieve its FSID and filehandle */\n\terror = nfs4_path_walk(server, mntfh, data->mnt_path);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* probe the filesystem info for this server filesystem */\n\terror = nfs_probe_fsinfo(server, mntfh, &fattr);\n\tif (error < 0)\n\t\tgoto error;\n\n\tdprintk(\"Referral FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\n\tspin_lock(&nfs_client_lock);\n\tlist_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nfs_volume_list);\n\tspin_unlock(&nfs_client_lock);\n\n\tserver->mount_time = jiffies;\n\n\tdprintk(\"<-- nfs_create_referral_server() = %p\\n\", server);\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\tdprintk(\"<-- nfs4_create_referral_server() = error %d\\n\", error);\n\treturn ERR_PTR(error);\n}", "target": 1, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "54af3bb543c071769141387a42deaaab5074da55", "hash": 78297515873739874445623617648032570180, "size": 69, "message": "NFS: Fix an Oops in encode_lookup()\n\nIt doesn't look as if the NFS file name limit is being initialised correctly\nin the struct nfs_server. Make sure that we limit whatever is being set in\nnfs_probe_fsinfo() and nfs_init_server().\n\nAlso ensure that readdirplus and nfs4_path_walk respect our file name\nlimits.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 799}
{"func": "static void zlib_stateful_finish(COMP_CTX *ctx)\n\t{\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);\n\t}", "target": 1, "cwe": ["CWE-399"], "project": "openssl", "commit_id": "1b31b5ad560b16e2fe1cad54a755e3e6b5e778a3", "hash": 227526666652226078098161975961705166937, "size": 4, "message": "Modify compression code so it avoids using ex_data free functions. This\nstops applications that call CRYPTO_free_all_ex_data() prematurely leaking\nmemory.", "idx": 800}
{"func": "void Mounter::umount(const QString &mountPoint, int pid)\n{\n    if (calledFromDBus()) {\n        registerPid(pid);\n    }\n\n    if (mpOk(mountPoint)) {\n        QProcess *proc=new QProcess(this);\n        connect(proc, SIGNAL(finished(int)), SLOT(umountResult(int)));\n        proc->start(\"umount\", QStringList() << mountPoint);\n        proc->setProperty(\"mp\", mountPoint);\n        proc->setProperty(\"pid\", pid);\n        procCount++;\n    } else {\n        emit umountStatus(mountPoint, pid, -1);\n    }\n}", "target": 1, "cwe": ["CWE-20", "CWE-22"], "project": "cantata", "commit_id": "afc4f8315d3e96574925fb530a7004cc9e6ce3d3", "hash": 211956164802391410201420686077165669594, "size": 17, "message": "Remove internal Samba shre mounting code, this had some privilege escalation issues, and is not well tested", "idx": 801}
{"func": "GF_Box *trgt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}", "target": 0, "cwe": ["CWE-125"], "project": "gpac", "commit_id": "bceb03fd2be95097a7b409ea59914f332fb6bc86", "hash": 185113714668031087814638948780550720665, "size": 5, "message": "fixed 2 possible heap overflows (inc. #1088)", "idx": 802}
{"func": "static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {\n\t// turn off bits 5, 6 and 7\n\tswitch(data[0] & 0x1f) { // 0x1f = b00111111\n\tcase 0x02: // op #$ff\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x0a: //op a\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"a\");\n\t\tbreak;\n\tcase 0x06: // op $ff\n\t\top->cycles = 5;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x16: // op $ff,x\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%02x,+\", reg, data[1]);\n\t\tbreak;\n\tcase 0x0e: // op $ffff\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"0x%04x\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x1e: // op $ffff,x\n\t\top->cycles = 7;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%04x,+\", reg, data[1] | data[2] << 8);\n\t\tbreak;\n\t}\n}", "target": 0, "cwe": ["CWE-190", "CWE-125"], "project": "radare2", "commit_id": "bbb4af56003c1afdad67af0c4339267ca38b1017", "hash": 82225029586742695850054891639384888599, "size": 29, "message": "Fix #10294 - crash in r2_hoobr__6502_op", "idx": 803}
{"func": "int wc_SignatureVerify(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    const byte* sig, word32 sig_len,\n    const void* key, word32 key_len)\n{\n    int ret;\n    word32 hash_len, hash_enc_len;\n#ifdef WOLFSSL_SMALL_STACK\n    byte *hash_data;\n#else\n    byte hash_data[MAX_DER_DIGEST_SZ];\n#endif\n\n    /* Check arguments */\n    if (data == NULL || data_len <= 0 ||\n        sig == NULL || sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (1 to max is okay) */\n    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid hash type/len\");\n        return ret;\n    }\n    hash_enc_len = hash_len = ret;\n\n#ifndef NO_RSA\n    if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        /* For RSA with ASN.1 encoding include room */\n        hash_enc_len += MAX_DER_DIGEST_ASN_SZ;\n    }\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    /* Allocate temporary buffer for hash data */\n    hash_data = (byte*)XMALLOC(hash_enc_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (hash_data == NULL) {\n        return MEMORY_E;\n    }\n#endif\n\n    /* Perform hash of data */\n    ret = wc_Hash(hash_type, data, data_len, hash_data, hash_len);\n    if (ret == 0) {\n        /* Handle RSA with DER encoding */\n        if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        #if defined(NO_RSA) || defined(NO_ASN)\n            ret = SIG_TYPE_E;\n        #else\n            ret = wc_SignatureDerEncode(hash_type, hash_data, hash_len,\n                &hash_enc_len);\n        #endif\n        }\n\n        if (ret == 0) {\n            /* Verify signature using hash */\n            ret = wc_SignatureVerifyHash(hash_type, sig_type,\n                hash_data, hash_enc_len, sig, sig_len, key, key_len);\n        }\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}", "target": 0, "cwe": ["CWE-200", "CWE-327", "CWE-347"], "project": "wolfssl", "commit_id": "23878512c65834d12811b1107d19a001478eca5d", "hash": 58142555751222853212373415129770686547, "size": 76, "message": "Change signature generation to verify by default", "idx": 804}
{"func": "flatpak_context_shared_to_args (FlatpakContextShares shares,\n                                FlatpakContextShares valid,\n                                GPtrArray           *args)\n{\n  return flatpak_context_bitmask_to_args (shares, valid, flatpak_context_shares, \"--share\", \"--unshare\", args);\n}", "target": 0, "cwe": ["CWE-94", "CWE-74"], "project": "flatpak", "commit_id": "6e5ae7a109cdfa9735ea7ccbd8cb79f9e8d3ae8b", "hash": 202538001628257388731722617432196408689, "size": 6, "message": "context: Add --env-fd option\n\nThis allows environment variables to be added to the context without\nmaking their values visible to processes running under a different uid,\nwhich might be significant if the variable's value is a token or some\nother secret value.\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>\nPart-of: https://github.com/flatpak/flatpak/security/advisories/GHSA-4ppf-fxf6-vxg2", "idx": 805}
{"func": "gdk_pixbuf_copy (const GdkPixbuf *pixbuf)\n{\n\tguchar *buf;\n\tint size;\n\n\tg_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);\n\n\t/* Calculate a semi-exact size.  Here we copy with full rowstrides;\n\t * maybe we should copy each row individually with the minimum\n\t * rowstride?\n\t */\n\n\tsize = gdk_pixbuf_get_byte_length (pixbuf);\n\n\tbuf = g_try_malloc (size * sizeof (guchar));\n\tif (!buf)\n\t\treturn NULL;\n\n\tmemcpy (buf, pixbuf->pixels, size);\n\n\treturn gdk_pixbuf_new_from_data (buf,\n\t\t\t\t\t pixbuf->colorspace, pixbuf->has_alpha,\n\t\t\t\t\t pixbuf->bits_per_sample,\n\t\t\t\t\t pixbuf->width, pixbuf->height,\n\t\t\t\t\t pixbuf->rowstride,\n\t\t\t\t\t free_buffer,\n\t\t\t\t\t NULL);\n}", "target": 1, "cwe": [], "project": "gdk-pixbuf", "commit_id": "deb78d971c4bcb9e3ccbb71e7925bc6baa707188", "hash": 307201077391649359853796260895083211780, "size": 28, "message": "Use g_try_malloc_n where it makes sense\n\nThis lets us avoid some manual overflow checks.", "idx": 806}
{"func": "  static port::StatusOr<CudnnRnnSequenceTensorDescriptor> Create(\n      GpuExecutor* parent, int max_seq_length, int batch_size, int data_size,\n      const absl::Span<const int>& seq_lengths, bool time_major,\n      cudnnDataType_t data_type) {\n    CHECK_GT(max_seq_length, 0);\n    int dims[] = {batch_size, data_size, 1};\n    int strides[] = {dims[1] * dims[2], dims[2], 1};\n    TensorDescriptor tensor_desc = CreateTensorDescriptor();\n    RETURN_IF_CUDNN_ERROR(cudnnSetTensorNdDescriptor(\n        /*tensorDesc=*/tensor_desc.get(), /*dataType=*/data_type,\n        /*nbDims=*/sizeof(dims) / sizeof(dims[0]), /*dimA=*/dims,\n        /*strideA=*/strides));\n    const int* seq_lengths_array = seq_lengths.data();\n    RNNDataDescriptor data_desc = CreateRNNDataDescriptor();\n    float padding_fill = 0.0f;\n    cudnnRNNDataLayout_t layout;\n    if (time_major) {\n      layout = CUDNN_RNN_DATA_LAYOUT_SEQ_MAJOR_UNPACKED;\n    } else {\n      layout = CUDNN_RNN_DATA_LAYOUT_BATCH_MAJOR_UNPACKED;\n    }\n    RETURN_IF_CUDNN_ERROR(cudnnSetRNNDataDescriptor(\n        /*RNNDataDesc=*/data_desc.get(), /*dataType*/ data_type,\n        /*layout=*/layout,\n        /*maxSeqLength=*/max_seq_length,\n        /*batchSize=*/batch_size, /*vectorSize=*/data_size,\n        /*seqLengthArray=*/seq_lengths_array,\n        /*paddingFill*/ (void*)&padding_fill));\n    return CudnnRnnSequenceTensorDescriptor(\n        parent, max_seq_length, batch_size, data_size, data_type,\n        std::move(data_desc), std::move(tensor_desc));\n  }", "target": 1, "cwe": ["CWE-20"], "project": "tensorflow", "commit_id": "14755416e364f17fb1870882fa778c7fec7f16e3", "hash": 46373760535153522269390833301470125976, "size": 32, "message": "Prevent CHECK-fail in LSTM/GRU with zero-length input.\n\nPiperOrigin-RevId: 346239181\nChange-Id: I5f233dbc076aab7bb4e31ba24f5abd4eaf99ea4f", "idx": 807}
{"func": "static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 old_spte;\n\tu64 *sptep = NULL;\n\n\tfor_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {\n\t\tsptep = iterator.sptep;\n\t\t*spte = old_spte;\n\t}\n\n\treturn sptep;\n}", "target": 0, "cwe": ["CWE-476"], "project": "linux", "commit_id": "9f46c187e2e680ecd9de7983e4d081c3391acc76", "hash": 36410174676083259478931829054848734473, "size": 13, "message": "KVM: x86/mmu: fix NULL pointer dereference on guest INVPCID\n\nWith shadow paging enabled, the INVPCID instruction results in a call\nto kvm_mmu_invpcid_gva.  If INVPCID is executed with CR0.PG=0, the\ninvlpg callback is not set and the result is a NULL pointer dereference.\nFix it trivially by checking for mmu->invlpg before every call.\n\nThere are other possibilities:\n\n- check for CR0.PG, because KVM (like all Intel processors after P5)\n  flushes guest TLB on CR0.PG changes so that INVPCID/INVLPG are a\n  nop with paging disabled\n\n- check for EFER.LMA, because KVM syncs and flushes when switching\n  MMU contexts outside of 64-bit mode\n\nAll of these are tricky, go for the simple solution.  This is CVE-2022-1789.\n\nReported-by: Yongkang Jia <kangel@zju.edu.cn>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 808}
{"func": "void testCacheManager::setUp()\n{\n    Mem::Init();\n}", "target": 1, "cwe": ["CWE-401"], "project": "squid", "commit_id": "26e65059bc06ebce508737b5cd0866478691566a", "hash": 286485392580211439886012506293718322987, "size": 4, "message": "Bug 5106: Broken cache manager URL parsing (#788)\n\nUse already parsed request-target URL in cache manager and\nupdate CacheManager to Tokanizer based URL parse\n\nRemoving use of sscan() and regex string processing which have\nproven to be problematic on many levels. Most particularly with\nregards to tolerance of normally harmless garbage syntax in URLs\nreceived.\n\nSupport for generic URI schemes is added possibly resolving some\nissues reported with ftp:// URL and manager access via ftp_port\nsockets.\n\nTruly generic support for /squid-internal-mgr/ path prefix is\nadded, fixing some user confusion about its use on cache_object:\nscheme URLs.\n\nTODO: support for single-name parameters and URL #fragments\nare left to future updates. As is refactoring the QueryParams\ndata storage to avoid SBuf data copying.", "idx": 809}
{"func": "static int xfrm_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tint len = nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr);\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_userpolicy_info *p;\n\tstruct xfrm_userpolicy_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t}\n\tlen += userpolicy_type_attrsize();\n\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemset(id, 0, sizeof(*id));\n\t\tid->dir = dir;\n\t\tif (c->data.byid)\n\t\t\tid->index = xp->index;\n\t\telse\n\t\t\tmemcpy(&id->sel, &xp->selector, sizeof(id->sel));\n\n\t\tattr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\n\tcopy_to_user_policy(xp, p, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_POLICY);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 0, "cwe": ["CWE-284"], "project": "linux", "commit_id": "677e806da4d916052585301785d847c3b3e6186a", "hash": 176090598142822946297502228820144970295, "size": 65, "message": "xfrm_user: validate XFRM_MSG_NEWAE XFRMA_REPLAY_ESN_VAL replay_window\n\nWhen a new xfrm state is created during an XFRM_MSG_NEWSA call we\nvalidate the user supplied replay_esn to ensure that the size is valid\nand to ensure that the replay_window size is within the allocated\nbuffer.  However later it is possible to update this replay_esn via a\nXFRM_MSG_NEWAE call.  There we again validate the size of the supplied\nbuffer matches the existing state and if so inject the contents.  We do\nnot at this point check that the replay_window is within the allocated\nmemory.  This leads to out-of-bounds reads and writes triggered by\nnetlink packets.  This leads to memory corruption and the potential for\npriviledge escalation.\n\nWe already attempt to validate the incoming replay information in\nxfrm_new_ae() via xfrm_replay_verify_len().  This confirms that the user\nis not trying to change the size of the replay state buffer which\nincludes the replay_esn.  It however does not check the replay_window\nremains within that buffer.  Add validation of the contained\nreplay_window.\n\nCVE-2017-7184\nSigned-off-by: Andy Whitcroft <apw@canonical.com>\nAcked-by: Steffen Klassert <steffen.klassert@secunet.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 810}
{"func": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\n\tsalsa20_ivsetup(ctx, walk.iv);\n\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}", "target": 1, "cwe": ["CWE-20", "CWE-200"], "project": "linux", "commit_id": "ecaaab5649781c5a0effdaf298a925063020500e", "hash": 75016091551884565887346361289147134465, "size": 36, "message": "crypto: salsa20 - fix blkcipher_walk API usage\n\nWhen asked to encrypt or decrypt 0 bytes, both the generic and x86\nimplementations of Salsa20 crash in blkcipher_walk_done(), either when\ndoing 'kfree(walk->buffer)' or 'free_page((unsigned long)walk->page)',\nbecause walk->buffer and walk->page have not been initialized.\n\nThe bug is that Salsa20 is calling blkcipher_walk_done() even when\nnothing is in 'walk.nbytes'.  But blkcipher_walk_done() is only meant to\nbe called when a nonzero number of bytes have been provided.\n\nThe broken code is part of an optimization that tries to make only one\ncall to salsa20_encrypt_bytes() to process inputs that are not evenly\ndivisible by 64 bytes.  To fix the bug, just remove this \"optimization\"\nand use the blkcipher_walk API the same way all the other users do.\n\nReproducer:\n\n    #include <linux/if_alg.h>\n    #include <sys/socket.h>\n    #include <unistd.h>\n\n    int main()\n    {\n            int algfd, reqfd;\n            struct sockaddr_alg addr = {\n                    .salg_type = \"skcipher\",\n                    .salg_name = \"salsa20\",\n            };\n            char key[16] = { 0 };\n\n            algfd = socket(AF_ALG, SOCK_SEQPACKET, 0);\n            bind(algfd, (void *)&addr, sizeof(addr));\n            reqfd = accept(algfd, 0, 0);\n            setsockopt(algfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key));\n            read(reqfd, key, sizeof(key));\n    }\n\nReported-by: syzbot <syzkaller@googlegroups.com>\nFixes: eb6f13eb9f81 (\"[CRYPTO] salsa20_generic: Fix multi-page processing\")\nCc: <stable@vger.kernel.org> # v2.6.25+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>", "idx": 811}
{"func": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\t/* Solaris writes POSIX.1e access and default ACLs together */\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1, "cwe": ["CWE-59", "CWE-61"], "project": "libarchive", "commit_id": "fba4f123cc456d2b2538f811bb831483bf336bad", "hash": 55274404642822313527847967347354193527, "size": 25, "message": "Fix handling of symbolic link ACLs\n\nOn Linux ACLs on symbolic links are not supported.\nWe must avoid calling acl_set_file() on symbolic links as their\ntargets are modified instead.\n\nWhile here, do not try to set default ACLs on non-directories.\n\nFixes #1565", "idx": 812}
{"func": "int mszip_decompress(struct mszip_stream *zip, off_t out_bytes) {\n  /* for the bit buffer */\n  register unsigned int bit_buffer;\n  register int bits_left;\n  unsigned char *i_ptr, *i_end;\n\n  int i, ret, state, error;\n\n  /* easy answers */\n  if (!zip || (out_bytes < 0)) return CL_ENULLARG;\n  if (zip->error) return zip->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = zip->o_end - zip->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (zip->wflag && (ret = mspack_write(zip->ofd, zip->o_ptr, i, zip->file)) != CL_SUCCESS) {\n      return zip->error = ret;\n    }\n    zip->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  while (out_bytes > 0) {\n    /* unpack another block */\n    MSZIP_RESTORE_BITS;\n\n    /* skip to next read 'CK' header */\n    i = bits_left & 7; MSZIP_REMOVE_BITS(i); /* align to bytestream */\n    state = 0;\n    do {\n      MSZIP_READ_BITS(i, 8);\n      if (i == 'C') state = 1;\n      else if ((state == 1) && (i == 'K')) state = 2;\n      else state = 0;\n    } while (state != 2);\n\n    /* inflate a block, repair and realign if necessary */\n    zip->window_posn = 0;\n    zip->bytes_output = 0;\n    MSZIP_STORE_BITS;\n    if ((error = mszip_inflate(zip))) {\n      cli_dbgmsg(\"mszip_decompress: inflate error %d\\n\", error);\n      if (zip->repair_mode) {\n\tcli_dbgmsg(\"mszip_decompress: MSZIP error, %u bytes of data lost\\n\",\n\t\t\t  MSZIP_FRAME_SIZE - zip->bytes_output);\n\tfor (i = zip->bytes_output; i < MSZIP_FRAME_SIZE; i++) {\n\t  zip->window[i] = '\\0';\n\t}\n\tzip->bytes_output = MSZIP_FRAME_SIZE;\n      }\n      else {\n\treturn zip->error = (error > 0) ? error : CL_EFORMAT;\n      }\n    }\n    zip->o_ptr = &zip->window[0];\n    zip->o_end = &zip->o_ptr[zip->bytes_output];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)zip->bytes_output) ?\n      (int)out_bytes : zip->bytes_output;\n    if (zip->wflag && (ret = mspack_write(zip->ofd, zip->o_ptr, i, zip->file)) != CL_SUCCESS) {\n      return zip->error = ret;\n    }\n\n    /* mspack errors (i.e. read errors) are fatal and can't be recovered */\n    if ((error > 0) && zip->repair_mode) return error;\n\n    zip->o_ptr  += i;\n    out_bytes   -= i;\n  }\n\n  if (out_bytes) {\n    cli_dbgmsg(\"mszip_decompress: bytes left to output\\n\");\n    return zip->error = CL_EFORMAT;\n  }\n  return CL_SUCCESS;\n}", "target": 1, "cwe": [], "project": "clamav-devel", "commit_id": "158c35e81a25ea5fda55a2a7f62ea9fec2e883d9", "hash": 286001574084344575189044320456714640106, "size": 79, "message": "libclamav/mspack.c: improve unpacking of malformed cabinets (bb#1826)", "idx": 813}
{"func": "bit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1, "cwe": ["CWE-703", "CWE-125"], "project": "libredwg", "commit_id": "95cc9300430d35feb05b06a9badf678419463dbe", "hash": 319504494838733504734436820066906843608, "size": 31, "message": "encode: protect from stack under-flow\n\nFrom GH #178 fuzzing", "idx": 814}
{"func": "static inline bool get_next_i(IterCtx *ctx, size_t *next_i) {\n\t(*next_i)++;\n\tut64 cur_addr = *next_i + ctx->start_addr;\n\tif (ctx->fcn) {\n\t\tif (!ctx->cur_bb) {\n\t\t\tctx->path = rz_list_new();\n\t\t\tctx->switch_path = rz_list_new();\n\t\t\tctx->bbl = rz_list_clone(ctx->fcn->bbs);\n\t\t\tctx->cur_bb = rz_analysis_get_block_at(ctx->fcn->analysis, ctx->fcn->addr);\n\t\t\trz_list_push(ctx->path, ctx->cur_bb);\n\t\t}\n\t\tRzAnalysisBlock *bb = ctx->cur_bb;\n\t\tif (cur_addr >= bb->addr + bb->size) {\n\t\t\trz_reg_arena_push(ctx->fcn->analysis->reg);\n\t\t\tRzListIter *bbit = NULL;\n\t\t\tif (bb->switch_op) {\n\t\t\t\tRzAnalysisCaseOp *cop = rz_list_first(bb->switch_op->cases);\n\t\t\t\tbbit = rz_list_find(ctx->bbl, &cop->jump, (RzListComparator)find_bb);\n\t\t\t\tif (bbit) {\n\t\t\t\t\trz_list_push(ctx->switch_path, bb->switch_op->cases->head);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbbit = rz_list_find(ctx->bbl, &bb->jump, (RzListComparator)find_bb);\n\t\t\t\tif (!bbit && bb->fail != UT64_MAX) {\n\t\t\t\t\tbbit = rz_list_find(ctx->bbl, &bb->fail, (RzListComparator)find_bb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bbit) {\n\t\t\t\tRzListIter *cop_it = rz_list_last(ctx->switch_path);\n\t\t\t\tRzAnalysisBlock *prev_bb = NULL;\n\t\t\t\tdo {\n\t\t\t\t\trz_reg_arena_pop(ctx->fcn->analysis->reg);\n\t\t\t\t\tprev_bb = rz_list_pop(ctx->path);\n\t\t\t\t\tif (prev_bb->fail != UT64_MAX) {\n\t\t\t\t\t\tbbit = rz_list_find(ctx->bbl, &prev_bb->fail, (RzListComparator)find_bb);\n\t\t\t\t\t\tif (bbit) {\n\t\t\t\t\t\t\trz_reg_arena_push(ctx->fcn->analysis->reg);\n\t\t\t\t\t\t\trz_list_push(ctx->path, prev_bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!bbit && cop_it) {\n\t\t\t\t\t\tRzAnalysisCaseOp *cop = cop_it->data;\n\t\t\t\t\t\tif (cop->jump == prev_bb->addr && cop_it->n) {\n\t\t\t\t\t\t\tcop = cop_it->n->data;\n\t\t\t\t\t\t\trz_list_pop(ctx->switch_path);\n\t\t\t\t\t\t\trz_list_push(ctx->switch_path, cop_it->n);\n\t\t\t\t\t\t\tcop_it = cop_it->n;\n\t\t\t\t\t\t\tbbit = rz_list_find(ctx->bbl, &cop->jump, (RzListComparator)find_bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cop_it && !cop_it->n) {\n\t\t\t\t\t\trz_list_pop(ctx->switch_path);\n\t\t\t\t\t\tcop_it = rz_list_last(ctx->switch_path);\n\t\t\t\t\t}\n\t\t\t\t} while (!bbit && !rz_list_empty(ctx->path));\n\t\t\t}\n\t\t\tif (!bbit) {\n\t\t\t\trz_list_free(ctx->path);\n\t\t\t\trz_list_free(ctx->switch_path);\n\t\t\t\trz_list_free(ctx->bbl);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tctx->cur_bb = bbit->data;\n\t\t\trz_list_push(ctx->path, ctx->cur_bb);\n\t\t\trz_list_delete(ctx->bbl, bbit);\n\t\t\t*next_i = ctx->cur_bb->addr - ctx->start_addr;\n\t\t}\n\t} else if (cur_addr >= ctx->end_addr) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0, "cwe": ["CWE-703"], "project": "rizin", "commit_id": "6ce71d8aa3dafe3cdb52d5d72ae8f4b95916f939", "hash": 26420366063084489964917596552239750151, "size": 72, "message": "Initialize retctx,ctx before freeing the inner elements\n\nIn rz_core_analysis_type_match retctx structure was initialized on the\nstack only after a \"goto out_function\", where a field of that structure\nwas freed. When the goto path is taken, the field is not properly\ninitialized and it cause cause a crash of Rizin or have other effects.\n\nFixes: CVE-2021-4022", "idx": 815}
{"func": "  void visit(AndPredicate & /*ope*/) override { set_error(); }", "target": 0, "cwe": ["CWE-125"], "project": "cpp-peglib", "commit_id": "b3b29ce8f3acf3a32733d930105a17d7b0ba347e", "hash": 258949810028381691136006554288958882942, "size": 1, "message": "Fix #122", "idx": 816}
{"func": "TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    INT32 startSize;\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT16_Unmarshal(&target->size, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->size == 0) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tstartSize = *size;\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->size != startSize - *size) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    return rc;\n}", "target": 1, "cwe": ["CWE-787"], "project": "libtpms", "commit_id": "f16250b35aff6995e540143a9858c9cf0d1f9573", "hash": 306372836430270572956739101060845575597, "size": 26, "message": "tpm2: Reset TPM2B buffer sizes after test fails for valid buffer size\n\nReset the buffer size indicator in a TPM2B type of buffer after it failed\nthe test for the maximum buffer size it allows. This prevents having bad\nbuffer sizes in memory that can come to haunt us when writing the volatile\nstate for example.\n\nSigned-off-by: Stefan Berger <stefanb@linux.ibm.com>", "idx": 817}
{"func": "static int get_busid_idx(const char *busid)\n{\n\tint i;\n\tint idx = -1;\n\n\tfor (i = 0; i < MAX_BUSID; i++)\n\t\tif (busid_table[i].name[0])\n\t\t\tif (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\treturn idx;\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux", "commit_id": "22076557b07c12086eeb16b8ce2b0b735f7a27e7", "hash": 319151975279004484229160119475304451591, "size": 13, "message": "usbip: usbip_host: fix NULL-ptr deref and use-after-free errors\n\nusbip_host updates device status without holding lock from stub probe,\ndisconnect and rebind code paths. When multiple requests to import a\ndevice are received, these unprotected code paths step all over each\nother and drive fails with NULL-ptr deref and use-after-free errors.\n\nThe driver uses a table lock to protect the busid array for adding and\ndeleting busids to the table. However, the probe, disconnect and rebind\npaths get the busid table entry and update the status without holding\nthe busid table lock. Add a new finer grain lock to protect the busid\nentry. This new lock will be held to search and update the busid entry\nfields from get_busid_idx(), add_match_busid() and del_match_busid().\n\nmatch_busid_show() does the same to access the busid entry fields.\n\nget_busid_priv() changed to return the pointer to the busid entry holding\nthe busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()\ncall put_busid_priv() to release the busid lock before returning. This\nchanges fixes the unprotected code paths eliminating the race conditions\nin updating the busid entries.\n\nReported-by: Jakub Jirasek\nSigned-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>\nCc: stable <stable@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 818}
{"func": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\n\t/*\n\t *  Pick a unique starting offset for each TCP connection endpoints\n\t *  (saddr, daddr, sport, dport).\n\t *  Note that the words are placed into the starting vector, which is\n\t *  then mixed with a partial MD4 over random data.\n\t */\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\n\tseq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;\n\tseq += keyptr->count;\n\t/*\n\t *\tAs close as possible to RFC 793, which\n\t *\tsuggests using a 250 kHz clock.\n\t *\tFurther reading shows this assumes 2 Mb/s networks.\n\t *\tFor 10 Mb/s Ethernet, a 1 MHz clock is appropriate.\n\t *\tFor 10 Gb/s Ethernet, a 1 GHz clock should be ok, but\n\t *\twe also need to limit the resolution so that the u32 seq\n\t *\toverlaps less than one time per MSL (2 minutes).\n\t *\tChoosing a clock of 64 ns period is OK. (period of 274 s)\n\t */\n\tseq += ktime_to_ns(ktime_get_real()) >> 6;\n\n\treturn seq;\n}", "target": 1, "cwe": ["CWE-703"], "project": "linux", "commit_id": "6e5714eaf77d79ae1c8b47e3e040ff5411b717ec", "hash": 153524571962904367492151335565715846151, "size": 34, "message": "net: Compute protocol sequence numbers and fragment IDs using MD5.\n\nComputers have become a lot faster since we compromised on the\npartial MD4 hash which we use currently for performance reasons.\n\nMD5 is a much safer choice, and is inline with both RFC1948 and\nother ISS generators (OpenBSD, Solaris, etc.)\n\nFurthermore, only having 24-bits of the sequence number be truly\nunpredictable is a very serious limitation.  So the periodic\nregeneration and 8-bit counter have been removed.  We compute and\nuse a full 32-bit sequence number.\n\nFor ipv6, DCCP was found to use a 32-bit truncated initial sequence\nnumber (it needs 43-bits) and that is fixed here as well.\n\nReported-by: Dan Kaminsky <dan@doxpara.com>\nTested-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 819}
{"func": "FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->bits_per_sample = value;\n\treturn true;\n}", "target": 0, "cwe": ["CWE-787"], "project": "flac", "commit_id": "e1575e4a7c5157cbf4e4a16dbd39b74f7174c7be", "hash": 258219715718258242598198001265650343146, "size": 10, "message": "libFlac: Exit at EOS in verify mode\n\nWhen verify mode is enabled, once decoder flags end of stream,\nencode processing is considered complete.\n\nCVE-2021-0561\n\nSigned-off-by: Ralph Giles <giles@thaumas.net>", "idx": 820}
{"func": "finish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (is_state->did_incsearch)\n    {\n\tis_state->did_incsearch = FALSE;\n\tif (gotesc)\n\t    curwin->w_cursor = is_state->save_cursor;\n\telse\n\t{\n\t    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t    {\n\t\t// put the '\" mark at the original position\n\t\tcurwin->w_cursor = is_state->save_cursor;\n\t\tsetpcmark();\n\t    }\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\trestore_viewstate(&is_state->old_viewstate);\n\thighlight_match = FALSE;\n\n\t// by default search all lines\n\tsearch_first_line = 0;\n\tsearch_last_line = MAXLNUM;\n\n\tmagic_overruled = is_state->magic_overruled_save;\n\n\tvalidate_cursor();\t// needed for TAB\n\tredraw_all_later(SOME_VALID);\n\tif (call_update_screen)\n\t    update_screen(SOME_VALID);\n    }\n}", "target": 0, "cwe": ["CWE-122", "CWE-787"], "project": "vim", "commit_id": "85b6747abc15a7a81086db31289cf1b8b17e6cb1", "hash": 199399104617826635836771993391029555325, "size": 35, "message": "patch 8.2.4214: illegal memory access with large 'tabstop' in Ex mode\n\nProblem:    Illegal memory access with large 'tabstop' in Ex mode.\nSolution:   Allocate enough memory.", "idx": 821}
{"func": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "d5aa407f59f5b83d2c50ec88f5bf56d40f1f8978", "hash": 184594288284485003087662523953294453899, "size": 10, "message": "tunnels: fix netns vs proto registration ordering\n\nSame stuff as in ip_gre patch: receive hook can be called before netns\nsetup is done, oopsing in net_generic().\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 822}
{"func": "GF_Err gf_isom_new_xml_subtitle_description(GF_ISOFile  *movie, u32 trackNumber,\n        const char *xmlnamespace, const char *xml_schema_loc, const char *mimes,\n        u32 *outDescriptionIndex)\n{\n\tGF_TrackBox                 *trak;\n\tGF_Err                      e;\n\tu32                         dataRefIndex;\n\tGF_MetaDataSampleEntryBox *stpp;\n\tchar *URLname = NULL;\n\tchar *URNname = NULL;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\tcase GF_ISOM_MEDIA_META:\n\tcase GF_ISOM_MEDIA_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!xmlnamespace) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"XML (Subtitle, Metadata or Text) SampleEntry: namespace is mandatory. Abort.\\n\"));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstpp = (GF_MetaDataSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STPP);\n\tif (!stpp) return GF_OUT_OF_MEM;\n\tstpp->dataReferenceIndex = dataRefIndex;\n\tgf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, stpp);\n\tif (outDescriptionIndex) *outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\tstpp->xml_namespace = gf_strdup(xmlnamespace);\n\tif (xml_schema_loc) stpp->xml_schema_loc = gf_strdup(xml_schema_loc); //optional\n\tif (mimes) stpp->mime_type = gf_strdup(mimes); //optional\n\treturn e;\n}", "target": 0, "cwe": ["CWE-476", "CWE-401"], "project": "gpac", "commit_id": "328c6d682698fdb9878dbb4f282963d42c538c01", "hash": 323868272712609131981350772225879160154, "size": 52, "message": "fixed #1756", "idx": 823}
{"func": "std::string dump_time_to_str(const real_time& t)\n{\n  char timestr[TIME_BUF_SIZE];\n  dump_time_header_impl(timestr, t);\n\n  return timestr;\n}", "target": 0, "cwe": ["CWE-770"], "project": "ceph", "commit_id": "ab29bed2fc9f961fe895de1086a8208e21ddaddc", "hash": 321932818277859263942981598896991576170, "size": 7, "message": "rgw: fix issues with 'enforce bounds' patch\n\nThe patch to enforce bounds on max-keys/max-uploads/max-parts had a few\nissues that would prevent us from compiling it. Instead of changing the\ncode provided by the submitter, we're addressing them in a separate\ncommit to maintain the DCO.\n\nSigned-off-by: Joao Eduardo Luis <joao@suse.de>\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>\n(cherry picked from commit 29bc434a6a81a2e5c5b8cfc4c8d5c82ca5bf538a)\nmimic specific fixes:\nAs the largeish change from master g_conf() isn't in mimic yet, use the g_conf\nglobal structure, also make rgw_op use the value from req_info ceph context as\nwe do for all the requests", "idx": 824}
{"func": "SAPI_API void sapi_activate(TSRMLS_D)\n{\n\tzend_llist_init(&SG(sapi_headers).headers, sizeof(sapi_header_struct), (void (*)(void *)) sapi_free_header, 0);\n\tSG(sapi_headers).send_default_content_type = 1;\n\n\t/*\n\tSG(sapi_headers).http_response_code = 200;\n\t*/\n\tSG(sapi_headers).http_status_line = NULL;\n\tSG(sapi_headers).mimetype = NULL;\n\tSG(headers_sent) = 0;\n\tSG(callback_run) = 0;\n\tSG(callback_func) = NULL;\n\tSG(read_post_bytes) = 0;\n\tSG(request_info).post_data = NULL;\n\tSG(request_info).raw_post_data = NULL;\n\tSG(request_info).current_user = NULL;\n\tSG(request_info).current_user_length = 0;\n\tSG(request_info).no_headers = 0;\n\tSG(request_info).post_entry = NULL;\n\tSG(request_info).proto_num = 1000; /* Default to HTTP 1.0 */\n\tSG(global_request_time) = 0;\n\n\t/* It's possible to override this general case in the activate() callback, if necessary. */\n\tif (SG(request_info).request_method && !strcmp(SG(request_info).request_method, \"HEAD\")) {\n\t\tSG(request_info).headers_only = 1;\n\t} else {\n\t\tSG(request_info).headers_only = 0;\n\t}\n\tSG(rfc1867_uploaded_files) = NULL;\n\n\t/* Handle request method */\n\tif (SG(server_context)) {\n\t\tif (PG(enable_post_data_reading) && SG(request_info).request_method) {\n\t\t\tif (SG(request_info).content_type && !strcmp(SG(request_info).request_method, \"POST\")) {\n\t\t\t\t/* HTTP POST may contain form data to be processed into variables\n\t\t\t\t * depending on given content type */\n\t\t\t\tsapi_read_post_data(TSRMLS_C);\n\t\t\t} else {\n\t\t\t\t/* Any other method with content payload will fill $HTTP_RAW_POST_DATA\n\t\t\t\t * if it is enabled by always_populate_raw_post_data.\n\t\t\t\t * It's up to the webserver to decide whether to allow a method or not. */\n\t\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t\t\tif (sapi_module.default_post_reader) {\n\t\t\t\t\tsapi_module.default_post_reader(TSRMLS_C);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t}\n\n\t\t/* Cookies */\n\t\tSG(request_info).cookie_data = sapi_module.read_cookies(TSRMLS_C);\n\n\t\tif (sapi_module.activate) {\n\t\t\tsapi_module.activate(TSRMLS_C);\n\t\t}\n\t}\n\tif (sapi_module.input_filter_init) {\n\t\tsapi_module.input_filter_init(TSRMLS_C);\n\t}\n}", "target": 0, "cwe": ["CWE-601"], "project": "php-src", "commit_id": "98b9dfaec95e6f910f125ed172cdbd25abd006ec", "hash": 263118965426329499663313531556142975014, "size": 62, "message": "Fix for HTTP_PROXY issue.\n\nThe following changes are made:\n- _SERVER/_ENV only has HTTP_PROXY if the local environment has it,\n  and only one from the environment.\n- getenv('HTTP_PROXY') only returns one from the local environment\n- getenv has optional second parameter, telling it to only consider\n  local environment", "idx": 825}
{"func": "static struct task_struct *copy_process(unsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace)\n{\n\tint retval;\n\tstruct task_struct *p;\n\tint cgroup_callbacks_done = 0;\n\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tretval = security_task_create(clone_flags);\n\tif (retval)\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current);\n\tif (!p)\n\t\tgoto fork_out;\n\n\trt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\tp->signal->rlim[RLIMIT_NPROC].rlim_cur) {\n\t\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&\n\t\t    p->real_cred->user != INIT_USER)\n\t\t\tgoto bad_fork_free;\n\t}\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (nr_threads >= max_threads)\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (!try_module_get(task_thread_info(p)->exec_domain->module))\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (p->binfmt && !try_module_get(p->binfmt->module))\n\t\tgoto bad_fork_cleanup_put_domain;\n\n\tp->did_exec = 0;\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tcopy_flags(clone_flags, p);\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_flipctr_idx = 0;\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tclear_tsk_thread_flag(p, TIF_SIGPENDING);\n\tinit_sigpending(&p->pending);\n\n\tp->utime = cputime_zero;\n\tp->stime = cputime_zero;\n\tp->gtime = cputime_zero;\n\tp->utimescaled = cputime_zero;\n\tp->stimescaled = cputime_zero;\n\tp->prev_utime = cputime_zero;\n\tp->prev_stime = cputime_zero;\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_DETECT_SOFTLOCKUP\n\tp->last_switch_count = 0;\n\tp->last_switch_timestamp = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cpu_timers_init(p);\n\n\tp->lock_depth = -1;\t\t/* -1 = no lock */\n\tdo_posix_clock_monotonic_gettime(&p->start_time);\n\tp->real_start_time = p->start_time;\n\tmonotonic_to_bootbased(&p->real_start_time);\n\tp->io_context = NULL;\n\tp->audit_context = NULL;\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n \tif (IS_ERR(p->mempolicy)) {\n \t\tretval = PTR_ERR(p->mempolicy);\n \t\tp->mempolicy = NULL;\n \t\tgoto bad_fork_cleanup_cgroup;\n \t}\n\tmpol_fix_fork_child_flag(p);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tp->irq_events = 0;\n#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW\n\tp->hardirqs_enabled = 1;\n#else\n\tp->hardirqs_enabled = 0;\n#endif\n\tp->hardirq_enable_ip = 0;\n\tp->hardirq_enable_event = 0;\n\tp->hardirq_disable_ip = _THIS_IP_;\n\tp->hardirq_disable_event = 0;\n\tp->softirqs_enabled = 1;\n\tp->softirq_enable_ip = _THIS_IP_;\n\tp->softirq_enable_event = 0;\n\tp->softirq_disable_ip = 0;\n\tp->softirq_disable_event = 0;\n\tp->hardirq_context = 0;\n\tp->softirq_context = 0;\n#endif\n#ifdef CONFIG_LOCKDEP\n\tp->lockdep_depth = 0; /* no locks held yet */\n\tp->curr_chain_key = 0;\n\tp->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n\tif (unlikely(current->ptrace))\n\t\tptrace_fork(p, clone_flags);\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tsched_fork(p, clone_flags);\n\n\tif ((retval = audit_alloc(p)))\n\t\tgoto bad_fork_cleanup_policy;\n\t/* copy all the process information */\n\tif ((retval = copy_semundo(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_audit;\n\tif ((retval = copy_files(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_semundo;\n\tif ((retval = copy_fs(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_files;\n\tif ((retval = copy_sighand(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_fs;\n\tif ((retval = copy_signal(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_sighand;\n\tif ((retval = copy_mm(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_signal;\n\tif ((retval = copy_namespaces(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_mm;\n\tif ((retval = copy_io(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tif (pid != &init_struct_pid) {\n\t\tretval = -ENOMEM;\n\t\tpid = alloc_pid(p->nsproxy->pid_ns);\n\t\tif (!pid)\n\t\t\tgoto bad_fork_cleanup_io;\n\n\t\tif (clone_flags & CLONE_NEWPID) {\n\t\t\tretval = pid_ns_prepare_proc(p->nsproxy->pid_ns);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t}\n\n\tftrace_graph_init_task(p);\n\n\tp->pid = pid_nr(pid);\n\tp->tgid = p->pid;\n\tif (clone_flags & CLONE_THREAD)\n\t\tp->tgid = current->tgid;\n\n\tif (current->nsproxy != p->nsproxy) {\n\t\tretval = ns_cgroup_clone(p, pid);\n\t\tif (retval)\n\t\t\tgoto bad_fork_free_graph;\n\t}\n\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n#ifdef CONFIG_FUTEX\n\tp->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n\tp->compat_robust_list = NULL;\n#endif\n\tINIT_LIST_HEAD(&p->pi_state_list);\n\tp->pi_state_cache = NULL;\n#endif\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tp->sas_ss_sp = p->sas_ss_size = 0;\n\n\t/*\n\t * Syscall tracing should be turned off in the child regardless\n\t * of CLONE_PTRACE.\n\t */\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_all_latency_tracing(p);\n\n\t/* Our parent execution domain becomes current domain\n\t   These must match for thread signalling to apply */\n\tp->parent_exec_id = p->self_exec_id;\n\n\t/* ok, now we should be set up.. */\n\tp->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);\n\tp->pdeath_signal = 0;\n\tp->exit_state = 0;\n\n\t/*\n\t * Ok, make it visible to the rest of the system.\n\t * We dont wake it up yet.\n\t */\n\tp->group_leader = p;\n\tINIT_LIST_HEAD(&p->thread_group);\n\n\t/* Now that the task is set up, run cgroup callbacks if\n\t * necessary. We need to run them before the task is visible\n\t * on the tasklist. */\n\tcgroup_fork_callbacks(p);\n\tcgroup_callbacks_done = 1;\n\n\t/* Need tasklist lock for parent etc handling! */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/*\n\t * The task hasn't been attached yet, so its cpus_allowed mask will\n\t * not be changed, nor will its assigned CPU.\n\t *\n\t * The cpus_allowed mask of the parent may have changed after it was\n\t * copied first time - so re-copy it here, then check the child's CPU\n\t * to ensure it is on a valid CPU (and if not, just force it back to\n\t * parent's CPU). This avoids alot of nasty races.\n\t */\n\tp->cpus_allowed = current->cpus_allowed;\n\tp->rt.nr_cpus_allowed = current->rt.nr_cpus_allowed;\n\tif (unlikely(!cpu_isset(task_cpu(p), p->cpus_allowed) ||\n\t\t\t!cpu_online(task_cpu(p))))\n\t\tset_task_cpu(p, smp_processor_id());\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD))\n\t\tp->real_parent = current->real_parent;\n\telse\n\t\tp->real_parent = current;\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Process group and session signals need to be delivered to just the\n\t * parent before the fork or both the parent and the child after the\n\t * fork. Restart if a signal comes in before we add the new process to\n\t * it's process group.\n\t * A fatal signal pending means that current will exit, so the new\n\t * thread can't slip out of an OOM kill (or normal SIGKILL).\n \t */\n\trecalc_sigpending();\n\tif (signal_pending(current)) {\n\t\tspin_unlock(&current->sighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tretval = -ERESTARTNOINTR;\n\t\tgoto bad_fork_free_graph;\n\t}\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->group_leader = current->group_leader;\n\t\tlist_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);\n\t}\n\n\tif (likely(p->pid)) {\n\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\ttracehook_finish_clone(p, clone_flags, trace);\n\n\t\tif (thread_group_leader(p)) {\n\t\t\tif (clone_flags & CLONE_NEWPID)\n\t\t\t\tp->nsproxy->pid_ns->child_reaper = p;\n\n\t\t\tp->signal->leader_pid = pid;\n\t\t\ttty_kref_put(p->signal->tty);\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\tset_task_pgrp(p, task_pgrp_nr(current));\n\t\t\tset_task_session(p, task_session_nr(current));\n\t\t\tattach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tattach_pid(p, PIDTYPE_SID, task_session(current));\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\t__get_cpu_var(process_counts)++;\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID, pid);\n\t\tnr_threads++;\n\t}\n\n\ttotal_forks++;\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tproc_fork_connector(p);\n\tcgroup_post_fork(p);\n\treturn p;\n\nbad_fork_free_graph:\n\tftrace_graph_exit_task(p);\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_io:\n\tput_io_context(p->io_context);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm)\n\t\tmmput(p->mm);\nbad_fork_cleanup_signal:\n\tcleanup_signal(p);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_policy:\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_cgroup:\n#endif\n\tcgroup_exit(p, cgroup_callbacks_done);\n\tdelayacct_tsk_free(p);\n\tif (p->binfmt)\n\t\tmodule_put(p->binfmt->module);\nbad_fork_cleanup_put_domain:\n\tmodule_put(task_thread_info(p)->exec_domain->module);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\tput_cred(p->real_cred);\n\tput_cred(p->cred);\nbad_fork_free:\n\tfree_task(p);\nfork_out:\n\treturn ERR_PTR(retval);\n}", "target": 1, "cwe": ["CWE-264"], "project": "linux-2.6", "commit_id": "2d5516cbb9daf7d0e342a2e3b0fc6f8c39a81205", "hash": 181459718677728536551782778465884074859, "size": 377, "message": "copy_process: fix CLONE_PARENT && parent_exec_id interaction\n\nCLONE_PARENT can fool the ->self_exec_id/parent_exec_id logic. If we\nre-use the old parent, we must also re-use ->parent_exec_id to make\nsure exit_notify() sees the right ->xxx_exec_id's when the CLONE_PARENT'ed\ntask exits.\n\nAlso, move down the \"p->parent_exec_id = p->self_exec_id\" thing, to place\ntwo different cases together.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nCc: Roland McGrath <roland@redhat.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: David Howells <dhowells@redhat.com>\nCc: Serge E. Hallyn <serge@hallyn.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 826}
{"func": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[node->outputs->data[index]];\n  } else {\n    return context->GetTensor(context, node->outputs->data[index]);\n  }\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tensorflow", "commit_id": "46d5b0852528ddfd614ded79bccc75589f801bd9", "hash": 143110351990498990270543960252685382912, "size": 8, "message": "[tflite] Test for `kTfLiteOptionalTensor` in `GetInput`.\n\n`GetInput`, `GetVariableInput` and `GetOutput` all fail to check for the case where `node->inputs->data[index]` is the special `kTfLiteOptionalTensor` value (-1) which then causes `context->tensors[node->inputs->data[index]]` to read from invalid memory location.\n\nThis fix makes `GetInput` and related return `nullptr` in those cases, asking the caller to check for `nullptr`. This is better than having `GetOptionalInputTensor` and `GetOptionalOutputTensor` (does not exist but could be added) as using the patched `GetInput` in error would be caught by a sanitizer test in the default optimized build (due to the `-fsanitize=null` option).\n\nPiperOrigin-RevId: 332512190\nChange-Id: Iabca54da2f2de02b6ece3c38b54f76d4277d689e", "idx": 827}
{"func": "new_label(codegen_scope *s)\n{\n  return s->lastlabel = s->pc;\n}", "target": 0, "cwe": ["CWE-415", "CWE-122"], "project": "mruby", "commit_id": "38b164ace7d6ae1c367883a3d67d7f559783faad", "hash": 38663038145576406059834154401663679945, "size": 4, "message": "codegen.c: fix a bug in `gen_values()`.\n\n- Fix limit handling that fails 15 arguments method calls.\n- Fix too early argument packing in arrays.", "idx": 828}
{"func": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1, "cwe": ["CWE-190"], "project": "linux", "commit_id": "9f645bcc566a1e9f921bdae7528a01ced5bc3713", "hash": 283168282956283656488004222139006184380, "size": 37, "message": "video: uvesafb: Fix integer overflow in allocation\n\ncmap->len can get close to INT_MAX/2, allowing for an integer overflow in\nallocation. This uses kmalloc_array() instead to catch the condition.\n\nReported-by: Dr Silvio Cesare of InfoSect <silvio.cesare@gmail.com>\nFixes: 8bdb3a2d7df48 (\"uvesafb: the driver core\")\nCc: stable@vger.kernel.org\nSigned-off-by: Kees Cook <keescook@chromium.org>", "idx": 829}
{"func": "  virtual ~Item()\n  {\n#ifdef EXTRA_DEBUG\n    name=0;\n#endif\n  }\t\t/*lint -e1509 */", "target": 0, "cwe": [], "project": "mysql-server", "commit_id": "f7316aa0c9a3909fc7498e7b95d5d3af044a7e21", "hash": 205063770641376192630912533277837773260, "size": 6, "message": "Bug#26361149  MYSQL SERVER CRASHES AT: COL IN(IFNULL(CONST,\n                       COL), NAME_CONST('NAME', NULL))\n\nBackport of Bug#19143243 fix.\n\nNAME_CONST item can return NULL_ITEM type in case of incorrect arguments.\nNULL_ITEM has special processing in Item_func_in function.\nIn Item_func_in::fix_length_and_dec an array of possible comparators is\ncreated. Since NAME_CONST function has NULL_ITEM type, corresponding\narray element is empty. Then NAME_CONST is wrapped to ITEM_CACHE.\nITEM_CACHE can not return proper type(NULL_ITEM) in Item_func_in::val_int(),\nso the NULL_ITEM is attempted compared with an empty comparator.\nThe fix is to disable the caching of Item_name_const item.", "idx": 830}
{"func": "MOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char huff_magic[5];\n    mobi_buffer_getstring(huff_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) {\n        debug_print(\"HUFF wrong magic: %s\\n\", huff_magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t data1_offset = mobi_buffer_get32(buf);\n    const size_t data2_offset = mobi_buffer_get32(buf);\n    /* skip little-endian table offsets */\n    mobi_buffer_setpos(buf, data1_offset);\n    if (buf->offset + (256 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data1 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 256 indices from data1 big-endian */\n    for (int i = 0; i < 256; i++) {\n        huffcdic->table1[i] = mobi_buffer_get32(buf);\n    }\n    mobi_buffer_setpos(buf, data2_offset);\n    if (buf->offset + (64 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data2 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 32 mincode-maxcode pairs from data2 big-endian */\n    huffcdic->mincode_table[0] = 0;\n    huffcdic->maxcode_table[0] = 0xFFFFFFFF;\n    for (int i = 1; i < 33; i++) {\n        const uint32_t mincode = mobi_buffer_get32(buf);\n        const uint32_t maxcode = mobi_buffer_get32(buf);\n        huffcdic->mincode_table[i] =  mincode << (32 - i);\n        huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}", "target": 1, "cwe": ["CWE-119", "CWE-125"], "project": "libmobi", "commit_id": "bec783e6212439a335ba6e8df7ab8ed610ca9a21", "hash": 78221779804000493651075537666198314351, "size": 45, "message": "Fix potential out-of-buffer read while parsing corrupt file, closes #35, #36", "idx": 831}
{"func": "frame_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t/* don't make it negative */\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t/* Handle all the frames in the column. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else /* frp->fr_layout == FR_ROW */\n    {\n\t/* Only need to handle the last frame in the row. */\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}", "target": 0, "cwe": ["CWE-416"], "project": "vim", "commit_id": "ec66c41d84e574baf8009dbc0bd088d2bc5b2421", "hash": 337657875298336112809340421549815280291, "size": 29, "message": "patch 8.1.2136: using freed memory with autocmd from fuzzer\n\nProblem:    using freed memory with autocmd from fuzzer. (Dhiraj Mishra,\n            Dominique Pelle)\nSolution:   Avoid using \"wp\" after autocommands. (closes #5041)", "idx": 832}
{"func": "ns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n\tregister u_int i, l;\n\tregister const u_char *rp = NULL;\n\tregister int compress = 0;\n\tint chars_processed;\n\tint elt;\n\tint data_size = ndo->ndo_snapend - bp;\n\n\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\treturn(NULL);\n\tif (!ND_TTEST2(*cp, 1))\n\t\treturn(NULL);\n\tchars_processed = 1;\n\tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n\t\tcompress = 0;\n\t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n\t\t\t\t}\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n\t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\t\treturn(NULL);\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\ti = *cp++;\n\t\t\t\tchars_processed++;\n\n\t\t\t\t/*\n\t\t\t\t * If we've looked at every character in\n\t\t\t\t * the message, this pointer will make\n\t\t\t\t * us look at some character again,\n\t\t\t\t * which means we're looping.\n\t\t\t\t */\n\t\t\t\tif (chars_processed >= data_size) {\n\t\t\t\t\tND_PRINT((ndo, \"<LOOP>\"));\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \"<ELT %d>\", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n\t\t\t}\n\n\t\t\tcp += l;\n\t\t\tchars_processed += l;\n\t\t\tND_PRINT((ndo, \".\"));\n\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\treturn(NULL);\n\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\treturn(NULL);\n\t\t\ti = *cp++;\n\t\t\tchars_processed++;\n\t\t\tif (!compress)\n\t\t\t\trp += l + 1;\n\t\t}\n\telse\n\t\tND_PRINT((ndo, \".\"));\n\treturn (rp);\n}", "target": 1, "cwe": ["CWE-399", "CWE-835"], "project": "tcpdump", "commit_id": "3a76fd7c95fced2c2f8c8148a9055c3a542eff29", "hash": 128281638820492277906995516701829193173, "size": 82, "message": "CVE-2017-12995/Check for DNS compression pointers that don't point backwards.\n\nThis is what BIND 9.11.0-P2 does; it not only detects pointers that\nloop, as \"point backwards\" means \"point before anything we've processed\nso far, including what we're processing right now\", so the pointer can't\npoint to itself (as that's what we're processing right now).\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levomäki.\n\nAdd a test using the capture file supplied by the reporter(s).\n\nAlso, add some infinite-pointer-loop captures.\n\nMore checks should be done.  We might, for example, want to make sure\nthe upper 2 bits of the label length/pointer byte are 00 or 11, and that\nif we encounter a pointer and jump backwards to what we think is a label\nthe label ends before the beginning of the last label we processed, to\nmake sure the pointer doesn't point backwards into the *middle* of a\nlabel, and also make sure the entire name is <= 255 bytes long.", "idx": 833}
{"func": "static void pn533_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct pn533_usb_phy *phy = usb_get_intfdata(interface);\n\n\tif (!phy)\n\t\treturn;\n\n\tpn533_unregister_device(phy->priv);\n\n\tusb_set_intfdata(interface, NULL);\n\n\tusb_kill_urb(phy->in_urb);\n\tusb_kill_urb(phy->out_urb);\n\tusb_kill_urb(phy->ack_urb);\n\n\tkfree(phy->in_urb->transfer_buffer);\n\tusb_free_urb(phy->in_urb);\n\tusb_free_urb(phy->out_urb);\n\tusb_free_urb(phy->ack_urb);\n\tkfree(phy->ack_buffer);\n\n\tnfc_info(&interface->dev, \"NXP PN533 NFC device disconnected\\n\");\n}", "target": 0, "cwe": ["CWE-416"], "project": "linux", "commit_id": "6af3aa57a0984e061f61308fe181a9a12359fecc", "hash": 127371535784034634497901444505410611350, "size": 23, "message": "NFC: pn533: fix use-after-free and memleaks\n\nThe driver would fail to deregister and its class device and free\nrelated resources on late probe errors.\n\nReported-by: syzbot+cb035c75c03dbe34b796@syzkaller.appspotmail.com\nFixes: 32ecc75ded72 (\"NFC: pn533: change order operations in dev registation\")\nSigned-off-by: Johan Hovold <johan@kernel.org>\nSigned-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>", "idx": 834}
{"func": "static void ms_adpcm_reset2 (_AFmoduleinst *i)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) i->modspec;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\td->track->fpos_next_frame = d->track->fpos_first_frame +\n\t\td->blockAlign * (d->track->nextfframe / framesPerBlock);\n\td->track->frames2ignore += d->framesToIgnore;\n\n\tassert(d->track->nextfframe % framesPerBlock == 0);\n}", "target": 1, "cwe": ["CWE-119"], "project": "audiofile", "commit_id": "e8cf0095b3f319739f9aa1ab5a1aa52b76be8cdd", "hash": 196070143317425089954031771905435022288, "size": 13, "message": "Fix decoding of multi-channel ADPCM audio files.", "idx": 835}
{"func": "    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Error with file handle size\");\n        res  = err;\n        type = WOLFSSH_FTP_FAILURE;\n        ret  = WS_BAD_FILE_E;\n    }", "target": 1, "cwe": ["CWE-190"], "project": "wolfssh", "commit_id": "edb272e35ee57e7b89f3e127222c6981b6a1e730", "hash": 24451018161307447304094827796965968484, "size": 6, "message": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)", "idx": 836}
{"func": "static int openssl_x509v3_subjectAltName(BIO *bio, X509_EXTENSION *extension)\n{\n\tGENERAL_NAMES *names;\n\tconst X509V3_EXT_METHOD *method = NULL;\n\tASN1_OCTET_STRING *extension_data;\n\tlong i, length, num;\n\tconst unsigned char *p;\n\n\tmethod = X509V3_EXT_get(extension);\n\tif (method == NULL) {\n\t\treturn -1;\n\t}\n\n\textension_data = X509_EXTENSION_get_data(extension);\n\tp = extension_data->data;\n\tlength = extension_data->length;\n\tif (method->it) {\n\t\tnames = (GENERAL_NAMES*) (ASN1_item_d2i(NULL, &p, length,\n\t\t\tASN1_ITEM_ptr(method->it)));\n\t} else {\n\t\tnames = (GENERAL_NAMES*) (method->d2i(NULL, &p, length));\n\t}\n\tif (names == NULL) {\n\t\tphp_openssl_store_errors();\n\t\treturn -1;\n\t}\n\n\tnum = sk_GENERAL_NAME_num(names);\n\tfor (i = 0; i < num; i++) {\n\t\tGENERAL_NAME *name;\n\t\tASN1_STRING *as;\n\t\tname = sk_GENERAL_NAME_value(names, i);\n\t\tswitch (name->type) {\n\t\t\tcase GEN_EMAIL:\n\t\t\t\tBIO_puts(bio, \"email:\");\n\t\t\t\tas = name->d.rfc822Name;\n\t\t\t\tBIO_write(bio, ASN1_STRING_get0_data(as),\n\t\t\t\t\tASN1_STRING_length(as));\n\t\t\t\tbreak;\n\t\t\tcase GEN_DNS:\n\t\t\t\tBIO_puts(bio, \"DNS:\");\n\t\t\t\tas = name->d.dNSName;\n\t\t\t\tBIO_write(bio, ASN1_STRING_get0_data(as),\n\t\t\t\t\tASN1_STRING_length(as));\n\t\t\t\tbreak;\n\t\t\tcase GEN_URI:\n\t\t\t\tBIO_puts(bio, \"URI:\");\n\t\t\t\tas = name->d.uniformResourceIdentifier;\n\t\t\t\tBIO_write(bio, ASN1_STRING_get0_data(as),\n\t\t\t\t\tASN1_STRING_length(as));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* use builtin print for GEN_OTHERNAME, GEN_X400,\n\t\t\t\t * GEN_EDIPARTY, GEN_DIRNAME, GEN_IPADD and GEN_RID\n\t\t\t\t */\n\t\t\t\tGENERAL_NAME_print(bio, name);\n\t\t\t}\n\t\t\t/* trailing ', ' except for last element */\n\t\t\tif (i < (num - 1)) {\n\t\t\t\tBIO_puts(bio, \", \");\n\t\t\t}\n\t}\n\tsk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);\n\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-326"], "project": "php-src", "commit_id": "0216630ea2815a5789a24279a1211ac398d4de79", "hash": 149545759224273965654753694004378196559, "size": 66, "message": "Fix bug #79601 (Wrong ciphertext/tag in AES-CCM encryption for a 12 bytes IV)", "idx": 837}
{"func": "static int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t   struct frag_hdr *fhdr, int nhoff)\n{\n\tstruct sk_buff *prev, *next;\n\tstruct net_device *dev;\n\tint offset, end;\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto err;\n\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((u8 *)&fhdr->frag_off -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t/* Is this the final fragment? */\n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t/* If we already have some bits beyond end\n\t\t * or have different end, the segment is corrupted.\n\t\t */\n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len))\n\t\t\tgoto err;\n\t\tfq->q.last_in |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t/* Check if the fragment is rounded to 8 bytes.\n\t\t * Required by the RFC.\n\t\t */\n\t\tif (end & 0x7) {\n\t\t\t/* RFC2460 says always send parameter problem in\n\t\t\t * this case. -DaveM\n\t\t\t */\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t\t  offsetof(struct ipv6hdr, payload_len));\n\t\t\treturn -1;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t/* Some bits beyond end -> corruption. */\n\t\t\tif (fq->q.last_in & INET_FRAG_LAST_IN)\n\t\t\t\tgoto err;\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto err;\n\n\t/* Point into the IP datagram 'data' part. */\n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data))\n\t\tgoto err;\n\n\tif (pskb_trim_rcsum(skb, end - offset))\n\t\tgoto err;\n\n\t/* Find out which fragments are in front and at the back of us\n\t * in the chain of fragments so far.  We must know where to put\n\t * this fragment, right?\n\t */\n\tprev = fq->q.fragments_tail;\n\tif (!prev || FRAG6_CB(prev)->offset < offset) {\n\t\tnext = NULL;\n\t\tgoto found;\n\t}\n\tprev = NULL;\n\tfor(next = fq->q.fragments; next != NULL; next = next->next) {\n\t\tif (FRAG6_CB(next)->offset >= offset)\n\t\t\tbreak;\t/* bingo! */\n\t\tprev = next;\n\t}\n\nfound:\n\t/* RFC5722, Section 4:\n\t *                                  When reassembling an IPv6 datagram, if\n\t *   one or more its constituent fragments is determined to be an\n\t *   overlapping fragment, the entire datagram (and any constituent\n\t *   fragments, including those not yet received) MUST be silently\n\t *   discarded.\n\t */\n\n\t/* Check for overlap with preceding fragment. */\n\tif (prev &&\n\t    (FRAG6_CB(prev)->offset + prev->len) - offset > 0)\n\t\tgoto discard_fq;\n\n\t/* Look for overlap with succeeding segment. */\n\tif (next && FRAG6_CB(next)->offset < end)\n\t\tgoto discard_fq;\n\n\tFRAG6_CB(skb)->offset = offset;\n\n\t/* Insert this fragment in the chain of fragments. */\n\tskb->next = next;\n\tif (!next)\n\t\tfq->q.fragments_tail = skb;\n\tif (prev)\n\t\tprev->next = skb;\n\telse\n\t\tfq->q.fragments = skb;\n\n\tdev = skb->dev;\n\tif (dev) {\n\t\tfq->iif = dev->ifindex;\n\t\tskb->dev = NULL;\n\t}\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.meat += skb->len;\n\tatomic_add(skb->truesize, &fq->q.net->mem);\n\n\t/* The first fragment.\n\t * nhoffset is obtained from the first fragment, of course.\n\t */\n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.last_in |= INET_FRAG_FIRST_IN;\n\t}\n\n\tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len)\n\t\treturn ip6_frag_reasm(fq, prev, dev);\n\n\twrite_lock(&ip6_frags.lock);\n\tlist_move_tail(&fq->q.lru_list, &fq->q.net->lru_list);\n\twrite_unlock(&ip6_frags.lock);\n\treturn -1;\n\ndiscard_fq:\n\tfq_kill(fq);\nerr:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -1;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "f46421416fb6b91513fb687d6503142cd99034a5", "hash": 193018681226064971629299650436620004069, "size": 152, "message": "ipv6: fix overlap check for fragments\n\nThe type of FRAG6_CB(prev)->offset is int, skb->len is *unsigned* int,\nand offset is int.\n\nWithout this patch, type conversion occurred to this expression, when\n(FRAG6_CB(prev)->offset + prev->len) is less than offset.\n\nSigned-off-by: Shan Wei <shanwei@cn.fujitsu.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 838}
{"func": "folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        length +=\n            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n        buf.trimStart(length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n\n    cursor.clone(msg.fragment, length);\n\n    buf.trimStart(cursor - buf.front());\n\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n\n    return std::move(msg);\n  }\n}", "target": 1, "cwe": ["CWE-119", "CWE-835", "CWE-787"], "project": "fizz", "commit_id": "40bbb161e72fb609608d53b9d64c56bb961a6ee2", "hash": 296696634526629714191751503090238822202, "size": 73, "message": "Avoid arithmetic operation on uint16 read from the wire.\n\nSummary:\nThis could overflow previously.\n\nCVE-2019-3560\n\nReviewed By: yfeldblum\n\nDifferential Revision: D14152362\n\nfbshipit-source-id: c0ebb3fc59b49c7c23e6bcb90458c19cd891be65", "idx": 839}
{"func": "static int bpf_lwt_xmit_reroute(struct sk_buff *skb)\n{\n\tstruct net_device *l3mdev = l3mdev_master_dev_rcu(skb_dst(skb)->dev);\n\tint oif = l3mdev ? l3mdev->ifindex : 0;\n\tstruct dst_entry *dst = NULL;\n\tint err = -EAFNOSUPPORT;\n\tstruct sock *sk;\n\tstruct net *net;\n\tbool ipv4;\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tipv4 = true;\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\tipv4 = false;\n\telse\n\t\tgoto err;\n\n\tsk = sk_to_full_sk(skb->sk);\n\tif (sk) {\n\t\tif (sk->sk_bound_dev_if)\n\t\t\toif = sk->sk_bound_dev_if;\n\t\tnet = sock_net(sk);\n\t} else {\n\t\tnet = dev_net(skb_dst(skb)->dev);\n\t}\n\n\tif (ipv4) {\n\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\tstruct flowi4 fl4 = {};\n\t\tstruct rtable *rt;\n\n\t\tfl4.flowi4_oif = oif;\n\t\tfl4.flowi4_mark = skb->mark;\n\t\tfl4.flowi4_uid = sock_net_uid(net, sk);\n\t\tfl4.flowi4_tos = RT_TOS(iph->tos);\n\t\tfl4.flowi4_flags = FLOWI_FLAG_ANYSRC;\n\t\tfl4.flowi4_proto = iph->protocol;\n\t\tfl4.daddr = iph->daddr;\n\t\tfl4.saddr = iph->saddr;\n\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\tgoto err;\n\t\t}\n\t\tdst = &rt->dst;\n\t} else {\n\t\tstruct ipv6hdr *iph6 = ipv6_hdr(skb);\n\t\tstruct flowi6 fl6 = {};\n\n\t\tfl6.flowi6_oif = oif;\n\t\tfl6.flowi6_mark = skb->mark;\n\t\tfl6.flowi6_uid = sock_net_uid(net, sk);\n\t\tfl6.flowlabel = ip6_flowinfo(iph6);\n\t\tfl6.flowi6_proto = iph6->nexthdr;\n\t\tfl6.daddr = iph6->daddr;\n\t\tfl6.saddr = iph6->saddr;\n\n\t\terr = ipv6_stub->ipv6_dst_lookup(net, skb->sk, &dst, &fl6);\n\t\tif (unlikely(err))\n\t\t\tgoto err;\n\t\tif (IS_ERR(dst)) {\n\t\t\terr = PTR_ERR(dst);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (unlikely(dst->error)) {\n\t\terr = dst->error;\n\t\tdst_release(dst);\n\t\tgoto err;\n\t}\n\n\t/* Although skb header was reserved in bpf_lwt_push_ip_encap(), it\n\t * was done for the previous dst, so we are doing it here again, in\n\t * case the new dst needs much more space. The call below is a noop\n\t * if there is enough header space in skb.\n\t */\n\terr = skb_cow_head(skb, LL_RESERVED_SPACE(dst->dev));\n\tif (unlikely(err))\n\t\tgoto err;\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst);\n\n\terr = dst_output(dev_net(skb_dst(skb)->dev), skb->sk, skb);\n\tif (unlikely(err))\n\t\treturn err;\n\n\t/* ip[6]_finish_output2 understand LWTUNNEL_XMIT_DONE */\n\treturn LWTUNNEL_XMIT_DONE;\n\nerr:\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 1, "cwe": [], "project": "net", "commit_id": "6c8991f41546c3c472503dff1ea9daaddf9331c2", "hash": 206957895986931408290927052143256027472, "size": 95, "message": "net: ipv6_stub: use ip6_dst_lookup_flow instead of ip6_dst_lookup\n\nipv6_stub uses the ip6_dst_lookup function to allow other modules to\nperform IPv6 lookups. However, this function skips the XFRM layer\nentirely.\n\nAll users of ipv6_stub->ip6_dst_lookup use ip_route_output_flow (via the\nip_route_output_key and ip_route_output helpers) for their IPv4 lookups,\nwhich calls xfrm_lookup_route(). This patch fixes this inconsistent\nbehavior by switching the stub to ip6_dst_lookup_flow, which also calls\nxfrm_lookup_route().\n\nThis requires some changes in all the callers, as these two functions\ntake different arguments and have different return types.\n\nFixes: 5f81bd2e5d80 (\"ipv6: export a stub for IPv6 symbols used by vxlan\")\nReported-by: Xiumei Mu <xmu@redhat.com>\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 840}
{"func": "struct sock *sk_alloc(struct net *net, int family, gfp_t priority,\n\t\t      struct proto *prot, int kern)\n{\n\tstruct sock *sk;\n\n\tsk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);\n\tif (sk) {\n\t\tsk->sk_family = family;\n\t\t/*\n\t\t * See comment in struct sock definition to understand\n\t\t * why we need sk_prot_creator -acme\n\t\t */\n\t\tsk->sk_prot = sk->sk_prot_creator = prot;\n\t\tsk->sk_kern_sock = kern;\n\t\tsock_lock_init(sk);\n\t\tsk->sk_net_refcnt = kern ? 0 : 1;\n\t\tif (likely(sk->sk_net_refcnt))\n\t\t\tget_net(net);\n\t\tsock_net_set(sk, net);\n\t\trefcount_set(&sk->sk_wmem_alloc, 1);\n\n\t\tmem_cgroup_sk_alloc(sk);\n\t\tcgroup_sk_alloc(&sk->sk_cgrp_data);\n\t\tsock_update_classid(&sk->sk_cgrp_data);\n\t\tsock_update_netprioidx(&sk->sk_cgrp_data);\n\t}\n\n\treturn sk;\n}", "target": 0, "cwe": ["CWE-704"], "project": "linux", "commit_id": "9d538fa60bad4f7b23193c89e843797a1cf71ef3", "hash": 179289633281825724701963309140529503657, "size": 29, "message": "net: Set sk_prot_creator when cloning sockets to the right proto\n\nsk->sk_prot and sk->sk_prot_creator can differ when the app uses\nIPV6_ADDRFORM (transforming an IPv6-socket to an IPv4-one).\nWhich is why sk_prot_creator is there to make sure that sk_prot_free()\ndoes the kmem_cache_free() on the right kmem_cache slab.\n\nNow, if such a socket gets transformed back to a listening socket (using\nconnect() with AF_UNSPEC) we will allocate an IPv4 tcp_sock through\nsk_clone_lock() when a new connection comes in. But sk_prot_creator will\nstill point to the IPv6 kmem_cache (as everything got copied in\nsk_clone_lock()). When freeing, we will thus put this\nmemory back into the IPv6 kmem_cache although it was allocated in the\nIPv4 cache. I have seen memory corruption happening because of this.\n\nWith slub-debugging and MEMCG_KMEM enabled this gives the warning\n\t\"cache_from_obj: Wrong slab cache. TCPv6 but object is from TCP\"\n\nA C-program to trigger this:\n\nvoid main(void)\n{\n        int fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);\n        int new_fd, newest_fd, client_fd;\n        struct sockaddr_in6 bind_addr;\n        struct sockaddr_in bind_addr4, client_addr1, client_addr2;\n        struct sockaddr unsp;\n        int val;\n\n        memset(&bind_addr, 0, sizeof(bind_addr));\n        bind_addr.sin6_family = AF_INET6;\n        bind_addr.sin6_port = ntohs(42424);\n\n        memset(&client_addr1, 0, sizeof(client_addr1));\n        client_addr1.sin_family = AF_INET;\n        client_addr1.sin_port = ntohs(42424);\n        client_addr1.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n        memset(&client_addr2, 0, sizeof(client_addr2));\n        client_addr2.sin_family = AF_INET;\n        client_addr2.sin_port = ntohs(42421);\n        client_addr2.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n        memset(&unsp, 0, sizeof(unsp));\n        unsp.sa_family = AF_UNSPEC;\n\n        bind(fd, (struct sockaddr *)&bind_addr, sizeof(bind_addr));\n\n        listen(fd, 5);\n\n        client_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n        connect(client_fd, (struct sockaddr *)&client_addr1, sizeof(client_addr1));\n        new_fd = accept(fd, NULL, NULL);\n        close(fd);\n\n        val = AF_INET;\n        setsockopt(new_fd, SOL_IPV6, IPV6_ADDRFORM, &val, sizeof(val));\n\n        connect(new_fd, &unsp, sizeof(unsp));\n\n        memset(&bind_addr4, 0, sizeof(bind_addr4));\n        bind_addr4.sin_family = AF_INET;\n        bind_addr4.sin_port = ntohs(42421);\n        bind(new_fd, (struct sockaddr *)&bind_addr4, sizeof(bind_addr4));\n\n        listen(new_fd, 5);\n\n        client_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n        connect(client_fd, (struct sockaddr *)&client_addr2, sizeof(client_addr2));\n\n        newest_fd = accept(new_fd, NULL, NULL);\n        close(new_fd);\n\n        close(client_fd);\n        close(new_fd);\n}\n\nAs far as I can see, this bug has been there since the beginning of the\ngit-days.\n\nSigned-off-by: Christoph Paasch <cpaasch@apple.com>\nReviewed-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 841}
{"func": "static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tint err;\n\tenum nl80211_iftype otype, ntype;\n\tstruct net_device *dev = info->user_ptr[1];\n\tbool change = false;\n\n\tmemset(&params, 0, sizeof(params));\n\n\totype = ntype = dev->ieee80211_ptr->iftype;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\tntype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (otype != ntype)\n\t\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tif (ntype != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn -EINVAL;\n\t\tif (netif_running(dev))\n\t\t\treturn -EBUSY;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\tchange = true;\n\t\terr = nl80211_valid_4addr(rdev, dev, params.use_4addr, ntype);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tparams.use_4addr = -1;\n\t}\n\n\terr = nl80211_parse_mon_options(rdev, ntype, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchange = true;\n\n\tif (change)\n\t\terr = cfg80211_change_iface(rdev, dev, ntype, &params);\n\telse\n\t\terr = 0;\n\n\tif (!err && params.use_4addr != -1)\n\t\tdev->ieee80211_ptr->use_4addr = params.use_4addr;\n\n\tif (change && !err) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_SET_INTERFACE);\n\t}\n\n\treturn err;\n}", "target": 0, "cwe": ["CWE-120"], "project": "linux", "commit_id": "f88eb7c0d002a67ef31aeb7850b42ff69abc46dc", "hash": 100467886740994853572888285251212905206, "size": 69, "message": "nl80211: validate beacon head\n\nWe currently don't validate the beacon head, i.e. the header,\nfixed part and elements that are to go in front of the TIM\nelement. This means that the variable elements there can be\nmalformed, e.g. have a length exceeding the buffer size, but\nmost downstream code from this assumes that this has already\nbeen checked.\n\nAdd the necessary checks to the netlink policy.\n\nCc: stable@vger.kernel.org\nFixes: ed1b6cc7f80f (\"cfg80211/nl80211: add beacon settings\")\nLink: https://lore.kernel.org/r/1569009255-I7ac7fbe9436e9d8733439eab8acbbd35e55c74ef@changeid\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>", "idx": 842}
{"func": "static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *args = NULL;\n\tphp_com_dotnet_object *obj = (php_com_dotnet_object*)object;\n\tint nargs;\n\tVARIANT v;\n\tint ret = FAILURE;\n\n\tif (V_VT(&obj->v) != VT_DISPATCH) {\n\t\treturn FAILURE;\n\t}\n\n\tnargs = ZEND_NUM_ARGS();\n\n\tif (nargs) {\n\t\targs = (zval *)safe_emalloc(sizeof(zval), nargs, 0);\n\t\tzend_get_parameters_array_ex(nargs, args);\n\t}\n\n\tVariantInit(&v);\n\n\tif (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {\n\t\tphp_com_zval_from_variant(return_value, &v, obj->code_page);\n\t\tret = SUCCESS;\n\t\tVariantClear(&v);\n\t}\n\n\tif (args) {\n\t\tefree(args);\n\t}\n\n\treturn ret;\n}", "target": 0, "cwe": ["CWE-502"], "project": "php-src", "commit_id": "115ee49b0be12e3df7d2c7027609fbe1a1297e42", "hash": 271138041635011619129923928374385514563, "size": 33, "message": "Fix #77177: Serializing or unserializing COM objects crashes\n\nFirstly, we avoid returning NULL from the get_property handler, but\ninstead return an empty HashTable, which already prevents the crashes.\nSecondly, since (de-)serialization obviously makes no sense for COM,\nDOTNET and VARIANT objects (at least with the current implementation),\nwe prohibit it right away.", "idx": 843}
{"func": "SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n\n  if (self.db_ == nullptr) {\n    // Create primary SQLite DB instance.\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n\n  // Internal usage may request the primary connection explicitly.\n  if (primary) {\n    return self.connection_;\n  }\n\n  // Create a 'database connection' for the managed database instance.\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n  return instance;\n}", "target": 1, "cwe": ["CWE-77", "CWE-295"], "project": "osquery", "commit_id": "c3f9a3dae22d43ed3b4f6a403cbf89da4cba7c3c", "hash": 9874972728394263060637734066669656325, "size": 23, "message": "Merge pull request from GHSA-4g56-2482-x7q8\n\n* Proposed fix for attach tables vulnerability\n\n* Add authorizer to ATC tables and cleanups\n\n- Add unit test for authorizer function", "idx": 844}
{"func": "void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger offset = fxArgToByteLength(the, 0, 0);\n\ttxInteger size;\n\tint endian = EndianBig;\n\ttxSlot* value;\n\tif (mxArgc > 1)\n\t\tmxPushSlot(mxArgv(1));\n\telse\n\t\tmxPushUndefined();\n\tvalue = the->stack;\t\n\t(*coercer)(the, value);\n\tif ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))\n\t\tendian = EndianLittle;\n\tsize = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);\n\tif ((size < delta) || ((size - delta) < offset))\n\t\tmxRangeError(\"out of range byteOffset\");\n\toffset += view->value.dataView.offset;\n\t(*setter)(the, buffer->value.reference->next, offset, value, endian);\n\tmxPop();\n}", "target": 0, "cwe": ["CWE-125"], "project": "moddable", "commit_id": "135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45", "hash": 70384960058388198429723668708184045462, "size": 24, "message": "XS: #896", "idx": 845}
{"func": "static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)\n{\n\tunsigned long rlim_cur;\n\tunsigned long irqs;\n\tint ret;\n\n\tmutex_lock(&proc->files_lock);\n\tif (proc->files == NULL) {\n\t\tret = -ESRCH;\n\t\tgoto err;\n\t}\n\tif (!lock_task_sighand(proc->tsk, &irqs)) {\n\t\tret = -EMFILE;\n\t\tgoto err;\n\t}\n\trlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);\n\tunlock_task_sighand(proc->tsk, &irqs);\n\n\tret = __alloc_fd(proc->files, 0, rlim_cur, flags);\nerr:\n\tmutex_unlock(&proc->files_lock);\n\treturn ret;\n}", "target": 0, "cwe": ["CWE-362"], "project": "linux", "commit_id": "5eeb2ca02a2f6084fc57ae5c244a38baab07033a", "hash": 68252241989377557312624318770084683750, "size": 23, "message": "ANDROID: binder: synchronize_rcu() when using POLLFREE.\n\nTo prevent races with ep_remove_waitqueue() removing the\nwaitqueue at the same time.\n\nReported-by: syzbot+a2a3c4909716e271487e@syzkaller.appspotmail.com\nSigned-off-by: Martijn Coenen <maco@android.com>\nCc: stable <stable@vger.kernel.org> # 4.14+\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 846}
{"func": "static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)\n{\n\tunsigned exp_len = task->hdr_len + len;\n\n\tif (exp_len > task->hdr_max) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(len & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */\n\ttask->hdr_len = exp_len;\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-787"], "project": "linux", "commit_id": "ec98ea7070e94cc25a422ec97d1421e28d97b7ee", "hash": 198045562678544695911291024152526799320, "size": 13, "message": "scsi: iscsi: Ensure sysfs attributes are limited to PAGE_SIZE\n\nAs the iSCSI parameters are exported back through sysfs, it should be\nenforcing that they never are more than PAGE_SIZE (which should be more\nthan enough) before accepting updates through netlink.\n\nChange all iSCSI sysfs attributes to use sysfs_emit().\n\nCc: stable@vger.kernel.org\nReported-by: Adam Nichols <adam@grimm-co.com>\nReviewed-by: Lee Duncan <lduncan@suse.com>\nReviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nReviewed-by: Mike Christie <michael.christie@oracle.com>\nSigned-off-by: Chris Leech <cleech@redhat.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>", "idx": 847}
{"func": "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon) {\n\tconst char *quotestr = \"`\";\n\tconst char *tick = NULL;\n\tchar *ptr, *ptr2, *str;\n\tchar *arroba = NULL;\n\tint i, ret = 0, pipefd;\n\tbool usemyblock = false;\n\tint scr_html = -1;\n\tint scr_color = -1;\n\tbool eos = false;\n\tbool haveQuote = false;\n\n\tif (!cmd) {\n\t\treturn 0;\n\t}\n\tcmd = r_str_trim_head_tail (cmd);\n\n\t/* quoted / raw command */\n\tswitch (*cmd) {\n\tcase '.':\n\t\tif (cmd[1] == '\"') { /* interpret */\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t\tbreak;\n\tcase '\"':\n\t\tfor (; *cmd; ) {\n\t\t\tint pipefd = -1;\n\t\t\tut64 oseek = UT64_MAX;\n\t\t\tchar *line, *p;\n\t\t\thaveQuote = *cmd == '\"';\n\t\t\tif (haveQuote) {\n\t\t\t//\t*cmd = 0;\n\t\t\t\tcmd++;\n\t\t\t\tp = find_eoq (cmd + 1);\n\t\t\t\tif (!p || !*p) {\n\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*p++ = 0;\n\t\t\t\tif (!*p) {\n\t\t\t\t\teos = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchar *sc = strchr (cmd, ';');\n\t\t\t\tif (sc) {\n\t\t\t\t\t*sc = 0;\n\t\t\t\t}\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\tif (!sc) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmd = sc + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[0]) {\n\t\t\t\t// workaround :D\n\t\t\t\tif (p[0] == '@') {\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q = 0;\n\t\t\t\t\t}\n\t\t\t\t\thaveQuote = q != NULL;\n\t\t\t\t\toseek = core->offset;\n\t\t\t\t\tr_core_seek (core,\n\t\t\t\t\t\t     r_num_math (core->num, p + 2), 1);\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tp = q;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = strchr (p + 1, ';');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p && *p && p[1] == '>') {\n\t\t\t\t\tstr = p + 2;\n\t\t\t\t\twhile (*str == '>') {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_flush ();\n\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, p[2] == '>');\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = strdup (cmd);\n\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n\t\t\tif (p && *p && p[1] == '|') {\n\t\t\t\tstr = p + 2;\n\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n\t\t\t} else {\n\t\t\t\tr_cmd_call (core->rcmd, line);\n\t\t\t}\n\t\t\tfree (line);\n\t\t\tif (oseek != UT64_MAX) {\n\t\t\t\tr_core_seek (core, oseek, 1);\n\t\t\t\toseek = UT64_MAX;\n\t\t\t}\n\t\t\tif (pipefd != -1) {\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (eos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (haveQuote) {\n\t\t\t\tif (*p == ';') {\n\t\t\t\t\tcmd = p + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (*p == '\"') {\n\t\t\t\t\t\tcmd = p + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tcmd = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcmd = p + 1;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase '(':\n\t\tif (cmd[1] != '*') {\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t}\n\n// TODO must honor \" and `\n\t/* comments */\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, '#', quotestr);\n\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n\t\t\t*ptr = '\\0';\n\t\t}\n\t}\n\n\t/* multiple commands */\n\t// TODO: must honor \" and ` boundaries\n\t//ptr = strrchr (cmd, ';');\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n\t\tif (colon && ptr) {\n\t\t\tint ret ;\n\t\t\t*ptr = '\\0';\n\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcmd = ptr + 1;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t*ptr = ';';\n\t\t\treturn ret;\n\t\t\t//r_cons_flush ();\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* pipe console to shell process */\n\t//ptr = strchr (cmd, '|');\n\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n\tif (ptr) {\n\t\tchar *ptr2 = strchr (cmd, '`');\n\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n\t\t\tif (!tick || (tick && tick > ptr)) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tcmd = r_str_clean (cmd);\n\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n\t\t\t\t\t// TODO: should be disable scr.color in pd| ?\n\t\t\t\t\teprintf (\"Usage: <r2command> | <program|H|>\\n\");\n\t\t\t\t\teprintf (\" pd|?   - show this help\\n\");\n\t\t\t\t\teprintf (\" pd|    - disable scr.html and scr.color\\n\");\n\t\t\t\t\teprintf (\" pd|H   - enable scr.html, respect scr.color\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t} else if (!strcmp (ptr + 1, \"H\")) { // \"|H\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n\t\t\t\t\tint value = core->num->value;\n\t\t\t\t\tif (*cmd) {\n\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_io_system (core->io, ptr + 1);\n\t\t\t\t\t}\n\t\t\t\t\tcore->num->value = value;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else { // \"|\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* bool conditions */\n\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n\t//ptr = strchr (cmd, '&');\n\twhile (ptr && ptr[1] == '&') {\n\t\t*ptr = '\\0';\n\t\tret = r_cmd_call (core->rcmd, cmd);\n\t\tif (ret == -1) {\n\t\t\teprintf (\"command error(%s)\\n\", cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++);\n\t\tptr = strchr (cmd, '&');\n\t}\n\n\t/* Out Of Band Input */\n\tfree (core->oobi);\n\tcore->oobi = NULL;\n\n\tptr = strstr (cmd, \"?*\");\n\tif (ptr) {\n\t\tchar *prech = ptr - 1;\n\t\tif (*prech != '~') {\n\t\t\tptr[1] = 0;\n\t\t\tif (*cmd != '#' && strlen (cmd) < 5) {\n\t\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\t\trecursive_help (core, cmd);\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n\t\t\t\tif (scr_html != -1) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tptr = strchr (cmd, '<');\n\tif (ptr) {\n\t\tptr[0] = '\\0';\n\t\tif (r_cons_singleton()->is_interactive) {\n\t\t\tif (ptr[1] == '<') {\n\t\t\t\t/* this is a bit mess */\n\t\t\t\t//const char *oprompt = strdup (r_line_singleton ()->prompt);\n\t\t\t\t//oprompt = \">\";\n\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = malloc (1);\n\t\t\t\tif (core->oobi) {\n\t\t\t\t\tcore->oobi[0] = '\\0';\n\t\t\t\t}\n\t\t\t\tcore->oobi_len = 0;\n\t\t\t\tfor (;;) {\n\t\t\t\t\tchar buf[1024];\n\t\t\t\t\tint ret;\n\t\t\t\t\twrite (1, \"> \", 2);\n\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n\t\t\t\t\tif (feof (stdin)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n\t\t\t\t\tret = strlen (buf);\n\t\t\t\t\tcore->oobi_len += ret;\n\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n\t\t\t\t\tif (core->oobi) {\n\t\t\t\t\t\tif (!strcmp (buf, str)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//r_line_set_prompt (oprompt);\n\t\t\t} else {\n\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\tif (!*str) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n\t\t\t\tif (!core->oobi) {\n\t\t\t\t\teprintf (\"cannot open file\\n\");\n\t\t\t\t} else if (ptr == cmd) {\n\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot slurp with << in non-interactive mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\nnext:\n#endif\n\t// TODO must honor \" and `\n\t/* pipe console to file */\n\tptr = strchr (cmd, '>');\n\tif (ptr) {\n\t\tint fdn = 1;\n\t\tint pipecolor = r_config_get_i (core->config, \"scr.pipecolor\");\n\t\tint use_editor = false;\n\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n\t\t*ptr = '\\0';\n\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n\t\tif (!*str) {\n\t\t\teprintf (\"No output?\\n\");\n\t\t\tgoto next2;\n\t\t}\n\t\t/* r_cons_flush() handles interactive output (to the terminal)\n\t\t * differently (e.g. asking about too long output). This conflicts\n\t\t * with piping to a file. Disable it while piping. */\n\t\tif (ptr > (cmd + 1) && ISWHITECHAR (ptr[-2])) {\n\t\t\tchar *fdnum = ptr - 1;\n\t\t\tif (*fdnum == 'H') { // \"H>\"\n\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\tpipecolor = true;\n\t\t\t\t*fdnum = 0;\n\t\t\t} else {\n\t\t\t\tif (IS_DIGIT(*fdnum)) {\n\t\t\t\t\tfdn = *fdnum - '0';\n\t\t\t\t}\n\t\t\t\t*fdnum = 0;\n\t\t\t}\n\t\t}\n\t\tr_cons_set_interactive (false);\n\t\tif (!strcmp (str, \"-\")) {\n\t\t\tuse_editor = true;\n\t\t\tstr = r_file_temp (\"dumpedit\");\n\t\t\tr_config_set (core->config, \"scr.color\", \"false\");\n\t\t}\n\t\tif (fdn > 0) {\n\t\t\tpipefd = r_cons_pipe_open (str, fdn, ptr[1] == '>');\n\t\t\tif (pipefd != -1) {\n\t\t\t\tif (!pipecolor) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n\t\t\t\t}\n\t\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t}\n\t\tr_cons_set_last_interactive ();\n\t\tif (!pipecolor) {\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t}\n\t\tif (use_editor) {\n\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n\t\t\tif (editor && *editor) {\n\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n\t\t\t\tr_file_rm (str);\n\t\t\t} else {\n\t\t\t\teprintf (\"No cfg.editor configured\\n\");\n\t\t\t}\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t\tfree (str);\n\t\t}\n\t\tif (scr_html != -1) {\n\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\treturn ret;\n\t}\nnext2:\n\t/* sub commands */\n\tptr = strchr (cmd, '`');\n\tif (ptr) {\n\t\tint empty = 0;\n\t\tint oneline = 1;\n\t\tif (ptr[1] == '`') {\n\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n\t\t\toneline = 0;\n\t\t\tempty = 1;\n\t\t}\n\t\tptr2 = strchr (ptr + 1, '`');\n\t\tif (empty) {\n\t\t\t/* do nothing */\n\t\t} else if (!ptr2) {\n\t\t\teprintf (\"parse: Missing backtick in expression.\\n\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tint value = core->num->value;\n\t\t\t*ptr = '\\0';\n\t\t\t*ptr2 = '\\0';\n\t\t\tif (ptr[1] == '!') {\n\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n\t\t\t} else {\n\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n\t\t\t}\n\t\t\tif (!str) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t// ignore contents if first char is pipe or comment\n\t\t\tif (*str == '|' || *str == '*') {\n\t\t\t\teprintf (\"r_core_cmd_subst_i: invalid backticked command\\n\");\n\t\t\t\tfree (str);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (oneline && str) {\n\t\t\t\tfor (i = 0; str[i]; i++) {\n\t\t\t\t\tif (str[i] == '\\n') {\n\t\t\t\t\t\tstr[i] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr = r_str_append (str, ptr2 + 1);\n\t\t\tcmd = r_str_append (strdup (cmd), str);\n\t\t\tcore->num->value = value;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\tfree (cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tfree (str);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t// TODO must honor \" and `\n\tcore->fixedblock = false;\n\n\tif (r_str_endswith (cmd, \"~?\") && cmd[2] == '\\0') {\n\t\tr_cons_grep_help ();\n\t\treturn true;\n\t}\n\tif (*cmd != '.') {\n\t\tr_cons_grep_parsecmd (cmd, quotestr);\n\t}\n\n\t/* temporary seek commands */\n\tif (*cmd!= '(' && *cmd != '\"') {\n\t\tptr = strchr (cmd, '@');\n\t\tif (ptr == cmd + 1 && *cmd == '?') {\n\t\t\tptr = NULL;\n\t\t}\n\t} else {\n\t\tptr = NULL;\n\t}\n\n\tcore->tmpseek = ptr? true: false;\n\tint rc = 0;\n\tif (ptr) {\n\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n\t\tut64 addr = UT64_MAX;\n\t\tconst char *tmpbits = NULL;\n\t\tconst char *offstr = NULL;\n\t\tut64 tmpbsz = core->blocksize;\n\t\tchar *tmpeval = NULL;\n\t\tut64 tmpoff = core->offset;\n\t\tchar *tmpasm = NULL;\n\t\tint tmpfd = -1;\n\t\tint sz, len;\n\t\tut8 *buf;\n\n\t\t*ptr = '\\0';\n\t\tfor (ptr++; *ptr == ' '; ptr++) {\n\t\t\t//nothing to see here\n\t\t}\n\t\tif (*ptr && ptr[1] == ':') {\n\t\t\t/* do nothing here */\n\t\t} else {\n\t\t\tptr--;\n\t\t}\n\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n\t\t\tstrchr (ptr + 2, '@'): NULL;\nrepeat_arroba:\n\t\tif (arroba) {\n\t\t\t*arroba = 0;\n\t\t}\n\t\tif (ptr[1] == '?') {\n\t\t\thelpCmdAt (core);\n\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n\t\t\tusemyblock = true;\n\t\t\tswitch (ptr[0]) {\n\t\t\tcase 'f': // \"@f:\" // slurp file in block\n\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n\t\t\t\tif (f) {\n\t\t\t\t\tbuf = malloc (sz);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tfree (core->block);\n\t\t\t\t\t\tcore->block = buf;\n\t\t\t\t\t\tcore->blocksize = sz;\n\t\t\t\t\t\tmemcpy (core->block, f, sz);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n\t\t\t\t\t}\n\t\t\t\t\tfree (f);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'r': // \"@r:\" // regname\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tut64 regval;\n\t\t\t\t\tchar *mander = strdup (ptr + 2);\n\t\t\t\t\tchar *sep = findSeparator (mander);\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tchar ch = *sep;\n\t\t\t\t\t\t*sep = 0;\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n\t\t\t\t\t\t*sep = ch;\n\t\t\t\t\t\tchar *numexpr = r_str_newf (\"0x%\"PFMT64x\"%s\", regval, sep);\n\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n\t\t\t\t\t\tfree (numexpr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t\tr_core_seek (core, regval, 1);\n\t\t\t\t\tfree (mander);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b': // \"@b:\" // bits\n\t\t\t\ttmpbits = strdup (r_config_get (core->config, \"asm.bits\"));\n\t\t\t\tr_config_set_i (core->config, \"asm.bits\",\n\t\t\t\t\tr_num_math (core->num, ptr + 2));\n\t\t\t\tbreak;\n\t\t\tcase 'i': // \"@i:\"\n\t\t\t\t{\n\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n\t\t\t\t\tif (addr) {\n\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'e': // \"@e:\"\n\t\t\t\ttmpeval = parse_tmp_evals (core, ptr + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'x': // \"@x:\" // hexpairs\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n\t\t\t\t\t\tr_core_block_size (core, R_ABS(len));\n\t\t\t\t\t\tmemcpy (core->block, buf, core->blocksize);\n\t\t\t\t\t\tcore->fixedblock = true;\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot allocate\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Invalid @x: syntax\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k': // \"@k\"\n\t\t\t\t {\n\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n\t\t\t\t\tif (out) {\n\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n\t\t\t\t\t\tfree (out);\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\tbreak;\n\t\t\tcase 'o': // \"@o:3\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\ttmpfd = core->io->raised;\n\t\t\t\t\tr_io_raise (core->io, atoi (ptr + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a': // \"@a:\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n\t\t\t\t\ttmpasm = strdup (r_config_get (core->config, \"asm.arch\"));\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q++ = 0;\n\t\t\t\t\t\ttmpbits = r_config_get (core->config, \"asm.bits\");\n\t\t\t\t\t\tr_config_set (core->config, \"asm.bits\", q);\n\t\t\t\t\t}\n\t\t\t\t\tr_config_set (core->config, \"asm.arch\", ptr + 2);\n\t\t\t\t\t// TODO: handle asm.bits\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Usage: pd 10 @a:arm:32\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"@s:\"\n\t\t\t\tlen = strlen (ptr + 2);\n\t\t\t\tr_core_block_size (core, len);\n\t\t\t\tmemcpy (core->block, ptr + 2, len);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\t*ptr = '@';\n\t\t\tgoto next_arroba; //ignore; //return ret;\n\t\t}\nignore:\n\t\tptr = r_str_trim_head (ptr + 1);\n\t\tptr--;\n\n\t\tcmd = r_str_clean (cmd);\n\t\tif (ptr2) {\n\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t    !memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t    !memcmp (ptr2 + 1, \"0x\", 2)) {\n\t\t\t\t/* 0xXXXX:0xYYYY */\n\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n\t\t\t\t/* XXXX:YYYY */\n\t\t\t} else {\n\t\t\t\t*ptr2 = '\\0';\n\t\t\t\tif (!ptr2[1]) {\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n\t\t\t}\n\t\t}\n\n\t\toffstr = r_str_trim_head (ptr + 1);\n\n\t\taddr = r_num_math (core->num, offstr);\n\t\tif (isalpha ((unsigned char)ptr[1]) && !addr) {\n\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tchar ch = *offstr;\n\t\t\tif (ch == '-' || ch == '+') {\n\t\t\t\taddr = core->offset + addr;\n\t\t\t}\n\t\t}\nnext_arroba:\n\t\tif (arroba) {\n\t\t\tptr = arroba;\n\t\t\tarroba = NULL;\n\t\t\tgoto repeat_arroba;\n\t\t}\n\t\tif (ptr[1] == '@') {\n\t\t\t// TODO: remove temporally seek (should be done by cmd_foreach)\n\t\t\tif (ptr[2] == '@') {\n\t\t\t\tchar *rule = ptr + 3;\n\t\t\t\twhile (*rule && *rule == ' ') rule++;\n\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n\t\t\t} else {\n\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n\t\t\t}\n\t\t\t//ret = -1; /* do not run out-of-foreach cmd */\n\t\t} else {\n\t\t\tbool tmpseek = false;\n\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n\t\t\t\t\"io.buffer.from\", \"lines.from\", \"search.from\", \"zoom.from\", NULL };\n\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n\t\t\t\t\"io.buffer.to\", \"lines.to\", \"search.to\", \"zoom.to\", NULL };\n\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n\n\t\t\t// @..\n\t\t\tif (ptr[1] == '.' && ptr[2] == '.') {\n\t\t\t\tchar *range = ptr + 3;\n\t\t\t\tchar *p = strchr (range, ' ');\n\t\t\t\tif (!p) {\n\t\t\t\t\teprintf (\"Usage: / ABCD @..0x1000 0x3000\\n\");\n\t\t\t\t\tfree (tmpeval);\n\t\t\t\t\tfree (tmpasm);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\t*p = '\\x00';\n\t\t\t\tut64 from = r_num_math (core->num, range);\n\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n\t\t\t\t// save current ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n\t\t\t\t}\n\t\t\t\t// set new ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n\t\t\t\t}\n\t\t\t\ttmpseek = true;\n\t\t\t}\n\t\t\tif (usemyblock) {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tcore->offset = addr;\n\t\t\t\t}\n\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t} else {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tif (!ptr[1] || r_core_seek (core, addr, 1)) {\n\t\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmpseek) {\n\t\t\t\t// restore ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ptr2) {\n\t\t\t*ptr2 = '!';\n\t\t\tr_core_block_size (core, tmpbsz);\n\t\t}\n\t\tif (tmpasm) {\n\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n\t\t\ttmpasm = NULL;\n\t\t}\n\t\tif (tmpfd != -1) {\n\t\t\tr_io_raise (core->io, tmpfd);\n\t\t}\n\t\tif (tmpbits) {\n\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n\t\t\ttmpbits = NULL;\n\t\t}\n\t\tif (tmpeval) {\n\t\t\tr_core_cmd0 (core, tmpeval);\n\t\t\tR_FREE (tmpeval);\n\t\t}\n\t\tr_core_seek (core, tmpoff, 1);\n\t\t*ptr = '@';\n\t\trc = ret;\n\t\tgoto beach;\n\t}\n\n\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\nbeach:\n\tif (scr_html != -1) {\n\t\tr_cons_flush ();\n\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t}\n\tif (scr_color != -1) {\n\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t}\n\tcore->fixedblock = false;\n\treturn rc;\nfail:\n\trc = -1;\n\tgoto beach;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "radare2", "commit_id": "00e8f205475332d7842d0f0d1481eeab4e83017c", "hash": 28499214244404139143496963232716797342, "size": 758, "message": "Fix #7727 - undefined pointers and out of band string access fixes", "idx": 848}
{"func": "const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {\n  // We must check if the 'cached_route_' optional is populated since this function can be called\n  // early via sendLocalReply(), before the cached route is populated.\n  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {\n    return &cached_route_.value()->routeEntry()->upgradeMap();\n  }\n\n  return nullptr;\n}", "target": 0, "cwe": ["CWE-22"], "project": "envoy", "commit_id": "5333b928d8bcffa26ab19bf018369a835f697585", "hash": 68026166552481494874085306412998807827, "size": 9, "message": "Implement handling of escaped slash characters in URL path\n\nFixes: CVE-2021-29492\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>", "idx": 849}
{"func": "vhost_user_set_log_base(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tint fd = msg->fds[0];\n\tuint64_t size, off;\n\tvoid *addr;\n\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\n\tif (fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR, \"invalid log fd: %d\\n\", fd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tif (msg->size != sizeof(VhostUserLog)) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid log base msg size: %\"PRId32\" != %d\\n\",\n\t\t\tmsg->size, (int)sizeof(VhostUserLog));\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tsize = msg->payload.log.mmap_size;\n\toff  = msg->payload.log.mmap_offset;\n\n\t/* Don't allow mmap_offset to point outside the mmap region */\n\tif (off > size) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"log offset %#\"PRIx64\" exceeds log size %#\"PRIx64\"\\n\",\n\t\t\toff, size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"log mmap size: %\"PRId64\", offset: %\"PRId64\"\\n\",\n\t\tsize, off);\n\n\t/*\n\t * mmap from 0 to workaround a hugepage mmap bug: mmap will\n\t * fail when offset is not page size aligned.\n\t */\n\taddr = mmap(0, size + off, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\tclose(fd);\n\tif (addr == MAP_FAILED) {\n\t\tVHOST_LOG_CONFIG(ERR, \"mmap log base failed!\\n\");\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\t/*\n\t * Free previously mapped log memory on occasionally\n\t * multiple VHOST_USER_SET_LOG_BASE.\n\t */\n\tif (dev->log_addr) {\n\t\tmunmap((void *)(uintptr_t)dev->log_addr, dev->log_size);\n\t}\n\tdev->log_addr = (uint64_t)(uintptr_t)addr;\n\tdev->log_base = dev->log_addr + off;\n\tdev->log_size = size;\n\n\t/*\n\t * The spec is not clear about it (yet), but QEMU doesn't expect\n\t * any payload in the reply.\n\t */\n\tmsg->size = 0;\n\tmsg->fd_num = 0;\n\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}", "target": 1, "cwe": ["CWE-190"], "project": "dpdk", "commit_id": "3ae4beb079ce242240c34376a066bbccd0c0b23e", "hash": 106014452904276012088093646655801009962, "size": 69, "message": "vhost: check log mmap offset and size overflow\n\nvhost_user_set_log_base() is a message handler that is\ncalled to handle the VHOST_USER_SET_LOG_BASE message.\nIts payload contains a 64 bit size and offset. Both are\nadded up and used as a size when calling mmap().\n\nThere is no integer overflow check. If an integer overflow\noccurs a smaller memory map would be created than\nrequested. Since the returned mapping is mapped as writable\nand used for logging, a memory corruption could occur.\n\nCVE-2020-10722\nFixes: fbc4d248b198 (\"vhost: fix offset while mmaping log base address\")\nCc: stable@dpdk.org\n\nReported-by: Ilja Van Sprundel <ivansprundel@ioactive.com>\nSigned-off-by: Maxime Coquelin <maxime.coquelin@redhat.com>\nReviewed-by: Xiaolong Ye <xiaolong.ye@intel.com>\nReviewed-by: Ilja Van Sprundel <ivansprundel@ioactive.com>", "idx": 850}
{"func": "DLLEXPORT unsigned long tjBufSize(int width, int height, int jpegSubsamp)\n{\n  unsigned long long retval = 0;\n  int mcuw, mcuh, chromasf;\n\n  if (width < 1 || height < 1 || jpegSubsamp < 0 || jpegSubsamp >= NUMSUBOPT)\n    THROWG(\"tjBufSize(): Invalid argument\");\n\n  /* This allows for rare corner cases in which a JPEG image can actually be\n     larger than the uncompressed input (we wouldn't mention it if it hadn't\n     happened before.) */\n  mcuw = tjMCUWidth[jpegSubsamp];\n  mcuh = tjMCUHeight[jpegSubsamp];\n  chromasf = jpegSubsamp == TJSAMP_GRAY ? 0 : 4 * 64 / (mcuw * mcuh);\n  retval = PAD(width, mcuw) * PAD(height, mcuh) * (2ULL + chromasf) + 2048ULL;\n  if (retval > (unsigned long long)((unsigned long)-1))\n    THROWG(\"tjBufSize(): Image is too large\");\n\nbailout:\n  return (unsigned long)retval;\n}", "target": 0, "cwe": ["CWE-787"], "project": "libjpeg-turbo", "commit_id": "2a9e3bd7430cfda1bc812d139e0609c6aca0b884", "hash": 8627395393505069898907274310075089825, "size": 21, "message": "TurboJPEG: Properly handle gigapixel images\n\nPrevent several integer overflow issues and subsequent segfaults that\noccurred when attempting to compress or decompress gigapixel images with\nthe TurboJPEG API:\n\n- Modify tjBufSize(), tjBufSizeYUV2(), and tjPlaneSizeYUV() to avoid\n  integer overflow when computing the return values and to return an\n  error if such an overflow is unavoidable.\n- Modify tjunittest to validate the above.\n- Modify tjCompress2(), tjEncodeYUVPlanes(), tjDecompress2(), and\n  tjDecodeYUVPlanes() to avoid integer overflow when computing the row\n  pointers in the 64-bit TurboJPEG C API.\n- Modify TJBench (both C and Java versions) to avoid overflowing the\n  size argument to malloc()/new and to fail gracefully if such an\n  overflow is unavoidable.\n\nIn general, this allows gigapixel images to be accommodated by the\n64-bit TurboJPEG C API when using automatic JPEG buffer (re)allocation.\nSuch images cannot currently be accommodated without automatic JPEG\nbuffer (re)allocation, due to the fact that tjAlloc() accepts a 32-bit\ninteger argument (oops.)  Such images cannot be accommodated in the\nTurboJPEG Java API due to the fact that Java always uses a signed 32-bit\ninteger as an array index.\n\nFixes #361", "idx": 851}
{"func": "const char *mnt_fs_get_user_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->user_optstr : NULL;\n}", "target": 0, "cwe": ["CWE-552", "CWE-703"], "project": "util-linux", "commit_id": "166e87368ae88bf31112a30e078cceae637f4cdb", "hash": 247012632492334304544697652996283813198, "size": 4, "message": "libmount: remove support for deleted mount table entries\n\nThe \"(deleted)\" suffix has been originally used by kernel for deleted\nmountpoints. Since kernel commit 9d4d65748a5ca26ea8650e50ba521295549bf4e3\n(Dec 2014) kernel does not use this suffix for mount stuff in /proc at\nall. Let's remove this support from libmount too.\n\nSigned-off-by: Karel Zak <kzak@redhat.com>", "idx": 852}
{"func": "onig_set_callout_data_by_callout_args_self(OnigCalloutArgs* args,\n                                           int slot, OnigType type, OnigValue* val)\n{\n  return onig_set_callout_data(args->regex, args->msa->mp, args->num, slot,\n                               type, val);\n}", "target": 0, "cwe": ["CWE-125"], "project": "oniguruma", "commit_id": "d3e402928b6eb3327f8f7d59a9edfa622fec557b", "hash": 83149748804063403195999736095040987450, "size": 6, "message": "fix heap-buffer-overflow", "idx": 853}
{"func": "bool con_is_visible(const struct vc_data *vc)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\treturn *vc->vc_display_fg == vc;\n}", "target": 0, "cwe": ["CWE-125"], "project": "linux", "commit_id": "3c4e0dff2095c579b142d5a0693257f1c58b4804", "hash": 62908184939264637692440132649457157283, "size": 6, "message": "vt: Disable KD_FONT_OP_COPY\n\nIt's buggy:\n\nOn Fri, Nov 06, 2020 at 10:30:08PM +0800, Minh Yuan wrote:\n> We recently discovered a slab-out-of-bounds read in fbcon in the latest\n> kernel ( v5.10-rc2 for now ).  The root cause of this vulnerability is that\n> \"fbcon_do_set_font\" did not handle \"vc->vc_font.data\" and\n> \"vc->vc_font.height\" correctly, and the patch\n> <https://lkml.org/lkml/2020/9/27/223> for VT_RESIZEX can't handle this\n> issue.\n>\n> Specifically, we use KD_FONT_OP_SET to set a small font.data for tty6, and\n> use  KD_FONT_OP_SET again to set a large font.height for tty1. After that,\n> we use KD_FONT_OP_COPY to assign tty6's vc_font.data to tty1's vc_font.data\n> in \"fbcon_do_set_font\", while tty1 retains the original larger\n> height. Obviously, this will cause an out-of-bounds read, because we can\n> access a smaller vc_font.data with a larger vc_font.height.\n\nFurther there was only one user ever.\n- Android's loadfont, busybox and console-tools only ever use OP_GET\n  and OP_SET\n- fbset documentation only mentions the kernel cmdline font: option,\n  not anything else.\n- systemd used OP_COPY before release 232 published in Nov 2016\n\nNow unfortunately the crucial report seems to have gone down with\ngmane, and the commit message doesn't say much. But the pull request\nhints at OP_COPY being broken\n\nhttps://github.com/systemd/systemd/pull/3651\n\nSo in other words, this never worked, and the only project which\nfoolishly every tried to use it, realized that rather quickly too.\n\nInstead of trying to fix security issues here on dead code by adding\nmissing checks, fix the entire thing by removing the functionality.\n\nNote that systemd code using the OP_COPY function ignored the return\nvalue, so it doesn't matter what we're doing here really - just in\ncase a lone server somewhere happens to be extremely unlucky and\nrunning an affected old version of systemd. The relevant code from\nfont_copy_to_all_vcs() in systemd was:\n\n\t/* copy font from active VT, where the font was uploaded to */\n\tcfo.op = KD_FONT_OP_COPY;\n\tcfo.height = vcs.v_active-1; /* tty1 == index 0 */\n\t(void) ioctl(vcfd, KDFONTOP, &cfo);\n\nNote this just disables the ioctl, garbage collecting the now unused\ncallbacks is left for -next.\n\nv2: Tetsuo found the old mail, which allowed me to find it on another\narchive. Add the link too.\n\nAcked-by: Peilin Ye <yepeilin.cs@gmail.com>\nReported-by: Minh Yuan <yuanmingbuaa@gmail.com>\nReferences: https://lists.freedesktop.org/archives/systemd-devel/2016-June/036935.html\nReferences: https://github.com/systemd/systemd/pull/3651\nCc: Greg KH <greg@kroah.com>\nCc: Peilin Ye <yepeilin.cs@gmail.com>\nCc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>\nSigned-off-by: Daniel Vetter <daniel.vetter@intel.com>\nLink: https://lore.kernel.org/r/20201108153806.3140315-1-daniel.vetter@ffwll.ch\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 854}
{"func": "wav_open\t(SF_PRIVATE *psf)\n{\tWAVLIKE_PRIVATE * wpriv ;\n\tint\tformat, subformat, error, blockalign = 0, framesperblock = 0 ;\n\n\tif ((wpriv = calloc (1, sizeof (WAVLIKE_PRIVATE))) == NULL)\n\t\treturn SFE_MALLOC_FAILED ;\n\tpsf->container_data = wpriv ;\n\n\twpriv->wavex_ambisonic = SF_AMBISONIC_NONE ;\n\tpsf->strings.flags = SF_STR_ALLOW_START | SF_STR_ALLOW_END ;\n\n\tif (psf->file.mode == SFM_READ || (psf->file.mode == SFM_RDWR && psf->filelength > 0))\n\t{\tif ((error = wav_read_header (psf, &blockalign, &framesperblock)))\n\t\t\treturn error ;\n\n\t\tpsf->next_chunk_iterator = wav_next_chunk_iterator ;\n\t\tpsf->get_chunk_size = wav_get_chunk_size ;\n\t\tpsf->get_chunk_data = wav_get_chunk_data ;\n\t\t} ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t{\tif (psf->is_pipe)\n\t\t\treturn SFE_NO_PIPE_WRITE ;\n\n\t\twpriv->wavex_ambisonic = SF_AMBISONIC_NONE ;\n\n\t\tformat = SF_CONTAINER (psf->sf.format) ;\n\t\tif (format != SF_FORMAT_WAV && format != SF_FORMAT_WAVEX)\n\t\t\treturn\tSFE_BAD_OPEN_FORMAT ;\n\n\t\tpsf->blockwidth = psf->bytewidth * psf->sf.channels ;\n\n\t\t/* RIFF WAVs are little-endian, RIFX WAVs are big-endian, default to little */\n\t\tpsf->endian = SF_ENDIAN (psf->sf.format) ;\n\t\tif (CPU_IS_BIG_ENDIAN && psf->endian == SF_ENDIAN_CPU)\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\telse if (psf->endian != SF_ENDIAN_BIG)\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\n\t\tif (psf->file.mode != SFM_RDWR || psf->filelength < 44)\n\t\t{\tpsf->filelength = 0 ;\n\t\t\tpsf->datalength = 0 ;\n\t\t\tpsf->dataoffset = 0 ;\n\t\t\tpsf->sf.frames = 0 ;\n\t\t\t} ;\n\n\t\tif (subformat == SF_FORMAT_IMA_ADPCM || subformat == SF_FORMAT_MS_ADPCM)\n\t\t{\tblockalign = wavlike_srate2blocksize (psf->sf.samplerate * psf->sf.channels) ;\n\t\t\tframesperblock = -1 ; /* Corrected later. */\n\t\t\t} ;\n\n\t\t/* By default, add the peak chunk to floating point files. Default behaviour\n\t\t** can be switched off using sf_command (SFC_SET_PEAK_CHUNK, SF_FALSE).\n\t\t*/\n\t\tif (psf->file.mode == SFM_WRITE && (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE))\n\t\t{\tif ((psf->peak_info = peak_info_calloc (psf->sf.channels)) == NULL)\n\t\t\t\treturn SFE_MALLOC_FAILED ;\n\t\t\tpsf->peak_info->peak_loc = SF_PEAK_START ;\n\t\t\t} ;\n\n\t\tpsf->write_header\t= wav_write_header ;\n\t\tpsf->set_chunk\t\t= wav_set_chunk ;\n\t\t} ;\n\n\tpsf->container_close = wav_close ;\n\tpsf->command = wav_command ;\n\n\tswitch (subformat)\n\t{\tcase SF_FORMAT_PCM_U8 :\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_PCM_24 :\n\t\tcase SF_FORMAT_PCM_32 :\n\t\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ULAW :\n\t\t\t\t\terror = ulaw_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ALAW :\n\t\t\t\t\terror = alaw_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\t\terror = float32_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\t\terror = double64_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IMA_ADPCM :\n\t\t\t\t\terror = wavlike_ima_init (psf, blockalign, framesperblock) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MS_ADPCM :\n\t\t\t\t\terror = wavlike_msadpcm_init (psf, blockalign, framesperblock) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_G721_32 :\n\t\t\t\t\terror = g72x_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_NMS_ADPCM_16 :\n\t\tcase SF_FORMAT_NMS_ADPCM_24 :\n\t\tcase SF_FORMAT_NMS_ADPCM_32 :\n\t\t\t\t\terror = nms_adpcm_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\t/* Lite remove end */\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\t\t\terror = gsm610_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tdefault : \treturn SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE || (psf->file.mode == SFM_RDWR && psf->filelength == 0))\n\t\treturn psf->write_header (psf, SF_FALSE) ;\n\n\treturn error ;\n} /* wav_open */", "target": 0, "cwe": ["CWE-476"], "project": "libsndfile", "commit_id": "6f3266277bed16525f0ac2f0f03ff4626f1923e5", "hash": 255410201298750704485249182554359441197, "size": 126, "message": "Fix max channel count bug\n\nThe code was allowing files to be written with a channel count of exactly\n`SF_MAX_CHANNELS` but was failing to read some file formats with the same\nchannel count.", "idx": 855}
{"func": "BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\n{\n    int i, j;\n    BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;\n    X509_ALGOR *xa;\n    ASN1_OCTET_STRING *data_body = NULL;\n    const EVP_MD *evp_md;\n    const EVP_CIPHER *evp_cipher = NULL;\n    EVP_CIPHER_CTX *evp_ctx = NULL;\n    X509_ALGOR *enc_alg = NULL;\n    STACK_OF(X509_ALGOR) *md_sk = NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\n    PKCS7_RECIP_INFO *ri = NULL;\n    unsigned char *ek = NULL, *tkey = NULL;\n    int eklen = 0, tkeylen = 0;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_NULL_POINTER);\n        return NULL;\n    }\n\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        }\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n            }\n\n            j = OBJ_obj2nid(xa->algorithm);\n            evp_md = EVP_get_digestbynid(j);\n            if (evp_md == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_UNKNOWN_DIGEST_TYPE);\n                goto err;\n            }\n\n            BIO_set_md(btmp, evp_md);\n            if (out == NULL)\n                out = btmp;\n            else\n                BIO_push(out, btmp);\n            btmp = NULL;\n        }\n    }\n\n    if (evp_cipher != NULL) {\n        if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n            goto err;\n        }\n\n        /*\n         * It was encrypted, we need to decrypt the secret key with the\n         * private key\n         */\n\n        /*\n         * Find the recipientInfo which matches the passed certificate (if\n         * any)\n         */\n\n        if (pcert) {\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n                if (!pkcs7_cmp_ri(ri, pcert))\n                    break;\n                ri = NULL;\n            }\n            if (ri == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\n                goto err;\n            }\n        }\n\n        /* If we haven't got a certificate try each ri in turn */\n        if (pcert == NULL) {\n            /*\n             * Always attempt to decrypt all rinfo even after success as a\n             * defence against MMA timing attacks.\n             */\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n\n                if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\n                    goto err;\n                ERR_clear_error();\n            }\n        } else {\n            /* Only exit on fatal errors, not decrypt failure */\n            if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\n                goto err;\n            ERR_clear_error();\n        }\n\n        evp_ctx = NULL;\n        BIO_get_cipher_ctx(etmp, &evp_ctx);\n        if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0)\n            goto err;\n        if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0)\n            goto err;\n        /* Generate random key as MMA defence */\n        tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);\n        tkey = OPENSSL_malloc(tkeylen);\n        if (!tkey)\n            goto err;\n        if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)\n            goto err;\n        if (ek == NULL) {\n            ek = tkey;\n            eklen = tkeylen;\n            tkey = NULL;\n        }\n\n        if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) {\n            /*\n             * Some S/MIME clients don't use the same key and effective key\n             * length. The key length is determined by the size of the\n             * decrypted RSA key.\n             */\n            if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen)) {\n                /* Use random key as MMA defence */\n                OPENSSL_clear_free(ek, eklen);\n                ek = tkey;\n                eklen = tkeylen;\n                tkey = NULL;\n            }\n        }\n        /* Clear errors so we don't leak information useful in MMA */\n        ERR_clear_error();\n        if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0)\n            goto err;\n\n        OPENSSL_clear_free(ek, eklen);\n        ek = NULL;\n        OPENSSL_clear_free(tkey, tkeylen);\n        tkey = NULL;\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (PKCS7_is_detached(p7) || (in_bio != NULL)) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;\n    }\n    BIO_push(out, bio);\n    bio = NULL;\n    return out;\n\n err:\n    OPENSSL_clear_free(ek, eklen);\n    OPENSSL_clear_free(tkey, tkeylen);\n    BIO_free_all(out);\n    BIO_free_all(btmp);\n    BIO_free_all(etmp);\n    BIO_free_all(bio);\n    return  NULL;\n}", "target": 1, "cwe": ["CWE-703"], "project": "openssl", "commit_id": "59302b600e8d5b77ef144e447bb046fd7ab72686", "hash": 56579458144976803996822874564842207302, "size": 217, "message": "PKCS#7: Fix NULL dereference with missing EncryptedContent.\n\nCVE-2015-1790\n\nReviewed-by: Rich Salz <rsalz@openssl.org>", "idx": 856}
{"func": "static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_state_t state)\n{\n\tif (substream->runtime->trigger_master == substream)\n\t\tsubstream->ops->trigger(substream,\n\t\t\t\t\tpause_pushed(state) ?\n\t\t\t\t\tSNDRV_PCM_TRIGGER_PAUSE_RELEASE :\n\t\t\t\t\tSNDRV_PCM_TRIGGER_PAUSE_PUSH);\n}", "target": 0, "cwe": ["CWE-125"], "project": "linux", "commit_id": "92ee3c60ec9fe64404dc035e7c41277d74aa26cb", "hash": 277988337636379902644052797947826836118, "size": 9, "message": "ALSA: pcm: Fix races among concurrent hw_params and hw_free calls\n\nCurrently we have neither proper check nor protection against the\nconcurrent calls of PCM hw_params and hw_free ioctls, which may result\nin a UAF.  Since the existing PCM stream lock can't be used for\nprotecting the whole ioctl operations, we need a new mutex to protect\nthose racy calls.\n\nThis patch introduced a new mutex, runtime->buffer_mutex, and applies\nit to both hw_params and hw_free ioctl code paths.  Along with it, the\nboth functions are slightly modified (the mmap_count check is moved\ninto the state-check block) for code simplicity.\n\nReported-by: Hu Jiahui <kirin.say@gmail.com>\nCc: <stable@vger.kernel.org>\nReviewed-by: Jaroslav Kysela <perex@perex.cz>\nLink: https://lore.kernel.org/r/20220322170720.3529-2-tiwai@suse.de\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "idx": 857}
{"func": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    /* According to M$, the high 4 bits of a FAT32 entry are reserved and\n\t     * are not part of the cluster number. So we never touch them. */\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1, "cwe": ["CWE-703", "CWE-189"], "project": "dosfstools", "commit_id": "07908124838afcc99c577d1d3e84cef2dbd39cb7", "hash": 128456988598425097867132969989473460136, "size": 58, "message": "set_fat(): Fix off-by-2 error leading to corruption in FAT12\n\nIn FAT12 two 12 bit entries are combined to a 24 bit value (three\nbytes). Therefore, when an even numbered FAT entry is set in FAT12, it\nmust be be combined with the following entry. To prevent accessing\nbeyond the end of the FAT array, it must be checked that the cluster is\nnot the last one.\n\nPreviously, the check tested that the requested cluster was equal to\nfs->clusters - 1. However, fs->clusters is the number of data clusters\nnot including the two reserved FAT entries at the start so the test\ntriggered two clusters early.\n\nIf the third to last entry was written on a FAT12 filesystem with an\nodd number of clusters, the second to last entry would be corrupted.\nThis corruption may also lead to invalid memory accesses when the\ncorrupted entry becomes out of bounds and is used later.\n\nChange the test to fs->clusters + 1 to fix.\n\nReported-by: Hanno Böck\nSigned-off-by: Andreas Bombe <aeb@debian.org>", "idx": 858}
{"func": "static noinline int copy_to_sk(struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct btrfs_ioctl_search_key *sk,\n\t\t\t       size_t *buf_size,\n\t\t\t       char __user *ubuf,\n\t\t\t       unsigned long *sk_offset,\n\t\t\t       int *num_found)\n{\n\tu64 found_transid;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ioctl_search_header sh;\n\tstruct btrfs_key test;\n\tunsigned long item_off;\n\tunsigned long item_len;\n\tint nritems;\n\tint i;\n\tint slot;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (btrfs_header_generation(leaf) > sk->max_transid) {\n\t\ti = nritems;\n\t\tgoto advance_key;\n\t}\n\tfound_transid = btrfs_header_generation(leaf);\n\n\tfor (i = slot; i < nritems; i++) {\n\t\titem_off = btrfs_item_ptr_offset(leaf, i);\n\t\titem_len = btrfs_item_size_nr(leaf, i);\n\n\t\tbtrfs_item_key_to_cpu(leaf, key, i);\n\t\tif (!key_in_sk(key, sk))\n\t\t\tcontinue;\n\n\t\tif (sizeof(sh) + item_len > *buf_size) {\n\t\t\tif (*num_found) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * return one empty item back for v1, which does not\n\t\t\t * handle -EOVERFLOW\n\t\t\t */\n\n\t\t\t*buf_size = sizeof(sh) + item_len;\n\t\t\titem_len = 0;\n\t\t\tret = -EOVERFLOW;\n\t\t}\n\n\t\tif (sizeof(sh) + item_len + *sk_offset > *buf_size) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsh.objectid = key->objectid;\n\t\tsh.offset = key->offset;\n\t\tsh.type = key->type;\n\t\tsh.len = item_len;\n\t\tsh.transid = found_transid;\n\n\t\t/* copy search result header */\n\t\tif (copy_to_user(ubuf + *sk_offset, &sh, sizeof(sh))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*sk_offset += sizeof(sh);\n\n\t\tif (item_len) {\n\t\t\tchar __user *up = ubuf + *sk_offset;\n\t\t\t/* copy the item */\n\t\t\tif (read_extent_buffer_to_user(leaf, up,\n\t\t\t\t\t\t       item_off, item_len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*sk_offset += item_len;\n\t\t}\n\t\t(*num_found)++;\n\n\t\tif (ret) /* -EOVERFLOW from above */\n\t\t\tgoto out;\n\n\t\tif (*num_found >= sk->nr_items) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nadvance_key:\n\tret = 0;\n\ttest.objectid = sk->max_objectid;\n\ttest.type = sk->max_type;\n\ttest.offset = sk->max_offset;\n\tif (btrfs_comp_cpu_keys(key, &test) >= 0)\n\t\tret = 1;\n\telse if (key->offset < (u64)-1)\n\t\tkey->offset++;\n\telse if (key->type < (u8)-1) {\n\t\tkey->offset = 0;\n\t\tkey->type++;\n\t} else if (key->objectid < (u64)-1) {\n\t\tkey->offset = 0;\n\t\tkey->type = 0;\n\t\tkey->objectid++;\n\t} else\n\t\tret = 1;\nout:\n\t/*\n\t *  0: all items from this leaf copied, continue with next\n\t *  1: * more items can be copied, but unused buffer is too small\n\t *     * all items were found\n\t *     Either way, it will stops the loop which iterates to the next\n\t *     leaf\n\t *  -EOVERFLOW: item was to large for buffer\n\t *  -EFAULT: could not copy extent buffer back to userspace\n\t */\n\treturn ret;\n}", "target": 0, "cwe": ["CWE-200"], "project": "linux", "commit_id": "8039d87d9e473aeb740d4fdbd59b9d2f89b2ced9", "hash": 231648925003744625933591867956889016768, "size": 124, "message": "Btrfs: fix file corruption and data loss after cloning inline extents\n\nCurrently the clone ioctl allows to clone an inline extent from one file\nto another that already has other (non-inlined) extents. This is a problem\nbecause btrfs is not designed to deal with files having inline and regular\nextents, if a file has an inline extent then it must be the only extent\nin the file and must start at file offset 0. Having a file with an inline\nextent followed by regular extents results in EIO errors when doing reads\nor writes against the first 4K of the file.\n\nAlso, the clone ioctl allows one to lose data if the source file consists\nof a single inline extent, with a size of N bytes, and the destination\nfile consists of a single inline extent with a size of M bytes, where we\nhave M > N. In this case the clone operation removes the inline extent\nfrom the destination file and then copies the inline extent from the\nsource file into the destination file - we lose the M - N bytes from the\ndestination file, a read operation will get the value 0x00 for any bytes\nin the the range [N, M] (the destination inode's i_size remained as M,\nthat's why we can read past N bytes).\n\nSo fix this by not allowing such destructive operations to happen and\nreturn errno EOPNOTSUPP to user space.\n\nCurrently the fstest btrfs/035 tests the data loss case but it totally\nignores this - i.e. expects the operation to succeed and does not check\nthe we got data loss.\n\nThe following test case for fstests exercises all these cases that result\nin file corruption and data loss:\n\n  seq=`basename $0`\n  seqres=$RESULT_DIR/$seq\n  echo \"QA output created by $seq\"\n  tmp=/tmp/$$\n  status=1\t# failure is the default!\n  trap \"_cleanup; exit \\$status\" 0 1 2 3 15\n\n  _cleanup()\n  {\n      rm -f $tmp.*\n  }\n\n  # get standard environment, filters and checks\n  . ./common/rc\n  . ./common/filter\n\n  # real QA test starts here\n  _need_to_be_root\n  _supported_fs btrfs\n  _supported_os Linux\n  _require_scratch\n  _require_cloner\n  _require_btrfs_fs_feature \"no_holes\"\n  _require_btrfs_mkfs_feature \"no-holes\"\n\n  rm -f $seqres.full\n\n  test_cloning_inline_extents()\n  {\n      local mkfs_opts=$1\n      local mount_opts=$2\n\n      _scratch_mkfs $mkfs_opts >>$seqres.full 2>&1\n      _scratch_mount $mount_opts\n\n      # File bar, the source for all the following clone operations, consists\n      # of a single inline extent (50 bytes).\n      $XFS_IO_PROG -f -c \"pwrite -S 0xbb 0 50\" $SCRATCH_MNT/bar \\\n          | _filter_xfs_io\n\n      # Test cloning into a file with an extent (non-inlined) where the\n      # destination offset overlaps that extent. It should not be possible to\n      # clone the inline extent from file bar into this file.\n      $XFS_IO_PROG -f -c \"pwrite -S 0xaa 0K 16K\" $SCRATCH_MNT/foo \\\n          | _filter_xfs_io\n      $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/bar $SCRATCH_MNT/foo\n\n      # Doing IO against any range in the first 4K of the file should work.\n      # Due to a past clone ioctl bug which allowed cloning the inline extent,\n      # these operations resulted in EIO errors.\n      echo \"File foo data after clone operation:\"\n      # All bytes should have the value 0xaa (clone operation failed and did\n      # not modify our file).\n      od -t x1 $SCRATCH_MNT/foo\n      $XFS_IO_PROG -c \"pwrite -S 0xcc 0 100\" $SCRATCH_MNT/foo | _filter_xfs_io\n\n      # Test cloning the inline extent against a file which has a hole in its\n      # first 4K followed by a non-inlined extent. It should not be possible\n      # as well to clone the inline extent from file bar into this file.\n      $XFS_IO_PROG -f -c \"pwrite -S 0xdd 4K 12K\" $SCRATCH_MNT/foo2 \\\n          | _filter_xfs_io\n      $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/bar $SCRATCH_MNT/foo2\n\n      # Doing IO against any range in the first 4K of the file should work.\n      # Due to a past clone ioctl bug which allowed cloning the inline extent,\n      # these operations resulted in EIO errors.\n      echo \"File foo2 data after clone operation:\"\n      # All bytes should have the value 0x00 (clone operation failed and did\n      # not modify our file).\n      od -t x1 $SCRATCH_MNT/foo2\n      $XFS_IO_PROG -c \"pwrite -S 0xee 0 90\" $SCRATCH_MNT/foo2 | _filter_xfs_io\n\n      # Test cloning the inline extent against a file which has a size of zero\n      # but has a prealloc extent. It should not be possible as well to clone\n      # the inline extent from file bar into this file.\n      $XFS_IO_PROG -f -c \"falloc -k 0 1M\" $SCRATCH_MNT/foo3 | _filter_xfs_io\n      $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/bar $SCRATCH_MNT/foo3\n\n      # Doing IO against any range in the first 4K of the file should work.\n      # Due to a past clone ioctl bug which allowed cloning the inline extent,\n      # these operations resulted in EIO errors.\n      echo \"First 50 bytes of foo3 after clone operation:\"\n      # Should not be able to read any bytes, file has 0 bytes i_size (the\n      # clone operation failed and did not modify our file).\n      od -t x1 $SCRATCH_MNT/foo3\n      $XFS_IO_PROG -c \"pwrite -S 0xff 0 90\" $SCRATCH_MNT/foo3 | _filter_xfs_io\n\n      # Test cloning the inline extent against a file which consists of a\n      # single inline extent that has a size not greater than the size of\n      # bar's inline extent (40 < 50).\n      # It should be possible to do the extent cloning from bar to this file.\n      $XFS_IO_PROG -f -c \"pwrite -S 0x01 0 40\" $SCRATCH_MNT/foo4 \\\n          | _filter_xfs_io\n      $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/bar $SCRATCH_MNT/foo4\n\n      # Doing IO against any range in the first 4K of the file should work.\n      echo \"File foo4 data after clone operation:\"\n      # Must match file bar's content.\n      od -t x1 $SCRATCH_MNT/foo4\n      $XFS_IO_PROG -c \"pwrite -S 0x02 0 90\" $SCRATCH_MNT/foo4 | _filter_xfs_io\n\n      # Test cloning the inline extent against a file which consists of a\n      # single inline extent that has a size greater than the size of bar's\n      # inline extent (60 > 50).\n      # It should not be possible to clone the inline extent from file bar\n      # into this file.\n      $XFS_IO_PROG -f -c \"pwrite -S 0x03 0 60\" $SCRATCH_MNT/foo5 \\\n          | _filter_xfs_io\n      $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/bar $SCRATCH_MNT/foo5\n\n      # Reading the file should not fail.\n      echo \"File foo5 data after clone operation:\"\n      # Must have a size of 60 bytes, with all bytes having a value of 0x03\n      # (the clone operation failed and did not modify our file).\n      od -t x1 $SCRATCH_MNT/foo5\n\n      # Test cloning the inline extent against a file which has no extents but\n      # has a size greater than bar's inline extent (16K > 50).\n      # It should not be possible to clone the inline extent from file bar\n      # into this file.\n      $XFS_IO_PROG -f -c \"truncate 16K\" $SCRATCH_MNT/foo6 | _filter_xfs_io\n      $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/bar $SCRATCH_MNT/foo6\n\n      # Reading the file should not fail.\n      echo \"File foo6 data after clone operation:\"\n      # Must have a size of 16K, with all bytes having a value of 0x00 (the\n      # clone operation failed and did not modify our file).\n      od -t x1 $SCRATCH_MNT/foo6\n\n      # Test cloning the inline extent against a file which has no extents but\n      # has a size not greater than bar's inline extent (30 < 50).\n      # It should be possible to clone the inline extent from file bar into\n      # this file.\n      $XFS_IO_PROG -f -c \"truncate 30\" $SCRATCH_MNT/foo7 | _filter_xfs_io\n      $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/bar $SCRATCH_MNT/foo7\n\n      # Reading the file should not fail.\n      echo \"File foo7 data after clone operation:\"\n      # Must have a size of 50 bytes, with all bytes having a value of 0xbb.\n      od -t x1 $SCRATCH_MNT/foo7\n\n      # Test cloning the inline extent against a file which has a size not\n      # greater than the size of bar's inline extent (20 < 50) but has\n      # a prealloc extent that goes beyond the file's size. It should not be\n      # possible to clone the inline extent from bar into this file.\n      $XFS_IO_PROG -f -c \"falloc -k 0 1M\" \\\n                      -c \"pwrite -S 0x88 0 20\" \\\n                      $SCRATCH_MNT/foo8 | _filter_xfs_io\n      $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/bar $SCRATCH_MNT/foo8\n\n      echo \"File foo8 data after clone operation:\"\n      # Must have a size of 20 bytes, with all bytes having a value of 0x88\n      # (the clone operation did not modify our file).\n      od -t x1 $SCRATCH_MNT/foo8\n\n      _scratch_unmount\n  }\n\n  echo -e \"\\nTesting without compression and without the no-holes feature...\\n\"\n  test_cloning_inline_extents\n\n  echo -e \"\\nTesting with compression and without the no-holes feature...\\n\"\n  test_cloning_inline_extents \"\" \"-o compress\"\n\n  echo -e \"\\nTesting without compression and with the no-holes feature...\\n\"\n  test_cloning_inline_extents \"-O no-holes\" \"\"\n\n  echo -e \"\\nTesting with compression and with the no-holes feature...\\n\"\n  test_cloning_inline_extents \"-O no-holes\" \"-o compress\"\n\n  status=0\n  exit\n\nCc: stable@vger.kernel.org\nSigned-off-by: Filipe Manana <fdmanana@suse.com>", "idx": 859}
{"func": "proto_register_kafka(void)\n{\n\n    int protocol_handle;\n\n    compute_kafka_api_names();\n\n    protocol_handle = proto_register_protocol(\"Kafka\", \"Kafka\", \"kafka\");\n    proto_register_kafka_protocol_fields(protocol_handle);\n    proto_register_kafka_protocol_subtrees(protocol_handle);\n    proto_register_kafka_expert_module(protocol_handle);\n    proto_register_kafka_preferences(protocol_handle);\n\n    proto_kafka = protocol_handle;\n\n}", "target": 0, "cwe": ["CWE-401"], "project": "wireshark", "commit_id": "f4374967bbf9c12746b8ec3cd54dddada9dd353e", "hash": 89248453680674974208096655437761395524, "size": 16, "message": "Kafka: Limit our decompression size.\n\nDon't assume that the Internet has our best interests at heart when it\ngives us the size of our decompression buffer. Assign an arbitrary limit\nof 50 MB.\n\nThis fixes #16739 in that it takes care of\n\n** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion \"end >= fi->start\"\n\nwhich is different from the original error output. It looks like *that*\nmight have taken care of in one of the other recent Kafka bug fixes.\n\nThe decompression routines return a success or failure status. Use\ngbooleans instead of ints for that.", "idx": 860}
{"func": "static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1, "cwe": ["CWE-415", "CWE-125"], "project": "radare2", "commit_id": "60208765887f5f008b3b9a883f3addc8bdb9c134", "hash": 177892588548153922268630655935754686006, "size": 41, "message": "Fix #9970 - heap oobread in mach0 parser (#10026)", "idx": 861}
{"func": "static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned char name_assign_type,\n\t\t\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t\t\t     struct vif_params *params)\n{\n\tstruct wireless_dev *wdev;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"enter: %s type %d\\n\", name, type);\n\terr = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);\n\tif (err) {\n\t\tbphy_err(wiphy, \"iface validation failed: err=%d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tcase NL80211_IFTYPE_AP:\n\t\twdev = brcmf_ap_add_vif(wiphy, name, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\twdev = brcmf_p2p_add_vif(wiphy, name, name_assign_type, type, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (IS_ERR(wdev))\n\t\tbphy_err(wiphy, \"add iface %s type %d failed: err=%d\\n\", name,\n\t\t\t type, (int)PTR_ERR(wdev));\n\telse\n\t\tbrcmf_cfg80211_update_proto_addr_mode(wdev);\n\n\treturn wdev;\n}", "target": 0, "cwe": ["CWE-787"], "project": "linux", "commit_id": "1b5e2423164b3670e8bc9174e4762d297990deff", "hash": 98326067142867018344999391354935154387, "size": 44, "message": "brcmfmac: assure SSID length from firmware is limited\n\nThe SSID length as received from firmware should not exceed\nIEEE80211_MAX_SSID_LEN as that would result in heap overflow.\n\nReviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>\nReviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>\nReviewed-by: Franky Lin <franky.lin@broadcom.com>\nSigned-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>", "idx": 862}
{"func": "_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/\n{\n    Py_ssize_t i;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    for (i = 0; i < self->unpickler->memo_size; i++) {\n        int status;\n        PyObject *key, *value;\n\n        value = self->unpickler->memo[i];\n        if (value == NULL)\n            continue;\n\n        key = PyLong_FromSsize_t(i);\n        if (key == NULL)\n            goto error;\n        status = PyDict_SetItem(new_memo, key, value);\n        Py_DECREF(key);\n        if (status < 0)\n            goto error;\n    }\n    return new_memo;\n\nerror:\n    Py_DECREF(new_memo);\n    return NULL;\n}", "target": 1, "cwe": ["CWE-190", "CWE-369"], "project": "cpython", "commit_id": "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd", "hash": 194991422923135545046343165409374239821, "size": 30, "message": "closes bpo-34656: Avoid relying on signed overflow in _pickle memos. (GH-9261)", "idx": 863}
{"func": "stdmac_file(const SMacro *s, Token **params, int nparams)\n{\n    (void)s;\n    (void)params;\n    (void)nparams;\n\n    return make_tok_qstr(NULL, src_get_fname());\n}", "target": 0, "cwe": [], "project": "nasm", "commit_id": "6299a3114ce0f3acd55d07de201a8ca2f0a83059", "hash": 96078742602315416256528486549418367261, "size": 8, "message": "BR 3392708: fix NULL pointer reference for invalid %stacksize\n\nAfter issuing an error message for a missing %stacksize argument, need\nto quit rather than continuing to try to access the pointer.\n\nFold uses of tok_text() while we are at it.\n\nReported-by: Suhwan <prada960808@gmail.com>\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>", "idx": 864}
{"func": "  bool val_native(THD *thd, Native *to)\n  {\n    return has_value() ? Time(thd, this).to_native(to, decimals) : true;\n  }", "target": 0, "cwe": ["CWE-617"], "project": "server", "commit_id": "807945f2eb5fa22e6f233cc17b85a2e141efe2c8", "hash": 281246239064165637771474113159579672714, "size": 4, "message": "MDEV-26402: A SEGV in Item_field::used_tables/update_depend_map_for_order...\n\nWhen doing condition pushdown from HAVING into WHERE,\nItem_equal::create_pushable_equalities() calls\nitem->set_extraction_flag(IMMUTABLE_FL) for constant items.\nThen, Item::cleanup_excluding_immutables_processor() checks for this flag\nto see if it should call item->cleanup() or leave the item as-is.\n\nThe failure happens when a constant item has a non-constant one inside it,\nlike:\n\n   (tbl.col=0 AND impossible_cond)\n\nitem->walk(cleanup_excluding_immutables_processor) works in a bottom-up\nway so it\n1. will call Item_func_eq(tbl.col=0)->cleanup()\n2. will not call Item_cond_and->cleanup (as the AND is constant)\n\nThis creates an item tree where a fixed Item has an un-fixed Item inside\nit which eventually causes an assertion failure.\n\nFixed by introducing this rule: instead of just calling\n\n  item->set_extraction_flag(IMMUTABLE_FL);\n\nwe call Item::walk() to set the flag for all sub-items of the item.", "idx": 865}
{"func": "static void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}", "target": 0, "cwe": ["CWE-401"], "project": "linux", "commit_id": "d80b64ff297e40c2b6f7d7abc1b3eba70d22a068", "hash": 336771086562159300474566500617641185764, "size": 10, "message": "KVM: SVM: Fix potential memory leak in svm_cpu_init()\n\nWhen kmalloc memory for sd->sev_vmcbs failed, we forget to free the page\nheld by sd->save_area. Also get rid of the var r as '-ENOMEM' is actually\nthe only possible outcome here.\n\nReviewed-by: Liran Alon <liran.alon@oracle.com>\nReviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>\nSigned-off-by: Miaohe Lin <linmiaohe@huawei.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 866}
{"func": "static int ext4_mb_init_backend(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_group_info ***group_info;\n\tstruct kmem_cache *cachep;\n\n\terr = ext4_mb_alloc_groupinfo(sb, ngroups);\n\tif (err)\n\t\treturn err;\n\n\tsbi->s_buddy_cache = new_inode(sb);\n\tif (sbi->s_buddy_cache == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't get new inode\");\n\t\tgoto err_freesgi;\n\t}\n\t/* To avoid potentially colliding with an valid on-disk inode number,\n\t * use EXT4_BAD_INO for the buddy cache inode number.  This inode is\n\t * not in the inode hash, so it should never be found by iget(), but\n\t * this will avoid confusion if it ever shows up during debugging. */\n\tsbi->s_buddy_cache->i_ino = EXT4_BAD_INO;\n\tEXT4_I(sbi->s_buddy_cache)->i_disksize = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tcond_resched();\n\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\tif (desc == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't read descriptor %u\", i);\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tif (ext4_mb_add_groupinfo(sb, i, desc) != 0)\n\t\t\tgoto err_freebuddy;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* a single flex group is supposed to be read by a single IO */\n\t\tsbi->s_mb_prefetch = 1 << sbi->s_es->s_log_groups_per_flex;\n\t\tsbi->s_mb_prefetch *= 8; /* 8 prefetch IOs in flight at most */\n\t} else {\n\t\tsbi->s_mb_prefetch = 32;\n\t}\n\tif (sbi->s_mb_prefetch > ext4_get_groups_count(sb))\n\t\tsbi->s_mb_prefetch = ext4_get_groups_count(sb);\n\t/* now many real IOs to prefetch within a single allocation at cr=0\n\t * given cr=0 is an CPU-related optimization we shouldn't try to\n\t * load too many groups, at some point we should start to use what\n\t * we've got in memory.\n\t * with an average random access time 5ms, it'd take a second to get\n\t * 200 groups (* N with flex_bg), so let's make this limit 4\n\t */\n\tsbi->s_mb_prefetch_limit = sbi->s_mb_prefetch * 4;\n\tif (sbi->s_mb_prefetch_limit > ext4_get_groups_count(sb))\n\t\tsbi->s_mb_prefetch_limit = ext4_get_groups_count(sb);\n\n\treturn 0;\n\nerr_freebuddy:\n\tcachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\twhile (i-- > 0)\n\t\tkmem_cache_free(cachep, ext4_get_group_info(sb, i));\n\ti = sbi->s_group_info_size;\n\trcu_read_lock();\n\tgroup_info = rcu_dereference(sbi->s_group_info);\n\twhile (i-- > 0)\n\t\tkfree(group_info[i]);\n\trcu_read_unlock();\n\tiput(sbi->s_buddy_cache);\nerr_freesgi:\n\trcu_read_lock();\n\tkvfree(rcu_dereference(sbi->s_group_info));\n\trcu_read_unlock();\n\treturn -ENOMEM;\n}", "target": 0, "cwe": ["CWE-703"], "project": "linux", "commit_id": "ce9f24cccdc019229b70a5c15e2b09ad9c0ab5d1", "hash": 214927809633147047878926610068347034854, "size": 75, "message": "ext4: check journal inode extents more carefully\n\nCurrently, system zones just track ranges of block, that are \"important\"\nfs metadata (bitmaps, group descriptors, journal blocks, etc.). This\nhowever complicates how extent tree (or indirect blocks) can be checked\nfor inodes that actually track such metadata - currently the journal\ninode but arguably we should be treating quota files or resize inode\nsimilarly. We cannot run __ext4_ext_check() on such metadata inodes when\nloading their extents as that would immediately trigger the validity\nchecks and so we just hack around that and special-case the journal\ninode. This however leads to a situation that a journal inode which has\nextent tree of depth at least one can have invalid extent tree that gets\nunnoticed until ext4_cache_extents() crashes.\n\nTo overcome this limitation, track inode number each system zone belongs\nto (0 is used for zones not belonging to any inode). We can then verify\ninode number matches the expected one when verifying extent tree and\nthus avoid the false errors. With this there's no need to to\nspecial-case journal inode during extent tree checking anymore so remove\nit.\n\nFixes: 0a944e8a6c66 (\"ext4: don't perform block validity checks on the journal inode\")\nReported-by: Wolfgang Frisch <wolfgang.frisch@suse.com>\nReviewed-by: Lukas Czerner <lczerner@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nLink: https://lore.kernel.org/r/20200728130437.7804-4-jack@suse.cz\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>", "idx": 867}
{"func": "file_info_cancel (NautilusDirectory *directory)\n{\n\tif (directory->details->get_info_in_progress != NULL) {\n\t\tg_cancellable_cancel (directory->details->get_info_in_progress->cancellable);\n\t\tdirectory->details->get_info_in_progress->directory = NULL;\n\t\tdirectory->details->get_info_in_progress = NULL;\n\t\tdirectory->details->get_info_file = NULL;\n\n\t\tasync_job_end (directory, \"file info\");\n\t}\n}", "target": 0, "cwe": [], "project": "nautilus", "commit_id": "7632a3e13874a2c5e8988428ca913620a25df983", "hash": 216810815369543446470272369468918930322, "size": 11, "message": "Check for trusted desktop file launchers.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-directory-async.c:\n\tCheck for trusted desktop file launchers.\n\n        * libnautilus-private/nautilus-file-private.h:\n        * libnautilus-private/nautilus-file.c:\n        * libnautilus-private/nautilus-file.h:\n        Add nautilus_file_is_trusted_link.\n\tAllow unsetting of custom display name.\n\n        * libnautilus-private/nautilus-mime-actions.c:\n\tDisplay dialog when trying to launch a non-trusted desktop file.\n\n\n\nsvn path=/trunk/; revision=15003", "idx": 868}
{"func": "QPDF::removePage(QPDFObjectHandle page)\n{\n    int pos = findPage(page); // also ensures flat /Pages\n    QTC::TC(\"qpdf\", \"QPDF remove page\",\n            (pos == 0) ? 0 :                            // remove at beginning\n            (pos == static_cast<int>(\n                this->m->all_pages.size() - 1)) ? 1 :   // end\n            2);                                         // remove in middle\n\n    QPDFObjectHandle pages = getRoot().getKey(\"/Pages\");\n    QPDFObjectHandle kids = pages.getKey(\"/Kids\");\n\n    kids.eraseItem(pos);\n    int npages = kids.getArrayNItems();\n    pages.replaceKey(\"/Count\", QPDFObjectHandle::newInteger(npages));\n    this->m->all_pages.erase(this->m->all_pages.begin() + pos);\n    assert(this->m->all_pages.size() == static_cast<size_t>(npages));\n    this->m->pageobj_to_pages_pos.erase(page.getObjGen());\n    assert(this->m->pageobj_to_pages_pos.size() == static_cast<size_t>(npages));\n    for (int i = pos; i < npages; ++i)\n    {\n        insertPageobjToPage(this->m->all_pages.at(i), i, false);\n    }\n}", "target": 1, "cwe": ["CWE-787"], "project": "qpdf", "commit_id": "d71f05ca07eb5c7cfa4d6d23e5c1f2a800f52e8e", "hash": 306424035139355303059310959292294262566, "size": 24, "message": "Fix sign and conversion warnings (major)\n\nThis makes all integer type conversions that have potential data loss\nexplicit with calls that do range checks and raise an exception. After\nthis commit, qpdf builds with no warnings when -Wsign-conversion\n-Wconversion is used with gcc or clang or when -W3 -Wd4800 is used\nwith MSVC. This significantly reduces the likelihood of potential\ncrashes from bogus integer values.\n\nThere are some parts of the code that take int when they should take\nsize_t or an offset. Such places would make qpdf not support files\nwith more than 2^31 of something that usually wouldn't be so large. In\nthe event that such a file shows up and is valid, at least qpdf would\nraise an error in the right spot so the issue could be legitimately\naddressed rather than failing in some weird way because of a silent\noverflow condition.", "idx": 869}
{"func": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "FFmpeg", "commit_id": "2a05c8f813de6f2278827734bf8102291e7484aa", "hash": 188046064961903596428699236920026139123, "size": 33, "message": "http: make length/offset-related variables unsigned.\n\nFixes #5992, reported and found by Paul Cher <paulcher@icloud.com>.", "idx": 870}
{"func": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\t\tgoto out;\n\n\t/* no undo structure around - allocate one. */\n\t/* step 1: figure out the size of the semaphore array */\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\n\t/* step 2: allocate new undo structure */\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* step 3: Acquire the lock on semaphore array */\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\n\t/*\n\t * step 4: check for races: did someone else allocate the undo struct?\n\t */\n\tun = lookup_undo(ulp, semid);\n\tif (un) {\n\t\tkfree(new);\n\t\tgoto success;\n\t}\n\t/* step 5: initialize & link new undo structure */\n\tnew->semadj = (short *) &new[1];\n\tnew->ulp = ulp;\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\n\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}", "target": 1, "cwe": ["CWE-703", "CWE-189"], "project": "linux", "commit_id": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3", "hash": 324667714056848892608385067440444523799, "size": 73, "message": "ipc,sem: fine grained locking for semtimedop\n\nIntroduce finer grained locking for semtimedop, to handle the common case\nof a program wanting to manipulate one semaphore from an array with\nmultiple semaphores.\n\nIf the call is a semop manipulating just one semaphore in an array with\nmultiple semaphores, only take the lock for that semaphore itself.\n\nIf the call needs to manipulate multiple semaphores, or another caller is\nin a transaction that manipulates multiple semaphores, the sem_array lock\nis taken, as well as all the locks for the individual semaphores.\n\nOn a 24 CPU system, performance numbers with the semop-multi\ntest with N threads and N semaphores, look like this:\n\n\tvanilla\t\tDavidlohr's\tDavidlohr's +\tDavidlohr's +\nthreads\t\t\tpatches\t\trwlock patches\tv3 patches\n10\t610652\t\t726325\t\t1783589\t\t2142206\n20\t341570\t\t365699\t\t1520453\t\t1977878\n30\t288102\t\t307037\t\t1498167\t\t2037995\n40\t290714\t\t305955\t\t1612665\t\t2256484\n50\t288620\t\t312890\t\t1733453\t\t2650292\n60\t289987\t\t306043\t\t1649360\t\t2388008\n70\t291298\t\t306347\t\t1723167\t\t2717486\n80\t290948\t\t305662\t\t1729545\t\t2763582\n90\t290996\t\t306680\t\t1736021\t\t2757524\n100\t292243\t\t306700\t\t1773700\t\t3059159\n\n[davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]\n[davidlohr.bueso@hp.com: make refcounter atomic]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Jason Low <jason.low2@hp.com>\nReviewed-by: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Emmanuel Benisty <benisty.e@gmail.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 871}
{"func": "static void oss_poll_in (HWVoiceIn *hw)\n{\n    OSSVoiceIn *oss = (OSSVoiceIn *) hw;\n\n    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);\n}", "target": 0, "cwe": ["CWE-369"], "project": "qemu", "commit_id": "7a4ede0047a8613b0e3b72c9d351038f013dd357", "hash": 108835609235057844631283208161799544829, "size": 6, "message": "audio/oss: fix buffer pos calculation\n\nFixes: 3ba4066d085f (\"ossaudio: port to the new audio backend api\")\nReported-by: ziming zhang <ezrakiez@gmail.com>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nMessage-Id: <20200120101804.29578-1-kraxel@redhat.com>\nReviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>", "idx": 872}
{"func": "int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)\n{\n\tenum rtrs_clt_state old_state;\n\tint err = -EBUSY;\n\tbool changed;\n\n\tchanged = rtrs_clt_change_state_get_old(clt_path,\n\t\t\t\t\t\t RTRS_CLT_RECONNECTING,\n\t\t\t\t\t\t &old_state);\n\tif (changed) {\n\t\tclt_path->reconnect_attempts = 0;\n\t\tqueue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);\n\t}\n\tif (changed || old_state == RTRS_CLT_RECONNECTING) {\n\t\t/*\n\t\t * flush_delayed_work() queues pending work for immediate\n\t\t * execution, so do the flush if we have queued something\n\t\t * right now or work is pending.\n\t\t */\n\t\tflush_delayed_work(&clt_path->reconnect_dwork);\n\t\terr = (READ_ONCE(clt_path->state) ==\n\t\t       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);\n\t}\n\n\treturn err;\n}", "target": 0, "cwe": ["CWE-415"], "project": "linux", "commit_id": "8700af2cc18c919b2a83e74e0479038fd113c15d", "hash": 334577736141832688878351592583953132067, "size": 26, "message": "RDMA/rtrs-clt: Fix possible double free in error case\n\nCallback function rtrs_clt_dev_release() for put_device() calls kfree(clt)\nto free memory. We shouldn't call kfree(clt) again, and we can't use the\nclt after kfree too.\n\nReplace device_register() with device_initialize() and device_add() so that\ndev_set_name can() be used appropriately.\n\nMove mutex_destroy() to the release function so it can be called in\nthe alloc_clt err path.\n\nFixes: eab098246625 (\"RDMA/rtrs-clt: Refactor the failure cases in alloc_clt\")\nLink: https://lore.kernel.org/r/20220217030929.323849-1-haris.iqbal@ionos.com\nReported-by: Miaoqian Lin <linmq006@gmail.com>\nSigned-off-by: Md Haris Iqbal <haris.iqbal@ionos.com>\nReviewed-by: Jack Wang <jinpu.wang@ionos.com>\nSigned-off-by: Jason Gunthorpe <jgg@nvidia.com>", "idx": 873}
{"func": "static void ext4_mb_mark_free_simple(struct super_block *sb,\n\t\t\t\tvoid *buddy, ext4_grpblk_t first, ext4_grpblk_t len,\n\t\t\t\t\tstruct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t min;\n\text4_grpblk_t max;\n\text4_grpblk_t chunk;\n\tunsigned int border;\n\n\tBUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));\n\n\tborder = 2 << sb->s_blocksize_bits;\n\n\twhile (len > 0) {\n\t\t/* find how many blocks can be covered since this position */\n\t\tmax = ffs(first | border) - 1;\n\n\t\t/* find how many blocks of power 2 we need to mark */\n\t\tmin = fls(len) - 1;\n\n\t\tif (max < min)\n\t\t\tmin = max;\n\t\tchunk = 1 << min;\n\n\t\t/* mark multiblock chunks only */\n\t\tgrp->bb_counters[min]++;\n\t\tif (min > 0)\n\t\t\tmb_clear_bit(first >> min,\n\t\t\t\t     buddy + sbi->s_mb_offsets[min]);\n\n\t\tlen -= chunk;\n\t\tfirst += chunk;\n\t}\n}", "target": 0, "cwe": ["CWE-416"], "project": "linux", "commit_id": "8844618d8aa7a9973e7b527d038a2a589665002c", "hash": 106834230626175680745544707473313632924, "size": 35, "message": "ext4: only look at the bg_flags field if it is valid\n\nThe bg_flags field in the block group descripts is only valid if the\nuninit_bg or metadata_csum feature is enabled.  We were not\nconsistently looking at this field; fix this.\n\nAlso block group #0 must never have uninitialized allocation bitmaps,\nor need to be zeroed, since that's where the root inode, and other\nspecial inodes are set up.  Check for these conditions and mark the\nfile system as corrupted if they are detected.\n\nThis addresses CVE-2018-10876.\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=199403\n\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@kernel.org", "idx": 874}
{"func": "int udp_v4_get_port(struct sock *sk, unsigned short snum)\n{\n\tunsigned int hash2_nulladdr =\n\t\tudp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);\n\tunsigned int hash2_partial =\n\t\tudp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);\n\n\t/* precompute partial secondary hash */\n\tudp_sk(sk)->udp_portaddr_hash = hash2_partial;\n\treturn udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);\n}", "target": 0, "cwe": ["CWE-400"], "project": "linux-2.6", "commit_id": "c377411f2494a931ff7facdbb3a6839b1266bcf6", "hash": 100535673975849068301841988586830977574, "size": 11, "message": "net: sk_add_backlog() take rmem_alloc into account\n\nCurrent socket backlog limit is not enough to really stop DDOS attacks,\nbecause user thread spend many time to process a full backlog each\nround, and user might crazy spin on socket lock.\n\nWe should add backlog size and receive_queue size (aka rmem_alloc) to\npace writers, and let user run without being slow down too much.\n\nIntroduce a sk_rcvqueues_full() helper, to avoid taking socket lock in\nstress situations.\n\nUnder huge stress from a multiqueue/RPS enabled NIC, a single flow udp\nreceiver can now process ~200.000 pps (instead of ~100 pps before the\npatch) on a 8 core machine.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 875}
{"func": "int Field_blob::store(const char *from,size_t length,CHARSET_INFO *cs)\n{\n  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;\n  size_t copy_length, new_length;\n  uint copy_len;\n  char *tmp;\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  String tmpstr(buff,sizeof(buff), &my_charset_bin);\n  int rc;\n\n  if (!length)\n  {\n    bzero(ptr,Field_blob::pack_length());\n    return 0;\n  }\n\n  /*\n    For min/max fields of statistical data 'table' is set to NULL.\n    It could not be otherwise as this data is shared by many instances\n    of the same base table.\n  */\n\n  if (table && table->blob_storage)    // GROUP_CONCAT with ORDER BY | DISTINCT\n  {\n    DBUG_ASSERT(!f_is_hex_escape(flags));\n    DBUG_ASSERT(field_charset == cs);\n    DBUG_ASSERT(length <= max_data_length());\n    \n    new_length= length;\n    copy_length= table->in_use->variables.group_concat_max_len;\n    if (new_length > copy_length)\n    {\n      new_length= Well_formed_prefix(cs,\n                                     from, copy_length, new_length).length();\n      table->blob_storage->set_truncated_value(true);\n    }\n    if (!(tmp= table->blob_storage->store(from, new_length)))\n      goto oom_error;\n\n    Field_blob::store_length(new_length);\n    bmove(ptr + packlength, (uchar*) &tmp, sizeof(char*));\n    return 0;\n  }\n\n  /*\n    If the 'from' address is in the range of the temporary 'value'-\n    object we need to copy the content to a different location or it will be\n    invalidated when the 'value'-object is reallocated to make room for\n    the new character set.\n  */\n  if (from >= value.ptr() && from <= value.ptr()+value.length())\n  {\n    /*\n      If content of the 'from'-address is cached in the 'value'-object\n      it is possible that the content needs a character conversion.\n    */\n    if (!String::needs_conversion_on_storage(length, cs, field_charset))\n    {\n      Field_blob::store_length(length);\n      bmove(ptr + packlength, &from, sizeof(char*));\n      return 0;\n    }\n    if (tmpstr.copy(from, length, cs))\n      goto oom_error;\n    from= tmpstr.ptr();\n  }\n\n  new_length= MY_MIN(max_data_length(), field_charset->mbmaxlen * length);\n  if (value.alloc(new_length))\n    goto oom_error;\n  tmp= const_cast<char*>(value.ptr());\n\n  if (f_is_hex_escape(flags))\n  {\n    copy_length= my_copy_with_hex_escaping(field_charset,\n                                           tmp, new_length,\n                                           from, length);\n    Field_blob::store_length(copy_length);\n    bmove(ptr + packlength, (uchar*) &tmp, sizeof(char*));\n    return 0;\n  }\n  rc= well_formed_copy_with_check((char*) value.ptr(), (uint) new_length,\n                                  cs, from, length,\n                                  length, true, &copy_len);\n  value.length(copy_len);\n  Field_blob::store_length(copy_len);\n  bmove(ptr+packlength,(uchar*) &tmp,sizeof(char*));\n\n  return rc;\n\noom_error:\n  /* Fatal OOM error */\n  bzero(ptr,Field_blob::pack_length());\n  return -1; \n}", "target": 0, "cwe": ["CWE-416", "CWE-703"], "project": "server", "commit_id": "08c7ab404f69d9c4ca6ca7a9cf7eec74c804f917", "hash": 124178423453534372811965461113802978797, "size": 95, "message": "MDEV-24176 Server crashes after insert in the table with virtual\ncolumn generated using date_format() and if()\n\nvcol_info->expr is allocated on expr_arena at parsing stage. Since\nexpr item is allocated on expr_arena all its containee items must be\nallocated on expr_arena too. Otherwise fix_session_expr() will\nencounter prematurely freed item.\n\nWhen table is reopened from cache vcol_info contains stale\nexpression. We refresh expression via TABLE::vcol_fix_exprs() but\nfirst we must prepare a proper context (Vcol_expr_context) which meets\nsome requirements:\n\n1. As noted above expr update must be done on expr_arena as there may\nbe new items created. It was a bug in fix_session_expr_for_read() and\nwas just not reproduced because of no second refix. Now refix is done\nfor more cases so it does reproduce. Tests affected: vcol.binlog\n\n2. Also name resolution context must be narrowed to the single table.\nTested by: vcol.update main.default vcol.vcol_syntax gcol.gcol_bugfixes\n\n3. sql_mode must be clean and not fail expr update.\n\nsql_mode such as MODE_NO_BACKSLASH_ESCAPES, MODE_NO_ZERO_IN_DATE, etc\nmust not affect vcol expression update. If the table was created\nsuccessfully any further evaluation must not fail. Tests affected:\nmain.func_like\n\nReviewed by: Sergei Golubchik <serg@mariadb.org>", "idx": 876}
{"func": "g_socket_client_connect_async (GSocketClient       *client,\n\t\t\t       GSocketConnectable  *connectable,\n\t\t\t       GCancellable        *cancellable,\n\t\t\t       GAsyncReadyCallback  callback,\n\t\t\t       gpointer             user_data)\n{\n  GSocketClientAsyncConnectData *data;\n\n  g_return_if_fail (G_IS_SOCKET_CLIENT (client));\n\n  data = g_slice_new0 (GSocketClientAsyncConnectData);\n  data->client = client;\n  data->connectable = g_object_ref (connectable);\n\n  if (can_use_proxy (client))\n    {\n      data->enumerator = g_socket_connectable_proxy_enumerate (connectable);\n      if (client->priv->proxy_resolver &&\n          G_IS_PROXY_ADDRESS_ENUMERATOR (data->enumerator))\n        {\n          g_object_set (G_OBJECT (data->enumerator),\n                        \"proxy-resolver\", client->priv->proxy_resolver,\n                        NULL);\n        }\n    }\n  else\n    data->enumerator = g_socket_connectable_enumerate (connectable);\n\n  data->task = g_task_new (client, cancellable, callback, user_data);\n  g_task_set_source_tag (data->task, g_socket_client_connect_async);\n  g_task_set_task_data (data->task, data, (GDestroyNotify)g_socket_client_async_connect_data_free);\n\n  enumerator_next_async (data);\n}", "target": 1, "cwe": ["CWE-754"], "project": "glib", "commit_id": "d553d92d6e9f53cbe5a34166fcb919ba652c6a8e", "hash": 266462760756795777150591589789194149267, "size": 34, "message": "gsocketclient: Fix criticals\n\nThis ensures the parent GTask is kept alive as long as an enumeration\nis running and trying to connect.\n\nCloses #1646\nCloses #1649", "idx": 877}
{"func": "printable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}", "target": 0, "cwe": ["CWE-399"], "project": "file", "commit_id": "90018fe22ff8b74a22fcd142225b0a00f3f12677", "hash": 56037078656715275949745547424649383019, "size": 20, "message": "bump recursion to 15, and allow it to be set from the command line.", "idx": 878}
{"func": "static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,\n                                          LICENSE_BLOB* target, const BYTE* packetMac)\n{\n\tBYTE macData[16];\n\n\treturn license_rc4_with_licenseKey(license, input, len, target) &&\n\t       security_mac_data(license->MacSaltKey, target->data, len, macData) &&\n\t       (memcmp(packetMac, macData, sizeof(macData)) == 0);\n}", "target": 0, "cwe": ["CWE-125"], "project": "FreeRDP", "commit_id": "6ade7b4cbfd71c54b3d724e8f2d6ac76a58e879a", "hash": 327071215619519893487675143035839842767, "size": 9, "message": "Fixed OOB Read in license_read_new_or_upgrade_license_packet\n\nCVE-2020-11099 thanks to @antonio-morales for finding this.", "idx": 879}
{"func": "R_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {\n\tRBinJavaStackMapFrame *stack_frame = r_bin_java_default_stack_frame ();\n\tRBinJavaVerificationObj *se = NULL;\n\tut64 offset = 0;\n\tif (!stack_frame) {\n\t\treturn NULL;\n\t}\n\tstack_frame->tag = buffer[offset];\n\toffset += 1;\n\tstack_frame->metas->type_info = (void *) r_bin_java_determine_stack_frame_type (stack_frame->tag);\n\tstack_frame->type = ((RBinJavaStackMapFrameMetas *) stack_frame->metas->type_info)->type;\n\tstack_frame->file_offset = buf_offset;\n\tstack_frame->p_stack_frame = p_frame;\n\tswitch (stack_frame->type) {\n\tcase R_BIN_JAVA_STACK_FRAME_SAME:\n\t\t// Maybe?  1. Copy the previous frames locals and set the locals count.\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFINT eprintf (\"><?><\\n\");\n\t\t\tIFDBG eprintf (\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1:\n\t\t// 1. Read the stack type\n\t\tstack_frame->number_of_stack_items = 1;\n\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: Parsed R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1.\\n\");\n\t\tif (se) {\n\t\t\toffset += se->size;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the Stack Items for the stack frame.\\n\");\n\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_list_append (stack_frame->stack_items, (void *) se);\n\t\t// Maybe?  3. Copy the previous frames locals and set the locals count.\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFDBG eprintf (\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals 1 Stack Element Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_CHOP:\n\t\t// 1. Calculate the max index we want to copy from the list of the\n\t\t// previous frames locals\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_CHOP.\\n\");\n\t\t// ut16 k = 251 - stack_frame->tag;\n\t\t/*,\n\t\tidx = p_frame->number_of_locals - k;\n\t\t*/\n\t\t// 2.  read the uoffset value\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// Maybe? 3. Copy the previous frames locals and set the locals count.\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFINT eprintf (\"><?><\\n\");\n\t\t\tIFDBG eprintf (\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: TODO Stack Frame Chop Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED:\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED.\\n\");\n\t\t// 1. Read the uoffset\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// 2. Read the stack element type\n\t\tstack_frame->number_of_stack_items = 1;\n\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (se) {\n\t\t\toffset += se->size;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the Stack Items for the stack frame.\\n\");\n\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_list_append (stack_frame->stack_items, (void *) se);\n\t\t// Maybe? 3. Copy the previous frames locals to the current locals\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFINT eprintf (\"><?><\\n\");\n\t\t\tIFDBG eprintf (\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals Frame Stack 1 Extended Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_APPEND:\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_APPEND.\\n\");\n\t\t// 1. Calculate the max index we want to copy from the list of the\n\t\t// previous frames locals\n\t\tut16 k = stack_frame->tag - 251;\n\t\tut32 i = 0;\n\t\t// 2. Read the uoffset\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// Maybe? 3. Copy the previous frames locals to the current locals\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\t// 4. Read off the rest of the appended locals types\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: Parsing verifying the k'th frame: %d of %d.\\n\", i, k);\n\t\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: Completed Parsing\\n\");\n\t\t\tif (se) {\n\t\t\t\toffset += se->size;\n\t\t\t} else {\n\t\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the locals for the stack frame.\\n\");\n\t\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_list_append (stack_frame->local_items, (void *) se);\n\t\t}\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: Breaking out of loop\");\n\t\tIFDBG eprintf (\"p_frame: %p\\n\", p_frame);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals + k;\n\t\t} else {\n\t\t\tIFINT eprintf (\"><?><\\n\");\n\t\t\tIFDBG eprintf (\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals Frame Stack 1 Extended Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_FULL_FRAME:\n\t\tIFDBG eprintf (\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_FULL_FRAME.\\n\");\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// IFDBG eprintf (\"r_bin_java_stack_map_frame_new: Code Size > 65535, read(%d byte(s)), offset = 0x%08x.\\n\", var_sz, stack_frame->offset_delta);\n\t\t// Read the number of variables based on the max # local variable\n\t\tstack_frame->number_of_locals = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// IFDBG eprintf (\"r_bin_java_stack_map_frame_new: Max ulocalvar > 65535, read(%d byte(s)), number_of_locals = 0x%08x.\\n\", var_sz, stack_frame->number_of_locals);\n\t\tIFDBG r_bin_java_print_stack_map_frame_summary(stack_frame);\n\t\t// read the number of locals off the stack\n\t\tfor (i = 0; i < stack_frame->number_of_locals; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (se) {\n\t\t\t\toffset += se->size;\n\t\t\t\t// r_list_append (stack_frame->local_items, (void *) se);\n\t\t\t} else {\n\t\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the locals for the stack frame.\\n\");\n\t\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_list_append (stack_frame->local_items, (void *) se);\n\t\t}\n\t\t// Read the number of stack items based on the max size of stack\n\t\tstack_frame->number_of_stack_items = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// IFDBG eprintf (\"r_bin_java_stack_map_frame_new: Max ustack items > 65535, read(%d byte(s)), number_of_locals = 0x%08x.\\n\", var_sz, stack_frame->number_of_stack_items);\n\t\t// read the stack items\n\t\tfor (i = 0; i < stack_frame->number_of_stack_items; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (se) {\n\t\t\t\toffset += se->size;\n\t\t\t\t// r_list_append (stack_frame->stack_items, (void *) se);\n\t\t\t} else {\n\t\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the stack items for the stack frame.\\n\");\n\t\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_list_append (stack_frame->local_items, (void *) se);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"java: Unknown type\\n\");\n\t\tbreak;\n\t}\n\t// IFDBG eprintf (\"Created a stack frame at offset(0x%08\"PFMT64x\") of size: %d\\n\", buf_offset, stack_frame->size);//r_bin_java_print_stack_map_frame_summary(stack_frame);\n\tstack_frame->size = offset;\n\t// IFDBG r_bin_java_print_stack_map_frame_summary(stack_frame);\n\treturn stack_frame;\n}", "target": 1, "cwe": ["CWE-119", "CWE-788"], "project": "radare2", "commit_id": "6c4428f018d385fc80a33ecddcb37becea685dd5", "hash": 234993436289501142937626898189591907073, "size": 188, "message": "Improve boundary checks to fix oobread segfaults ##crash\n\n* Reported by Cen Zhang via huntr.dev\n* Reproducer: bins/fuzzed/javaoob-havoc.class", "idx": 880}
{"func": "inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)\n{\n\trr->type = (QueryType)((input[0] << 8) + input[1]);\n\trr->rr_class = (input[2] << 8) + input[3];\n\trr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];\n\trr->rdlength = (input[8] << 8) + input[9];\n}", "target": 0, "cwe": [], "project": "inspircd", "commit_id": "58c893e834ff20495d007709220881a3ff13f423", "hash": 19862481210089349379059193798727219457, "size": 7, "message": "Fixed infinite loop cauesd by invalid dns packets", "idx": 881}
{"func": "static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (sps_id >= 16) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \"max_sublayers_minus1\");\n\tsps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \"chroma_format_idc\");\n\tsps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \"log2_ctu_size_minus5\");\n\tCtbSizeY = 1<<sps->log2_ctu_size;\n\n\tsps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"sps_ptl_dpb_hrd_params_present_flag\");\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tVVC_ProfileTierLevel ptl, *p_ptl;\n\t\tif (sps->vps_id) {\n\t\t\tp_ptl = &ptl;\n\t\t} else {\n\t\t\tp_ptl = &vvc->vps[0].ptl[0];\n\t\t}\n\t\tmemset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));\n\t\tp_ptl->pt_present = 1;\n\t\tp_ptl->ptl_max_tid = sps->max_sublayers;\n\t\tvvc_profile_tier_level(bs, p_ptl, 0);\n\t}\n\tsps->gdr_enabled = gf_bs_read_int_log(bs, 1, \"gdr_enabled\");\n\tsps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \"ref_pic_resampling\");\n\tif (sps->ref_pic_resampling)\n\t\tsps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \"res_change_in_clvs\");\n\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\tsps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_present_flag\");\n\tif (sps->conf_window) {\n\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\t}\n\tsps->subpic_info_present = gf_bs_read_int_log(bs, 1, \"subpic_info_present\");\n\tif (sps->subpic_info_present) {\n\t\tsps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \"nb_subpics_minus1\");\n\t\tif (sps->nb_subpics>1) {\n\t\t\tu32 tmpWidthVal, tmpHeightVal;\n\t\t\tsps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \"independent_subpic_flags\");\n\t\t\tsps->subpic_same_size = gf_bs_read_int_log(bs, 1, \"subpic_same_size\");\n\n\t\t\ttmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpWidthVal = gf_get_bit_size(tmpWidthVal);\n\t\t\ttmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpHeightVal = gf_get_bit_size(tmpHeightVal);\n\n\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\tif( !sps->subpic_same_size || !i) {\n\t\t\t\t\tif (i && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_ctu_top_left_x\");\n\t\t\t\t\tif (i && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_ctu_top_left_y\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_width_minus1\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_height_minus1\");\n\t\t\t\t}\n\t\t\t\tif (!sps->independent_subpic_flags) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"subpic_treated_as_pic_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"loop_filter_across_subpic_enabled_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsps->subpicid_len = gf_bs_read_ue_log(bs, \"subpic_id_len_minus1\") + 1;\n\t\t\tsps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_explicitly_signalled_flag\");\n\t\t\tif (sps->subpicid_mapping_explicit) {\n\t\t\t\tsps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\t\t\t\tif (sps->subpicid_mapping_present) {\n\t\t\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\t\t\tgf_bs_read_ue_log(bs, \"subpic_id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsps->bitdepth = gf_bs_read_ue_log(bs, \"bitdepth_minus8\") + 8;\n\tgf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tgf_bs_read_int_log(bs, 1, \"entry_point_offsets_present_flag\");\n\tsps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \"log2_max_poc_lsb_minus4\");\n\tif ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_flag\")))\n\t\tsps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \"poc_msb_cycle_len_minus1\");\n\n\tu8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \"sps_num_extra_ph_bytes\");\n\tfor (i=0; i<sps_num_extra_ph_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_ph_bit_present_flag\", 1))\n\t\t\tsps->ph_num_extra_bits++;\n\t}\n\tu8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \"num_extra_sh_bytes\");\n\tfor (i=0; i<sps_num_extra_sh_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_sh_bit_present_flag\", i))\n\t\t\tsps->sh_num_extra_bits++;\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tu8 sps_sublayer_dpb_params_flag = 0;\n\t\tif (sps->max_sublayers>1) {\n\t\t\tsps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \"sps_sublayer_dpb_params_flag\");\n\t\t}\n\t\tfor (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_dec_pic_buffering_minus1\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_latency_increase_plus1\", i);\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tgf_bs_read_int_log(bs, 1, \"sps_partition_constraints_override_enabled_flag\");\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tu8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_luma\");\n\tif (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_luma\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_luma\");\n\t}\n\tu8 sps_qtbtt_dual_tree_intra_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \"sps_qtbtt_dual_tree_intra_flag\");\n\t}\n\tif (sps_qtbtt_dual_tree_intra_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_intra_slice_chroma\");\n\t\tu8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_chroma\");\n\t\tif( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_chroma\");\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_chroma\");\n\t\t}\n\t}\n\n\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_inter_slice\");\n\tu8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_inter_slice\");\n\tif (sps_max_mtt_hierarchy_depth_inter_slice != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_inter_slice\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_inter_slice\");\n\t}\n\t//u8 sps_max_luma_transform_size_64_flag = 0;\n\tif (CtbSizeY > 32) {\n\t\t/*sps_max_luma_transform_size_64_flag = */gf_bs_read_int_log(bs, 1, \"sps_max_luma_transform_size_64_flag\");\n\t}\n\tu8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_transform_skip_enabled_flag\");\n\n\tif (sps_transform_skip_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_transform_skip_max_size_minus2\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_bdpcm_enabled_flag\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"sps_mts_enabled_flag\")) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_intra_enabled_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_inter_enabled_flag\");\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_lfnst_enabled_flag\");\n\tif (sps->chroma_format_idc) {\n\t\tu8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_joint_cbcr_enabled_flag\");\n\t\tu8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \"sps_same_qp_table_for_chroma_flag\");\n\t\tu32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);\n\t\tfor (i=0; i<numQpTables; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"sps_qp_table_start_minus26\", i);\n\t\t\tu32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \"sps_num_points_in_qp_table_minus1\", i);\n\t\t\tfor (j=0; j<sps_num_points_in_qp_table; j++) {\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_in_val_minus1\", i, j);\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_diff_val\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_sao_enabled_flag\");\n\tsps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_alf_enabled_flag\");\n\tif (sps->alf_enabled_flag && sps->chroma_format_idc) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_ccalf_enabled_flag\");\n\t}\n\t/*! TODO parse the rest !*/\n\n\treturn sps_id;\n}", "target": 1, "cwe": ["CWE-190", "CWE-787"], "project": "gpac", "commit_id": "51cdb67ff7c5f1242ac58c5aa603ceaf1793b788", "hash": 148825474867684869587297774229812441473, "size": 195, "message": "add safety in avc/hevc/vvc sps/pps/vps ID check - cf #1720 #1721 #1722", "idx": 882}
{"func": "proc_file_lseek(struct file *file, loff_t offset, int orig)\n{\n    lock_kernel();\n\n    switch (orig) {\n    case 0:\n\tif (offset < 0)\n\t    goto out;\n\tfile->f_pos = offset;\n\tunlock_kernel();\n\treturn(file->f_pos);\n    case 1:\n\tif (offset + file->f_pos < 0)\n\t    goto out;\n\tfile->f_pos += offset;\n\tunlock_kernel();\n\treturn(file->f_pos);\n    case 2:\n\tgoto out;\n    default:\n\tgoto out;\n    }\n\nout:\n    unlock_kernel();\n    return -EINVAL;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "8b90db0df7187a01fb7177f1f812123138f562cf", "hash": 260607114478156520904058156506806423202, "size": 27, "message": "Insanity avoidance in /proc\n\nThe old /proc interfaces were never updated to use loff_t, and are just\ngenerally broken.  Now, we should be using the seq_file interface for\nall of the proc files, but converting the legacy functions is more work\nthan most people care for and has little upside..\n\nBut at least we can make the non-LFS rules explicit, rather than just\ninsanely wrapping the offset or something.\n\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>", "idx": 883}
{"func": "sug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}", "target": 1, "cwe": ["CWE-476", "CWE-787"], "project": "vim", "commit_id": "6669de1b235843968e88844ca6d3c8dec4b01a9e", "hash": 251994504140226133444029248568129507567, "size": 97, "message": "patch 9.0.0240: crash when using \":mkspell\" with an empty .dic file\n\nProblem:    Crash when using \":mkspell\" with an empty .dic file.\nSolution:   Check for an empty word tree.", "idx": 884}
{"func": "static int setlabspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont,\n                       int CIESubst)\n{\n    /* In this case, we will treat this as an ICC color space, with a\n       CIELAB 16 bit profile */\n    ref labdict;\n    int code = 0;\n    float                   range_buff[4], white[3], black[3];\n    static const float      dflt_range[4] = { -100, 100, -100, 100 };\n    static const float      dflt_black[3] = {0,0,0}, dflt_white[3] = {0,0,0};\n    int i;\n    gs_client_color cc;\n\n    *cont = 0;\n    code = array_get(imemory, r, 1, &labdict);\n    if (code < 0)\n        return code;\n/* Get all the parts */\n    code = dict_floats_param( imemory, &labdict, \"Range\", 4, range_buff,\n                              dflt_range );\n    if (code < 0)\n        return code;\n    for (i = 0; i < 4 && range_buff[i + 1] >= range_buff[i]; i += 2);\n    if (i != 4)\n        return_error(gs_error_rangecheck);\n    code = dict_floats_param( imemory, &labdict, \"BlackPoint\", 3, black,\n                              dflt_black );\n    if (code < 0)\n        return code;\n    code = dict_floats_param( imemory, &labdict, \"WhitePoint\", 3, white,\n                              dflt_white );\n    if (code < 0)\n        return code;\n    if (white[0] <= 0 || white[1] != 1.0 || white[2] <= 0)\n        return_error(gs_error_rangecheck);\n    code = seticc_lab(i_ctx_p, white, black, range_buff);\n    if ( code < 0)\n        return gs_rethrow(code, \"setting PDF lab color space\");\n    cc.pattern = 0x00;\n    for (i=0;i<3;i++)\n        cc.paint.values[i] = 0;\n    code = gs_setcolor(igs, &cc);\n    return code;\n}", "target": 0, "cwe": [], "project": "ghostpdl", "commit_id": "b326a71659b7837d3acde954b18bda1a6f5e9498", "hash": 299879214148381158381896196503257637095, "size": 44, "message": "Bug 699655: Properly check the return value....\n\n...when getting a value from a dictionary", "idx": 885}
{"func": "static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)\n{\n\tswitch (order) {\n\tcase 0:\n\t\treturn (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;\n\tcase 1:\n\t\treturn (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;\n\tcase 2:\n\t\treturn (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;\n\tcase 3:\n\t\treturn ((uint8_t *)rcblock)[index];\n\tcase 4:\n\t\treturn be16toh(((uint16_t *)rcblock)[index]);\n\tcase 5:\n\t\treturn be32toh(((uint32_t *)rcblock)[index]);\n\tcase 6:\n\t\treturn be64toh(((uint64_t *)rcblock)[index]);\n\tdefault:\n\t\tassert(0);\n\t}\n\n\treturn 0;\t/* NOT REACHED */\n}", "target": 0, "cwe": ["CWE-200"], "project": "tcmu-runner", "commit_id": "8cf8208775022301adaa59c240bb7f93742d1329", "hash": 291817453581850792233337297081390576800, "size": 23, "message": "removed all check_config callback implementations to avoid security issues\n\nsee github issue #194\n\nqcow.c contained an information leak, could test for existance of any\nfile in the system\n\nfile_example.c and file_optical.c allow also to test for existance of\nany file, plus to temporarily create empty new files anywhere in the\nfile system. This also involves a race condition, if a file didn't exist\nin the first place, but would be created in-between by some other\nprocess, then the file would be deleted by the check_config\nimplementation.", "idx": 886}
{"func": "static int jpc_enc_encodemainbody(jpc_enc_t *enc)\n{\n\tint tileno;\n\tint tilex;\n\tint tiley;\n\tint i;\n\tjpc_sot_t *sot;\n\tjpc_enc_tcmpt_t *comp;\n\tjpc_enc_tcmpt_t *endcomps;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_rlvl_t *lvl;\n\tint rlvlno;\n\tjpc_qcc_t *qcc;\n\tjpc_cod_t *cod;\n\tint adjust;\n\tint j;\n\tint absbandno;\n\tlong numbytes;\n\tlong tilehdrlen;\n\tlong tilelen;\n\tjpc_enc_tile_t *tile;\n\tjpc_enc_cp_t *cp;\n\tdouble rho;\n\tint lyrno;\n\tint cmptno;\n\tint samestepsizes;\n\tjpc_enc_ccp_t *ccps;\n\tjpc_enc_tccp_t *tccp;\n\tint bandno;\n\tuint_fast32_t x;\n\tuint_fast32_t y;\n\tint mingbits;\n\tint actualnumbps;\n\tjpc_fix_t mxmag;\n\tjpc_fix_t mag;\n\tint numgbits;\n\n\tcp = enc->cp;\n\n\t/* Avoid compile warnings. */\n\tnumbytes = 0;\n\n\tfor (tileno = 0; tileno < JAS_CAST(int, cp->numtiles); ++tileno) {\n\t\ttilex = tileno % cp->numhtiles;\n\t\ttiley = tileno / cp->numhtiles;\n\n\t\tif (!(enc->curtile = jpc_enc_tile_create(enc->cp, enc->image,\n\t\t  tileno))) {\n\t\t\tjas_eprintf(\"cannot create tile\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\ttile = enc->curtile;\n\n\t\tif (jas_getdbglevel() >= 10) {\n\t\t\tjpc_enc_dump(enc);\n\t\t}\n\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (cmptno = 0, comp = tile->tcmpts; cmptno < tile->numtcmpts; ++cmptno, ++comp) {\n\t\t\tif (!cp->ccps[cmptno].sgnd) {\n\t\t\t\tadjust = 1 << (cp->ccps[cmptno].prec - 1);\n\t\t\t\tfor (i = 0; i < jas_matrix_numrows(comp->data); ++i) {\n\t\t\t\t\tfor (j = 0; j < jas_matrix_numcols(comp->data); ++j) {\n\t\t\t\t\t\t*jas_matrix_getref(comp->data, i, j) -= adjust;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!tile->intmode) {\n\t\t\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\t\t\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\t\t\t\tjas_matrix_asl(comp->data, JPC_FIX_FRACBITS);\n\t\t\t\t}\n\t\t}\n\n\t\tswitch (tile->mctid) {\n\t\tcase JPC_MCT_RCT:\nassert(jas_image_numcmpts(enc->image) == 3);\n\t\t\tjpc_rct(tile->tcmpts[0].data, tile->tcmpts[1].data,\n\t\t\t  tile->tcmpts[2].data);\n\t\t\tbreak;\n\t\tcase JPC_MCT_ICT:\nassert(jas_image_numcmpts(enc->image) == 3);\n\t\t\tjpc_ict(tile->tcmpts[0].data, tile->tcmpts[1].data,\n\t\t\t  tile->tcmpts[2].data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < jas_image_numcmpts(enc->image); ++i) {\n\t\t\tcomp = &tile->tcmpts[i];\n\t\t\tjpc_tsfb_analyze(comp->tsfb, comp->data);\n\n\t\t}\n\n\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (cmptno = 0, comp = tile->tcmpts; comp != endcomps; ++cmptno, ++comp) {\n\t\t\tmingbits = 0;\n\t\t\tabsbandno = 0;\n\t\t\t/* All bands must have a corresponding quantizer step size,\n\t\t\t  even if they contain no samples and are never coded. */\n\t\t\t/* Some bands may not be hit by the loop below, so we must\n\t\t\t  initialize all of the step sizes to a sane value. */\n\t\t\tmemset(comp->stepsizes, 0, sizeof(comp->stepsizes));\n\t\t\tfor (rlvlno = 0, lvl = comp->rlvls; rlvlno < comp->numrlvls; ++rlvlno, ++lvl) {\n\t\t\t\tif (!lvl->bands) {\n\t\t\t\t\tabsbandno += rlvlno ? 3 : 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\t\tif (!band->data) {\n\t\t\t\t\t\t++absbandno;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tactualnumbps = 0;\n\t\t\t\t\tmxmag = 0;\n\t\t\t\t\tfor (y = 0; y < JAS_CAST(uint_fast32_t, jas_matrix_numrows(band->data)); ++y) {\n\t\t\t\t\t\tfor (x = 0; x < JAS_CAST(uint_fast32_t, jas_matrix_numcols(band->data)); ++x) {\n\t\t\t\t\t\t\tmag = JAS_ABS(jas_matrix_get(band->data, y, x));\n\t\t\t\t\t\t\tif (mag > mxmag) {\n\t\t\t\t\t\t\t\tmxmag = mag;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (tile->intmode) {\n\t\t\t\t\t\tactualnumbps = jpc_fix_firstone(mxmag) + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactualnumbps = jpc_fix_firstone(mxmag) + 1 - JPC_FIX_FRACBITS;\n\t\t\t\t\t}\n\t\t\t\t\tnumgbits = actualnumbps - (cp->ccps[cmptno].prec - 1 +\n\t\t\t\t\t  band->analgain);\n#if 0\njas_eprintf(\"%d %d mag=%d actual=%d numgbits=%d\\n\", cp->ccps[cmptno].prec, band->analgain, mxmag, actualnumbps, numgbits);\n#endif\n\t\t\t\t\tif (numgbits > mingbits) {\n\t\t\t\t\t\tmingbits = numgbits;\n\t\t\t\t\t}\n\t\t\t\t\tif (!tile->intmode) {\n\t\t\t\t\t\tband->absstepsize = jpc_fix_div(jpc_inttofix(1\n\t\t\t\t\t\t  << (band->analgain + 1)),\n\t\t\t\t\t\t  band->synweight);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tband->absstepsize = jpc_inttofix(1);\n\t\t\t\t\t}\n\t\t\t\t\tband->stepsize = jpc_abstorelstepsize(\n\t\t\t\t\t  band->absstepsize, cp->ccps[cmptno].prec +\n\t\t\t\t\t  band->analgain);\n\t\t\t\t\tband->numbps = cp->tccp.numgbits +\n\t\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\n\t\t\t\t\tif ((!tile->intmode) && band->data) {\n\t\t\t\t\t\tjpc_quantize(band->data, band->absstepsize);\n\t\t\t\t\t}\n\n\t\t\t\t\tcomp->stepsizes[absbandno] = band->stepsize;\n\t\t\t\t\t++absbandno;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert(JPC_FIX_FRACBITS >= JPC_NUMEXTRABITS);\n\t\t\tif (!tile->intmode) {\n\t\t\t\tjas_matrix_divpow2(comp->data, JPC_FIX_FRACBITS - JPC_NUMEXTRABITS);\n\t\t\t} else {\n\t\t\t\tjas_matrix_asl(comp->data, JPC_NUMEXTRABITS);\n\t\t\t}\n\n#if 0\njas_eprintf(\"mingbits %d\\n\", mingbits);\n#endif\n\t\t\tif (mingbits > cp->tccp.numgbits) {\n\t\t\t\tjas_eprintf(\"error: too few guard bits (need at least %d)\\n\",\n\t\t\t\t  mingbits);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!(enc->tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tjas_eprintf(\"cannot open tmp file\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Write the tile header. */\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOT))) {\n\t\t\treturn -1;\n\t\t}\n\t\tsot = &enc->mrk->parms.sot;\n\t\tsot->len = 0;\n\t\tsot->tileno = tileno;\n\t\tsot->partno = 0;\n\t\tsot->numparts = 1;\n\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write SOT marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\ttccp = &cp->tccp;\n\t\tfor (cmptno = 0; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno) {\n\t\t\tcomp = &tile->tcmpts[cmptno];\n\t\t\tif (comp->numrlvls != tccp->maxrlvls) {\n\t\t\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n/* XXX = this is not really correct. we are using comp #0's precint sizes\nand other characteristics */\n\t\t\t\tcomp = &tile->tcmpts[0];\n\t\t\t\tcod = &enc->mrk->parms.cod;\n\t\t\t\tcod->compparms.csty = 0;\n\t\t\t\tcod->compparms.numdlvls = comp->numrlvls - 1;\n\t\t\t\tcod->prg = tile->prg;\n\t\t\t\tcod->numlyrs = tile->numlyrs;\n\t\t\t\tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(comp->cblkwidthexpn);\n\t\t\t\tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(comp->cblkheightexpn);\n\t\t\t\tcod->compparms.cblksty = comp->cblksty;\n\t\t\t\tcod->compparms.qmfbid = comp->qmfbid;\n\t\t\t\tcod->mctrans = (tile->mctid != JPC_MCT_NONE);\n\t\t\t\tfor (i = 0; i < comp->numrlvls; ++i) {\n\t\t\t\t\tcod->compparms.rlvls[i].parwidthval = comp->rlvls[i].prcwidthexpn;\n\t\t\t\t\tcod->compparms.rlvls[i].parheightval = comp->rlvls[i].prcheightexpn;\n\t\t\t\t}\n\t\t\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjpc_ms_destroy(enc->mrk);\n\t\t\t\tenc->mrk = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (cmptno = 0, comp = tile->tcmpts; cmptno < JAS_CAST(int,\n\t\t  cp->numcmpts); ++cmptno, ++comp) {\n\t\t\tccps = &cp->ccps[cmptno];\n\t\t\tif (JAS_CAST(int, ccps->numstepsizes) == comp->numstepsizes) {\n\t\t\t\tsamestepsizes = 1;\n\t\t\t\tfor (bandno = 0; bandno < JAS_CAST(int, ccps->numstepsizes);\n\t\t\t\t  ++bandno) {\n\t\t\t\t\tif (ccps->stepsizes[bandno] != comp->stepsizes[bandno]) {\n\t\t\t\t\t\tsamestepsizes = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsamestepsizes = 0;\n\t\t\t}\n\t\t\tif (!samestepsizes) {\n\t\t\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tqcc = &enc->mrk->parms.qcc;\n\t\t\t\tqcc->compno = cmptno;\n\t\t\t\tqcc->compparms.numguard = cp->tccp.numgbits;\n\t\t\t\tqcc->compparms.qntsty = (comp->qmfbid == JPC_COX_INS) ?\n\t\t\t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\t\t\t\tqcc->compparms.numstepsizes = comp->numstepsizes;\n\t\t\t\tqcc->compparms.stepsizes = comp->stepsizes;\n\t\t\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tqcc->compparms.stepsizes = 0;\n\t\t\t\tjpc_ms_destroy(enc->mrk);\n\t\t\t\tenc->mrk = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* Write a SOD marker to indicate the end of the tile header. */\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOD))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write SOD marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\t\ttilehdrlen = jas_stream_getrwcount(enc->tmpstream);\n\t\tassert(tilehdrlen >= 0);\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\tif (jpc_enc_enccblks(enc)) {\n\t\t\tabort();\n\t\t\treturn -1;\n\t\t}\n\n\t\tcp = enc->cp;\n\t\trho = (double) (tile->brx - tile->tlx) * (tile->bry - tile->tly) /\n\t\t  ((cp->refgrdwidth - cp->imgareatlx) * (cp->refgrdheight -\n\t\t  cp->imgareatly));\n\t\ttile->rawsize = cp->rawsize * rho;\n\n\t\tfor (lyrno = 0; lyrno < tile->numlyrs - 1; ++lyrno) {\n\t\t\ttile->lyrsizes[lyrno] = tile->rawsize * jpc_fixtodbl(\n\t\t\t  cp->tcp.ilyrrates[lyrno]);\n\t\t}\n#if !defined(__clang__)\n\t\t// WARNING:\n\t\t// Some versions of Clang (e.g., 3.7.1 and 3.8.1) appear to generate\n\t\t// incorrect code for the following line.\n\t\ttile->lyrsizes[tile->numlyrs - 1] =\n\t\t  (cp->totalsize != UINT_FAST32_MAX) ?\n\t\t  (rho * enc->mainbodysize) : UINT_FAST32_MAX;\n#else\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\ttile->lyrsizes[tile->numlyrs - 1] = (rho * enc->mainbodysize);\n\t\t} else {\n\t\t\ttile->lyrsizes[tile->numlyrs - 1] = UINT_FAST32_MAX;\n\t\t}\n#endif\n//jas_eprintf(\"TESTING %ld %ld\\n\", cp->totalsize != UINT_FAST32_MAX, tile->lyrsizes[0]);\n\t\tfor (lyrno = 0; lyrno < tile->numlyrs; ++lyrno) {\n\t\t\tif (tile->lyrsizes[lyrno] != UINT_FAST32_MAX) {\n\t\t\t\tif (JAS_CAST(uint_fast32_t, tilehdrlen) <= tile->lyrsizes[lyrno]) {\n\t\t\t\t\ttile->lyrsizes[lyrno] -= tilehdrlen;\n\t\t\t\t} else {\n\t\t\t\t\ttile->lyrsizes[lyrno] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rateallocate(enc, tile->numlyrs, tile->lyrsizes)) {\n\t\t\treturn -1;\n\t\t}\n\n#if 0\njas_eprintf(\"ENCODE TILE DATA\\n\");\n#endif\n\t\tif (jpc_enc_encodetiledata(enc)) {\n\t\t\tjas_eprintf(\"dotile failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\ttilelen = jas_stream_tell(enc->tmpstream);\n\n\t\tif (jas_stream_seek(enc->tmpstream, 6, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_putuint32(enc->tmpstream, tilelen);\n\n\t\tif (jas_stream_seek(enc->tmpstream, 0, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_putdata(enc->out, enc->tmpstream, -1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tenc->len += tilelen;\n\n\t\tjas_stream_close(enc->tmpstream);\n\t\tenc->tmpstream = 0;\n\n\t\tjpc_enc_tile_destroy(enc->curtile);\n\t\tenc->curtile = 0;\n\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-617"], "project": "jasper", "commit_id": "6cd1e1d8aff56d0d86d4e7d1e7e3e4dd1c64b55d", "hash": 105826705517471886253164813726207324070, "size": 376, "message": "jpc_enc: jpc_abstorelstepsize() returns error instead of aborting\n\nFixes CVE-2018-9252\n\nCloses https://github.com/jasper-maint/jasper/issues/16", "idx": 887}
{"func": "g_file_unmount_mountable_with_operation (GFile               *file,\n                                         GMountUnmountFlags   flags,\n                                         GMountOperation     *mount_operation,\n                                         GCancellable        *cancellable,\n                                         GAsyncReadyCallback  callback,\n                                         gpointer             user_data)\n{\n  GFileIface *iface;\n\n  g_return_if_fail (G_IS_FILE (file));\n\n  iface = G_FILE_GET_IFACE (file);\n\n  if (iface->unmount_mountable == NULL && iface->unmount_mountable_with_operation == NULL)\n    {\n      g_task_report_new_error (file, callback, user_data,\n                               g_file_unmount_mountable_with_operation,\n                               G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n                               _(\"Operation not supported\"));\n      return;\n    }\n\n  if (iface->unmount_mountable_with_operation != NULL)\n    (* iface->unmount_mountable_with_operation) (file,\n                                                 flags,\n                                                 mount_operation,\n                                                 cancellable,\n                                                 callback,\n                                                 user_data);\n  else\n    (* iface->unmount_mountable) (file,\n                                  flags,\n                                  cancellable,\n                                  callback,\n                                  user_data);\n}", "target": 0, "cwe": ["CWE-362"], "project": "glib", "commit_id": "d8f8f4d637ce43f8699ba94c9b7648beda0ca174", "hash": 280630495664338332557383161492082429823, "size": 36, "message": "gfile: Limit access to files when copying\n\nfile_copy_fallback creates new files with default permissions and\nset the correct permissions after the operation is finished. This\nmight cause that the files can be accessible by more users during\nthe operation than expected. Use G_FILE_CREATE_PRIVATE for the new\nfiles to limit access to those files.", "idx": 888}
{"func": "static void maybe_unmark_and_push(struct sock *x)\n{\n\tstruct unix_sock *u = unix_sk(x);\n\n\tif (u->gc_tree != GC_ORPHAN)\n\t\treturn;\n\tsock_hold(x);\n\tu->gc_tree = gc_current;\n\tgc_current = x;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "1fd05ba5a2f2aa8e7b9b52ef55df850e2e7d54c9", "hash": 75883221676963211260493668825283485461, "size": 10, "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 889}
{"func": "add_update_var_type(regex_t* reg, enum UpdateVarType type)\n{\n  UpdateVarType t = (UpdateVarType )type;\n\n  BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);\n  return 0;\n}", "target": 0, "cwe": ["CWE-476"], "project": "oniguruma", "commit_id": "410f5916429e7d2920e1d4867388514f605413b8", "hash": 163021670699347768414231784995802364872, "size": 7, "message": "fix #87: Read unknown address in onig_error_code_to_str()", "idx": 890}
{"func": "do_unprotect (const char *passphrase,\n              int pkt_version, int pubkey_algo, int is_protected,\n              const char *curve, gcry_mpi_t *skey, size_t skeysize,\n              int protect_algo, void *protect_iv, size_t protect_ivlen,\n              int s2k_mode, int s2k_algo, byte *s2k_salt, u32 s2k_count,\n              u16 desired_csum, gcry_sexp_t *r_key)\n{\n  gpg_error_t err;\n  unsigned int npkey, nskey, skeylen;\n  gcry_cipher_hd_t cipher_hd = NULL;\n  u16 actual_csum;\n  size_t nbytes;\n  int i;\n  gcry_mpi_t tmpmpi;\n\n  *r_key = NULL;\n\n  err = prepare_unprotect (pubkey_algo, skey, skeysize, s2k_mode,\n                           &npkey, &nskey, &skeylen);\n  if (err)\n    return err;\n\n  /* Check whether SKEY is at all protected.  If it is not protected\n     merely verify the checksum.  */\n  if (!is_protected)\n    {\n      actual_csum = 0;\n      for (i=npkey; i < nskey; i++)\n        {\n          if (!skey[i] || gcry_mpi_get_flag (skey[i], GCRYMPI_FLAG_USER1))\n            return gpg_error (GPG_ERR_BAD_SECKEY);\n\n          if (gcry_mpi_get_flag (skey[i], GCRYMPI_FLAG_OPAQUE))\n            {\n              unsigned int nbits;\n              const unsigned char *buffer;\n              buffer = gcry_mpi_get_opaque (skey[i], &nbits);\n              nbytes = (nbits+7)/8;\n              actual_csum += checksum (buffer, nbytes);\n            }\n          else\n            {\n              unsigned char *buffer;\n\n              err = gcry_mpi_aprint (GCRYMPI_FMT_PGP, &buffer, &nbytes,\n                                     skey[i]);\n              if (!err)\n                actual_csum += checksum (buffer, nbytes);\n              xfree (buffer);\n            }\n          if (err)\n            return err;\n        }\n\n      if (actual_csum != desired_csum)\n        return gpg_error (GPG_ERR_CHECKSUM);\n\n      goto do_convert;\n    }\n\n\n  if (gcry_cipher_test_algo (protect_algo))\n    {\n      /* The algorithm numbers are Libgcrypt numbers but fortunately\n         the OpenPGP algorithm numbers map one-to-one to the Libgcrypt\n         numbers.  */\n      log_info (_(\"protection algorithm %d (%s) is not supported\\n\"),\n                protect_algo, gnupg_cipher_algo_name (protect_algo));\n      return gpg_error (GPG_ERR_CIPHER_ALGO);\n    }\n\n  if (gcry_md_test_algo (s2k_algo))\n    {\n      log_info (_(\"protection hash algorithm %d (%s) is not supported\\n\"),\n                s2k_algo, gcry_md_algo_name (s2k_algo));\n      return gpg_error (GPG_ERR_DIGEST_ALGO);\n    }\n\n  err = gcry_cipher_open (&cipher_hd, protect_algo,\n                          GCRY_CIPHER_MODE_CFB,\n                          (GCRY_CIPHER_SECURE\n                           | (protect_algo >= 100 ?\n                              0 : GCRY_CIPHER_ENABLE_SYNC)));\n  if (err)\n    {\n      log_error (\"failed to open cipher_algo %d: %s\\n\",\n                 protect_algo, gpg_strerror (err));\n      return err;\n    }\n\n  err = hash_passphrase_and_set_key (passphrase, cipher_hd, protect_algo,\n                                     s2k_mode, s2k_algo, s2k_salt, s2k_count);\n  if (err)\n    {\n      gcry_cipher_close (cipher_hd);\n      return err;\n    }\n\n  gcry_cipher_setiv (cipher_hd, protect_iv, protect_ivlen);\n\n  actual_csum = 0;\n  if (pkt_version >= 4)\n    {\n      int ndata;\n      unsigned int ndatabits;\n      const unsigned char *p;\n      unsigned char *data;\n      u16 csum_pgp7 = 0;\n\n      if (!gcry_mpi_get_flag (skey[npkey], GCRYMPI_FLAG_OPAQUE ))\n        {\n          gcry_cipher_close (cipher_hd);\n          return gpg_error (GPG_ERR_BAD_SECKEY);\n        }\n      p = gcry_mpi_get_opaque (skey[npkey], &ndatabits);\n      ndata = (ndatabits+7)/8;\n\n      if (ndata > 1)\n        csum_pgp7 = p[ndata-2] << 8 | p[ndata-1];\n      data = xtrymalloc_secure (ndata);\n      if (!data)\n        {\n          err = gpg_error_from_syserror ();\n          gcry_cipher_close (cipher_hd);\n          return err;\n        }\n      gcry_cipher_decrypt (cipher_hd, data, ndata, p, ndata);\n\n      p = data;\n      if (is_protected == 2)\n        {\n          /* This is the new SHA1 checksum method to detect tampering\n             with the key as used by the Klima/Rosa attack.  */\n          desired_csum = 0;\n          actual_csum = 1;  /* Default to bad checksum.  */\n\n          if (ndata < 20)\n            log_error (\"not enough bytes for SHA-1 checksum\\n\");\n          else\n            {\n              gcry_md_hd_t h;\n\n              if (gcry_md_open (&h, GCRY_MD_SHA1, 1))\n                BUG(); /* Algo not available. */\n              gcry_md_write (h, data, ndata - 20);\n              gcry_md_final (h);\n              if (!memcmp (gcry_md_read (h, GCRY_MD_SHA1), data+ndata-20, 20))\n                actual_csum = 0; /* Digest does match.  */\n              gcry_md_close (h);\n            }\n        }\n      else\n        {\n          /* Old 16 bit checksum method.  */\n          if (ndata < 2)\n            {\n              log_error (\"not enough bytes for checksum\\n\");\n              desired_csum = 0;\n              actual_csum = 1;  /* Mark checksum bad.  */\n            }\n          else\n            {\n              desired_csum = (data[ndata-2] << 8 | data[ndata-1]);\n              actual_csum = checksum (data, ndata-2);\n              if (desired_csum != actual_csum)\n                {\n                  /* This is a PGP 7.0.0 workaround */\n                  desired_csum = csum_pgp7; /* Take the encrypted one.  */\n                }\n            }\n        }\n\n      /* Better check it here.  Otherwise the gcry_mpi_scan would fail\n         because the length may have an arbitrary value.  */\n      if (desired_csum == actual_csum)\n        {\n          for (i=npkey; i < nskey; i++ )\n            {\n              if (gcry_mpi_scan (&tmpmpi, GCRYMPI_FMT_PGP, p, ndata, &nbytes))\n                {\n                  /* Checksum was okay, but not correctly decrypted.  */\n                  desired_csum = 0;\n                  actual_csum = 1;   /* Mark checksum bad.  */\n                  break;\n                }\n              gcry_mpi_release (skey[i]);\n              skey[i] = tmpmpi;\n              ndata -= nbytes;\n              p += nbytes;\n            }\n          skey[i] = NULL;\n          skeylen = i;\n          assert (skeylen <= skeysize);\n\n          /* Note: at this point NDATA should be 2 for a simple\n             checksum or 20 for the sha1 digest.  */\n        }\n      xfree(data);\n    }\n  else /* Packet version <= 3.  */\n    {\n      unsigned char *buffer;\n\n      for (i = npkey; i < nskey; i++)\n        {\n          const unsigned char *p;\n          size_t ndata;\n          unsigned int ndatabits;\n\n          if (!skey[i] || !gcry_mpi_get_flag (skey[i], GCRYMPI_FLAG_OPAQUE))\n            {\n              gcry_cipher_close (cipher_hd);\n              return gpg_error (GPG_ERR_BAD_SECKEY);\n            }\n          p = gcry_mpi_get_opaque (skey[i], &ndatabits);\n          ndata = (ndatabits+7)/8;\n\n          if (!(ndata >= 2) || !(ndata == ((p[0] << 8 | p[1]) + 7)/8 + 2))\n            {\n              gcry_cipher_close (cipher_hd);\n              return gpg_error (GPG_ERR_BAD_SECKEY);\n            }\n\n          buffer = xtrymalloc_secure (ndata);\n          if (!buffer)\n            {\n              err = gpg_error_from_syserror ();\n              gcry_cipher_close (cipher_hd);\n              return err;\n            }\n\n          gcry_cipher_sync (cipher_hd);\n          buffer[0] = p[0];\n          buffer[1] = p[1];\n          gcry_cipher_decrypt (cipher_hd, buffer+2, ndata-2, p+2, ndata-2);\n          actual_csum += checksum (buffer, ndata);\n          err = gcry_mpi_scan (&tmpmpi, GCRYMPI_FMT_PGP, buffer, ndata, &ndata);\n          xfree (buffer);\n          if (err)\n            {\n              /* Checksum was okay, but not correctly decrypted.  */\n              desired_csum = 0;\n              actual_csum = 1;   /* Mark checksum bad.  */\n              break;\n            }\n          gcry_mpi_release (skey[i]);\n          skey[i] = tmpmpi;\n        }\n    }\n  gcry_cipher_close (cipher_hd);\n\n  /* Now let's see whether we have used the correct passphrase. */\n  if (actual_csum != desired_csum)\n    return gpg_error (GPG_ERR_BAD_PASSPHRASE);\n\n do_convert:\n  if (nskey != skeylen)\n    err = gpg_error (GPG_ERR_BAD_SECKEY);\n  else\n    err = convert_secret_key (r_key, pubkey_algo, skey, curve);\n  if (err)\n    return err;\n\n  /* The checksum may fail, thus we also check the key itself.  */\n  err = gcry_pk_testkey (*r_key);\n  if (err)\n    {\n      gcry_sexp_release (*r_key);\n      *r_key = NULL;\n      return gpg_error (GPG_ERR_BAD_PASSPHRASE);\n    }\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-20"], "project": "gnupg", "commit_id": "2183683bd633818dd031b090b5530951de76f392", "hash": 54939955585315816430106049516825415452, "size": 274, "message": "Use inline functions to convert buffer data to scalars.\n\n* common/host2net.h (buf16_to_ulong, buf16_to_uint): New.\n(buf16_to_ushort, buf16_to_u16): New.\n(buf32_to_size_t, buf32_to_ulong, buf32_to_uint, buf32_to_u32): New.\n--\n\nCommit 91b826a38880fd8a989318585eb502582636ddd8 was not enough to\navoid all sign extension on shift problems.  Hanno Böck found a case\nwith an invalid read due to this problem.  To fix that once and for\nall almost all uses of \"<< 24\" and \"<< 8\" are changed by this patch to\nuse an inline function from host2net.h.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>", "idx": 891}
{"func": "static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n}", "target": 1, "cwe": [], "project": "kvm", "commit_id": "234f3ce485d54017f15cf5e0699cff4100121601", "hash": 333017737704949136397973456719686534947, "size": 16, "message": "KVM: x86: Emulator fixes for eip canonical checks on near branches\n\nBefore changing rip (during jmp, call, ret, etc.) the target should be asserted\nto be canonical one, as real CPUs do.  During sysret, both target rsp and rip\nshould be canonical. If any of these values is noncanonical, a #GP exception\nshould occur.  The exception to this rule are syscall and sysenter instructions\nin which the assigned rip is checked during the assignment to the relevant\nMSRs.\n\nThis patch fixes the emulator to behave as real CPUs do for near branches.\nFar branches are handled by the next patch.\n\nThis fixes CVE-2014-3647.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 892}
{"func": "void dev_disable_lro(struct net_device *dev)\n{\n\t/*\n\t * If we're trying to disable lro on a vlan device\n\t * use the underlying physical device instead\n\t */\n\tif (is_vlan_dev(dev))\n\t\tdev = vlan_dev_real_dev(dev);\n\n\t/* the same for macvlan devices */\n\tif (netif_is_macvlan(dev))\n\t\tdev = macvlan_dev_real_dev(dev);\n\n\tdev->wanted_features &= ~NETIF_F_LRO;\n\tnetdev_update_features(dev);\n\n\tif (unlikely(dev->features & NETIF_F_LRO))\n\t\tnetdev_WARN(dev, \"failed to disable LRO!\\n\");\n}", "target": 0, "cwe": [], "project": "linux", "commit_id": "7bced397510ab569d31de4c70b39e13355046387", "hash": 172604035455691471007834776637958824600, "size": 19, "message": "net_dma: simple removal\n\nPer commit \"77873803363c net_dma: mark broken\" net_dma is no longer used\nand there is no plan to fix it.\n\nThis is the mechanical removal of bits in CONFIG_NET_DMA ifdef guards.\nReverting the remainder of the net_dma induced changes is deferred to\nsubsequent patches.\n\nMarked for stable due to Roman's report of a memory leak in\ndma_pin_iovec_pages():\n\n    https://lkml.org/lkml/2014/9/3/177\n\nCc: Dave Jiang <dave.jiang@intel.com>\nCc: Vinod Koul <vinod.koul@intel.com>\nCc: David Whipple <whipple@securedatainnovations.ch>\nCc: Alexander Duyck <alexander.h.duyck@intel.com>\nCc: <stable@vger.kernel.org>\nReported-by: Roman Gushchin <klamm@yandex-team.ru>\nAcked-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Dan Williams <dan.j.williams@intel.com>", "idx": 893}
{"func": "CopySendString(CopyState cstate, const char *str)\n{\n\tappendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));\n}", "target": 0, "cwe": ["CWE-209"], "project": "postgres", "commit_id": "804b6b6db4dcfc590a468e7be390738f9f7755fb", "hash": 273074430600933047495991500207531517680, "size": 4, "message": "Fix column-privilege leak in error-message paths\n\nWhile building error messages to return to the user,\nBuildIndexValueDescription, ExecBuildSlotValueDescription and\nri_ReportViolation would happily include the entire key or entire row in\nthe result returned to the user, even if the user didn't have access to\nview all of the columns being included.\n\nInstead, include only those columns which the user is providing or which\nthe user has select rights on.  If the user does not have any rights\nto view the table or any of the columns involved then no detail is\nprovided and a NULL value is returned from BuildIndexValueDescription\nand ExecBuildSlotValueDescription.  Note that, for key cases, the user\nmust have access to all of the columns for the key to be shown; a\npartial key will not be returned.\n\nFurther, in master only, do not return any data for cases where row\nsecurity is enabled on the relation and row security should be applied\nfor the user.  This required a bit of refactoring and moving of things\naround related to RLS- note the addition of utils/misc/rls.c.\n\nBack-patch all the way, as column-level privileges are now in all\nsupported versions.\n\nThis has been assigned CVE-2014-8161, but since the issue and the patch\nhave already been publicized on pgsql-hackers, there's no point in trying\nto hide this commit.", "idx": 894}
{"func": "static int tg3_mdio_init(struct tg3 *tp)\n{\n\tint i;\n\tu32 reg;\n\tstruct phy_device *phydev;\n\n\tif (tg3_flag(tp, 5717_PLUS)) {\n\t\tu32 is_serdes;\n\n\t\ttp->phy_addr = tp->pci_fn + 1;\n\n\t\tif (tg3_chip_rev_id(tp) != CHIPREV_ID_5717_A0)\n\t\t\tis_serdes = tr32(SG_DIG_STATUS) & SG_DIG_IS_SERDES;\n\t\telse\n\t\t\tis_serdes = tr32(TG3_CPMU_PHY_STRAP) &\n\t\t\t\t    TG3_CPMU_PHY_STRAP_IS_SERDES;\n\t\tif (is_serdes)\n\t\t\ttp->phy_addr += 7;\n\t} else\n\t\ttp->phy_addr = TG3_PHY_MII_ADDR;\n\n\ttg3_mdio_start(tp);\n\n\tif (!tg3_flag(tp, USE_PHYLIB) || tg3_flag(tp, MDIOBUS_INITED))\n\t\treturn 0;\n\n\ttp->mdio_bus = mdiobus_alloc();\n\tif (tp->mdio_bus == NULL)\n\t\treturn -ENOMEM;\n\n\ttp->mdio_bus->name     = \"tg3 mdio bus\";\n\tsnprintf(tp->mdio_bus->id, MII_BUS_ID_SIZE, \"%x\",\n\t\t (tp->pdev->bus->number << 8) | tp->pdev->devfn);\n\ttp->mdio_bus->priv     = tp;\n\ttp->mdio_bus->parent   = &tp->pdev->dev;\n\ttp->mdio_bus->read     = &tg3_mdio_read;\n\ttp->mdio_bus->write    = &tg3_mdio_write;\n\ttp->mdio_bus->reset    = &tg3_mdio_reset;\n\ttp->mdio_bus->phy_mask = ~(1 << TG3_PHY_MII_ADDR);\n\ttp->mdio_bus->irq      = &tp->mdio_irq[0];\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++)\n\t\ttp->mdio_bus->irq[i] = PHY_POLL;\n\n\t/* The bus registration will look for all the PHYs on the mdio bus.\n\t * Unfortunately, it does not ensure the PHY is powered up before\n\t * accessing the PHY ID registers.  A chip reset is the\n\t * quickest way to bring the device back to an operational state..\n\t */\n\tif (tg3_readphy(tp, MII_BMCR, &reg) || (reg & BMCR_PDOWN))\n\t\ttg3_bmcr_reset(tp);\n\n\ti = mdiobus_register(tp->mdio_bus);\n\tif (i) {\n\t\tdev_warn(&tp->pdev->dev, \"mdiobus_reg failed (0x%x)\\n\", i);\n\t\tmdiobus_free(tp->mdio_bus);\n\t\treturn i;\n\t}\n\n\tphydev = tp->mdio_bus->phy_map[TG3_PHY_MII_ADDR];\n\n\tif (!phydev || !phydev->drv) {\n\t\tdev_warn(&tp->pdev->dev, \"No PHY devices\\n\");\n\t\tmdiobus_unregister(tp->mdio_bus);\n\t\tmdiobus_free(tp->mdio_bus);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (phydev->drv->phy_id & phydev->drv->phy_id_mask) {\n\tcase PHY_ID_BCM57780:\n\t\tphydev->interface = PHY_INTERFACE_MODE_GMII;\n\t\tphydev->dev_flags |= PHY_BRCM_AUTO_PWRDWN_ENABLE;\n\t\tbreak;\n\tcase PHY_ID_BCM50610:\n\tcase PHY_ID_BCM50610M:\n\t\tphydev->dev_flags |= PHY_BRCM_CLEAR_RGMII_MODE |\n\t\t\t\t     PHY_BRCM_RX_REFCLK_UNUSED |\n\t\t\t\t     PHY_BRCM_DIS_TXCRXC_NOENRGY |\n\t\t\t\t     PHY_BRCM_AUTO_PWRDWN_ENABLE;\n\t\tif (tg3_flag(tp, RGMII_INBAND_DISABLE))\n\t\t\tphydev->dev_flags |= PHY_BRCM_STD_IBND_DISABLE;\n\t\tif (tg3_flag(tp, RGMII_EXT_IBND_RX_EN))\n\t\t\tphydev->dev_flags |= PHY_BRCM_EXT_IBND_RX_ENABLE;\n\t\tif (tg3_flag(tp, RGMII_EXT_IBND_TX_EN))\n\t\t\tphydev->dev_flags |= PHY_BRCM_EXT_IBND_TX_ENABLE;\n\t\t/* fallthru */\n\tcase PHY_ID_RTL8211C:\n\t\tphydev->interface = PHY_INTERFACE_MODE_RGMII;\n\t\tbreak;\n\tcase PHY_ID_RTL8201E:\n\tcase PHY_ID_BCMAC131:\n\t\tphydev->interface = PHY_INTERFACE_MODE_MII;\n\t\tphydev->dev_flags |= PHY_BRCM_AUTO_PWRDWN_ENABLE;\n\t\ttp->phy_flags |= TG3_PHYFLG_IS_FET;\n\t\tbreak;\n\t}\n\n\ttg3_flag_set(tp, MDIOBUS_INITED);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5785)\n\t\ttg3_mdio_config_5785(tp);\n\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-476", "CWE-119"], "project": "linux", "commit_id": "715230a44310a8cf66fbfb5a46f9a62a9b2de424", "hash": 283350638191163327563442958665318126562, "size": 104, "message": "tg3: fix length overflow in VPD firmware parsing\n\nCommit 184b89044fb6e2a74611dafa69b1dce0d98612c6 (\"tg3: Use VPD fw version\nwhen present\") introduced VPD parsing that contained a potential length\noverflow.\n\nLimit the hardware's reported firmware string length (max 255 bytes) to\nstay inside the driver's firmware string length (32 bytes). On overflow,\ntruncate the formatted firmware string instead of potentially overwriting\nportions of the tg3 struct.\n\nhttp://cansecwest.com/slides/2013/PrivateCore%20CSW%202013.pdf\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nReported-by: Oded Horovitz <oded@privatecore.com>\nReported-by: Brad Spengler <spender@grsecurity.net>\nCc: stable@vger.kernel.org\nCc: Matt Carlson <mcarlson@broadcom.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 895}
{"func": "struct dump_dir *dd_create(const char *dir, uid_t uid, mode_t mode)\n{\n    /* a little trick to copy read bits from file mode to exec bit of dir mode*/\n    mode_t dir_mode = mode | ((mode & 0444) >> 2);\n    struct dump_dir *dd = dd_init();\n\n    dd->mode = mode;\n\n    /* Unlike dd_opendir, can't use realpath: the directory doesn't exist yet,\n     * realpath will always return NULL. We don't really have to:\n     * dd_opendir(\".\") makes sense, dd_create(\".\") does not.\n     */\n    dir = dd->dd_dirname = rm_trailing_slashes(dir);\n\n    const char *last_component = strrchr(dir, '/');\n    if (last_component)\n        last_component++;\n    else\n        last_component = dir;\n    if (dot_or_dotdot(last_component))\n    {\n        /* dd_create(\".\"), dd_create(\"..\"), dd_create(\"dir/.\"),\n         * dd_create(\"dir/..\") and similar are madness, refuse them.\n         */\n        error_msg(\"Bad dir name '%s'\", dir);\n        dd_close(dd);\n        return NULL;\n    }\n\n    /* Was creating it with mode 0700 and user as the owner, but this allows\n     * the user to replace any file in the directory, changing security-sensitive data\n     * (e.g. \"uid\", \"analyzer\", \"executable\")\n     */\n    if (g_mkdir_with_parents(dd->dd_dirname, dir_mode) != 0)\n    {\n        perror_msg(\"Can't create directory '%s'\", dir);\n        dd_close(dd);\n        return NULL;\n    }\n\n    if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)\n    {\n        dd_close(dd);\n        return NULL;\n    }\n\n    /* mkdir's mode (above) can be affected by umask, fix it */\n    if (chmod(dir, dir_mode) == -1)\n    {\n        perror_msg(\"Can't change mode of '%s'\", dir);\n        dd_close(dd);\n        return NULL;\n    }\n\n    dd->dd_uid = (uid_t)-1L;\n    dd->dd_gid = (gid_t)-1L;\n    if (uid != (uid_t)-1L)\n    {\n        /* Get ABRT's user id */\n        dd->dd_uid = 0;\n        struct passwd *pw = getpwnam(\"abrt\");\n        if (pw)\n            dd->dd_uid = pw->pw_uid;\n        else\n            error_msg(\"user 'abrt' does not exist, using uid 0\");\n\n        /* Get crashed application's group id */\n        /*dd->dd_gid = 0; - dd_init did this already */\n        pw = getpwuid(uid);\n        if (pw)\n            dd->dd_gid = pw->pw_gid;\n        else\n            error_msg(\"User %lu does not exist, using gid 0\", (long)uid);\n\n        if (chown(dir, dd->dd_uid, dd->dd_gid) == -1)\n        {\n            perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dir,\n                       (long)dd->dd_uid, (long)dd->dd_gid);\n        }\n    }\n\n    return dd;\n}", "target": 1, "cwe": ["CWE-264"], "project": "libreport", "commit_id": "3bbf961b1884dd32654dd39b360dd78ef294b10a", "hash": 1656038694107171846388044690601905728, "size": 83, "message": "never follow symlinks rhbz#887866\n\n- use lchown instead chown and O_NOFOLLOW where we use open", "idx": 896}
{"func": "        static int on_method(http_parser* self_)\n        {\n            HTTPParser* self = static_cast<HTTPParser*>(self_);\n            self->req.method = static_cast<HTTPMethod>(self->method);\n\n            return 0;\n        }", "target": 0, "cwe": ["CWE-416"], "project": "Crow", "commit_id": "fba01dc76d6ea940ad7c8392e8f39f9647241d8e", "hash": 91839871143478126295602758348803176247, "size": 7, "message": "Prevent HTTP pipelining which Crow doesn't support.", "idx": 897}
{"func": "static gboolean DecodeHeader(unsigned char *BFH, unsigned char *BIH,\n                             struct bmp_progressive_state *State,\n                             GError **error)\n{\n\tgint clrUsed;\n\tguint bytesPerPixel;\n\n\t/* First check for the two first bytes content. A sane\n\t   BMP file must start with bytes 0x42 0x4D.  */\n\tif (*BFH != 0x42 || *(BFH + 1) != 0x4D) {\n\t\tg_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"BMP image has bogus header data\"));\n\t\tState->read_state = READ_STATE_ERROR;\n\t\treturn FALSE;\n\t}\n\n        /* FIXME this is totally unrobust against bogus image data. */\n\tif (State->BufferSize < lsb_32 (&BIH[0]) + 14) {\n\t\tState->BufferSize = lsb_32 (&BIH[0]) + 14;\n\t\tif (!grow_buffer (State, error))\n\t\t\treturn FALSE;\n\t\treturn TRUE;\n\t}\n\n#if DUMPBIH\n\tDumpBIH(BIH);\n#endif    \n\n\tState->Header.size = lsb_32 (&BIH[0]);\n\tif (State->Header.size == 124) {\n                /* BMP v5 */\n\t\tState->Header.width = lsb_32 (&BIH[4]);\n\t\tState->Header.height = lsb_32 (&BIH[8]);\n\t\tState->Header.depth = lsb_16 (&BIH[14]);\n\t\tState->Compressed = lsb_32 (&BIH[16]);\n\t} else if (State->Header.size == 108) {\n                /* BMP v4 */\n\t\tState->Header.width = lsb_32 (&BIH[4]);\n\t\tState->Header.height = lsb_32 (&BIH[8]);\n\t\tState->Header.depth = lsb_16 (&BIH[14]);\n\t\tState->Compressed = lsb_32 (&BIH[16]);\n\t} else if (State->Header.size == 64) {\n                /* BMP OS/2 v2 */\n\t\tState->Header.width = lsb_32 (&BIH[4]);\n\t\tState->Header.height = lsb_32 (&BIH[8]);\n\t\tState->Header.depth = lsb_16 (&BIH[14]);\n\t\tState->Compressed = lsb_32 (&BIH[16]);\n\t} else if (State->Header.size == 40) {\n                /* BMP v3 */ \n\t\tState->Header.width = lsb_32 (&BIH[4]);\n\t\tState->Header.height = lsb_32 (&BIH[8]);\n\t\tState->Header.depth = lsb_16 (&BIH[14]);\n\t\tState->Compressed = lsb_32 (&BIH[16]);\n\t} else if (State->Header.size == 12) {\n                /* BMP OS/2 */\n\t\tState->Header.width = lsb_16 (&BIH[4]);\n\t\tState->Header.height = lsb_16 (&BIH[6]);\n\t\tState->Header.depth = lsb_16 (&BIH[10]);\n\t\tState->Compressed = BI_RGB;\n\t} else {\n\t\tg_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"BMP image has unsupported header size\"));\n\t\tState->read_state = READ_STATE_ERROR;\n\t\treturn FALSE;\n\t}\n\n        if (State->Header.depth > 32)\n          {\n\t\tg_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"BMP image has unsupported depth\"));\n\t\tState->read_state = READ_STATE_ERROR;\n\t\treturn FALSE;\n          }\n\n\tif (State->Header.size == 12)\n\t\tclrUsed = 1 << State->Header.depth;\n\telse\n\t\tclrUsed = (int) (BIH[35] << 24) + (BIH[34] << 16) + (BIH[33] << 8) + (BIH[32]);\n\n        if (clrUsed > (1 << State->Header.depth))\n          {\n\t\tg_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"BMP image has oversize palette\"));\n\t\tState->read_state = READ_STATE_ERROR;\n\t\treturn FALSE;\n          }\n\n\tif (clrUsed != 0)\n\t\tState->Header.n_colors = clrUsed;\n\telse\n            State->Header.n_colors = (1 << State->Header.depth);\n\n\tState->Type = State->Header.depth;\t/* This may be less trivial someday */\n\n\t/* Negative heights indicates bottom-down pixelorder */\n\tif (State->Header.height < 0) {\n\t\tState->Header.height = -State->Header.height;\n\t\tState->Header.Negative = 1;\n\t}\n\n\tif (State->Header.Negative && \n\t    (State->Compressed != BI_RGB && State->Compressed != BI_BITFIELDS))\n\t{\n\t\tg_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"Topdown BMP images cannot be compressed\"));\n\t\tState->read_state = READ_STATE_ERROR;\n\t\treturn FALSE;\n\t}\n\n\tif (State->Header.width <= 0 || State->Header.height == 0 ||\n\t    (State->Compressed == BI_RLE4 && State->Type != 4)    ||\n\t    (State->Compressed == BI_RLE8 && State->Type != 8)\t  ||\n\t    (State->Compressed == BI_BITFIELDS && !(State->Type == 16 || State->Type == 32)) ||\n\t    (State->Compressed > BI_BITFIELDS)) {\n\t\tg_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"BMP image has bogus header data\"));\n\t\tState->read_state = READ_STATE_ERROR;\n\t\treturn FALSE;\n\t}\n\n\tif ((State->Type >= 8) && (State->Type <= 32) && (State->Type % 8 == 0)) {\n\t\tbytesPerPixel = State->Type / 8;\n\t\tState->LineWidth = State->Header.width * bytesPerPixel;\n\t\tif (State->Header.width != State->LineWidth / bytesPerPixel) {\n\t\t\tg_set_error_literal (error,\n\t\t\t\t\t     GDK_PIXBUF_ERROR,\n\t\t\t\t\t     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n\t\t\t\t\t     _(\"BMP image width too large\"));\n\t\t\treturn FALSE;\n\t\t}\n\t} else if (State->Type == 4)\n\t\tState->LineWidth = (State->Header.width + 1) / 2;\n\telse if (State->Type == 1) {\n\t\tState->LineWidth = State->Header.width / 8;\n\t\tif ((State->Header.width & 7) != 0)\n\t\t\tState->LineWidth++;\n\t} else {\n\t\tg_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"BMP image has bogus header data\"));\n\t\tState->read_state = READ_STATE_ERROR;\n\t\treturn FALSE;\n\t}\n\n\t/* Pad to a 32 bit boundary */\n\tif (((State->LineWidth % 4) > 0)\n\t    && (State->Compressed == BI_RGB || State->Compressed == BI_BITFIELDS))\n\t\tState->LineWidth = (State->LineWidth / 4) * 4 + 4;\n\n\tif (State->pixbuf == NULL) {\n\t\tif (State->size_func) {\n\t\t\tgint width = State->Header.width;\n\t\t\tgint height = State->Header.height;\n\n\t\t\t(*State->size_func) (&width, &height, State->user_data);\n\t\t\tif (width == 0 || height == 0) {\n\t\t\t\tState->read_state = READ_STATE_DONE;\n\t\t\t\tState->BufferSize = 0;\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (State->Type == 32 || \n\t\t    State->Compressed == BI_RLE4 || \n\t\t    State->Compressed == BI_RLE8)\n\t\t\tState->pixbuf =\n\t\t\t\tgdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8,\n\t\t\t\t\t       (gint) State->Header.width,\n\t\t\t\t\t       (gint) State->Header.height);\n\t\telse\n\t\t\tState->pixbuf =\n\t\t\t\tgdk_pixbuf_new(GDK_COLORSPACE_RGB, FALSE, 8,\n\t\t\t\t\t       (gint) State->Header.width,\n\t\t\t\t\t       (gint) State->Header.height);\n\t\t\n\t\tif (State->pixbuf == NULL) {\n\t\t\tg_set_error_literal (error,\n                                             GDK_PIXBUF_ERROR,\n                                             GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                                             _(\"Not enough memory to load bitmap image\"));\n\t\t\tState->read_state = READ_STATE_ERROR;\n\t\t\treturn FALSE;\n\t\t\t}\n\t\t\n\t\tif (State->prepared_func != NULL)\n\t\t\t/* Notify the client that we are ready to go */\n\t\t\t(*State->prepared_func) (State->pixbuf, NULL, State->user_data);\n\t\t\n\t\t/* make all pixels initially transparent */\n\t\tif (State->Compressed == BI_RLE4 || State->Compressed == BI_RLE8) {\n\t\t\tmemset (State->pixbuf->pixels, 0, State->pixbuf->rowstride * State->Header.height);\n\t\t\tState->compr.p = State->pixbuf->pixels \n\t\t\t\t+ State->pixbuf->rowstride * (State->Header.height- 1);\n\t\t}\n\t}\n\t\n\tState->BufferDone = 0;\n\tif (State->Type <= 8) {\n                gint samples;\n\n\t\tState->read_state = READ_STATE_PALETTE;\n\n\t\t/* Allocate enough to hold the palette */\n\t        samples = (State->Header.size == 12 ? 3 : 4);\n\t\tState->BufferSize = State->Header.n_colors * samples;\n\n\t\t/* Skip over everything between the palette and the data.\n\t\t   This protects us against a malicious BFH[10] value.\n                */\n\t\tState->BufferPadding = (lsb_32 (&BFH[10]) - 14 - State->Header.size) - State->BufferSize;\n\n\t} else if (State->Compressed == BI_RGB) {\n\t\tif (State->BufferSize < lsb_32 (&BFH[10]))\n\t\t{\n\t\t\t/* skip over padding between headers and image data */\n\t\t\tState->read_state = READ_STATE_HEADERS;\n\t\t\tState->BufferDone = State->BufferSize;\n\t\t\tState->BufferSize = lsb_32 (&BFH[10]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tState->read_state = READ_STATE_DATA;\n\t\t\tState->BufferSize = State->LineWidth;\n\t\t}\n\t} else if (State->Compressed == BI_BITFIELDS) {\n               if (State->Header.size == 108 || State->Header.size == 124) \n               {\n\t\t\t/* v4 and v5 have the bitmasks in the header */\n\t\t\tif (!decode_bitmasks (&BIH[40], State, error)) {\n\t\t\t       State->read_state = READ_STATE_ERROR;\n\t\t\t       return FALSE;\n                        }\n               }\n               else \n               {\n\t\t       State->read_state = READ_STATE_BITMASKS;\n\t\t       State->BufferSize = 12;\n               }\n\t} else {\n\t\tg_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"BMP image has bogus header data\"));\n\t\tState->read_state = READ_STATE_ERROR;\n\t\treturn FALSE;\n\t}\n\n\tif (!grow_buffer (State, error)) \n\t\treturn FALSE;\n\n        return TRUE;\n}", "target": 0, "cwe": [], "project": "gdk-pixbuf", "commit_id": "779429ce34e439c01d257444fe9d6739e72a2024", "hash": 39394730753267252292471537468836926157, "size": 265, "message": "bmp: Detect integer overflow of the line width\n\nInstead of risking crashes or OOM, return an error if\nwe detect integer overflow.\n\nThe commit also includes a test image that triggers\nthis overflow when used with pixbuf-read.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=768738", "idx": 898}
{"func": "int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n    buffer_verify(buffer);\n\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (buffer->used + len < len) {\n        return -1;\n    }\n\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return -1;\n        }\n    }\n\n    memcpy(buffer->data + buffer->used, data, len);\n    buffer->used += len;\n    buffer_verify(buffer);\n    return 0;\n}", "target": 1, "cwe": ["CWE-476"], "project": "libssh-mirror", "commit_id": "245ad744b5ab0582fef7cf3905a717b791d7e08b", "hash": 76183384846249302511818610102621201456, "size": 26, "message": "buffer: Add NULL check for 'buffer' argument\n\nSigned-off-by: Andreas Schneider <asn@cryptomilk.org>\nReviewed-by: Anderson Toshiyuki Sasaki <ansasaki@redhat.com>\nReviewed-by: Jakub Jelen <jjelen@redhat.com>", "idx": 899}
{"func": "mpls_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\tconst u_char *p;\n\tuint32_t label_entry;\n\tuint16_t label_stack_depth = 0;\n\tenum mpls_packet_type pt = PT_UNKNOWN;\n\n\tp = bp;\n\tND_PRINT((ndo, \"MPLS\"));\n\tdo {\n\t\tND_TCHECK2(*p, sizeof(label_entry));\n\t\tif (length < sizeof(label_entry)) {\n\t\t\tND_PRINT((ndo, \"[|MPLS], length %u\", length));\n\t\t\treturn;\n\t\t}\n\t\tlabel_entry = EXTRACT_32BITS(p);\n\t\tND_PRINT((ndo, \"%s(label %u\",\n\t\t       (label_stack_depth && ndo->ndo_vflag) ? \"\\n\\t\" : \" \",\n       \t\t       MPLS_LABEL(label_entry)));\n\t\tlabel_stack_depth++;\n\t\tif (ndo->ndo_vflag &&\n\t\t    MPLS_LABEL(label_entry) < sizeof(mpls_labelname) / sizeof(mpls_labelname[0]))\n\t\t\tND_PRINT((ndo, \" (%s)\", mpls_labelname[MPLS_LABEL(label_entry)]));\n\t\tND_PRINT((ndo, \", exp %u\", MPLS_EXP(label_entry)));\n\t\tif (MPLS_STACK(label_entry))\n\t\t\tND_PRINT((ndo, \", [S]\"));\n\t\tND_PRINT((ndo, \", ttl %u)\", MPLS_TTL(label_entry)));\n\n\t\tp += sizeof(label_entry);\n\t\tlength -= sizeof(label_entry);\n\t} while (!MPLS_STACK(label_entry));\n\n\t/*\n\t * Try to figure out the packet type.\n\t */\n\tswitch (MPLS_LABEL(label_entry)) {\n\n\tcase 0:\t/* IPv4 explicit NULL label */\n\tcase 3:\t/* IPv4 implicit NULL label */\n\t\tpt = PT_IPV4;\n\t\tbreak;\n\n\tcase 2:\t/* IPv6 explicit NULL label */\n\t\tpt = PT_IPV6;\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * Generally there's no indication of protocol in MPLS label\n\t\t * encoding.\n\t\t *\n\t\t * However, draft-hsmit-isis-aal5mux-00.txt describes a\n\t\t * technique for encapsulating IS-IS and IP traffic on the\n\t\t * same ATM virtual circuit; you look at the first payload\n\t\t * byte to determine the network layer protocol, based on\n\t\t * the fact that\n\t\t *\n\t\t *\t1) the first byte of an IP header is 0x45-0x4f\n\t\t *\t   for IPv4 and 0x60-0x6f for IPv6;\n\t\t *\n\t\t *\t2) the first byte of an OSI CLNP packet is 0x81,\n\t\t *\t   the first byte of an OSI ES-IS packet is 0x82,\n\t\t *\t   and the first byte of an OSI IS-IS packet is\n\t\t *\t   0x83;\n\t\t *\n\t\t * so the network layer protocol can be inferred from the\n\t\t * first byte of the packet, if the protocol is one of the\n\t\t * ones listed above.\n\t\t *\n\t\t * Cisco sends control-plane traffic MPLS-encapsulated in\n\t\t * this fashion.\n\t\t */\n\t\tND_TCHECK(*p);\n\t\tif (length < 1) {\n\t\t\t/* nothing to print */\n\t\t\treturn;\n\t\t}\n\t\tswitch(*p) {\n\n\t\tcase 0x45:\n\t\tcase 0x46:\n\t\tcase 0x47:\n\t\tcase 0x48:\n\t\tcase 0x49:\n\t\tcase 0x4a:\n\t\tcase 0x4b:\n\t\tcase 0x4c:\n\t\tcase 0x4d:\n\t\tcase 0x4e:\n\t\tcase 0x4f:\n\t\t\tpt = PT_IPV4;\n\t\t\tbreak;\n\n\t\tcase 0x60:\n\t\tcase 0x61:\n\t\tcase 0x62:\n\t\tcase 0x63:\n\t\tcase 0x64:\n\t\tcase 0x65:\n\t\tcase 0x66:\n\t\tcase 0x67:\n\t\tcase 0x68:\n\t\tcase 0x69:\n\t\tcase 0x6a:\n\t\tcase 0x6b:\n\t\tcase 0x6c:\n\t\tcase 0x6d:\n\t\tcase 0x6e:\n\t\tcase 0x6f:\n\t\t\tpt = PT_IPV6;\n\t\t\tbreak;\n\n\t\tcase 0x81:\n\t\tcase 0x82:\n\t\tcase 0x83:\n\t\t\tpt = PT_OSI;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* ok bail out - we did not figure out what it is*/\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Print the payload.\n\t */\n\tif (pt == PT_UNKNOWN) {\n\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\tND_DEFAULTPRINT(p, length);\n\t\treturn;\n\t}\n\tND_PRINT((ndo, ndo->ndo_vflag ? \"\\n\\t\" : \" \"));\n\tswitch (pt) {\n\n\tcase PT_IPV4:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\n\tcase PT_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\n\tcase PT_OSI:\n\t\tisoclns_print(ndo, p, length, length);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|MPLS]\"));\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "tcpdump", "commit_id": "1dcd10aceabbc03bf571ea32b892c522cbe923de", "hash": 338653992515448387997130014089821070091, "size": 155, "message": "CVE-2017-12897/ISO CLNS: Use ND_TTEST() for the bounds checks in isoclns_print().\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nDon't pass the remaining caplen - that's too hard to get right, and we\nwere getting it wrong in at least one case; just use ND_TTEST().\n\nAdd a test using the capture file supplied by the reporter(s).", "idx": 900}
{"func": "startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)\n{\n    int i;\n\n    callbacks++;\n    if (noout)\n\treturn;\n    fprintf(stdout, \"SAX.startElement(%s\", (char *) name);\n    if (atts != NULL) {\n        for (i = 0;(atts[i] != NULL);i++) {\n\t    fprintf(stdout, \", %s='\", atts[i++]);\n\t    if (atts[i] != NULL)\n\t        fprintf(stdout, \"%s'\", atts[i]);\n\t}\n    }\n    fprintf(stdout, \")\\n\");\n}", "target": 0, "cwe": ["CWE-416"], "project": "libxml2", "commit_id": "1358d157d0bd83be1dfe356a69213df9fac0b539", "hash": 68305339567463724682500714993194324512, "size": 17, "message": "Fix use-after-free with `xmllint --html --push`\n\nCall htmlCtxtUseOptions to make sure that names aren't stored in\ndictionaries.\n\nNote that this issue only affects xmllint using the HTML push parser.\n\nFixes #230.", "idx": 901}
{"func": "static ssize_t type_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\n\tswitch (this_leaf->type) {\n\tcase CACHE_TYPE_DATA:\n\t\treturn sprintf(buf, \"Data\\n\");\n\tcase CACHE_TYPE_INST:\n\t\treturn sprintf(buf, \"Instruction\\n\");\n\tcase CACHE_TYPE_UNIFIED:\n\t\treturn sprintf(buf, \"Unified\\n\");\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1, "cwe": ["CWE-787"], "project": "linux", "commit_id": "aa838896d87af561a33ecefea1caa4c15a68bc47", "hash": 332529294441819218549607641330445646187, "size": 16, "message": "drivers core: Use sysfs_emit and sysfs_emit_at for show(device *...) functions\n\nConvert the various sprintf fmaily calls in sysfs device show functions\nto sysfs_emit and sysfs_emit_at for PAGE_SIZE buffer safety.\n\nDone with:\n\n$ spatch -sp-file sysfs_emit_dev.cocci --in-place --max-width=80 .\n\nAnd cocci script:\n\n$ cat sysfs_emit_dev.cocci\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\treturn\n-\tstrcpy(buf, chr);\n+\tsysfs_emit(buf, chr);\n\t...>\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsprintf(buf,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tsnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n\tlen =\n-\tscnprintf(buf, PAGE_SIZE,\n+\tsysfs_emit(buf,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nidentifier len;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t<...\n-\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n+\tlen += sysfs_emit_at(buf, len,\n\t...);\n\t...>\n\treturn len;\n}\n\n@@\nidentifier d_show;\nidentifier dev, attr, buf;\nexpression chr;\n@@\n\nssize_t d_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t...\n-\tstrcpy(buf, chr);\n-\treturn strlen(buf);\n+\treturn sysfs_emit(buf, chr);\n}\n\nSigned-off-by: Joe Perches <joe@perches.com>\nLink: https://lore.kernel.org/r/3d033c33056d88bbe34d4ddb62afd05ee166ab9a.1600285923.git.joe@perches.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "idx": 902}
{"func": "add_bwrap_wrapper (FlatpakBwrap *bwrap,\n                   const char   *app_info_path,\n                   GError      **error)\n{\n  glnx_autofd int app_info_fd = -1;\n  g_auto(GLnxDirFdIterator) dir_iter = { 0 };\n  struct dirent *dent;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy/\", NULL);\n\n  app_info_fd = open (app_info_path, O_RDONLY | O_CLOEXEC);\n  if (app_info_fd == -1)\n    return glnx_throw_errno_prefix (error, _(\"Failed to open app info file\"));\n\n  if (!glnx_dirfd_iterator_init_at (AT_FDCWD, \"/\", FALSE, &dir_iter, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  while (TRUE)\n    {\n      glnx_autofd int o_path_fd = -1;\n      struct statfs stfs;\n\n      if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dir_iter, &dent, NULL, error))\n        return FALSE;\n\n      if (dent == NULL)\n        break;\n\n      if (strcmp (dent->d_name, \".flatpak-info\") == 0)\n        continue;\n\n      /* O_PATH + fstatfs is the magic that we need to statfs without automounting the target */\n      o_path_fd = openat (dir_iter.fd, dent->d_name, O_PATH | O_NOFOLLOW | O_CLOEXEC);\n      if (o_path_fd == -1 || fstatfs (o_path_fd, &stfs) != 0 || stfs.f_type == AUTOFS_SUPER_MAGIC)\n        continue; /* AUTOFS mounts are risky and can cause us to block (see issue #1633), so ignore it. Its unlikely the proxy needs such a directory. */\n\n      if (dent->d_type == DT_DIR)\n        {\n          if (strcmp (dent->d_name, \"tmp\") == 0 ||\n              strcmp (dent->d_name, \"var\") == 0 ||\n              strcmp (dent->d_name, \"run\") == 0)\n            flatpak_bwrap_add_arg (bwrap, \"--bind\");\n          else\n            flatpak_bwrap_add_arg (bwrap, \"--ro-bind\");\n\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n      else if (dent->d_type == DT_LNK)\n        {\n          ssize_t symlink_size;\n          char path_buffer[PATH_MAX + 1];\n\n          symlink_size = readlinkat (dir_iter.fd, dent->d_name, path_buffer, sizeof (path_buffer) - 1);\n          if (symlink_size < 0)\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n          path_buffer[symlink_size] = 0;\n\n          flatpak_bwrap_add_args (bwrap, \"--symlink\", path_buffer, NULL);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n    }\n\n  flatpak_bwrap_add_args (bwrap, \"--bind\", proxy_socket_dir, proxy_socket_dir, NULL);\n\n  /* This is a file rather than a bind mount, because it will then\n     not be unmounted from the namespace when the namespace dies. */\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--file\", glnx_steal_fd (&app_info_fd), \"/.flatpak-info\");\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  return TRUE;\n}", "target": 0, "cwe": ["CWE-20"], "project": "flatpak", "commit_id": "a9107feeb4b8275b78965b36bf21b92d5724699e", "hash": 40945122753103531456621417333578851539, "size": 79, "message": "run: Only compare the lowest 32 ioctl arg bits for TIOCSTI\n\nCloses #2782.\n\nCloses: #2783\nApproved by: alexlarsson", "idx": 903}
{"func": "static struct dst_entry *rxe_find_route6(struct net_device *ndev,\n\t\t\t\t\t struct in6_addr *saddr,\n\t\t\t\t\t struct in6_addr *daddr)\n{\n\tstruct dst_entry *ndst;\n\tstruct flowi6 fl6 = { { 0 } };\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_oif = ndev->ifindex;\n\tmemcpy(&fl6.saddr, saddr, sizeof(*saddr));\n\tmemcpy(&fl6.daddr, daddr, sizeof(*daddr));\n\tfl6.flowi6_proto = IPPROTO_UDP;\n\n\tif (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),\n\t\t\t\t\t\trecv_sockets.sk6->sk, &ndst, &fl6))) {\n\t\tpr_err_ratelimited(\"no route to %pI6\\n\", daddr);\n\t\tgoto put;\n\t}\n\n\tif (unlikely(ndst->error)) {\n\t\tpr_err(\"no route to %pI6\\n\", daddr);\n\t\tgoto put;\n\t}\n\n\treturn ndst;\nput:\n\tdst_release(ndst);\n\treturn NULL;\n}", "target": 1, "cwe": [], "project": "net", "commit_id": "6c8991f41546c3c472503dff1ea9daaddf9331c2", "hash": 272638707518751320675281950384246485351, "size": 29, "message": "net: ipv6_stub: use ip6_dst_lookup_flow instead of ip6_dst_lookup\n\nipv6_stub uses the ip6_dst_lookup function to allow other modules to\nperform IPv6 lookups. However, this function skips the XFRM layer\nentirely.\n\nAll users of ipv6_stub->ip6_dst_lookup use ip_route_output_flow (via the\nip_route_output_key and ip_route_output helpers) for their IPv4 lookups,\nwhich calls xfrm_lookup_route(). This patch fixes this inconsistent\nbehavior by switching the stub to ip6_dst_lookup_flow, which also calls\nxfrm_lookup_route().\n\nThis requires some changes in all the callers, as these two functions\ntake different arguments and have different return types.\n\nFixes: 5f81bd2e5d80 (\"ipv6: export a stub for IPv6 symbols used by vxlan\")\nReported-by: Xiumei Mu <xmu@redhat.com>\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 904}
{"func": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!fstype)\n\t\treturn -EINVAL;\n\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\t/* Only in special cases allow devices from mounts\n\t\t * created outside the initial user namespace.\n\t\t */\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-269"], "project": "user-namespace", "commit_id": "9566d6742852c527bf5af38af5cbb878dad75705", "hash": 68944697216652118592422694919480922417, "size": 43, "message": "mnt: Correct permission checks in do_remount\n\nWhile invesgiating the issue where in \"mount --bind -oremount,ro ...\"\nwould result in later \"mount --bind -oremount,rw\" succeeding even if\nthe mount started off locked I realized that there are several\nadditional mount flags that should be locked and are not.\n\nIn particular MNT_NOSUID, MNT_NODEV, MNT_NOEXEC, and the atime\nflags in addition to MNT_READONLY should all be locked.  These\nflags are all per superblock, can all be changed with MS_BIND,\nand should not be changable if set by a more privileged user.\n\nThe following additions to the current logic are added in this patch.\n- nosuid may not be clearable by a less privileged user.\n- nodev  may not be clearable by a less privielged user.\n- noexec may not be clearable by a less privileged user.\n- atime flags may not be changeable by a less privileged user.\n\nThe logic with atime is that always setting atime on access is a\nglobal policy and backup software and auditing software could break if\natime bits are not updated (when they are configured to be updated),\nand serious performance degradation could result (DOS attack) if atime\nupdates happen when they have been explicitly disabled.  Therefore an\nunprivileged user should not be able to mess with the atime bits set\nby a more privileged user.\n\nThe additional restrictions are implemented with the addition of\nMNT_LOCK_NOSUID, MNT_LOCK_NODEV, MNT_LOCK_NOEXEC, and MNT_LOCK_ATIME\nmnt flags.\n\nTaken together these changes and the fixes for MNT_LOCK_READONLY\nshould make it safe for an unprivileged user to create a user\nnamespace and to call \"mount --bind -o remount,... ...\" without\nthe danger of mount flags being changed maliciously.\n\nCc: stable@vger.kernel.org\nAcked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>", "idx": 905}
{"func": "njs_encode_base64_length(const njs_str_t *src, size_t *out_size)\n{\n    size_t  size;\n\n    size = (src->length == 0) ? 0 : njs_base64_encoded_length(src->length);\n\n    if (out_size != NULL) {\n        *out_size = size;\n    }\n\n    return size;\n}", "target": 0, "cwe": [], "project": "njs", "commit_id": "36f04a3178fcb6da8513cc3dbf35215c2a581b3f", "hash": 279616328303416583652942559428053939574, "size": 12, "message": "Fixed String.prototype.replace() with byte strings.\n\nThis closes #522 issue on Github.", "idx": 906}
{"func": "RsaCheckPrime(\n\t      bigNum           prime,\n\t      UINT32           exponent,\n\t      RAND_STATE      *rand\n\t      )\n{\n#if !RSA_KEY_SIEVE\n    TPM_RC          retVal = TPM_RC_SUCCESS;\n    UINT32          modE = BnModWord(prime, exponent);\n    NOT_REFERENCED(rand);\n    if(modE == 0)\n\t// evenly divisible so add two keeping the number odd\n\tBnAddWord(prime, prime, 2);\n    // want 0 != (p - 1) mod e\n    // which is 1 != p mod e\n    else if(modE == 1)\n\t// subtract 2 keeping number odd and insuring that\n\t// 0 != (p - 1) mod e\n\tBnSubWord(prime, prime, 2);\n    if(BnIsProbablyPrime(prime, rand) == 0)\n\tERROR_RETURN(g_inFailureMode ? TPM_RC_FAILURE : TPM_RC_VALUE);\n Exit:\n    return retVal;\n#else\n    return PrimeSelectWithSieve(prime, exponent, rand);\n#endif\n}", "target": 0, "cwe": ["CWE-331"], "project": "libtpms", "commit_id": "625171be0c8225824740b5d0fb7e8562f6a1c6a8", "hash": 167006958333150271142210911208223627876, "size": 27, "message": "tpm2: rev155: Add new RsaAdjustPrimeCandidate code but do not use\n\nAdd in the new RsaAdjustPrimeCandidate() function but do not use it\nso far since it creates slightly different primes than the previous\ncode and we would get different derived keys if we were to use it with\n'old' seeds.\n\nAdjust the code to return the same results for 64 bit and 32 bit machines.\n\nSigned-off-by: Stefan Berger <stefanb@linux.ibm.com>", "idx": 907}
{"func": "static void virtio_serial_register_types(void)\n{\n    type_register_static(&virtser_bus_info);\n    type_register_static(&virtio_serial_port_type_info);\n    type_register_static(&virtio_device_info);\n}", "target": 0, "cwe": ["CWE-120", "CWE-787"], "project": "qemu", "commit_id": "7882080388be5088e72c425b02223c02e6cb4295", "hash": 241725496194686807249252419958642194947, "size": 6, "message": "virtio-serial: fix ANY_LAYOUT\n\nDon't assume a specific layout for control messages.\nRequired by virtio 1.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Amit Shah <amit.shah@redhat.com>\nReviewed-by: Jason Wang <jasowang@redhat.com>", "idx": 908}
{"func": "void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port)\n{\n\tstruct hsr_node *node_dst;\n\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn;\n\n\tnode_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);\n\tif (!node_dst) {\n\t\tWARN_ONCE(1, \"%s: Unknown node\\n\", __func__);\n\t\treturn;\n\t}\n\tif (port->type != node_dst->AddrB_port)\n\t\treturn;\n\n\tether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);\n}", "target": 0, "cwe": ["CWE-772", "CWE-269", "CWE-401"], "project": "linux", "commit_id": "6caabe7f197d3466d238f70915d65301f1716626", "hash": 254648732332932375714025376232698041728, "size": 23, "message": "net: hsr: fix memory leak in hsr_dev_finalize()\n\nIf hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER) failed to\nadd port, it directly returns res and forgets to free the node\nthat allocated in hsr_create_self_node(), and forgets to delete\nthe node->mac_list linked in hsr->self_node_db.\n\nBUG: memory leak\nunreferenced object 0xffff8881cfa0c780 (size 64):\n  comm \"syz-executor.0\", pid 2077, jiffies 4294717969 (age 2415.377s)\n  hex dump (first 32 bytes):\n    e0 c7 a0 cf 81 88 ff ff 00 02 00 00 00 00 ad de  ................\n    00 e6 49 cd 81 88 ff ff c0 9b 87 d0 81 88 ff ff  ..I.............\n  backtrace:\n    [<00000000e2ff5070>] hsr_dev_finalize+0x736/0x960 [hsr]\n    [<000000003ed2e597>] hsr_newlink+0x2b2/0x3e0 [hsr]\n    [<000000003fa8c6b6>] __rtnl_newlink+0xf1f/0x1600 net/core/rtnetlink.c:3182\n    [<000000001247a7ad>] rtnl_newlink+0x66/0x90 net/core/rtnetlink.c:3240\n    [<00000000e7d1b61d>] rtnetlink_rcv_msg+0x54e/0xb90 net/core/rtnetlink.c:5130\n    [<000000005556bd3a>] netlink_rcv_skb+0x129/0x340 net/netlink/af_netlink.c:2477\n    [<00000000741d5ee6>] netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]\n    [<00000000741d5ee6>] netlink_unicast+0x49a/0x650 net/netlink/af_netlink.c:1336\n    [<000000009d56f9b7>] netlink_sendmsg+0x88b/0xdf0 net/netlink/af_netlink.c:1917\n    [<0000000046b35c59>] sock_sendmsg_nosec net/socket.c:621 [inline]\n    [<0000000046b35c59>] sock_sendmsg+0xc3/0x100 net/socket.c:631\n    [<00000000d208adc9>] __sys_sendto+0x33e/0x560 net/socket.c:1786\n    [<00000000b582837a>] __do_sys_sendto net/socket.c:1798 [inline]\n    [<00000000b582837a>] __se_sys_sendto net/socket.c:1794 [inline]\n    [<00000000b582837a>] __x64_sys_sendto+0xdd/0x1b0 net/socket.c:1794\n    [<00000000c866801d>] do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290\n    [<00000000fea382d9>] entry_SYSCALL_64_after_hwframe+0x49/0xbe\n    [<00000000e01dacb3>] 0xffffffffffffffff\n\nFixes: c5a759117210 (\"net/hsr: Use list_head (and rcu) instead of array for slave devices.\")\nReported-by: Hulk Robot <hulkci@huawei.com>\nSigned-off-by: Mao Wenan <maowenan@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 909}
{"func": "uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )\r\n{\r\n    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n    {\r\n        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n    return 0xFF;\r\n}\r", "target": 0, "cwe": ["CWE-120", "CWE-787"], "project": "LoRaMac-node", "commit_id": "e3063a91daa7ad8a687223efa63079f0c24568e4", "hash": 58512248486079225828873011401171361064, "size": 11, "message": "Added received buffer size checks.", "idx": 910}
{"func": "void buildFinishedTLS(SSL& ssl, Finished& fin, const opaque* sender) \n{\n    opaque handshake_hash[FINISHED_SZ];\n\n    ssl.useHashes().use_MD5().get_digest(handshake_hash);\n    ssl.useHashes().use_SHA().get_digest(&handshake_hash[MD5_LEN]);\n\n    const opaque* side;\n    if ( strncmp((const char*)sender, (const char*)client, SIZEOF_SENDER) == 0)\n        side = tls_client;\n    else\n        side = tls_server;\n\n    PRF(fin.set_md5(), TLS_FINISHED_SZ, \n        ssl.getSecurity().get_connection().master_secret_, SECRET_LEN, \n        side, FINISHED_LABEL_SZ, \n        handshake_hash, FINISHED_SZ);\n\n    fin.set_length(TLS_FINISHED_SZ);  // shorter length for TLS\n}", "target": 0, "cwe": [], "project": "mysql-server", "commit_id": "b9768521bdeb1a8069c7b871f4536792b65fd79b", "hash": 154868830277984558955166295940822087626, "size": 20, "message": "Updated yassl to yassl-2.3.8\n\n(cherry picked from commit 7f9941eab55ed672bfcccd382dafbdbcfdc75aaa)", "idx": 911}
{"func": "static int megasas_handle_dcmd(MegasasState *s, MegasasCmd *cmd)\n{\n    int opcode, len;\n    int retval = 0;\n    const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;\n\n    opcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n    trace_megasas_handle_dcmd(cmd->index, opcode);\n    len = megasas_map_dcmd(s, cmd);\n    if (len < 0) {\n        return MFI_STAT_MEMORY_NOT_AVAILABLE;\n    }\n    while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {\n        cmdptr++;\n    }\n    if (cmdptr->opcode == -1) {\n        trace_megasas_dcmd_unhandled(cmd->index, opcode, len);\n        retval = megasas_dcmd_dummy(s, cmd);\n    } else {\n        trace_megasas_dcmd_enter(cmd->index, cmdptr->desc, len);\n        retval = cmdptr->func(s, cmd);\n    }\n    if (retval != MFI_STAT_INVALID_STATUS) {\n        megasas_finish_dcmd(cmd, len);\n    }\n    return retval;\n}", "target": 1, "cwe": ["CWE-401"], "project": "qemu", "commit_id": "765a707000e838c30b18d712fe6cb3dd8e0435f3", "hash": 249580832386457904352283950820947709489, "size": 27, "message": "megasas: fix guest-triggered memory leak\n\nIf the guest sets the sglist size to a value >=2GB, megasas_handle_dcmd\nwill return MFI_STAT_MEMORY_NOT_AVAILABLE without freeing the memory.\nAvoid this by returning only the status from map_dcmd, and loading\ncmd->iov_size in the caller.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "idx": 912}
{"func": "int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n{\n    char *param, buffer[128], tmp[128];\n    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n    SrtStack stack[16];\n    int closing_brace_missing = 0;\n\n    stack[0].tag[0] = 0;\n    strcpy(stack[0].param[PARAM_SIZE],  \"{\\\\fs}\");\n    strcpy(stack[0].param[PARAM_COLOR], \"{\\\\c}\");\n    strcpy(stack[0].param[PARAM_FACE],  \"{\\\\fn}\");\n\n    for (; !end && *in; in++) {\n        switch (*in) {\n        case '\\r':\n            break;\n        case '\\n':\n            if (line_start) {\n                end = 1;\n                break;\n            }\n            rstrip_spaces_buf(dst);\n            av_bprintf(dst, \"\\\\N\");\n            line_start = 1;\n            break;\n        case ' ':\n            if (!line_start)\n                av_bprint_chars(dst, *in, 1);\n            break;\n        case '{':    /* skip all {\\xxx} substrings except for {\\an%d}\n                        and all microdvd like styles such as {Y:xxx} */\n            len = 0;\n            an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;\n\n            if (!closing_brace_missing) {\n                if (   (an != 1 && in[1] == '\\\\')\n                    || (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {\n                    char *bracep = strchr(in+2, '}');\n                    if (bracep) {\n                        in = bracep;\n                        break;\n                    } else\n                        closing_brace_missing = 1;\n                }\n            }\n\n            av_bprint_chars(dst, *in, 1);\n            break;\n        case '<':\n            tag_close = in[1] == '/';\n            len = 0;\n            if (sscanf(in+tag_close+1, \"%127[^<>]>%n\", buffer, &len) >= 1 && len > 0) {\n                const char *tagname = buffer;\n                while (*tagname == ' ')\n                    tagname++;\n                if ((param = strchr(tagname, ' ')))\n                    *param++ = 0;\n                if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||\n                    ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {\n                    int i, j, unknown = 0;\n                    in += len + tag_close;\n                    if (!tag_close)\n                        memset(stack+sptr, 0, sizeof(*stack));\n                    if (!strcmp(tagname, \"font\")) {\n                        if (tag_close) {\n                            for (i=PARAM_NUMBER-1; i>=0; i--)\n                                if (stack[sptr-1].param[i][0])\n                                    for (j=sptr-2; j>=0; j--)\n                                        if (stack[j].param[i][0]) {\n                                            av_bprintf(dst, \"%s\", stack[j].param[i]);\n                                            break;\n                                        }\n                        } else {\n                            while (param) {\n                                if (!strncmp(param, \"size=\", 5)) {\n                                    unsigned font_size;\n                                    param += 5 + (param[5] == '\"');\n                                    if (sscanf(param, \"%u\", &font_size) == 1) {\n                                        snprintf(stack[sptr].param[PARAM_SIZE],\n                                             sizeof(stack[0].param[PARAM_SIZE]),\n                                             \"{\\\\fs%u}\", font_size);\n                                    }\n                                } else if (!strncmp(param, \"color=\", 6)) {\n                                    param += 6 + (param[6] == '\"');\n                                    snprintf(stack[sptr].param[PARAM_COLOR],\n                                         sizeof(stack[0].param[PARAM_COLOR]),\n                                         \"{\\\\c&H%X&}\",\n                                         html_color_parse(log_ctx, param));\n                                } else if (!strncmp(param, \"face=\", 5)) {\n                                    param += 5 + (param[5] == '\"');\n                                    len = strcspn(param,\n                                                  param[-1] == '\"' ? \"\\\"\" :\" \");\n                                    av_strlcpy(tmp, param,\n                                               FFMIN(sizeof(tmp), len+1));\n                                    param += len;\n                                    snprintf(stack[sptr].param[PARAM_FACE],\n                                             sizeof(stack[0].param[PARAM_FACE]),\n                                             \"{\\\\fn%s}\", tmp);\n                                }\n                                if ((param = strchr(param, ' ')))\n                                    param++;\n                            }\n                            for (i=0; i<PARAM_NUMBER; i++)\n                                if (stack[sptr].param[i][0])\n                                    av_bprintf(dst, \"%s\", stack[sptr].param[i]);\n                        }\n                    } else if (tagname[0] && !tagname[1] && strspn(tagname, \"bisu\") == 1) {\n                        av_bprintf(dst, \"{\\\\%c%d}\", tagname[0], !tag_close);\n                    } else {\n                        unknown = 1;\n                        snprintf(tmp, sizeof(tmp), \"</%s>\", tagname);\n                    }\n                    if (tag_close) {\n                        sptr--;\n                    } else if (unknown && !strstr(in, tmp)) {\n                        in -= len + tag_close;\n                        av_bprint_chars(dst, *in, 1);\n                    } else\n                        av_strlcpy(stack[sptr++].tag, tagname,\n                                   sizeof(stack[0].tag));\n                    break;\n                }\n            }\n        default:\n            av_bprint_chars(dst, *in, 1);\n            break;\n        }\n        if (*in != ' ' && *in != '\\r' && *in != '\\n')\n            line_start = 0;\n    }\n\n    if (!av_bprint_is_complete(dst))\n        return AVERROR(ENOMEM);\n\n    while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], \"\\\\N\", 2))\n        dst->len -= 2;\n    dst->str[dst->len] = 0;\n    rstrip_spaces_buf(dst);\n\n    return 0;\n}", "target": 1, "cwe": ["CWE-125"], "project": "FFmpeg", "commit_id": "23ccf3cabb4baf6e8af4b1af3fcc59c904736f21", "hash": 4694659124186853334896561880084717622, "size": 141, "message": "avcodec/htmlsubtitles: Fixes denial of service due to use of sscanf in inner loop for tag scaning\n\nFixes: [Semmle Security Reports #19438]\nFixes: dos_sscanf1.mkv\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 1f00c97bc3475c477f3c468cf2d924d5761d0982)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>", "idx": 913}
{"func": "void perf_event_exec(void)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\trcu_read_lock();\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = current->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tperf_event_enable_on_exec(ctx);\n\t}\n\trcu_read_unlock();\n}", "target": 0, "cwe": ["CWE-284", "CWE-264"], "project": "linux", "commit_id": "f63a8daa5812afef4f06c962351687e1ff9ccb2b", "hash": 235919176501990402406972392985392732011, "size": 15, "message": "perf: Fix event->ctx locking\n\nThere have been a few reported issues wrt. the lack of locking around\nchanging event->ctx. This patch tries to address those.\n\nIt avoids the whole rwsem thing; and while it appears to work, please\ngive it some thought in review.\n\nWhat I did fail at is sensible runtime checks on the use of\nevent->ctx, the RCU use makes it very hard.\n\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nLink: http://lkml.kernel.org/r/20150123125834.209535886@infradead.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>", "idx": 914}
{"func": "  usage( char*  execname )\n  {\n    fprintf( stderr,  \"\\n\" );\n    fprintf( stderr,  \"ftgrid: simple glyph grid viewer -- part of the FreeType project\\n\" );\n    fprintf( stderr,  \"-----------------------------------------------------------\\n\" );\n    fprintf( stderr,  \"\\n\" );\n    fprintf( stderr,  \"Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\\n\",\n             execname );\n    fprintf( stderr,  \"\\n\" );\n    fprintf( stderr,  \"  -r R      use resolution R dpi (default: 72 dpi)\\n\" );\n    fprintf( stderr,  \"  -f index  specify first index to display\\n\" );\n    fprintf( stderr,  \"\\n\" );\n\n    exit( 1 );\n  }", "target": 0, "cwe": ["CWE-120"], "project": "freetype2-demos", "commit_id": "b995299b73ba4cd259f221f500d4e63095508bec", "hash": 198719629754258090150441329116395434056, "size": 15, "message": "Fix Savannah bug #30054.\n\n* src/ftdiff.c, src/ftgrid.c, src/ftmulti.c, src/ftstring.c,\nsrc/ftview.c: Use precision for `%s' where appropriate to avoid\nbuffer overflows.", "idx": 915}
{"func": "void\nPerl_init_uniprops(pTHX)\n{\n    dVAR;\n\n    PL_user_def_props = newHV();\n\n#ifdef USE_ITHREADS\n\n    HvSHAREKEYS_off(PL_user_def_props);\n    PL_user_def_props_aTHX = aTHX;\n\n#endif\n\n    /* Set up the inversion list global variables */\n\n    PL_XPosix_ptrs[_CC_ASCII] = _new_invlist_C_array(uni_prop_ptrs[UNI_ASCII]);\n    PL_XPosix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXALNUM]);\n    PL_XPosix_ptrs[_CC_ALPHA] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXALPHA]);\n    PL_XPosix_ptrs[_CC_BLANK] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXBLANK]);\n    PL_XPosix_ptrs[_CC_CASED] =  _new_invlist_C_array(uni_prop_ptrs[UNI_CASED]);\n    PL_XPosix_ptrs[_CC_CNTRL] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXCNTRL]);\n    PL_XPosix_ptrs[_CC_DIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXDIGIT]);\n    PL_XPosix_ptrs[_CC_GRAPH] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXGRAPH]);\n    PL_XPosix_ptrs[_CC_LOWER] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXLOWER]);\n    PL_XPosix_ptrs[_CC_PRINT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXPRINT]);\n    PL_XPosix_ptrs[_CC_PUNCT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXPUNCT]);\n    PL_XPosix_ptrs[_CC_SPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXSPACE]);\n    PL_XPosix_ptrs[_CC_UPPER] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXUPPER]);\n    PL_XPosix_ptrs[_CC_VERTSPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_VERTSPACE]);\n    PL_XPosix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXWORD]);\n    PL_XPosix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXXDIGIT]);\n\n    PL_Posix_ptrs[_CC_ASCII] = _new_invlist_C_array(uni_prop_ptrs[UNI_ASCII]);\n    PL_Posix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXALNUM]);\n    PL_Posix_ptrs[_CC_ALPHA] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXALPHA]);\n    PL_Posix_ptrs[_CC_BLANK] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXBLANK]);\n    PL_Posix_ptrs[_CC_CASED] = PL_Posix_ptrs[_CC_ALPHA];\n    PL_Posix_ptrs[_CC_CNTRL] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXCNTRL]);\n    PL_Posix_ptrs[_CC_DIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXDIGIT]);\n    PL_Posix_ptrs[_CC_GRAPH] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXGRAPH]);\n    PL_Posix_ptrs[_CC_LOWER] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXLOWER]);\n    PL_Posix_ptrs[_CC_PRINT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXPRINT]);\n    PL_Posix_ptrs[_CC_PUNCT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXPUNCT]);\n    PL_Posix_ptrs[_CC_SPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXSPACE]);\n    PL_Posix_ptrs[_CC_UPPER] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXUPPER]);\n    PL_Posix_ptrs[_CC_VERTSPACE] = NULL;\n    PL_Posix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXWORD]);\n    PL_Posix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXXDIGIT]);\n\n    PL_GCB_invlist = _new_invlist_C_array(_Perl_GCB_invlist);\n    PL_SB_invlist = _new_invlist_C_array(_Perl_SB_invlist);\n    PL_WB_invlist = _new_invlist_C_array(_Perl_WB_invlist);\n    PL_LB_invlist = _new_invlist_C_array(_Perl_LB_invlist);\n    PL_SCX_invlist = _new_invlist_C_array(_Perl_SCX_invlist);\n\n    PL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);\n    PL_Latin1 = _new_invlist_C_array(Latin1_invlist);\n    PL_UpperLatin1 = _new_invlist_C_array(UpperLatin1_invlist);\n\n    PL_Assigned_invlist = _new_invlist_C_array(uni_prop_ptrs[UNI_ASSIGNED]);\n\n    PL_utf8_perl_idstart = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_IDSTART]);\n    PL_utf8_perl_idcont = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_IDCONT]);\n\n    PL_utf8_charname_begin = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_CHARNAME_BEGIN]);\n    PL_utf8_charname_continue = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_CHARNAME_CONTINUE]);\n\n    PL_in_some_fold = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_ANY_FOLDS]);\n    PL_HasMultiCharFold = _new_invlist_C_array(uni_prop_ptrs[\n                                            UNI__PERL_FOLDS_TO_MULTI_CHAR]);\n    PL_InMultiCharFold = _new_invlist_C_array(uni_prop_ptrs[\n                                            UNI__PERL_IS_IN_MULTI_CHAR_FOLD]);\n    PL_NonFinalFold = _new_invlist_C_array(uni_prop_ptrs[\n                                            UNI__PERL_NON_FINAL_FOLDS]);\n\n    PL_utf8_toupper = _new_invlist_C_array(Uppercase_Mapping_invlist);\n    PL_utf8_tolower = _new_invlist_C_array(Lowercase_Mapping_invlist);\n    PL_utf8_totitle = _new_invlist_C_array(Titlecase_Mapping_invlist);\n    PL_utf8_tofold = _new_invlist_C_array(Case_Folding_invlist);\n    PL_utf8_tosimplefold = _new_invlist_C_array(Simple_Case_Folding_invlist);\n    PL_utf8_foldclosures = _new_invlist_C_array(_Perl_IVCF_invlist);\n    PL_utf8_mark = _new_invlist_C_array(uni_prop_ptrs[UNI_M]);\n    PL_CCC_non0_non230 = _new_invlist_C_array(_Perl_CCC_non0_non230_invlist);\n    PL_Private_Use = _new_invlist_C_array(uni_prop_ptrs[UNI_CO]);\n\n#ifdef UNI_XIDC\n    /* The below are used only by deprecated functions.  They could be removed */\n    PL_utf8_xidcont  = _new_invlist_C_array(uni_prop_ptrs[UNI_XIDC]);\n    PL_utf8_idcont   = _new_invlist_C_array(uni_prop_ptrs[UNI_IDC]);\n    PL_utf8_xidstart = _new_invlist_C_array(uni_prop_ptrs[UNI_XIDS]);\n#endif", "target": 0, "cwe": ["CWE-190", "CWE-787"], "project": "perl5", "commit_id": "897d1f7fd515b828e4b198d8b8bef76c6faf03ed", "hash": 198959774573163543365462457478843679289, "size": 92, "message": "regcomp.c: Prevent integer overflow from nested regex quantifiers.\n\n(CVE-2020-10543) On 32bit systems the size calculations for nested regular\nexpression quantifiers could overflow causing heap memory corruption.\n\nFixes: Perl/perl5-security#125\n(cherry picked from commit bfd31397db5dc1a5c5d3e0a1f753a4f89a736e71)", "idx": 916}
{"func": "_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tint fd, ret;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_close\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\n\t/* Sort dir list so directories are fixed up in depth-first order. */\n\tp = sort_dir_list(a->fixup_list);\n\n\twhile (p != NULL) {\n\t\tfd = -1;\n\t\ta->pst = NULL; /* Mark stat cache as out-of-date. */\n\t\tif (p->fixup &\n\t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {\n\t\t\tfd = open(p->name,\n\t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);\n\t\t}\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, fd, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE) {\n#ifdef HAVE_FCHMOD\n\t\t\tif (fd >= 0)\n\t\t\t\tfchmod(fd, p->mode);\n\t\t\telse\n#endif\n\t\t\tchmod(p->name, p->mode);\n\t\t}\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n\t\t\t    p->name, &p->acl, p->mode);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, fd, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}", "target": 1, "cwe": ["CWE-59", "CWE-269"], "project": "libarchive", "commit_id": "b41daecb5ccb4c8e3b2c53fd6147109fc12c3043", "hash": 336317145226986185995385645696679108441, "size": 58, "message": "Do not follow symlinks when processing the fixup list\n\nUse lchmod() instead of chmod() and tell the remaining functions that the\nreal file to be modified is a symbolic link.\n\nFixes #1566", "idx": 917}
{"func": "ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tbitmap_blk = ext4_inode_bitmap(sb, desc);\n\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n\t\text4_error(sb, \"Invalid inode bitmap blk %llu in \"\n\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t    block_group, bitmap_blk);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\tmemset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\ttrace_ext4_load_inode_bitmap(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\tput_bh(bh);\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t   \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\nverify:\n\terr = ext4_validate_inode_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}", "target": 1, "cwe": ["CWE-416"], "project": "linux", "commit_id": "8844618d8aa7a9973e7b527d038a2a589665002c", "hash": 131088302481578622854607859619351275556, "size": 87, "message": "ext4: only look at the bg_flags field if it is valid\n\nThe bg_flags field in the block group descripts is only valid if the\nuninit_bg or metadata_csum feature is enabled.  We were not\nconsistently looking at this field; fix this.\n\nAlso block group #0 must never have uninitialized allocation bitmaps,\nor need to be zeroed, since that's where the root inode, and other\nspecial inodes are set up.  Check for these conditions and mark the\nfile system as corrupted if they are detected.\n\nThis addresses CVE-2018-10876.\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=199403\n\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@kernel.org", "idx": 918}
{"func": "parse_char_class(Node** np, OnigToken* tok, UChar** src, UChar* end,\n\t\t ScanEnv* env)\n{\n  int r, neg, len, fetched, and_start;\n  OnigCodePoint v, vs;\n  UChar *p;\n  Node* node;\n  CClassNode *cc, *prev_cc;\n  CClassNode work_cc;\n\n  enum CCSTATE state;\n  enum CCVALTYPE val_type, in_type;\n  int val_israw, in_israw;\n\n  *np = NULL_NODE;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  prev_cc = (CClassNode* )NULL;\n  r = fetch_token_in_cc(tok, src, end, env);\n  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {\n    neg = 1;\n    r = fetch_token_in_cc(tok, src, end, env);\n  }\n  else {\n    neg = 0;\n  }\n\n  if (r < 0) return r;\n  if (r == TK_CC_CLOSE) {\n    if (! code_exist_check((OnigCodePoint )']',\n                           *src, env->pattern_end, 1, env))\n      return ONIGERR_EMPTY_CHAR_CLASS;\n\n    CC_ESC_WARN(env, (UChar* )\"]\");\n    r = tok->type = TK_CHAR;  /* allow []...] */\n  }\n\n  *np = node = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(node);\n  cc = CCLASS_(node);\n\n  and_start = 0;\n  state = CCS_START;\n  p = *src;\n  while (r != TK_CC_CLOSE) {\n    fetched = 0;\n    switch (r) {\n    case TK_CHAR:\n    any_char_in:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);\n      if (len > 1) {\n        in_type = CCV_CODE_POINT;\n      }\n      else if (len < 0) {\n        r = len;\n        goto err;\n      }\n      else {\n        /* sb_char: */\n        in_type = CCV_SB;\n      }\n      v = (OnigCodePoint )tok->u.c;\n      in_israw = 0;\n      goto val_entry2;\n      break;\n\n    case TK_RAW_BYTE:\n      /* tok->base != 0 : octal or hexadec. */\n      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {\n        UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n        UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;\n        UChar* psave = p;\n        int i, base = tok->base;\n\n        buf[0] = tok->u.c;\n        for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {\n          r = fetch_token_in_cc(tok, &p, end, env);\n          if (r < 0) goto err;\n          if (r != TK_RAW_BYTE || tok->base != base) {\n            fetched = 1;\n            break;\n          }\n          buf[i] = tok->u.c;\n        }\n\n        if (i < ONIGENC_MBC_MINLEN(env->enc)) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n\n        len = enclen(env->enc, buf);\n        if (i < len) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n        else if (i > len) { /* fetch back */\n          p = psave;\n          for (i = 1; i < len; i++) {\n            r = fetch_token_in_cc(tok, &p, end, env);\n          }\n          fetched = 0;\n        }\n\n        if (i == 1) {\n          v = (OnigCodePoint )buf[0];\n          goto raw_single;\n        }\n        else {\n          v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);\n          in_type = CCV_CODE_POINT;\n        }\n      }\n      else {\n        v = (OnigCodePoint )tok->u.c;\n      raw_single:\n        in_type = CCV_SB;\n      }\n      in_israw = 1;\n      goto val_entry2;\n      break;\n\n    case TK_CODE_POINT:\n      v = tok->u.code;\n      in_israw = 1;\n    val_entry:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);\n      if (len < 0) {\n        r = len;\n        goto err;\n      }\n      in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);\n    val_entry2:\n      r = next_state_val(cc, &vs, v, &val_israw, in_israw, in_type, &val_type,\n\t\t\t &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_POSIX_BRACKET_OPEN:\n      r = parse_posix_bracket(cc, &p, end, env);\n      if (r < 0) goto err;\n      if (r == 1) {  /* is not POSIX bracket */\n        CC_ESC_WARN(env, (UChar* )\"[\");\n        p = tok->backp;\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n        goto val_entry;\n      }\n      goto next_class;\n      break;\n\n    case TK_CHAR_TYPE:\n      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);\n      if (r != 0) return r;\n\n    next_class:\n      r = next_state_class(cc, &vs, &val_type, &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_CHAR_PROPERTY:\n      {\n        int ctype = fetch_char_property_to_ctype(&p, end, env);\n        if (ctype < 0) return ctype;\n        r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);\n        if (r != 0) return r;\n        goto next_class;\n      }\n      break;\n\n    case TK_CC_RANGE:\n      if (state == CCS_VALUE) {\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) { /* allow [x-] */\n        range_end_val:\n          v = (OnigCodePoint )'-';\n          in_israw = 0;\n          goto val_entry;\n        }\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n        state = CCS_RANGE;\n      }\n      else if (state == CCS_START) {\n        /* [-xa] is allowed */\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        /* [--x] or [a&&-x] is warned. */\n        if (r == TK_CC_RANGE || and_start != 0)\n          CC_ESC_WARN(env, (UChar* )\"-\");\n\n        goto val_entry;\n      }\n      else if (state == CCS_RANGE) {\n        CC_ESC_WARN(env, (UChar* )\"-\");\n        goto any_char_in;  /* [!--x] is allowed */\n      }\n      else { /* CCS_COMPLETE */\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n\t\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;   /* [0-9-a] is allowed as [0-9\\-a] */\n        }\n        r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n        goto err;\n      }\n      break;\n\n    case TK_CC_CC_OPEN: /* [ */\n      {\n        Node *anode;\n        CClassNode* acc;\n\n        r = parse_char_class(&anode, tok, &p, end, env);\n        if (r != 0) {\n          onig_node_free(anode);\n          goto cc_open_err;\n        }\n        acc = CCLASS_(anode);\n        r = or_cclass(cc, acc, env->enc);\n        onig_node_free(anode);\n\n      cc_open_err:\n        if (r != 0) goto err;\n      }\n      break;\n\n    case TK_CC_AND: /* && */\n      {\n        if (state == CCS_VALUE) {\n          r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                             &val_type, &state, env);\n          if (r != 0) goto err;\n        }\n        /* initialize local variables */\n        and_start = 1;\n        state = CCS_START;\n\n        if (IS_NOT_NULL(prev_cc)) {\n          r = and_cclass(prev_cc, cc, env->enc);\n          if (r != 0) goto err;\n          bbuf_free(cc->mbuf);\n        }\n        else {\n          prev_cc = cc;\n          cc = &work_cc;\n        }\n        initialize_cclass(cc);\n      }\n      break;\n\n    case TK_EOT:\n      r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;\n      goto err;\n      break;\n    default:\n      r = ONIGERR_PARSER_BUG;\n      goto err;\n      break;\n    }\n\n    if (fetched)\n      r = tok->type;\n    else {\n      r = fetch_token_in_cc(tok, &p, end, env);\n      if (r < 0) goto err;\n    }\n  }\n\n  if (state == CCS_VALUE) {\n    r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n\t\t       &val_type, &state, env);\n    if (r != 0) goto err;\n  }\n\n  if (IS_NOT_NULL(prev_cc)) {\n    r = and_cclass(prev_cc, cc, env->enc);\n    if (r != 0) goto err;\n    bbuf_free(cc->mbuf);\n    cc = prev_cc;\n  }\n\n  if (neg != 0)\n    NCCLASS_SET_NOT(cc);\n  else\n    NCCLASS_CLEAR_NOT(cc);\n  if (IS_NCCLASS_NOT(cc) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {\n    int is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);\n    if (is_empty != 0)\n      BITSET_IS_EMPTY(cc->bs, is_empty);\n\n    if (is_empty == 0) {\n#define NEWLINE_CODE    0x0a\n\n      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {\n        if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)\n          BITSET_SET_BIT(cc->bs, NEWLINE_CODE);\n        else\n          add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);\n      }\n    }\n  }\n  *src = p;\n  env->parse_depth--;\n  return 0;\n\n err:\n  if (cc != CCLASS_(*np))\n    bbuf_free(cc->mbuf);\n  return r;\n}", "target": 1, "cwe": ["CWE-787"], "project": "oniguruma", "commit_id": "ddbf55698b5f7ffdfa737b0b8e0079af1fdd7cb1", "hash": 64241044757890280930670508766365020879, "size": 328, "message": "re-fix #60 by check val_type", "idx": 919}
{"func": "parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)\n{\n\tstruct buf *work = 0;\n\tstruct footnote_item *item;\n\tstruct footnote_ref *ref;\n\n\tif (footnotes->count == 0)\n\t\treturn;\n\n\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n\n\titem = footnotes->head;\n\twhile (item) {\n\t\tref = item->ref;\n\t\tparse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);\n\t\titem = item->next;\n\t}\n\n\tif (rndr->cb.footnotes)\n\t\trndr->cb.footnotes(ob, work, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n}", "target": 0, "cwe": [], "project": "redcarpet", "commit_id": "e5a10516d07114d582d13b9125b733008c61c242", "hash": 251878733295814199763718319820850700311, "size": 22, "message": "Avoid rewinding previous inline when auto-linking\n\nWhen a bit like \"_foo_1@bar.com\" is processed, first the emphasis is\nrendered, then the 1 is output verbatim. When the `@` is encountered,\nRedcarpet tries to find the \"local part\" of the address and stops when\nit encounters an invalid char (i.e. here the `!`).\n\nThe problem is that when it searches for the local part, Redcarpet\nrewinds the characters but here, the emphasis is already rendered so\nthe previous HTML tag is rewinded as well and is not correctly closed.", "idx": 920}
{"func": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}", "target": 0, "cwe": ["CWE-190"], "project": "linux", "commit_id": "d1e7fd6462ca9fc76650fbe6ca800e35b24267da", "hash": 116009833704452656395793081636747842284, "size": 17, "message": "signal: Extend exec_id to 64bits\n\nReplace the 32bit exec_id with a 64bit exec_id to make it impossible\nto wrap the exec_id counter.  With care an attacker can cause exec_id\nwrap and send arbitrary signals to a newly exec'd parent.  This\nbypasses the signal sending checks if the parent changes their\ncredentials during exec.\n\nThe severity of this problem can been seen that in my limited testing\nof a 32bit exec_id it can take as little as 19s to exec 65536 times.\nWhich means that it can take as little as 14 days to wrap a 32bit\nexec_id.  Adam Zabrocki has succeeded wrapping the self_exe_id in 7\ndays.  Even my slower timing is in the uptime of a typical server.\nWhich means self_exec_id is simply a speed bump today, and if exec\ngets noticably faster self_exec_id won't even be a speed bump.\n\nExtending self_exec_id to 64bits introduces a problem on 32bit\narchitectures where reading self_exec_id is no longer atomic and can\ntake two read instructions.  Which means that is is possible to hit\na window where the read value of exec_id does not match the written\nvalue.  So with very lucky timing after this change this still\nremains expoiltable.\n\nI have updated the update of exec_id on exec to use WRITE_ONCE\nand the read of exec_id in do_notify_parent to use READ_ONCE\nto make it clear that there is no locking between these two\nlocations.\n\nLink: https://lore.kernel.org/kernel-hardening/20200324215049.GA3710@pi3.com.pl\nFixes: 2.3.23pre2\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>", "idx": 921}
{"func": "void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double level) {\n  api::WebContents* api_web_contents = api::WebContents::From(web_contents());\n  if (api_web_contents) {\n    api_web_contents->SetTemporaryZoomLevel(level);\n  }\n}", "target": 1, "cwe": [], "project": "electron", "commit_id": "e9fa834757f41c0b9fe44a4dffe3d7d437f52d34", "hash": 301612576540546026678772353044713296332, "size": 6, "message": "fix: ensure ElectronBrowser mojo service is only bound to appropriate render frames (#33344)\n\n* fix: ensure ElectronBrowser mojo service is only bound to authorized render frames\r\n\r\nNotes: no-notes\r\n\r\n* refactor: extract electron API IPC to its own mojo interface\r\n\r\n* fix: just check main frame not primary main frame\r\n\r\nCo-authored-by: Samuel Attard <samuel.r.attard@gmail.com>\r\nCo-authored-by: Samuel Attard <sattard@salesforce.com>", "idx": 922}
{"func": "detect_mysql_capabilities_for_backup()\n{\n\tif (xtrabackup_incremental) {\n\t\t/* INNODB_CHANGED_PAGES are listed in\n\t\tINFORMATION_SCHEMA.PLUGINS in MariaDB, but\n\t\tFLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS\n\t\tis not supported for versions below 10.1.6\n\t\t(see MDEV-7472) */\n\t\tif (server_flavor == FLAVOR_MARIADB &&\n\t\t    mysql_server_version < 100106) {\n\t\t\thave_changed_page_bitmaps = false;\n\t\t}\n\t}\n\n\t/* do some sanity checks */\n\tif (opt_galera_info && !have_galera_enabled) {\n\t\tmsg(\"--galera-info is specified on the command \"\n\t\t \t\"line, but the server does not support Galera \"\n\t\t \t\"replication. Ignoring the option.\\n\");\n\t\topt_galera_info = false;\n\t}\n\n\tif (opt_slave_info && have_multi_threaded_slave &&\n\t    !have_gtid_slave && !opt_safe_slave_backup) {\n\t\tmsg(\"The --slave-info option requires GTID enabled or \"\n\t\t\t\"--safe-slave-backup option used for a multi-threaded \"\n\t\t\t\"slave.\\n\");\n\t\treturn(false);\n\t}\n\n\treturn(true);\n}", "target": 0, "cwe": ["CWE-200"], "project": "percona-xtrabackup", "commit_id": "7742f875bb289a874246fb4653b7cd9f14b588fe", "hash": 149435837177893486466411684303924038805, "size": 32, "message": "PXB-2722 password is written into xtrabackup_info\nhttps://jira.percona.com/browse/PXB-2722\n\nAnalysis:\npassword passed with -p option is written into backup tool_command in xtrabackup_info\n\nFix:\nmask password before writting into xtrabackup_info", "idx": 923}
{"func": "int InstanceKlass::find_method_by_name(const Array<Method*>* methods,\n                                       const Symbol* name,\n                                       int* end_ptr) {\n  assert(end_ptr != NULL, \"just checking\");\n  int start = quick_search(methods, name);\n  int end = start + 1;\n  if (start != -1) {\n    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;\n    while (end < methods->length() && (methods->at(end))->name() == name) ++end;\n    *end_ptr = end;\n    return start;\n  }\n  return -1;\n}", "target": 0, "cwe": [], "project": "jdk17u", "commit_id": "f8eb9abe034f7c6bea4da05a9ea42017b3f80730", "hash": 200296582015805648028056559353655754586, "size": 14, "message": "8270386: Better verification of scan methods\n\nReviewed-by: coleenp\nBackport-of: ac329cef45979bd0159ecd1347e36f7129bb2ce4", "idx": 924}
{"func": "get_address(\n    exarg_T\t*eap UNUSED,\n    char_u\t**ptr,\n    cmd_addr_T\taddr_type,\n    int\t\tskip,\t\t// only skip the address, don't use it\n    int\t\tsilent,\t\t// no errors or side effects\n    int\t\tto_other_file,  // flag: may jump to other file\n    int\t\taddress_count UNUSED) // 1 for first address, >1 after comma\n{\n    int\t\tc;\n    int\t\ti;\n    long\tn;\n    char_u\t*cmd;\n    pos_T\tpos;\n    pos_T\t*fp;\n    linenr_T\tlnum;\n    buf_T\t*buf;\n\n    cmd = skipwhite(*ptr);\n    lnum = MAXLNUM;\n    do\n    {\n\tswitch (*cmd)\n\t{\n\t    case '.':\t\t\t    // '.' - Cursor position\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '$':\t\t\t    // '$' - last line\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = LAST_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = ARGCOUNT;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\tbuf = lastbuf;\n\t\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t\t{\n\t\t\t    if (buf->b_prev == NULL)\n\t\t\t\tbreak;\n\t\t\t    buf = buf->b_prev;\n\t\t\t}\n\t\t\tlnum = buf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = LAST_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_valid_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '\\'':\t\t\t    // ''' - mark\n\t\tif (*++cmd == NUL)\n\t\t{\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\n\t\t    ++cmd;\n\t\telse\n\t\t{\n\t\t    // Only accept a mark in another file when it is\n\t\t    // used by itself: \":'M\".\n\t\t    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n\t\t    ++cmd;\n\t\t    if (fp == (pos_T *)-1)\n\t\t\t// Jumped to another file.\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t    else\n\t\t    {\n\t\t\tif (check_mark(fp) == FAIL)\n\t\t\t{\n\t\t\t    cmd = NULL;\n\t\t\t    goto error;\n\t\t\t}\n\t\t\tlnum = fp->lnum;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '/':\n\t    case '?':\t\t\t// '/' or '?' - search\n\t\tc = *cmd++;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\t// skip \"/pat/\"\n\t\t{\n\t\t    cmd = skip_regexp(cmd, c, magic_isset());\n\t\t    if (*cmd == c)\n\t\t\t++cmd;\n\t\t}\n\t\telse\n\t\t{\n\t\t    int flags;\n\n\t\t    pos = curwin->w_cursor; // save curwin->w_cursor\n\n\t\t    // When '/' or '?' follows another address, start from\n\t\t    // there.\n\t\t    if (lnum != MAXLNUM)\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\n\t\t    // Start a forward search at the end of the line (unless\n\t\t    // before the first line).\n\t\t    // Start a backward search at the start of the line.\n\t\t    // This makes sure we never match in the current\n\t\t    // line, and can match anywhere in the\n\t\t    // next/previous line.\n\t\t    if (c == '/' && curwin->w_cursor.lnum > 0)\n\t\t\tcurwin->w_cursor.col = MAXCOL;\n\t\t    else\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    searchcmdlen = 0;\n\t\t    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n\t\t    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL))\n\t\t    {\n\t\t\tcurwin->w_cursor = pos;\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum = curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor = pos;\n\t\t    // adjust command string pointer\n\t\t    cmd += searchcmdlen;\n\t\t}\n\t\tbreak;\n\n\t    case '\\\\':\t\t    // \"\\?\", \"\\/\" or \"\\&\", repeat search\n\t\t++cmd;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (*cmd == '&')\n\t\t    i = RE_SUBST;\n\t\telse if (*cmd == '?' || *cmd == '/')\n\t\t    i = RE_SEARCH;\n\t\telse\n\t\t{\n\t\t    emsg(_(e_backslash_should_be_followed_by));\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t    /*\n\t\t     * When search follows another address, start from\n\t\t     * there.\n\t\t     */\n\t\t    if (lnum != MAXLNUM)\n\t\t\tpos.lnum = lnum;\n\t\t    else\n\t\t\tpos.lnum = curwin->w_cursor.lnum;\n\n\t\t    /*\n\t\t     * Start the search just like for the above\n\t\t     * do_search().\n\t\t     */\n\t\t    if (*cmd != '?')\n\t\t\tpos.col = MAXCOL;\n\t\t    else\n\t\t\tpos.col = 0;\n\t\t    pos.coladd = 0;\n\t\t    if (searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t*cmd == '?' ? BACKWARD : FORWARD,\n\t\t\t\t(char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL)\n\t\t\tlnum = pos.lnum;\n\t\t    else\n\t\t    {\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t}\n\t\t++cmd;\n\t\tbreak;\n\n\t    default:\n\t\tif (VIM_ISDIGIT(*cmd))\t// absolute line number\n\t\t    lnum = getdigits(&cmd);\n\t}\n\n\tfor (;;)\n\t{\n\t    cmd = skipwhite(cmd);\n\t    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))\n\t\tbreak;\n\n\t    if (lnum == MAXLNUM)\n\t    {\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\t// \"+1\" is same as \".+1\"\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t\tlnum = 1;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\tlnum = 0;\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    if (VIM_ISDIGIT(*cmd))\n\t\ti = '+';\t\t// \"number\" is same as \"+number\"\n\t    else\n\t\ti = *cmd++;\n\t    if (!VIM_ISDIGIT(*cmd))\t// '+' is '+1', but '+0' is not '+1'\n\t\tn = 1;\n\t    else\n\t\tn = getdigits(&cmd);\n\n\t    if (addr_type == ADDR_TABS_RELATIVE)\n\t    {\n\t\temsg(_(e_invalid_range));\n\t\tcmd = NULL;\n\t\tgoto error;\n\t    }\n\t    else if (addr_type == ADDR_LOADED_BUFFERS\n\t\t    || addr_type == ADDR_BUFFERS)\n\t\tlnum = compute_buffer_local_count(\n\t\t\t\t    addr_type, lnum, (i == '-') ? -1 * n : n);\n\t    else\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Relative line addressing, need to adjust for folded lines\n\t\t// now, but only do it after the first address.\n\t\tif (addr_type == ADDR_LINES && (i == '-' || i == '+')\n\t\t\t&& address_count >= 2)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t\tif (i == '-')\n\t\t    lnum -= n;\n\t\telse\n\t\t    lnum += n;\n\t    }\n\t}\n    } while (*cmd == '/' || *cmd == '?');\n\nerror:\n    *ptr = cmd;\n    return lnum;\n}", "target": 1, "cwe": ["CWE-122"], "project": "vim", "commit_id": "35a319b77f897744eec1155b736e9372c9c5575f", "hash": 255515585455667424007181368478490735353, "size": 350, "message": "patch 8.2.3489: ml_get error after search with range\n\nProblem:    ml_get error after search with range.\nSolution:   Limit the line number to the buffer line count.", "idx": 925}
{"func": "static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {\n  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&\n      dpf.writable && dpf.setConfigurable && dpf.configurable &&\n      !dpf.setSetter && !dpf.setGetter;\n}", "target": 0, "cwe": ["CWE-843", "CWE-125"], "project": "hermes", "commit_id": "fe52854cdf6725c2eaa9e125995da76e6ceb27da", "hash": 111337230187842701337703034102471455702, "size": 5, "message": "[CVE-2020-1911] Look up HostObject computed properties on the right object in the prototype chain.\n\nSummary:\nThe change in the hermes repository fixes the security vulnerability\nCVE-2020-1911.  This vulnerability only affects applications which\nallow evaluation of uncontrolled, untrusted JavaScript code not\nshipped with the app, so React Native apps will generally not be affected.\n\nThis revision includes a test for the bug.  The test is generic JSI\ncode, so it is included in the hermes and react-native repositories.\n\nChangelog: [Internal]\n\nReviewed By: tmikov\n\nDifferential Revision: D23322992\n\nfbshipit-source-id: 4e88c974afe1ad33a263f9cac03e9dc98d33649a", "idx": 926}
{"func": "struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)\n{\n\tskb_release_all(dst);\n\treturn __skb_clone(dst, src);\n}", "target": 0, "cwe": ["CWE-416"], "project": "net", "commit_id": "36d5fe6a000790f56039afe26834265db0a3ad4c", "hash": 1802689942834989401654340542355176300, "size": 5, "message": "core, nfqueue, openvswitch: Orphan frags in skb_zerocopy and handle errors\n\nskb_zerocopy can copy elements of the frags array between skbs, but it doesn't\norphan them. Also, it doesn't handle errors, so this patch takes care of that\nas well, and modify the callers accordingly. skb_tx_error() is also added to\nthe callers so they will signal the failed delivery towards the creator of the\nskb.\n\nSigned-off-by: Zoltan Kiss <zoltan.kiss@citrix.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 927}
{"func": "unsigned int ldb_get_flags(struct ldb_context *ldb)\n{\n\treturn ldb->flags;\n}", "target": 0, "cwe": ["CWE-476"], "project": "samba", "commit_id": "d8b9bb274b7e7a390cf3bda9cd732cb2227bdbde", "hash": 151539617395707820487843148999213858865, "size": 4, "message": "CVE-2020-10730: lib ldb: Check if ldb_lock_backend_callback called twice\n\nPrevent use after free issues if ldb_lock_backend_callback is called\ntwice, usually due to ldb_module_done being called twice. This can happen if a\nmodule ignores the return value from function a function that calls\nldb_module_done as part of it's error handling.\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=14364\n\nSigned-off-by: Gary Lockyer <gary@catalyst.net.nz>\nReviewed-by: Andrew Bartlett <abartlet@samba.org>", "idx": 928}
{"func": "virDomainCoreDump(virDomainPtr domain, const char *to, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s, flags=%x\", to, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);\n\n    if (conn->driver->domainCoreDump) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute core file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainCoreDump(domain, absolute_to, flags);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}", "target": 0, "cwe": ["CWE-254"], "project": "libvirt", "commit_id": "506e9d6c2d4baaf580d489fff0690c0ff2ff588f", "hash": 188781958509975548862100002902577752740, "size": 44, "message": "virDomainGetTime: Deny on RO connections\n\nWe have a policy that if API may end up talking to a guest agent\nit should require RW connection. We don't obey the rule in\nvirDomainGetTime().\n\nSigned-off-by: Michal Privoznik <mprivozn@redhat.com>", "idx": 929}
{"func": "vbf_stp_error(struct worker *wrk, struct busyobj *bo)\n{\n\tssize_t l, ll, o;\n\tdouble now;\n\tuint8_t *ptr;\n\tstruct vsb *synth_body;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\tAN(bo->fetch_objcore->flags & OC_F_BUSY);\n\tassert(bo->director_state == DIR_S_NULL);\n\n\twrk->stats->fetch_failed++;\n\n\tnow = W_TIM_real(wrk);\n\tVSLb_ts_busyobj(bo, \"Error\", now);\n\n\tif (bo->fetch_objcore->stobj->stevedore != NULL)\n\t\tObjFreeObj(bo->wrk, bo->fetch_objcore);\n\n\t// XXX: reset all beresp flags ?\n\n\tHTTP_Setup(bo->beresp, bo->ws, bo->vsl, SLT_BerespMethod);\n\thttp_PutResponse(bo->beresp, \"HTTP/1.1\", 503, \"Backend fetch failed\");\n\thttp_TimeHeader(bo->beresp, \"Date: \", now);\n\thttp_SetHeader(bo->beresp, \"Server: Varnish\");\n\n\tbo->fetch_objcore->t_origin = now;\n\tif (!VTAILQ_EMPTY(&bo->fetch_objcore->objhead->waitinglist)) {\n\t\t/*\n\t\t * If there is a waitinglist, it means that there is no\n\t\t * grace-able object, so cache the error return for a\n\t\t * short time, so the waiting list can drain, rather than\n\t\t * each objcore on the waiting list sequentially attempt\n\t\t * to fetch from the backend.\n\t\t */\n\t\tbo->fetch_objcore->ttl = 1;\n\t\tbo->fetch_objcore->grace = 5;\n\t\tbo->fetch_objcore->keep = 5;\n\t} else {\n\t\tbo->fetch_objcore->ttl = 0;\n\t\tbo->fetch_objcore->grace = 0;\n\t\tbo->fetch_objcore->keep = 0;\n\t}\n\n\tsynth_body = VSB_new_auto();\n\tAN(synth_body);\n\n\tVCL_backend_error_method(bo->vcl, wrk, NULL, bo, synth_body);\n\n\tAZ(VSB_finish(synth_body));\n\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL) {\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tif (wrk->handling == VCL_RET_RETRY) {\n\t\tVSB_destroy(&synth_body);\n\t\tif (bo->retries++ < cache_param->max_retries)\n\t\t\treturn (F_STP_RETRY);\n\t\tVSLb(bo->vsl, SLT_VCL_Error, \"Too many retries, failing\");\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\tbo->vfc->bo = bo;\n\tbo->vfc->wrk = bo->wrk;\n\tbo->vfc->oc = bo->fetch_objcore;\n\tbo->vfc->http = bo->beresp;\n\tbo->vfc->esi_req = bo->bereq;\n\n\tif (vbf_beresp2obj(bo)) {\n\t\t(void)VFP_Error(bo->vfc, \"Could not get storage\");\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tll = VSB_len(synth_body);\n\to = 0;\n\twhile (ll > 0) {\n\t\tl = ll;\n\t\tif (VFP_GetStorage(bo->vfc, &l, &ptr) != VFP_OK)\n\t\t\tbreak;\n\t\tmemcpy(ptr, VSB_data(synth_body) + o, l);\n\t\tVFP_Extend(bo->vfc, l);\n\t\tll -= l;\n\t\to += l;\n\t}\n\tAZ(ObjSetU64(wrk, bo->fetch_objcore, OA_LEN, o));\n\tVSB_destroy(&synth_body);\n\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FINISHED);\n\treturn (F_STP_DONE);\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "project": "varnish-cache", "commit_id": "176f8a075a963ffbfa56f1c460c15f6a1a6af5a7", "hash": 289862724300099148232715371041111764759, "size": 97, "message": "Avoid buffer read overflow on vcl_error and -sfile\n\nThe file stevedore may return a buffer larger than asked for when\nrequesting storage. Due to lack of check for this condition, the code\nto copy the synthetic error memory buffer from vcl_error would overrun\nthe buffer.\n\nPatch by @shamger\n\nFixes: #2429", "idx": 930}
{"func": "States& SSL::useStates()\n{\n    return states_;\n}", "target": 0, "cwe": ["CWE-254"], "project": "mysql-server", "commit_id": "e7061f7e5a96c66cb2e0bf46bec7f6ff35801a69", "hash": 218569659464353444806541647879750238690, "size": 4, "message": "Bug #22738607:  YASSL FUNCTION X509_NAME_GET_INDEX_BY_NID IS NOT WORKING AS EXPECTED.", "idx": 931}
{"func": "get_char_length_tree(Node* node, regex_t* reg, int* len)\n{\n  return get_char_length_tree1(node, reg, len, 0);\n}", "target": 0, "cwe": ["CWE-125"], "project": "php-src", "commit_id": "c6e34d91b88638966662caac62c4d0e90538e317", "hash": 277283236868617911980726449406624683885, "size": 4, "message": "Fix bug #77371 (heap buffer overflow in mb regex functions - compile_string_node)", "idx": 932}
{"func": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n\n}", "target": 1, "cwe": ["CWE-918"], "project": "arangodb", "commit_id": "d9b7f019d2435f107b19a59190bf9cc27d5f34dd", "hash": 35156937576729943531477075055023183623, "size": 23, "message": "[APM-78] Disable installation from remote URL (#15292)", "idx": 933}
{"func": "mptcp_print(netdissect_options *ndo,\n            const u_char *cp, u_int len, u_char flags)\n{\n        const struct mptcp_option *opt;\n        u_int subtype;\n\n        if (len < 3)\n                return 0;\n\n        opt = (const struct mptcp_option *) cp;\n        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);\n\n        ND_PRINT((ndo, \" %s\", mptcp_options[subtype].name));\n        return mptcp_options[subtype].print(ndo, cp, len, flags);\n}", "target": 0, "cwe": ["CWE-125", "CWE-787"], "project": "tcpdump", "commit_id": "4c3aee4bb0294c232d56b6d34e9eeb74f630fe8c", "hash": 263118687116177857108455144601675615760, "size": 15, "message": "CVE-2017-13040/MPTCP: Clean up printing DSS suboption.\n\nDo the length checking inline; that means we print stuff up to the point\nat which we run out of option data.\n\nFirst check to make sure we have at least 4 bytes of option, so we have\nflags to check.\n\nThis fixes a buffer over-read discovered by Kim Gwan Yeong.\n\nAdd a test using the capture file supplied by the reporter(s).", "idx": 934}
{"func": "SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,\n\t\tstruct sigevent __user *, timer_event_spec,\n\t\ttimer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (copy_from_user(&event, timer_event_spec, sizeof (event)))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}", "target": 0, "cwe": ["CWE-190"], "project": "linux", "commit_id": "78c9c4dfbf8c04883941445a195276bb4bb92c76", "hash": 320819527568444995019684844157196144371, "size": 13, "message": "posix-timers: Sanitize overrun handling\n\nThe posix timer overrun handling is broken because the forwarding functions\ncan return a huge number of overruns which does not fit in an int. As a\nconsequence timer_getoverrun(2) and siginfo::si_overrun can turn into\nrandom number generators.\n\nThe k_clock::timer_forward() callbacks return a 64 bit value now. Make\nk_itimer::ti_overrun[_last] 64bit as well, so the kernel internal\naccounting is correct. 3Remove the temporary (int) casts.\n\nAdd a helper function which clamps the overrun value returned to user space\nvia timer_getoverrun(2) or siginfo::si_overrun limited to a positive value\nbetween 0 and INT_MAX. INT_MAX is an indicator for user space that the\noverrun value has been clamped.\n\nReported-by: Team OWL337 <icytxw@gmail.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nAcked-by: John Stultz <john.stultz@linaro.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Michael Kerrisk <mtk.manpages@gmail.com>\nLink: https://lkml.kernel.org/r/20180626132705.018623573@linutronix.de", "idx": 935}
{"func": "int __kvm_set_memory_region(struct kvm *kvm,\n\t\t\t    struct kvm_userspace_memory_region *mem,\n\t\t\t    int user_alloc)\n{\n\tint r;\n\tgfn_t base_gfn;\n\tunsigned long npages;\n\tunsigned long i;\n\tstruct kvm_memory_slot *memslot;\n\tstruct kvm_memory_slot old, new;\n\tstruct kvm_memslots *slots, *old_memslots;\n\n\tr = -EINVAL;\n\t/* General sanity checks */\n\tif (mem->memory_size & (PAGE_SIZE - 1))\n\t\tgoto out;\n\tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n\t\tgoto out;\n\t/* We can read the guest memory with __xxx_user() later on. */\n\tif (user_alloc &&\n\t    ((mem->userspace_addr & (PAGE_SIZE - 1)) ||\n\t     !access_ok(VERIFY_WRITE,\n\t\t\t(void __user *)(unsigned long)mem->userspace_addr,\n\t\t\tmem->memory_size)))\n\t\tgoto out;\n\tif (mem->slot >= KVM_MEM_SLOTS_NUM)\n\t\tgoto out;\n\tif (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)\n\t\tgoto out;\n\n\tmemslot = id_to_memslot(kvm->memslots, mem->slot);\n\tbase_gfn = mem->guest_phys_addr >> PAGE_SHIFT;\n\tnpages = mem->memory_size >> PAGE_SHIFT;\n\n\tr = -EINVAL;\n\tif (npages > KVM_MEM_MAX_NR_PAGES)\n\t\tgoto out;\n\n\tif (!npages)\n\t\tmem->flags &= ~KVM_MEM_LOG_DIRTY_PAGES;\n\n\tnew = old = *memslot;\n\n\tnew.id = mem->slot;\n\tnew.base_gfn = base_gfn;\n\tnew.npages = npages;\n\tnew.flags = mem->flags;\n\n\t/* Disallow changing a memory slot's size. */\n\tr = -EINVAL;\n\tif (npages && old.npages && npages != old.npages)\n\t\tgoto out_free;\n\n\t/* Check for overlaps */\n\tr = -EEXIST;\n\tfor (i = 0; i < KVM_MEMORY_SLOTS; ++i) {\n\t\tstruct kvm_memory_slot *s = &kvm->memslots->memslots[i];\n\n\t\tif (s == memslot || !s->npages)\n\t\t\tcontinue;\n\t\tif (!((base_gfn + npages <= s->base_gfn) ||\n\t\t      (base_gfn >= s->base_gfn + s->npages)))\n\t\t\tgoto out_free;\n\t}\n\n\t/* Free page dirty bitmap if unneeded */\n\tif (!(new.flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\tnew.dirty_bitmap = NULL;\n\n\tr = -ENOMEM;\n\n\t/* Allocate if a slot is being created */\n\tif (npages && !old.npages) {\n\t\tnew.user_alloc = user_alloc;\n\t\tnew.userspace_addr = mem->userspace_addr;\n#ifndef CONFIG_S390\n\t\tnew.rmap = vzalloc(npages * sizeof(*new.rmap));\n\t\tif (!new.rmap)\n\t\t\tgoto out_free;\n#endif /* not defined CONFIG_S390 */\n\t\tif (kvm_arch_create_memslot(&new, npages))\n\t\t\tgoto out_free;\n\t}\n\n\t/* Allocate page dirty bitmap if needed */\n\tif ((new.flags & KVM_MEM_LOG_DIRTY_PAGES) && !new.dirty_bitmap) {\n\t\tif (kvm_create_dirty_bitmap(&new) < 0)\n\t\t\tgoto out_free;\n\t\t/* destroy any largepage mappings for dirty tracking */\n\t}\n\n\tif (!npages) {\n\t\tstruct kvm_memory_slot *slot;\n\n\t\tr = -ENOMEM;\n\t\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!slots)\n\t\t\tgoto out_free;\n\t\tslot = id_to_memslot(slots, mem->slot);\n\t\tslot->flags |= KVM_MEMSLOT_INVALID;\n\n\t\tupdate_memslots(slots, NULL);\n\n\t\told_memslots = kvm->memslots;\n\t\trcu_assign_pointer(kvm->memslots, slots);\n\t\tsynchronize_srcu_expedited(&kvm->srcu);\n\t\t/* From this point no new shadow pages pointing to a deleted\n\t\t * memslot will be created.\n\t\t *\n\t\t * validation of sp->gfn happens in:\n\t\t * \t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\t\t * \t- kvm_is_visible_gfn (mmu_check_roots)\n\t\t */\n\t\tkvm_arch_flush_shadow(kvm);\n\t\tkfree(old_memslots);\n\t}\n\n\tr = kvm_arch_prepare_memory_region(kvm, &new, old, mem, user_alloc);\n\tif (r)\n\t\tgoto out_free;\n\n\t/* map the pages in iommu page table */\n\tif (npages) {\n\t\tr = kvm_iommu_map_pages(kvm, &new);\n\t\tif (r)\n\t\t\tgoto out_free;\n\t}\n\n\tr = -ENOMEM;\n\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\tGFP_KERNEL);\n\tif (!slots)\n\t\tgoto out_free;\n\n\t/* actual memory is freed via old in kvm_free_physmem_slot below */\n\tif (!npages) {\n\t\tnew.rmap = NULL;\n\t\tnew.dirty_bitmap = NULL;\n\t\tmemset(&new.arch, 0, sizeof(new.arch));\n\t}\n\n\tupdate_memslots(slots, &new);\n\told_memslots = kvm->memslots;\n\trcu_assign_pointer(kvm->memslots, slots);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\tkvm_arch_commit_memory_region(kvm, mem, old, user_alloc);\n\n\t/*\n\t * If the new memory slot is created, we need to clear all\n\t * mmio sptes.\n\t */\n\tif (npages && old.base_gfn != mem->guest_phys_addr >> PAGE_SHIFT)\n\t\tkvm_arch_flush_shadow(kvm);\n\n\tkvm_free_physmem_slot(&old, &new);\n\tkfree(old_memslots);\n\n\treturn 0;\n\nout_free:\n\tkvm_free_physmem_slot(&new, &old);\nout:\n\treturn r;\n\n}", "target": 1, "cwe": ["CWE-264"], "project": "kvm", "commit_id": "32f6daad4651a748a58a3ab6da0611862175722f", "hash": 195116695660102534550070297632047081115, "size": 167, "message": "KVM: unmap pages from the iommu when slots are removed\n\nWe've been adding new mappings, but not destroying old mappings.\nThis can lead to a page leak as pages are pinned using\nget_user_pages, but only unpinned with put_page if they still\nexist in the memslots list on vm shutdown.  A memslot that is\ndestroyed while an iommu domain is enabled for the guest will\ntherefore result in an elevated page reference count that is\nnever cleared.\n\nAdditionally, without this fix, the iommu is only programmed\nwith the first translation for a gpa.  This can result in\npeer-to-peer errors if a mapping is destroyed and replaced by a\nnew mapping at the same gpa as the iommu will still be pointing\nto the original, pinned memory address.\n\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>", "idx": 936}
{"func": "cmp_addr_policies(smartlist_t *a, smartlist_t *b)\n{\n  int r, i;\n  int len_a = a ? smartlist_len(a) : 0;\n  int len_b = b ? smartlist_len(b) : 0;\n\n  for (i = 0; i < len_a && i < len_b; ++i) {\n    if ((r = cmp_single_addr_policy(smartlist_get(a, i), smartlist_get(b, i))))\n      return r;\n  }\n  if (i == len_a && i == len_b)\n    return 0;\n  if (i < len_a)\n    return -1;\n  else\n    return 1;\n}", "target": 1, "cwe": [], "project": "tor", "commit_id": "1afc2ed956a35b40dfd1d207652af5b50c295da7", "hash": 224323832711172152301829323289673399172, "size": 17, "message": "Fix policies.c instance of the \"if (r=(a-b)) return r\" pattern\n\nI think this one probably can't underflow, since the input ranges\nare small.  But let's not tempt fate.\n\nThis patch also replaces the \"cmp\" functions here with just \"eq\"\nfunctions, since nothing actually checked for anything besides 0 and\nnonzero.\n\nRelated to 21278.", "idx": 937}
{"func": "TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node,\n                                  TfLiteDepthwiseConvParams* params,\n                                  OpData* data, const TfLiteTensor* input,\n                                  const TfLiteTensor* filter,\n                                  const TfLiteTensor* bias,\n                                  TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n  const int batch_size = SizeOfDimension(input, 0);\n  TF_LITE_ENSURE(context, batch_size != 0);\n  const int input_size = NumElements(input) / batch_size;\n  TfLiteTensor* input_quantized;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_quantized_index,\n                                     &input_quantized));\n  int8_t* quantized_input_ptr_batch = input_quantized->data.int8;\n  TfLiteTensor* scaling_factors_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->scaling_factors_index,\n                                     &scaling_factors_tensor));\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor);\n  TfLiteTensor* input_offset_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_offset_index,\n                                     &input_offset_tensor));\n  int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor);\n\n  for (int b = 0; b < batch_size; ++b) {\n    const int offset = b * input_size;\n    tensor_utils::AsymmetricQuantizeFloats(\n        GetTensorData<float>(input) + offset, input_size,\n        quantized_input_ptr_batch + offset, &scaling_factors_ptr[b],\n        &input_offset_ptr[b]);\n  }\n\n  DepthwiseParams op_params;\n  op_params.padding_type = PaddingType::kSame;\n  op_params.padding_values.width = data->padding.width;\n  op_params.padding_values.height = data->padding.height;\n  op_params.stride_width = params->stride_width;\n  op_params.stride_height = params->stride_height;\n  op_params.dilation_width_factor = params->dilation_width_factor;\n  op_params.dilation_height_factor = params->dilation_height_factor;\n  op_params.depth_multiplier = params->depth_multiplier;\n\n  op_params.weights_offset = 0;\n  op_params.float_activation_min = output_activation_min;\n  op_params.float_activation_max = output_activation_max;\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  if (kernel_type == kReference) {\n    reference_integer_ops::DepthwiseConvHybridPerChannel(\n        op_params, scaling_factors_ptr, GetTensorShape(input),\n        quantized_input_ptr_batch, GetTensorShape(filter),\n        GetTensorData<int8>(filter), GetTensorShape(bias),\n        GetTensorData<float>(bias), GetTensorShape(output),\n        GetTensorData<float>(output), affine_quantization->scale->data,\n        input_offset_ptr);\n  } else {\n    optimized_integer_ops::DepthwiseConvHybridPerChannel(\n        op_params, scaling_factors_ptr, GetTensorShape(input),\n        quantized_input_ptr_batch, GetTensorShape(filter),\n        GetTensorData<int8>(filter), GetTensorShape(bias),\n        GetTensorData<float>(bias), GetTensorShape(output),\n        GetTensorData<float>(output), affine_quantization->scale->data,\n        input_offset_ptr, CpuBackendContext::GetFromContext(context));\n  }\n\n  return kTfLiteOk;\n}", "target": 1, "cwe": ["CWE-908"], "project": "tensorflow", "commit_id": "8933b8a21280696ab119b63263babdb54c298538", "hash": 337525428317234653609777031137182914582, "size": 71, "message": "Fix a null pointer exception caused by branching on uninitialized data.\n\nThis is due to not checking that the params for the quantization exists. If there is no quantization, we should not access the `.params` field.\n\nPiperOrigin-RevId: 385173491\nChange-Id: I8fc476c4b274fdb21ba741caa0fbc6d1b8840663", "idx": 938}
{"func": "static int am_validate_authn_context_class_ref(request_rec *r,\n        LassoSaml2Assertion *assertion) {\n    int i = 0;\n    LassoSaml2AuthnStatement *authn_statement = NULL;\n    LassoSaml2AuthnContext *authn_context = NULL;\n    am_dir_cfg_rec *dir_cfg;\n    apr_array_header_t *refs;\n\n    dir_cfg = am_get_dir_cfg(r);\n    refs = dir_cfg->authn_context_class_ref;\n    if (! refs->nelts)\n        return OK;\n\n    if (! assertion->AuthnStatement) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Missing AuthnStatement in assertion, returning BadRequest.\");\n        return HTTP_BAD_REQUEST;\n    }\n    /* we only consider the first AuthnStatement, I do not know of any idp\n     * sending more than one. */\n    authn_statement = g_list_first(assertion->AuthnStatement)->data;\n    if (! authn_statement->AuthnContext) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Missing AuthnContext in assertion, returning BadRequest.\");\n        return HTTP_BAD_REQUEST;\n    }\n    authn_context = authn_statement->AuthnContext;\n    if (! authn_context->AuthnContextClassRef) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Missing AuthnContextClassRef in assertion, returning Forbidden.\");\n        return HTTP_FORBIDDEN;\n    }\n    for (i = 0; i < refs->nelts; i++) {\n        const char *ref = ((char **)refs->elts)[i];\n        if (strcmp(ref, authn_context->AuthnContextClassRef) == 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                          \"AuthnContextClassRef (%s) matches the \"\n                          \"MellonAuthnContextClassRef directive, \"\n                          \"access can be granted.\",\n                          authn_context->AuthnContextClassRef);\n            return OK;\n        }\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  \"AuthnContextClassRef (%s) does not match the \"\n                  \"MellonAuthnContextClassRef directive, returning \"\n                  \"Forbidden.\",\n                  authn_context->AuthnContextClassRef);\n    return HTTP_FORBIDDEN;\n}", "target": 0, "cwe": [], "project": "mod_auth_mellon", "commit_id": "6bdda9170a8f1757dabc5b109958657417728018", "hash": 16567170106591468931763691725573245510, "size": 50, "message": "Fix segmentation fault when receiving badly formed logout message.\n\nIf the logout message is badly formed, we won't get the entityID in\n`logout->parent.remote_providerID`. If we call `apr_hash_get()` with a\nnull pointer, it will cause a segmentation fault.\n\nAdd a check to validate that the entityID is correctly set.", "idx": 939}
{"func": "build_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  /* initial guess at needed space */\n    char *component = NULL;\n\n    data = malloc(size * sizeof(krb5_data));\n    if (!data) { retval = ENOMEM; }\n\n    if (!retval) {\n        r = strdup(realm);\n        if (!r) { retval = ENOMEM; }\n    }\n\n    while (!retval && (component = va_arg(ap, char *))) {\n        if (count == size) {\n            krb5_data *new_data = NULL;\n\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    /* take ownership */\n        data = NULL; /* take ownership */\n    }\n\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n\n    return retval;\n}", "target": 1, "cwe": ["CWE-119", "CWE-125"], "project": "krb5", "commit_id": "f0c094a1b745d91ef2f9a4eae2149aac026a5789", "hash": 252675918525097052657660671360186264254, "size": 59, "message": "Fix build_principal memory bug [CVE-2015-2697]\n\nIn build_principal_va(), use k5memdup0() instead of strdup() to make a\ncopy of the realm, to ensure that we allocate the correct number of\nbytes and do not read past the end of the input string.  This bug\naffects krb5_build_principal(), krb5_build_principal_va(), and\nkrb5_build_principal_alloc_va().  krb5_build_principal_ext() is not\naffected.\n\nCVE-2015-2697:\n\nIn MIT krb5 1.7 and later, an authenticated attacker may be able to\ncause a KDC to crash using a TGS request with a large realm field\nbeginning with a null byte.  If the KDC attempts to find a referral to\nanswer the request, it constructs a principal name for lookup using\nkrb5_build_principal() with the requested realm.  Due to a bug in this\nfunction, the null byte causes only one byte be allocated for the\nrealm field of the constructed principal, far less than its length.\nSubsequent operations on the lookup principal may cause a read beyond\nthe end of the mapped memory region, causing the KDC process to crash.\n\nCVSSv2: AV:N/AC:L/Au:S/C:N/I:N/A:C/E:POC/RL:OF/RC:C\n\nticket: 8252 (new)\ntarget_version: 1.14\ntags: pullup", "idx": 940}
{"func": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-415"], "project": "linux", "commit_id": "251e22abde21833b3d29577e4d8c7aaccd650eee", "hash": 120073743616286829970611295684782467767, "size": 11, "message": "pinctrl: amd: Use devm_pinctrl_register() for pinctrl registration\n\nUse devm_pinctrl_register() for pin control registration and clean\nerror path.\n\nSigned-off-by: Laxman Dewangan <ldewangan@nvidia.com>\nSigned-off-by: Linus Walleij <linus.walleij@linaro.org>", "idx": 941}
{"func": "static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* FIXME: skip headers if necessary ?! */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n\t\t*addr_len = sizeof(*saddr);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}", "target": 1, "cwe": ["CWE-20"], "project": "net", "commit_id": "bceaa90240b6019ed73b49965eac7d167610be69", "hash": 301793387358630841513159711231184270180, "size": 44, "message": "inet: prevent leakage of uninitialized memory to user in recv syscalls\n\nOnly update *addr_len when we actually fill in sockaddr, otherwise we\ncan return uninitialized memory from the stack to the caller in the\nrecvfrom, recvmmsg and recvmsg syscalls. Drop the the (addr_len == NULL)\nchecks because we only get called with a valid addr_len pointer either\nfrom sock_common_recvmsg or inet_recvmsg.\n\nIf a blocking read waits on a socket which is concurrently shut down we\nnow return zero and set msg_msgnamelen to 0.\n\nReported-by: mpb <mpb.mail@gmail.com>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 942}
{"func": "apprentice_map(struct magic_set *ms, const char *fn)\n{\n\tuint32_t *ptr;\n\tuint32_t version, entries, nentries;\n\tint needsbyteswap;\n\tchar *dbname = NULL;\n\tstruct magic_map *map;\n\tsize_t i;\n\tphp_stream *stream = NULL;\n\tphp_stream_statbuf st;\n\n\n\tTSRMLS_FETCH();\n\n\tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL) {\n\t\tfile_oomem(ms, sizeof(*map));\n\t\tefree(map);\n\t\tgoto error;\n\t}\n\n\tif (fn == NULL) {\n\t\tmap->p = (void *)&php_magic_database;\n\t\tgoto internal_loaded;\n\t}\n\n#ifdef PHP_WIN32\n\t/* Don't bother on windows with php_stream_open_wrapper,\n\treturn to give apprentice_load() a chance. */\n\tif (php_stream_stat_path_ex((char *)fn, 0, &st, NULL) == SUCCESS) {\n               if (st.sb.st_mode & S_IFDIR) {\n                       goto error;\n               }\n       }\n#endif\n\n\tdbname = mkdbname(ms, fn, 0);\n\tif (dbname == NULL)\n\t\tgoto error;\n\n\t\tstream = php_stream_open_wrapper((char *)fn, \"rb\", REPORT_ERRORS, NULL);\n\n\tif (!stream) {\n\t\tgoto error;\n\t}\n\n\tif (php_stream_stat(stream, &st) < 0) {\n\t\tfile_error(ms, errno, \"cannot stat `%s'\", dbname);\n\t\tgoto error;\n\t}\n\n\tif (st.sb.st_size < 8) {\n\t\tfile_error(ms, 0, \"file `%s' is too small\", dbname);\n\t\tgoto error;\n\t}\n\n\tmap->len = (size_t)st.sb.st_size;\n\tif ((map->p = CAST(void *, emalloc(map->len))) == NULL) {\n\t\tfile_oomem(ms, map->len);\n\t\tgoto error;\n\t}\n\tif (php_stream_read(stream, map->p, (size_t)st.sb.st_size) != (size_t)st.sb.st_size) {\n\t\tfile_badread(ms);\n\t\tgoto error;\n\t}\n\tmap->len = 0;\n#define RET\t1\n\n\tphp_stream_close(stream);\n\tstream = NULL;\n\ninternal_loaded:\n\tptr = (uint32_t *)(void *)map->p;\n\tif (*ptr != MAGICNO) {\n\t\tif (swap4(*ptr) != MAGICNO) {\n\t\t\tfile_error(ms, 0, \"bad magic in `%s'\", dbname);\n\t\t\tgoto error;\n\t\t}\n\t\tneedsbyteswap = 1;\n\t} else\n\t\tneedsbyteswap = 0;\n\tif (needsbyteswap)\n\t\tversion = swap4(ptr[1]);\n\telse\n\t\tversion = ptr[1];\n\tif (version != VERSIONNO) {\n\t\tfile_error(ms, 0, \"File %d.%d supports only version %d magic \"\n\t\t    \"files. `%s' is version %d\", FILE_VERSION_MAJOR, patchlevel,\n\t\t    VERSIONNO, dbname, version);\n\t\tgoto error;\n\t}\n\n\t/* php_magic_database is a const, performing writes will segfault. This is for big-endian\n\tmachines only, PPC and Sparc specifically. Consider static variable or MINIT in\n\tfuture. */\n\tif (needsbyteswap && fn == NULL) {\n\t\tmap->p = emalloc(sizeof(php_magic_database));\n\t\tmap->p = memcpy(map->p, php_magic_database, sizeof(php_magic_database));\n\t}\n\n\tif (NULL != fn) {\n\t\tnentries = (uint32_t)(st.sb.st_size / sizeof(struct magic));\n\t\tentries = (uint32_t)(st.sb.st_size / sizeof(struct magic));\n\t\tif ((off_t)(entries * sizeof(struct magic)) != st.sb.st_size) {\n\t\t\tfile_error(ms, 0, \"Size of `%s' %llu is not a multiple of %zu\",\n\t\t\t\tdbname, (unsigned long long)st.sb.st_size,\n\t\t\t\tsizeof(struct magic));\n\t\t\tgoto error;\n\t\t}\n\t}\n\tmap->magic[0] = CAST(struct magic *, map->p) + 1;\n\tnentries = 0;\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tif (needsbyteswap)\n\t\t\tmap->nmagic[i] = swap4(ptr[i + 2]);\n\t\telse\n\t\t\tmap->nmagic[i] = ptr[i + 2];\n\t\tif (i != MAGIC_SETS - 1)\n\t\t\tmap->magic[i + 1] = map->magic[i] + map->nmagic[i];\n\t\tnentries += map->nmagic[i];\n\t}\n\tif (NULL != fn && entries != nentries + 1) {\n\t\tfile_error(ms, 0, \"Inconsistent entries in `%s' %u != %u\",\n\t\t    dbname, entries, nentries + 1);\n\t\tgoto error;\n\t}\n\n\tif (needsbyteswap)\n\t\tfor (i = 0; i < MAGIC_SETS; i++)\n\t\t\tbyteswap(map->magic[i], map->nmagic[i]);\n\n\tif (dbname) {\n\t\tefree(dbname);\n\t}\n\treturn map;\n\nerror:\n\tif (stream) {\n\t\tphp_stream_close(stream);\n\t}\n\tapprentice_unmap(map);\n\tif (dbname) {\n\t\tefree(dbname);\n\t}\n\treturn NULL;\n}", "target": 0, "cwe": ["CWE-17"], "project": "php-src", "commit_id": "a72cd07f2983dc43a6bb35209dc4687852e53c09", "hash": 125574356621690575720089271524033792635, "size": 145, "message": "Fixed bug #68665 (Invalid free)", "idx": 943}
{"func": "static int get_rdrand_seed()\n{\n    DEBUG_SEED(\"get_rdrand_seed\");\n    int r;\n    while (_rdrand32_step(&r) == 0);\n    return r;\n}", "target": 0, "cwe": ["CWE-119", "CWE-310"], "project": "json-c", "commit_id": "64e36901a0614bf64a19bc3396469c66dcd0b015", "hash": 330033677679254991498513801656040105490, "size": 7, "message": "Patch to address the following issues:\n\n* CVE-2013-6371: hash collision denial of service\n* CVE-2013-6370: buffer overflow if size_t is larger than int", "idx": 944}
{"func": "xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,\n\t\t\t\t   xmlSchemaTypePtr type)\n{\n    if (! WXS_IS_UNION(type))\n\treturn(0);\n    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,\n\ttype->memberTypes));\n}", "target": 0, "cwe": ["CWE-134"], "project": "libxml2", "commit_id": "4472c3a5a5b516aaf59b89be602fbce52756c3e9", "hash": 260310748164068691822083983595990857297, "size": 8, "message": "Fix some format string warnings with possible format string vulnerability\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=761029\n\nDecorate every method in libxml2 with the appropriate\nLIBXML_ATTR_FORMAT(fmt,args) macro and add some cleanups\nfollowing the reports.", "idx": 945}
{"func": "struct lzxd_stream *lzxd_init(struct mspack_system *system,\n\t\t\t      struct mspack_file *input,\n\t\t\t      struct mspack_file *output,\n\t\t\t      int window_bits,\n\t\t\t      int reset_interval,\n\t\t\t      int input_buffer_size,\n\t\t\t      off_t output_length,\n\t\t\t      char is_delta)\n{\n  unsigned int window_size = 1 << window_bits;\n  struct lzxd_stream *lzx;\n\n  if (!system) return NULL;\n\n  /* LZX DELTA window sizes are between 2^17 (128KiB) and 2^25 (32MiB),\n   * regular LZX windows are between 2^15 (32KiB) and 2^21 (2MiB)\n   */\n  if (is_delta) {\n      if (window_bits < 17 || window_bits > 25) return NULL;\n  }\n  else {\n      if (window_bits < 15 || window_bits > 21) return NULL;\n  }\n\n  input_buffer_size = (input_buffer_size + 1) & -2;\n  if (!input_buffer_size) return NULL;\n\n  /* allocate decompression state */\n  if (!(lzx = (struct lzxd_stream *) system->alloc(system, sizeof(struct lzxd_stream)))) {\n    return NULL;\n  }\n\n  /* allocate decompression window and input buffer */\n  lzx->window = (unsigned char *) system->alloc(system, (size_t) window_size);\n  lzx->inbuf  = (unsigned char *) system->alloc(system, (size_t) input_buffer_size);\n  if (!lzx->window || !lzx->inbuf) {\n    system->free(lzx->window);\n    system->free(lzx->inbuf);\n    system->free(lzx);\n    return NULL;\n  }\n\n  /* initialise decompression state */\n  lzx->sys             = system;\n  lzx->input           = input;\n  lzx->output          = output;\n  lzx->offset          = 0;\n  lzx->length          = output_length;\n\n  lzx->inbuf_size      = input_buffer_size;\n  lzx->window_size     = 1 << window_bits;\n  lzx->ref_data_size   = 0;\n  lzx->window_posn     = 0;\n  lzx->frame_posn      = 0;\n  lzx->frame           = 0;\n  lzx->reset_interval  = reset_interval;\n  lzx->intel_filesize  = 0;\n  lzx->intel_curpos    = 0;\n  lzx->intel_started   = 0;\n  lzx->error           = MSPACK_ERR_OK;\n  lzx->num_offsets     = position_slots[window_bits - 15] << 3;\n  lzx->is_delta        = is_delta;\n\n  lzx->o_ptr = lzx->o_end = &lzx->e8_buf[0];\n  lzxd_reset_state(lzx);\n  INIT_BITS;\n  return lzx;\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "clamav-devel", "commit_id": "a83773682e856ad6529ba6db8d1792e6d515d7f1", "hash": 262175092694984811426811358294525256871, "size": 68, "message": "fixing potential OOB window write when unpacking chm files", "idx": 946}
{"func": "run_sigchld_trap (nchild)\n     int nchild;\n{\n  char *trap_command;\n  int i;\n\n  /* Turn off the trap list during the call to parse_and_execute ()\n     to avoid potentially infinite recursive calls.  Preserve the\n     values of last_command_exit_value, last_made_pid, and the_pipeline\n     around the execution of the trap commands. */\n  trap_command = savestring (trap_list[SIGCHLD]);\n\n  begin_unwind_frame (\"SIGCHLD trap\");\n  unwind_protect_int (last_command_exit_value);\n  unwind_protect_int (last_command_exit_signal);\n  unwind_protect_var (last_made_pid);\n  unwind_protect_int (interrupt_immediately);\n  unwind_protect_int (jobs_list_frozen);\n  unwind_protect_pointer (the_pipeline);\n  unwind_protect_pointer (subst_assign_varlist);\n  unwind_protect_pointer (this_shell_builtin);\n\n  /* We have to add the commands this way because they will be run\n     in reverse order of adding.  We don't want maybe_set_sigchld_trap ()\n     to reference freed memory. */\n  add_unwind_protect (xfree, trap_command);\n  add_unwind_protect (maybe_set_sigchld_trap, trap_command);\n\n  subst_assign_varlist = (WORD_LIST *)NULL;\n  the_pipeline = (PROCESS *)NULL;\n\n  running_trap = SIGCHLD + 1;\n\n  set_impossible_sigchld_trap ();\n  jobs_list_frozen = 1;\n  for (i = 0; i < nchild; i++)\n    {\n#if 0\n      interrupt_immediately = 1;\n#endif\n      parse_and_execute (savestring (trap_command), \"trap\", SEVAL_NOHIST|SEVAL_RESETLINE);\n    }\n\n  run_unwind_frame (\"SIGCHLD trap\");\n  running_trap = 0;\n}", "target": 1, "cwe": [], "project": "bash", "commit_id": "955543877583837c85470f7fb8a97b7aa8d45e6c", "hash": 250530469649440026541707762131958542503, "size": 46, "message": "bash-4.4-rc2 release", "idx": 947}
{"func": "static void ext4_da_page_release_reservation(struct page *page,\n\t\t\t\t\t     unsigned int offset,\n\t\t\t\t\t     unsigned int length)\n{\n\tint to_release = 0, contiguous_blks = 0;\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tunsigned int stop = offset + length;\n\tint num_clusters;\n\text4_fsblk_t lblk;\n\n\tBUG_ON(stop > PAGE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\n\t\tif (next_off > stop)\n\t\t\tbreak;\n\n\t\tif ((offset <= curr_off) && (buffer_delay(bh))) {\n\t\t\tto_release++;\n\t\t\tcontiguous_blks++;\n\t\t\tclear_buffer_delay(bh);\n\t\t} else if (contiguous_blks) {\n\t\t\tlblk = page->index <<\n\t\t\t       (PAGE_SHIFT - inode->i_blkbits);\n\t\t\tlblk += (curr_off >> inode->i_blkbits) -\n\t\t\t\tcontiguous_blks;\n\t\t\text4_es_remove_extent(inode, lblk, contiguous_blks);\n\t\t\tcontiguous_blks = 0;\n\t\t}\n\t\tcurr_off = next_off;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (contiguous_blks) {\n\t\tlblk = page->index << (PAGE_SHIFT - inode->i_blkbits);\n\t\tlblk += (curr_off >> inode->i_blkbits) - contiguous_blks;\n\t\text4_es_remove_extent(inode, lblk, contiguous_blks);\n\t}\n\n\t/* If we have released all the blocks belonging to a cluster, then we\n\t * need to release the reserved space for that cluster. */\n\tnum_clusters = EXT4_NUM_B2C(sbi, to_release);\n\twhile (num_clusters > 0) {\n\t\tlblk = (page->index << (PAGE_SHIFT - inode->i_blkbits)) +\n\t\t\t((num_clusters - 1) << sbi->s_cluster_bits);\n\t\tif (sbi->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, lblk))\n\t\t\text4_da_release_space(inode, 1);\n\n\t\tnum_clusters--;\n\t}\n}", "target": 0, "cwe": ["CWE-200"], "project": "linux", "commit_id": "06bd3c36a733ac27962fea7d6f47168841376824", "hash": 64574512709863915472486919226963395323, "size": 57, "message": "ext4: fix data exposure after a crash\n\nHuang has reported that in his powerfail testing he is seeing stale\nblock contents in some of recently allocated blocks although he mounts\next4 in data=ordered mode. After some investigation I have found out\nthat indeed when delayed allocation is used, we don't add inode to\ntransaction's list of inodes needing flushing before commit. Originally\nwe were doing that but commit f3b59291a69d removed the logic with a\nflawed argument that it is not needed.\n\nThe problem is that although for delayed allocated blocks we write their\ncontents immediately after allocating them, there is no guarantee that\nthe IO scheduler or device doesn't reorder things and thus transaction\nallocating blocks and attaching them to inode can reach stable storage\nbefore actual block contents. Actually whenever we attach freshly\nallocated blocks to inode using a written extent, we should add inode to\ntransaction's ordered inode list to make sure we properly wait for block\ncontents to be written before committing the transaction. So that is\nwhat we do in this patch. This also handles other cases where stale data\nexposure was possible - like filling hole via mmap in\ndata=ordered,nodelalloc mode.\n\nThe only exception to the above rule are extending direct IO writes where\nblkdev_direct_IO() waits for IO to complete before increasing i_size and\nthus stale data exposure is not possible. For now we don't complicate\nthe code with optimizing this special case since the overhead is pretty\nlow. In case this is observed to be a performance problem we can always\nhandle it using a special flag to ext4_map_blocks().\n\nCC: stable@vger.kernel.org\nFixes: f3b59291a69d0b734be1fc8be489fef2dd846d3d\nReported-by: \"HUANG Weller (CM/ESW12-CN)\" <Weller.Huang@cn.bosch.com>\nTested-by: \"HUANG Weller (CM/ESW12-CN)\" <Weller.Huang@cn.bosch.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>", "idx": 948}
{"func": "psutil_per_cpu_times(PyObject *self, PyObject *args) {\n    natural_t cpu_count;\n    natural_t i;\n    processor_info_array_t info_array;\n    mach_msg_type_number_t info_count;\n    kern_return_t error;\n    processor_cpu_load_info_data_t *cpu_load_info = NULL;\n    int ret;\n    PyObject *py_retlist = PyList_New(0);\n    PyObject *py_cputime = NULL;\n\n    if (py_retlist == NULL)\n        return NULL;\n\n    mach_port_t host_port = mach_host_self();\n    error = host_processor_info(host_port, PROCESSOR_CPU_LOAD_INFO,\n                                &cpu_count, &info_array, &info_count);\n    if (error != KERN_SUCCESS) {\n        PyErr_Format(\n            PyExc_RuntimeError,\n            \"host_processor_info(PROCESSOR_CPU_LOAD_INFO) syscall failed: %s\",\n             mach_error_string(error));\n        goto error;\n    }\n    mach_port_deallocate(mach_task_self(), host_port);\n\n    cpu_load_info = (processor_cpu_load_info_data_t *) info_array;\n\n    for (i = 0; i < cpu_count; i++) {\n        py_cputime = Py_BuildValue(\n            \"(dddd)\",\n            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_USER] / CLK_TCK,\n            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_NICE] / CLK_TCK,\n            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_SYSTEM] / CLK_TCK,\n            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_IDLE] / CLK_TCK\n        );\n        if (!py_cputime)\n            goto error;\n        if (PyList_Append(py_retlist, py_cputime))\n            goto error;\n        Py_DECREF(py_cputime);\n    }\n\n    ret = vm_deallocate(mach_task_self(), (vm_address_t)info_array,\n                        info_count * sizeof(int));\n    if (ret != KERN_SUCCESS)\n        PyErr_WarnEx(PyExc_RuntimeWarning, \"vm_deallocate() failed\", 2);\n    return py_retlist;\n\nerror:\n    Py_XDECREF(py_cputime);\n    Py_DECREF(py_retlist);\n    if (cpu_load_info != NULL) {\n        ret = vm_deallocate(mach_task_self(), (vm_address_t)info_array,\n                            info_count * sizeof(int));\n        if (ret != KERN_SUCCESS)\n            PyErr_WarnEx(PyExc_RuntimeWarning, \"vm_deallocate() failed\", 2);\n    }\n    return NULL;\n}", "target": 1, "cwe": ["CWE-415"], "project": "psutil", "commit_id": "7d512c8e4442a896d56505be3e78f1156f443465", "hash": 213009054925852913159935570748005574377, "size": 60, "message": "Use Py_CLEAR instead of Py_DECREF to also set the variable to NULL (#1616)\n\nThese files contain loops that convert system data into python objects\r\nand during the process they create objects and dereference their\r\nrefcounts after they have been added to the resulting list.\r\n\r\nHowever, in case of errors during the creation of those python objects,\r\nthe refcount to previously allocated objects is dropped again with\r\nPy_XDECREF, which should be a no-op in case the paramater is NULL. Even\r\nso, in most of these loops the variables pointing to the objects are\r\nnever set to NULL, even after Py_DECREF is called at the end of the loop\r\niteration. This means, after the first iteration, if an error occurs\r\nthose python objects will get their refcount dropped two times,\r\nresulting in a possible double-free.", "idx": 949}
{"func": "static noinline void vmwrite_error(unsigned long field, unsigned long value)\n{\n\tprintk(KERN_ERR \"vmwrite error: reg %lx value %lx (err %d)\\n\",\n\t       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));\n\tdump_stack();\n}", "target": 0, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "16175a796d061833aacfbd9672235f2d2725df65", "hash": 300106292851313859179967774695068312203, "size": 6, "message": "KVM: VMX: Don't allow uninhibited access to EFER on i386\n\nvmx_set_msr() does not allow i386 guests to touch EFER, but they can still\ndo so through the default: label in the switch.  If they set EFER_LME, they\ncan oops the host.\n\nFix by having EFER access through the normal channel (which will check for\nEFER_LME) even on i386.\n\nReported-and-tested-by: Benjamin Gilbert <bgilbert@cs.cmu.edu>\nCc: stable@kernel.org\nSigned-off-by: Avi Kivity <avi@redhat.com>", "idx": 950}
{"func": "static void bond_uninit(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct bond_up_slave *usable, *all;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tbond_netpoll_cleanup(bond_dev);\n\n\t/* Release the bonded slaves */\n\tbond_for_each_slave(bond, slave, iter)\n\t\t__bond_release_one(bond_dev, slave->dev, true, true);\n\tnetdev_info(bond_dev, \"Released all slaves\\n\");\n\n\tusable = rtnl_dereference(bond->usable_slaves);\n\tif (usable) {\n\t\tRCU_INIT_POINTER(bond->usable_slaves, NULL);\n\t\tkfree_rcu(usable, rcu);\n\t}\n\n\tall = rtnl_dereference(bond->all_slaves);\n\tif (all) {\n\t\tRCU_INIT_POINTER(bond->all_slaves, NULL);\n\t\tkfree_rcu(all, rcu);\n\t}\n\n\tlist_del(&bond->bond_list);\n\n\tbond_debug_unregister(bond);\n}", "target": 0, "cwe": ["CWE-476", "CWE-703"], "project": "linux", "commit_id": "105cd17a866017b45f3c45901b394c711c97bf40", "hash": 292186587943727692697965447420892666308, "size": 30, "message": "bonding: fix null dereference in bond_ipsec_add_sa()\n\nIf bond doesn't have real device, bond->curr_active_slave is null.\nBut bond_ipsec_add_sa() dereferences bond->curr_active_slave without\nnull checking.\nSo, null-ptr-deref would occur.\n\nTest commands:\n    ip link add bond0 type bond\n    ip link set bond0 up\n    ip x s add proto esp dst 14.1.1.1 src 15.1.1.1 spi \\\n0x07 mode transport reqid 0x07 replay-window 32 aead 'rfc4106(gcm(aes))' \\\n0x44434241343332312423222114131211f4f3f2f1 128 sel src 14.0.0.52/24 \\\ndst 14.0.0.70/24 proto tcp offload dev bond0 dir in\n\nSplat looks like:\nKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\nCPU: 4 PID: 680 Comm: ip Not tainted 5.13.0-rc3+ #1168\nRIP: 0010:bond_ipsec_add_sa+0xc4/0x2e0 [bonding]\nCode: 85 21 02 00 00 4d 8b a6 48 0c 00 00 e8 75 58 44 ce 85 c0 0f 85 14\n01 00 00 48 b8 00 00 00 00 00 fc ff df 4c 89 e2 48 c1 ea 03 <80> 3c 02\n00 0f 85 fc 01 00 00 48 8d bb e0 02 00 00 4d 8b 2c 24 48\nRSP: 0018:ffff88810946f508 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffff88810b4e8040 RCX: 0000000000000001\nRDX: 0000000000000000 RSI: ffffffff8fe34280 RDI: ffff888115abe100\nRBP: ffff88810946f528 R08: 0000000000000003 R09: fffffbfff2287e11\nR10: 0000000000000001 R11: ffff888115abe0c8 R12: 0000000000000000\nR13: ffffffffc0aea9a0 R14: ffff88800d7d2000 R15: ffff88810b4e8330\nFS:  00007efc5552e680(0000) GS:ffff888119c00000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000055c2530dbf40 CR3: 0000000103056004 CR4: 00000000003706e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n xfrm_dev_state_add+0x2a9/0x770\n ? memcpy+0x38/0x60\n xfrm_add_sa+0x2278/0x3b10 [xfrm_user]\n ? xfrm_get_policy+0xaa0/0xaa0 [xfrm_user]\n ? register_lock_class+0x1750/0x1750\n xfrm_user_rcv_msg+0x331/0x660 [xfrm_user]\n ? rcu_read_lock_sched_held+0x91/0xc0\n ? xfrm_user_state_lookup.constprop.39+0x320/0x320 [xfrm_user]\n ? find_held_lock+0x3a/0x1c0\n ? mutex_lock_io_nested+0x1210/0x1210\n ? sched_clock_cpu+0x18/0x170\n netlink_rcv_skb+0x121/0x350\n ? xfrm_user_state_lookup.constprop.39+0x320/0x320 [xfrm_user]\n ? netlink_ack+0x9d0/0x9d0\n ? netlink_deliver_tap+0x17c/0xa50\n xfrm_netlink_rcv+0x68/0x80 [xfrm_user]\n netlink_unicast+0x41c/0x610\n ? netlink_attachskb+0x710/0x710\n netlink_sendmsg+0x6b9/0xb70\n[ ...]\n\nFixes: 18cb261afd7b (\"bonding: support hardware encryption offload to slaves\")\nSigned-off-by: Taehee Yoo <ap420073@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 951}
{"func": "QString BootDoctor::errorString()\n{\n    return m_lastErrorString;\n}", "target": 0, "cwe": ["CWE-59", "CWE-61"], "project": "deepin-clone", "commit_id": "e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab", "hash": 22279092150906717852281326051642855557, "size": 4, "message": "fix: Do not use the \"/tmp\" directory\n\nhttps://github.com/linuxdeepin/deepin-clone/issues/16\nhttps://bugzilla.opensuse.org/show_bug.cgi?id=1130388", "idx": 952}
{"func": "static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)\n{\n\tBYTE c;\n\tBYTE flags;\n\tUINT32 extra = 0;\n\tint opIndex;\n\tint haveBits;\n\tint inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment = segmentSize - 1;\n\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(stream, flags); /* header (1 byte) */\n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tStream_Seek(stream, cbSegment);\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\n\tzgfx->pbInputCurrent = pbSegment;\n\tzgfx->pbInputEnd = &pbSegment[cbSegment - 1];\n\t/* NumberOfBitsToDecode = ((NumberOfBytesToDecode - 1) * 8) - ValueOfLastByte */\n\tzgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;\n\tzgfx->cBitsCurrent = 0;\n\tzgfx->BitsCurrent = 0;\n\n\twhile (zgfx->cBitsRemaining)\n\t{\n\t\thaveBits = 0;\n\t\tinPrefix = 0;\n\n\t\tfor (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)\n\t\t{\n\t\t\twhile (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)\n\t\t\t{\n\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\tinPrefix = (inPrefix << 1) + zgfx->bits;\n\t\t\t\thaveBits++;\n\t\t\t}\n\n\t\t\tif (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)\n\t\t\t{\n\t\t\t\tif (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)\n\t\t\t\t{\n\t\t\t\t\t/* Literal */\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tdistance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;\n\n\t\t\t\t\tif (distance != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Match */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\tif (zgfx->bits == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 4;\n\t\t\t\t\t\t\textra = 2;\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\t\twhile (zgfx->bits == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount *= 2;\n\t\t\t\t\t\t\t\textra++;\n\t\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Unencoded */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}", "target": 1, "cwe": ["CWE-119", "CWE-125", "CWE-787"], "project": "FreeRDP", "commit_id": "17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7", "hash": 49543813041022765347790625235930791255, "size": 122, "message": "Fixed CVE-2018-8784\n\nThanks to Eyal Itkin from Check Point Software Technologies.", "idx": 953}
{"func": "static unsigned int irda_poll(struct file * file, struct socket *sock,\n\t\t\t      poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tunsigned int mask;\n\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\n\tpoll_wait(file, sk->sk_sleep, wait);\n\tmask = 0;\n\n\t/* Exceptional events? */\n\tif (sk->sk_err)\n\t\tmask |= POLLERR;\n\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\tIRDA_DEBUG(0, \"%s(), POLLHUP\\n\", __func__);\n\t\tmask |= POLLHUP;\n\t}\n\n\t/* Readable? */\n\tif (!skb_queue_empty(&sk->sk_receive_queue)) {\n\t\tIRDA_DEBUG(4, \"Socket is readable\\n\");\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\n\t/* Connection-based need to check for termination and startup */\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\tIRDA_DEBUG(0, \"%s(), POLLHUP\\n\", __func__);\n\t\t\tmask |= POLLHUP;\n\t\t}\n\n\t\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\t\tif ((self->tx_flow == FLOW_START) &&\n\t\t\t    sock_writeable(sk))\n\t\t\t{\n\t\t\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif ((self->tx_flow == FLOW_START) &&\n\t\t    sock_writeable(sk))\n\t\t{\n\t\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\t\t}\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tif (sock_writeable(sk))\n\t\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn mask;\n}", "target": 0, "cwe": ["CWE-200"], "project": "linux-2.6", "commit_id": "09384dfc76e526c3993c09c42e016372dc9dd22c", "hash": 259380128299509018556345339431407482066, "size": 58, "message": "irda: Fix irda_getname() leak\n\nirda_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 954}
{"func": "nautilus_file_get_icon (NautilusFile *file,\n\t\t\tint size,\n\t\t\tNautilusFileIconFlags flags)\n{\n\tNautilusIconInfo *icon;\n\tGIcon *gicon;\n\tGdkPixbuf *raw_pixbuf, *scaled_pixbuf;\n\tint modified_size;\n\n\tif (file == NULL) {\n\t\treturn NULL;\n\t}\n\t\n\tgicon = get_custom_icon (file);\n\tif (gicon) {\n\t\ticon = nautilus_icon_info_lookup (gicon, size);\n\t\tg_object_unref (gicon);\n\t\treturn icon;\n\t}\n\n\tif (flags & NAUTILUS_FILE_ICON_FLAGS_FORCE_THUMBNAIL_SIZE) {\n\t\tmodified_size = size;\n\t} else {\n\t\tmodified_size = size * cached_thumbnail_size / NAUTILUS_ICON_SIZE_STANDARD; \n\t}\n\n\tif (flags & NAUTILUS_FILE_ICON_FLAGS_USE_THUMBNAILS &&\n\t    nautilus_file_should_show_thumbnail (file)) {\n\t\tif (file->details->thumbnail) {\n\t\t\tint w, h, s;\n\t\t\tdouble scale;\n\n\t\t\traw_pixbuf = g_object_ref (file->details->thumbnail);\n\n\t\t\tw = gdk_pixbuf_get_width (raw_pixbuf);\n\t\t\th = gdk_pixbuf_get_height (raw_pixbuf);\n\t\t\t\n\t\t\ts = MAX (w, h);\n\t\t\tscale = (double)modified_size / s;\n\n\n\t\t\tif (scale > 0.99) {\n\t\t\t\t/* never scale any thumbnails up */\n\t\t\t\tscaled_pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB,\n\t\t\t\t\t\t\t\tgdk_pixbuf_get_has_alpha (raw_pixbuf),\n\t\t\t\t\t\t\t\tgdk_pixbuf_get_bits_per_sample (raw_pixbuf),\n\t\t\t\t\t\t\t\tw * scale, h * scale);\n\t\t\t\tgdk_pixbuf_fill (scaled_pixbuf, 0xffffff00);\n\t\t\t\tgdk_pixbuf_copy_area (raw_pixbuf,\n\t\t\t\t\t\t      0, 0, w, h,\n\t\t\t\t\t\t      scaled_pixbuf,\n\t\t\t\t\t\t      (gdk_pixbuf_get_width (scaled_pixbuf) - w) / 2,\n\t\t\t\t\t\t      (gdk_pixbuf_get_height (scaled_pixbuf) - h) / 2);\n\t\t\t} else {\n\t\t\t\tscaled_pixbuf = gdk_pixbuf_scale_simple (raw_pixbuf,\n\t\t\t\t\t\t\t\t\t w * scale, h * scale,\n\t\t\t\t\t\t\t\t\t GDK_INTERP_BILINEAR);\n\t\t\t}\n\t\t\tnautilus_thumbnail_frame_image (&scaled_pixbuf);\n\t\t\tg_object_unref (raw_pixbuf);\n\n\t\t\tif (modified_size > 128 &&\n\t\t\t    !file->details->thumbnail_wants_original) {\n\t\t\t\t/* Invalidate if we resize upward */\n\t\t\t\tfile->details->thumbnail_wants_original = TRUE;\n\t\t\t\tnautilus_file_invalidate_attributes (file, NAUTILUS_FILE_ATTRIBUTE_THUMBNAIL);\n\t\t\t}\n\t\t\t\n\t\t\ticon = nautilus_icon_info_new_for_pixbuf (scaled_pixbuf);\n\t\t\tg_object_unref (scaled_pixbuf);\n\t\t\treturn icon;\n\t\t} else if (file->details->thumbnail_path == NULL &&\n\t\t\t   file->details->can_read &&\t\t\t\t\n\t\t\t   !file->details->is_thumbnailing &&\n\t\t\t   (!file->details->thumbnailing_failed ||\n\t\t\t    !nautilus_has_valid_failed_thumbnail (file))) {\n\t\t\tif (nautilus_can_thumbnail (file)) {\n\t\t\t\tnautilus_create_thumbnail (file);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (file->details->is_thumbnailing &&\n\t    flags & NAUTILUS_FILE_ICON_FLAGS_USE_THUMBNAILS)\n\t\tgicon = g_themed_icon_new (ICON_NAME_THUMBNAIL_LOADING);\n\telse\n\t\tgicon = nautilus_file_get_gicon (file, flags);\n\t\n\tif (gicon) {\n\t\ticon = nautilus_icon_info_lookup (gicon, size);\n\t\tif (nautilus_icon_info_is_fallback (icon)) {\n\t\t\tg_object_unref (icon);\n\t\t\ticon = nautilus_icon_info_lookup (get_default_file_icon (flags), size);\n\t\t}\n\t\tg_object_unref (gicon);\n\t\treturn icon;\n\t} else {\n\t\treturn nautilus_icon_info_lookup (get_default_file_icon (flags), size);\n\t}\n}", "target": 0, "cwe": [], "project": "nautilus", "commit_id": "7632a3e13874a2c5e8988428ca913620a25df983", "hash": 45580439508203716818209214200365092817, "size": 100, "message": "Check for trusted desktop file launchers.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-directory-async.c:\n\tCheck for trusted desktop file launchers.\n\n        * libnautilus-private/nautilus-file-private.h:\n        * libnautilus-private/nautilus-file.c:\n        * libnautilus-private/nautilus-file.h:\n        Add nautilus_file_is_trusted_link.\n\tAllow unsetting of custom display name.\n\n        * libnautilus-private/nautilus-mime-actions.c:\n\tDisplay dialog when trying to launch a non-trusted desktop file.\n\n\n\nsvn path=/trunk/; revision=15003", "idx": 955}
{"func": "bool Item_param::add_as_clone(THD *thd)\n{\n  LEX *lex= thd->lex;\n  uint master_pos= pos_in_query + lex->clone_spec_offset;\n  List_iterator_fast<Item_param> it(lex->param_list);\n  Item_param *master_param;\n  while ((master_param = it++))\n  {\n    if (master_pos == master_param->pos_in_query)\n      return master_param->register_clone(this);\n  }\n  DBUG_ASSERT(false);\n  return false;\n}", "target": 0, "cwe": ["CWE-89"], "project": "server", "commit_id": "b5e16a6e0381b28b598da80b414168ce9a5016e5", "hash": 2983293294243452296292233074171125204, "size": 14, "message": "MDEV-26061 MariaDB server crash at Field::set_default\n\n* Item_default_value::fix_fields creates a copy of its argument's field.\n* Field::default_value is changed when its expression is prepared in\n  unpack_vcol_info_from_frm()\n\nThis means we must unpack any vcol expression that includes DEFAULT(x)\nstrictly after unpacking x->default_value.\n\nTo avoid building and solving this dependency graph on every table open,\nwe update Item_default_value::field->default_value after all vcols\nare unpacked and fixed.", "idx": 956}
{"func": "dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n{\n\tint i=-1;\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len;\n\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\n\t/* Try to find item in queue, to prevent duplicate entries */\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\n\t/* If we already have an entry and this one is a fragment,\n\t * don't discard it and rather try to reassemble it.\n\t */\n\tif (item != NULL && frag_len < msg_hdr->msg_len)\n\t\titem = NULL;\n\n\t/* Discard the message if sequence number was already there, is\n\t * too far in the future, already in the queue or if we received\n\t * a FINISHED before the SERVER_HELLO, which then must be a stale\n\t * retransmit.\n\t */\n\tif (msg_hdr->seq <= s->d1->handshake_read_seq ||\n\t\tmsg_hdr->seq > s->d1->handshake_read_seq + 10 || item != NULL ||\n\t\t(s->d1->handshake_read_seq == 0 && msg_hdr->type == SSL3_MT_FINISHED))\n\t\t{\n\t\tunsigned char devnull [256];\n\n\t\twhile (frag_len)\n\t\t\t{\n\t\t\ti = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\t\t\tdevnull,\n\t\t\t\tfrag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);\n\t\t\tif (i<=0) goto err;\n\t\t\tfrag_len -= i;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (frag_len && frag_len < msg_hdr->msg_len)\n\t\t\treturn dtls1_reassemble_fragment(s, msg_hdr, ok);\n\n\t\tfrag = dtls1_hm_fragment_new(frag_len, 0);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\n\t\tif (frag_len)\n\t\t\t{\n\t\t\t/* read the body of the fragment (header has already been read */\n\t\t\ti = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\t\t\tfrag->fragment,frag_len,0);\n\t\t\tif (i<=0 || (unsigned long)i!=frag_len)\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\tmemset(seq64be,0,sizeof(seq64be));\n\t\tseq64be[6] = (unsigned char)(msg_hdr->seq>>8);\n\t\tseq64be[7] = (unsigned char)(msg_hdr->seq);\n\n\t\titem = pitem_new(seq64be, frag);\n\t\tif ( item == NULL)\n\t\t\tgoto err;\n\n\t\tpqueue_insert(s->d1->buffered_messages, item);\n\t\t}\n\n\treturn DTLS1_HM_FRAGMENT_RETRY;\n\nerr:\n\tif ( frag != NULL) dtls1_hm_fragment_free(frag);\n\tif ( item != NULL) OPENSSL_free(item);\n\t*ok = 0;\n\treturn i;\n\t}", "target": 1, "cwe": [], "project": "openssl", "commit_id": "bff1ce4e6a1c57c3d0a5f9e4f85ba6385fccfe8b", "hash": 183952221427997795538565839035434812494, "size": 82, "message": "Avoid double free when processing DTLS packets.\n\nThe |item| variable, in both of these cases, may contain a pointer to a\n|pitem| structure within |s->d1->buffered_messages|. It was being freed\nin the error case while still being in |buffered_messages|. When the\nerror later caused the |SSL*| to be destroyed, the item would be double\nfreed.\n\nThanks to Wah-Teh Chang for spotting that the fix in 1632ef74 was\ninconsistent with the other error paths (but correct).\n\nFixes CVE-2014-3505\n\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Emilia Käsper <emilia@openssl.org>", "idx": 957}
{"func": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}", "target": 1, "cwe": ["CWE-476"], "project": "httpd", "commit_id": "f990e5ecad40b100a8a5c7c1033c46044a9cb244", "hash": 172068702792085315081162612263931698574, "size": 6, "message": "mod_htt2: fix incomplete sync with latest changes in github, adjust version number.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1889119 13f79535-47bb-0310-9956-ffa450edef68", "idx": 958}
{"func": "uint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {\n  return connection_manager_.config_.tracingConfig()->max_path_tag_length_;\n}", "target": 0, "cwe": ["CWE-400", "CWE-703"], "project": "envoy", "commit_id": "afc39bea36fd436e54262f150c009e8d72db5014", "hash": 328931243650899947744142433225935386139, "size": 3, "message": "Track byteSize of HeaderMap internally.\n\nIntroduces a cached byte size updated internally in HeaderMap. The value\nis stored as an optional, and is cleared whenever a non-const pointer or\nreference to a HeaderEntry is accessed. The cached value can be set with\nrefreshByteSize() which performs an iteration over the HeaderMap to sum\nthe size of each key and value in the HeaderMap.\n\nSigned-off-by: Asra Ali <asraa@google.com>", "idx": 959}
{"func": "xps_parse_path(xps_document *doc, const fz_matrix *ctm, char *base_uri, xps_resource *dict, fz_xml *root)\n{\n\tfz_xml *node;\n\n\tchar *fill_uri;\n\tchar *stroke_uri;\n\tchar *opacity_mask_uri;\n\n\tchar *transform_att;\n\tchar *clip_att;\n\tchar *data_att;\n\tchar *fill_att;\n\tchar *stroke_att;\n\tchar *opacity_att;\n\tchar *opacity_mask_att;\n\n\tfz_xml *transform_tag = NULL;\n\tfz_xml *clip_tag = NULL;\n\tfz_xml *data_tag = NULL;\n\tfz_xml *fill_tag = NULL;\n\tfz_xml *stroke_tag = NULL;\n\tfz_xml *opacity_mask_tag = NULL;\n\n\tchar *fill_opacity_att = NULL;\n\tchar *stroke_opacity_att = NULL;\n\n\tchar *stroke_dash_array_att;\n\tchar *stroke_dash_cap_att;\n\tchar *stroke_dash_offset_att;\n\tchar *stroke_end_line_cap_att;\n\tchar *stroke_start_line_cap_att;\n\tchar *stroke_line_join_att;\n\tchar *stroke_miter_limit_att;\n\tchar *stroke_thickness_att;\n\tchar *navigate_uri_att;\n\n\tfz_stroke_state *stroke = NULL;\n\tfz_matrix transform;\n\tfloat samples[FZ_MAX_COLORS];\n\tfz_colorspace *colorspace;\n\tfz_path *path = NULL;\n\tfz_path *stroke_path = NULL;\n\tfz_rect area;\n\tint fill_rule;\n\tint dash_len = 0;\n\tfz_matrix local_ctm;\n\n\t/*\n\t * Extract attributes and extended attributes.\n\t */\n\n\ttransform_att = fz_xml_att(root, \"RenderTransform\");\n\tclip_att = fz_xml_att(root, \"Clip\");\n\tdata_att = fz_xml_att(root, \"Data\");\n\tfill_att = fz_xml_att(root, \"Fill\");\n\tstroke_att = fz_xml_att(root, \"Stroke\");\n\topacity_att = fz_xml_att(root, \"Opacity\");\n\topacity_mask_att = fz_xml_att(root, \"OpacityMask\");\n\n\tstroke_dash_array_att = fz_xml_att(root, \"StrokeDashArray\");\n\tstroke_dash_cap_att = fz_xml_att(root, \"StrokeDashCap\");\n\tstroke_dash_offset_att = fz_xml_att(root, \"StrokeDashOffset\");\n\tstroke_end_line_cap_att = fz_xml_att(root, \"StrokeEndLineCap\");\n\tstroke_start_line_cap_att = fz_xml_att(root, \"StrokeStartLineCap\");\n\tstroke_line_join_att = fz_xml_att(root, \"StrokeLineJoin\");\n\tstroke_miter_limit_att = fz_xml_att(root, \"StrokeMiterLimit\");\n\tstroke_thickness_att = fz_xml_att(root, \"StrokeThickness\");\n\tnavigate_uri_att = fz_xml_att(root, \"FixedPage.NavigateUri\");\n\n\tfor (node = fz_xml_down(root); node; node = fz_xml_next(node))\n\t{\n\t\tif (!strcmp(fz_xml_tag(node), \"Path.RenderTransform\"))\n\t\t\ttransform_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Path.OpacityMask\"))\n\t\t\topacity_mask_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Path.Clip\"))\n\t\t\tclip_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Path.Fill\"))\n\t\t\tfill_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Path.Stroke\"))\n\t\t\tstroke_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Path.Data\"))\n\t\t\tdata_tag = fz_xml_down(node);\n\t}\n\n\tfill_uri = base_uri;\n\tstroke_uri = base_uri;\n\topacity_mask_uri = base_uri;\n\n\txps_resolve_resource_reference(doc, dict, &data_att, &data_tag, NULL);\n\txps_resolve_resource_reference(doc, dict, &clip_att, &clip_tag, NULL);\n\txps_resolve_resource_reference(doc, dict, &transform_att, &transform_tag, NULL);\n\txps_resolve_resource_reference(doc, dict, &fill_att, &fill_tag, &fill_uri);\n\txps_resolve_resource_reference(doc, dict, &stroke_att, &stroke_tag, &stroke_uri);\n\txps_resolve_resource_reference(doc, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri);\n\n\t/*\n\t * Act on the information we have gathered:\n\t */\n\n\tif (!data_att && !data_tag)\n\t\treturn;\n\n\tif (fill_tag && !strcmp(fz_xml_tag(fill_tag), \"SolidColorBrush\"))\n\t{\n\t\tfill_opacity_att = fz_xml_att(fill_tag, \"Opacity\");\n\t\tfill_att = fz_xml_att(fill_tag, \"Color\");\n\t\tfill_tag = NULL;\n\t}\n\n\tif (stroke_tag && !strcmp(fz_xml_tag(stroke_tag), \"SolidColorBrush\"))\n\t{\n\t\tstroke_opacity_att = fz_xml_att(stroke_tag, \"Opacity\");\n\t\tstroke_att = fz_xml_att(stroke_tag, \"Color\");\n\t\tstroke_tag = NULL;\n\t}\n\n\tif (stroke_att || stroke_tag)\n\t{\n\t\tif (stroke_dash_array_att)\n\t\t{\n\t\t\tchar *s = stroke_dash_array_att;\n\n\t\t\twhile (*s)\n\t\t\t{\n\t\t\t\twhile (*s == ' ')\n\t\t\t\t\ts++;\n\t\t\t\tif (*s) /* needed in case of a space before the last quote */\n\t\t\t\t\tdash_len++;\n\n\t\t\t\twhile (*s && *s != ' ')\n\t\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t\tstroke = fz_new_stroke_state_with_dash_len(doc->ctx, dash_len);\n\t\tstroke->start_cap = xps_parse_line_cap(stroke_start_line_cap_att);\n\t\tstroke->dash_cap = xps_parse_line_cap(stroke_dash_cap_att);\n\t\tstroke->end_cap = xps_parse_line_cap(stroke_end_line_cap_att);\n\n\t\tstroke->linejoin = FZ_LINEJOIN_MITER_XPS;\n\t\tif (stroke_line_join_att)\n\t\t{\n\t\t\tif (!strcmp(stroke_line_join_att, \"Miter\")) stroke->linejoin = FZ_LINEJOIN_MITER_XPS;\n\t\t\tif (!strcmp(stroke_line_join_att, \"Round\")) stroke->linejoin = FZ_LINEJOIN_ROUND;\n\t\t\tif (!strcmp(stroke_line_join_att, \"Bevel\")) stroke->linejoin = FZ_LINEJOIN_BEVEL;\n\t\t}\n\n\t\tstroke->miterlimit = 10;\n\t\tif (stroke_miter_limit_att)\n\t\t\tstroke->miterlimit = fz_atof(stroke_miter_limit_att);\n\n\t\tstroke->linewidth = 1;\n\t\tif (stroke_thickness_att)\n\t\t\tstroke->linewidth = fz_atof(stroke_thickness_att);\n\n\t\tstroke->dash_phase = 0;\n\t\tstroke->dash_len = 0;\n\t\tif (stroke_dash_array_att)\n\t\t{\n\t\t\tchar *s = stroke_dash_array_att;\n\n\t\t\tif (stroke_dash_offset_att)\n\t\t\t\tstroke->dash_phase = fz_atof(stroke_dash_offset_att) * stroke->linewidth;\n\n\t\t\twhile (*s)\n\t\t\t{\n\t\t\t\twhile (*s == ' ')\n\t\t\t\t\ts++;\n\t\t\t\tif (*s) /* needed in case of a space before the last quote */\n\t\t\t\t\tstroke->dash_list[stroke->dash_len++] = fz_atof(s) * stroke->linewidth;\n\t\t\t\twhile (*s && *s != ' ')\n\t\t\t\t\ts++;\n\t\t\t}\n\t\t\tstroke->dash_len = dash_len;\n\t\t}\n\t}\n\n\ttransform = fz_identity;\n\tif (transform_att)\n\t\txps_parse_render_transform(doc, transform_att, &transform);\n\tif (transform_tag)\n\t\txps_parse_matrix_transform(doc, transform_tag, &transform);\n\tfz_concat(&local_ctm, &transform, ctm);\n\n\tif (clip_att || clip_tag)\n\t\txps_clip(doc, &local_ctm, dict, clip_att, clip_tag);\n\n\tfill_rule = 0;\n\tif (data_att)\n\t\tpath = xps_parse_abbreviated_geometry(doc, data_att, &fill_rule);\n\telse if (data_tag)\n\t{\n\t\tpath = xps_parse_path_geometry(doc, dict, data_tag, 0, &fill_rule);\n\t\tif (stroke_att || stroke_tag)\n\t\t\tstroke_path = xps_parse_path_geometry(doc, dict, data_tag, 1, &fill_rule);\n\t}\n\tif (!stroke_path)\n\t\tstroke_path = path;\n\n\tif (stroke_att || stroke_tag)\n\t{\n\t\tfz_bound_path(doc->ctx, stroke_path, stroke, &local_ctm, &area);\n\t\tif (stroke_path != path && (fill_att || fill_tag)) {\n\t\t\tfz_rect bounds;\n\t\t\tfz_bound_path(doc->ctx, path, NULL, &local_ctm, &bounds);\n\t\t\tfz_union_rect(&area, &bounds);\n\t\t}\n\t}\n\telse\n\t\tfz_bound_path(doc->ctx, path, NULL, &local_ctm, &area);\n\n\tif (navigate_uri_att)\n\t\txps_add_link(doc, &area, base_uri, navigate_uri_att);\n\n\txps_begin_opacity(doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n\n\tif (fill_att)\n\t{\n\t\txps_parse_color(doc, base_uri, fill_att, &colorspace, samples);\n\t\tif (fill_opacity_att)\n\t\t\tsamples[0] *= fz_atof(fill_opacity_att);\n\t\txps_set_color(doc, colorspace, samples);\n\n\t\tfz_fill_path(doc->dev, path, fill_rule == 0, &local_ctm,\n\t\t\tdoc->colorspace, doc->color, doc->alpha);\n\t}\n\n\tif (fill_tag)\n\t{\n\t\tfz_clip_path(doc->dev, path, &area, fill_rule == 0, &local_ctm);\n\t\txps_parse_brush(doc, &local_ctm, &area, fill_uri, dict, fill_tag);\n\t\tfz_pop_clip(doc->dev);\n\t}\n\n\tif (stroke_att)\n\t{\n\t\txps_parse_color(doc, base_uri, stroke_att, &colorspace, samples);\n\t\tif (stroke_opacity_att)\n\t\t\tsamples[0] *= fz_atof(stroke_opacity_att);\n\t\txps_set_color(doc, colorspace, samples);\n\n\t\tfz_stroke_path(doc->dev, stroke_path, stroke, &local_ctm,\n\t\t\tdoc->colorspace, doc->color, doc->alpha);\n\t}\n\n\tif (stroke_tag)\n\t{\n\t\tfz_clip_stroke_path(doc->dev, stroke_path, &area, stroke, &local_ctm);\n\t\txps_parse_brush(doc, &local_ctm, &area, stroke_uri, dict, stroke_tag);\n\t\tfz_pop_clip(doc->dev);\n\t}\n\n\txps_end_opacity(doc, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n\n\tif (stroke_path != path)\n\t\tfz_free_path(doc->ctx, stroke_path);\n\tfz_free_path(doc->ctx, path);\n\tpath = NULL;\n\tfz_drop_stroke_state(doc->ctx, stroke);\n\n\tif (clip_att || clip_tag)\n\t\tfz_pop_clip(doc->dev);\n}", "target": 0, "cwe": ["CWE-119"], "project": "mupdf", "commit_id": "60dabde18d7fe12b19da8b509bdfee9cc886aafc", "hash": 119153809474539931925300847474442951410, "size": 263, "message": "Bug 694957: fix stack buffer overflow in xps_parse_color\n\nxps_parse_color happily reads more than FZ_MAX_COLORS values out of a\nContextColor array which overflows the passed in samples array.\nLimiting the number of allowed samples to FZ_MAX_COLORS and make sure\nto use that constant for all callers fixes the problem.\n\nThanks to Jean-Jamil Khalifé for reporting and investigating the issue\nand providing a sample exploit file.", "idx": 960}
{"func": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstruct dentry *root = mount_pseudo(fs_type, \"aio:\", NULL, NULL,\n\t\t\t\t\t   AIO_RING_MAGIC);\n\n\tif (!IS_ERR(root))\n\t\troot->d_sb->s_iflags |= SB_I_NOEXEC;\n\treturn root;\n}", "target": 0, "cwe": ["CWE-416"], "project": "linux", "commit_id": "84c4e1f89fefe70554da0ab33be72c9be7994379", "hash": 317077012229945809258410659192687846230, "size": 10, "message": "aio: simplify - and fix - fget/fput for io_submit()\n\nAl Viro root-caused a race where the IOCB_CMD_POLL handling of\nfget/fput() could cause us to access the file pointer after it had\nalready been freed:\n\n \"In more details - normally IOCB_CMD_POLL handling looks so:\n\n   1) io_submit(2) allocates aio_kiocb instance and passes it to\n      aio_poll()\n\n   2) aio_poll() resolves the descriptor to struct file by req->file =\n      fget(iocb->aio_fildes)\n\n   3) aio_poll() sets ->woken to false and raises ->ki_refcnt of that\n      aio_kiocb to 2 (bumps by 1, that is).\n\n   4) aio_poll() calls vfs_poll(). After sanity checks (basically,\n      \"poll_wait() had been called and only once\") it locks the queue.\n      That's what the extra reference to iocb had been for - we know we\n      can safely access it.\n\n   5) With queue locked, we check if ->woken has already been set to\n      true (by aio_poll_wake()) and, if it had been, we unlock the\n      queue, drop a reference to aio_kiocb and bugger off - at that\n      point it's a responsibility to aio_poll_wake() and the stuff\n      called/scheduled by it. That code will drop the reference to file\n      in req->file, along with the other reference to our aio_kiocb.\n\n   6) otherwise, we see whether we need to wait. If we do, we unlock the\n      queue, drop one reference to aio_kiocb and go away - eventual\n      wakeup (or cancel) will deal with the reference to file and with\n      the other reference to aio_kiocb\n\n   7) otherwise we remove ourselves from waitqueue (still under the\n      queue lock), so that wakeup won't get us. No async activity will\n      be happening, so we can safely drop req->file and iocb ourselves.\n\n  If wakeup happens while we are in vfs_poll(), we are fine - aio_kiocb\n  won't get freed under us, so we can do all the checks and locking\n  safely. And we don't touch ->file if we detect that case.\n\n  However, vfs_poll() most certainly *does* touch the file it had been\n  given. So wakeup coming while we are still in ->poll() might end up\n  doing fput() on that file. That case is not too rare, and usually we\n  are saved by the still present reference from descriptor table - that\n  fput() is not the final one.\n\n  But if another thread closes that descriptor right after our fget()\n  and wakeup does happen before ->poll() returns, we are in trouble -\n  final fput() done while we are in the middle of a method:\n\nAl also wrote a patch to take an extra reference to the file descriptor\nto fix this, but I instead suggested we just streamline the whole file\npointer handling by submit_io() so that the generic aio submission code\nsimply keeps the file pointer around until the aio has completed.\n\nFixes: bfe4037e722e (\"aio: implement IOCB_CMD_POLL\")\nAcked-by: Al Viro <viro@zeniv.linux.org.uk>\nReported-by: syzbot+503d4cc169fcec1cb18c@syzkaller.appspotmail.com\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 961}
{"func": "static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,\n\t\t\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tu64 bytes, packets;\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin_irq(&ring->syncp);\n\t\tpackets = ring->stats.packets;\n\t\tbytes   = ring->stats.bytes;\n\t} while (u64_stats_fetch_retry_irq(&ring->syncp, start));\n\n\tstats->tx_packets += packets;\n\tstats->tx_bytes   += bytes;\n}", "target": 0, "cwe": ["CWE-400", "CWE-401"], "project": "linux", "commit_id": "27d461333459d282ffa4a2bdb6b215a59d493a8f", "hash": 22182905039981879764415891794161212863, "size": 15, "message": "i40e: prevent memory leak in i40e_setup_macvlans\n\nIn i40e_setup_macvlans if i40e_setup_channel fails the allocated memory\nfor ch should be released.\n\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nTested-by: Andrew Bowers <andrewx.bowers@intel.com>\nSigned-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>", "idx": 962}
{"func": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}", "target": 1, "cwe": ["CWE-703"], "project": "linux", "commit_id": "a134f083e79fb4c3d0a925691e732c56911b4326", "hash": 202234528717985920932046062008151108050, "size": 14, "message": "ipv4: Missing sk_nulls_node_init() in ping_unhash().\n\nIf we don't do that, then the poison value is left in the ->pprev\nbacklink.\n\nThis can cause crashes if we do a disconnect, followed by a connect().\n\nTested-by: Linus Torvalds <torvalds@linux-foundation.org>\nReported-by: Wen Xu <hotdog3645@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 963}
{"func": "static void __init of_unittest_overlay_0(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 0);\n}", "target": 0, "cwe": ["CWE-401"], "project": "linux", "commit_id": "e13de8fe0d6a51341671bbe384826d527afe8d44", "hash": 107880887853235427707714776231392395788, "size": 8, "message": "of: unittest: fix memory leak in unittest_data_add\n\nIn unittest_data_add, a copy buffer is created via kmemdup. This buffer\nis leaked if of_fdt_unflatten_tree fails. The release for the\nunittest_data buffer is added.\n\nFixes: b951f9dc7f25 (\"Enabling OF selftest to run without machine's devicetree\")\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nReviewed-by: Frank Rowand <frowand.list@gmail.com>\nSigned-off-by: Rob Herring <robh@kernel.org>", "idx": 964}
{"func": "AP4_HvccAtom::AP4_HvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_HVCC, size)\n{\n    // make a copy of our configuration bytes\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n\n    // parse the payload\n    m_ConfigurationVersion   = payload[0];\n    m_GeneralProfileSpace    = (payload[1]>>6) & 0x03;\n    m_GeneralTierFlag        = (payload[1]>>5) & 0x01;\n    m_GeneralProfile         = (payload[1]   ) & 0x1F;\n    m_GeneralProfileCompatibilityFlags = AP4_BytesToUInt32BE(&payload[2]);\n    m_GeneralConstraintIndicatorFlags  = (((AP4_UI64)AP4_BytesToUInt32BE(&payload[6]))<<16) | AP4_BytesToUInt16BE(&payload[10]);\n    m_GeneralLevel           = payload[12];\n    m_Reserved1              = (payload[13]>>4) & 0x0F;\n    m_MinSpatialSegmentation = AP4_BytesToUInt16BE(&payload[13]) & 0x0FFF;\n    m_Reserved2              = (payload[15]>>2) & 0x3F;\n    m_ParallelismType        = payload[15] & 0x03;\n    m_Reserved3              = (payload[16]>>2) & 0x3F;\n    m_ChromaFormat           = payload[16] & 0x03;\n    m_Reserved4              = (payload[17]>>3) & 0x1F;\n    m_LumaBitDepth           = 8+(payload[17] & 0x07);\n    m_Reserved5              = (payload[18]>>3) & 0x1F;\n    m_ChromaBitDepth         = 8+(payload[18] & 0x07);\n    m_AverageFrameRate       = AP4_BytesToUInt16BE(&payload[19]);\n    m_ConstantFrameRate      = (payload[21]>>6) & 0x03;\n    m_NumTemporalLayers      = (payload[21]>>3) & 0x07;\n    m_TemporalIdNested       = (payload[21]>>2) & 0x01;\n    m_NaluLengthSize         = 1+(payload[21] & 0x03);\n    \n    AP4_UI08 num_seq = payload[22];\n    m_Sequences.SetItemCount(num_seq);\n    unsigned int cursor = 23;\n    for (unsigned int i=0; i<num_seq; i++) {\n\n        Sequence& seq = m_Sequences[i];\n        if (cursor+1 > payload_size) break;\n        seq.m_ArrayCompleteness = (payload[cursor] >> 7) & 0x01;\n        seq.m_Reserved          = (payload[cursor] >> 6) & 0x01;\n        seq.m_NaluType          = payload[cursor] & 0x3F;\n        cursor += 1;\n        \n        if (cursor+2 > payload_size) break;\n        AP4_UI16 nalu_count = AP4_BytesToUInt16BE(&payload[cursor]);\n        seq.m_Nalus.SetItemCount(nalu_count);\n        cursor += 2;\n        \n        for (unsigned int j=0; j<nalu_count; j++) {\n            if (cursor+2 > payload_size) break;\n            unsigned int nalu_length = AP4_BytesToUInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + nalu_length > payload_size) break;\n            seq.m_Nalus[j].SetData(&payload[cursor], nalu_length);\n            cursor += nalu_length;\n        }\n    }\n}", "target": 1, "cwe": ["CWE-125", "CWE-787"], "project": "Bento4", "commit_id": "53499d8d4c69142137c7c7f0097a444783fdeb90", "hash": 50115741194071784441354795355224241759, "size": 58, "message": "fix for #188", "idx": 965}
{"func": "static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,\n\t\t\t   u32 session_id, u32 peer_session_id,\n\t\t\t   struct l2tp_session_cfg *cfg)\n{\n\tunsigned char name_assign_type;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct l2tp_session *session;\n\tstruct l2tp_eth *priv;\n\tstruct l2tp_eth_sess *spriv;\n\tint rc;\n\tstruct l2tp_eth_net *pn;\n\n\tif (cfg->ifname) {\n\t\tstrlcpy(name, cfg->ifname, IFNAMSIZ);\n\t\tname_assign_type = NET_NAME_USER;\n\t} else {\n\t\tstrcpy(name, L2TP_ETH_DEV_NAME);\n\t\tname_assign_type = NET_NAME_ENUM;\n\t}\n\n\tsession = l2tp_session_create(sizeof(*spriv), tunnel, session_id,\n\t\t\t\t      peer_session_id, cfg);\n\tif (IS_ERR(session)) {\n\t\trc = PTR_ERR(session);\n\t\tgoto out;\n\t}\n\n\tdev = alloc_netdev(sizeof(*priv), name, name_assign_type,\n\t\t\t   l2tp_eth_dev_setup);\n\tif (!dev) {\n\t\trc = -ENOMEM;\n\t\tgoto out_del_session;\n\t}\n\n\tdev_net_set(dev, net);\n\tdev->min_mtu = 0;\n\tdev->max_mtu = ETH_MAX_MTU;\n\tl2tp_eth_adjust_mtu(tunnel, session, dev);\n\n\tpriv = netdev_priv(dev);\n\tpriv->dev = dev;\n\tpriv->session = session;\n\tINIT_LIST_HEAD(&priv->list);\n\n\tpriv->tunnel_sock = tunnel->sock;\n\tsession->recv_skb = l2tp_eth_dev_recv;\n\tsession->session_close = l2tp_eth_delete;\n#if IS_ENABLED(CONFIG_L2TP_DEBUGFS)\n\tsession->show = l2tp_eth_show;\n#endif\n\n\tspriv = l2tp_session_priv(session);\n\tspriv->dev = dev;\n\n\trc = register_netdev(dev);\n\tif (rc < 0)\n\t\tgoto out_del_dev;\n\n\t__module_get(THIS_MODULE);\n\t/* Must be done after register_netdev() */\n\tstrlcpy(session->ifname, dev->name, IFNAMSIZ);\n\n\tdev_hold(dev);\n\tpn = l2tp_eth_pernet(dev_net(dev));\n\tspin_lock(&pn->l2tp_eth_lock);\n\tlist_add(&priv->list, &pn->l2tp_eth_dev_list);\n\tspin_unlock(&pn->l2tp_eth_lock);\n\n\treturn 0;\n\nout_del_dev:\n\tfree_netdev(dev);\n\tspriv->dev = NULL;\nout_del_session:\n\tl2tp_session_delete(session);\nout:\n\treturn rc;\n}", "target": 0, "cwe": ["CWE-416"], "project": "linux", "commit_id": "f026bc29a8e093edfbb2a77700454b285c97e8ad", "hash": 81749459980831287163944604411674421312, "size": 79, "message": "l2tp: pass tunnel pointer to ->session_create()\n\nUsing l2tp_tunnel_find() in pppol2tp_session_create() and\nl2tp_eth_create() is racy, because no reference is held on the\nreturned session. These functions are only used to implement the\n->session_create callback which is run by l2tp_nl_cmd_session_create().\nTherefore searching for the parent tunnel isn't necessary because\nl2tp_nl_cmd_session_create() already has a pointer to it and holds a\nreference.\n\nThis patch modifies ->session_create()'s prototype to directly pass the\nthe parent tunnel as parameter, thus avoiding searching for it in\npppol2tp_session_create() and l2tp_eth_create().\n\nSince we have to touch the ->session_create() call in\nl2tp_nl_cmd_session_create(), let's also remove the useless conditional:\nwe know that ->session_create isn't NULL at this point because it's\nalready been checked earlier in this same function.\n\nFinally, one might be tempted to think that the removed\nl2tp_tunnel_find() calls were harmless because they would return the\nsame tunnel as the one held by l2tp_nl_cmd_session_create() anyway.\nBut that tunnel might be removed and a new one created with same tunnel\nId before the l2tp_tunnel_find() call. In this case l2tp_tunnel_find()\nwould return the new tunnel which wouldn't be protected by the\nreference held by l2tp_nl_cmd_session_create().\n\nFixes: 309795f4bec2 (\"l2tp: Add netlink control API for L2TP\")\nFixes: d9e31d17ceba (\"l2tp: Add L2TP ethernet pseudowire support\")\nSigned-off-by: Guillaume Nault <g.nault@alphalink.fr>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 966}
{"func": "static void removeduplicateobjs(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)\n{\n\tint num, other;\n\tint xref_len = pdf_xref_len(ctx, doc);\n\n\tfor (num = 1; num < xref_len; num++)\n\t{\n\t\t/* Only compare an object to objects preceding it */\n\t\tfor (other = 1; other < num; other++)\n\t\t{\n\t\t\tpdf_obj *a, *b;\n\t\t\tint newnum, streama = 0, streamb = 0, differ = 0;\n\n\t\t\tif (num == other || !opts->use_list[num] || !opts->use_list[other])\n\t\t\t\tcontinue;\n\n\t\t\t/* TODO: resolve indirect references to see if we can omit them */\n\n\t\t\t/*\n\t\t\t * Comparing stream objects data contents would take too long.\n\t\t\t *\n\t\t\t * pdf_obj_num_is_stream calls pdf_cache_object and ensures\n\t\t\t * that the xref table has the objects loaded.\n\t\t\t */\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tstreama = pdf_obj_num_is_stream(ctx, doc, num);\n\t\t\t\tstreamb = pdf_obj_num_is_stream(ctx, doc, other);\n\t\t\t\tdiffer = streama || streamb;\n\t\t\t\tif (streama && streamb && opts->do_garbage >= 4)\n\t\t\t\t\tdiffer = 0;\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\t/* Assume different */\n\t\t\t\tdiffer = 1;\n\t\t\t}\n\t\t\tif (differ)\n\t\t\t\tcontinue;\n\n\t\t\ta = pdf_get_xref_entry(ctx, doc, num)->obj;\n\t\t\tb = pdf_get_xref_entry(ctx, doc, other)->obj;\n\n\t\t\tif (pdf_objcmp(ctx, a, b))\n\t\t\t\tcontinue;\n\n\t\t\tif (streama && streamb)\n\t\t\t{\n\t\t\t\t/* Check to see if streams match too. */\n\t\t\t\tfz_buffer *sa = NULL;\n\t\t\t\tfz_buffer *sb = NULL;\n\n\t\t\t\tfz_var(sa);\n\t\t\t\tfz_var(sb);\n\n\t\t\t\tdiffer = 1;\n\t\t\t\tfz_try(ctx)\n\t\t\t\t{\n\t\t\t\t\tunsigned char *dataa, *datab;\n\t\t\t\t\tsize_t lena, lenb;\n\t\t\t\t\tsa = pdf_load_raw_stream_number(ctx, doc, num);\n\t\t\t\t\tsb = pdf_load_raw_stream_number(ctx, doc, other);\n\t\t\t\t\tlena = fz_buffer_storage(ctx, sa, &dataa);\n\t\t\t\t\tlenb = fz_buffer_storage(ctx, sb, &datab);\n\t\t\t\t\tif (lena == lenb && memcmp(dataa, datab, lena) == 0)\n\t\t\t\t\t\tdiffer = 0;\n\t\t\t\t}\n\t\t\t\tfz_always(ctx)\n\t\t\t\t{\n\t\t\t\t\tfz_drop_buffer(ctx, sa);\n\t\t\t\t\tfz_drop_buffer(ctx, sb);\n\t\t\t\t}\n\t\t\t\tfz_catch(ctx)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t\tif (differ)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Keep the lowest numbered object */\n\t\t\tnewnum = fz_mini(num, other);\n\t\t\topts->renumber_map[num] = newnum;\n\t\t\topts->renumber_map[other] = newnum;\n\t\t\topts->rev_renumber_map[newnum] = num; /* Either will do */\n\t\t\topts->use_list[fz_maxi(num, other)] = 0;\n\n\t\t\t/* One duplicate was found, do not look for another */\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1, "cwe": ["CWE-119"], "project": "mupdf", "commit_id": "520cc26d18c9ee245b56e9e91f9d4fcae02be5f0", "hash": 67711434582248561547229134106728219878, "size": 92, "message": "Bug 689699: Avoid buffer overrun.\n\nWhen cleaning a pdf file, various lists (of pdf_xref_len length) are\ndefined early on.\n\nIf we trigger a repair during the clean, this can cause pdf_xref_len\nto increase causing an overrun.\n\nFix this by watching for changes in the length, and checking accesses\nto the list for validity.\n\nThis also appears to fix bugs 698700-698703.", "idx": 967}
{"func": "NCURSES_SP_NAME(mcprint) (NCURSES_SP_DCLx char *data, int len)\n/* ship binary character data to the printer via mc4/mc5/mc5p */\n{\n    int result;\n    char *mybuf, *switchon;\n    size_t onsize, offsize;\n    size_t need;\n\n    errno = 0;\n    if (!HasTInfoTerminal(SP_PARM)\n\t|| len <= 0\n\t|| (!prtr_non && (!prtr_on || !prtr_off))) {\n\terrno = ENODEV;\n\treturn (ERR);\n    }\n\n    if (prtr_non) {\n\tswitchon = TPARM_1(prtr_non, len);\n\tonsize = strlen(switchon);\n\toffsize = 0;\n    } else {\n\tswitchon = prtr_on;\n\tonsize = strlen(prtr_on);\n\toffsize = strlen(prtr_off);\n    }\n\n    need = onsize + (size_t) len + offsize;\n\n    if (switchon == 0\n\t|| (mybuf = typeMalloc(char, need + 1)) == 0) {\n\terrno = ENOMEM;\n\treturn (ERR);\n    }\n\n    _nc_STRCPY(mybuf, switchon, need);\n    memcpy(mybuf + onsize, data, (size_t) len);\n    if (offsize)\n\t_nc_STRCPY(mybuf + onsize + len, prtr_off, need);\n\n    /*\n     * We're relying on the atomicity of UNIX writes here.  The\n     * danger is that output from a refresh() might get interspersed\n     * with the printer data after the write call returns but before the\n     * data has actually been shipped to the terminal.  If the write(2)\n     * operation is truly atomic we're protected from this.\n     */\n    result = (int) write(TerminalOf(SP_PARM)->Filedes, mybuf, need);\n\n    /*\n     * By giving up our scheduler slot here we increase the odds that the\n     * kernel will ship the contiguous clist items from the last write\n     * immediately.\n     */\n#ifndef _WIN32\n    (void) sleep(0);\n#endif\n    free(mybuf);\n    return (result);\n}", "target": 1, "cwe": [], "project": "ncurses", "commit_id": "790a85dbd4a81d5f5d8dd02a44d84f01512ef443", "hash": 213409188221164947186167568041566544920, "size": 59, "message": "ncurses 6.2 - patch 20200531\n\n+ correct configure version-check/warnng for g++ to allow for 10.x\n+ re-enable \"bel\" in konsole-base (report by Nia Huang)\n+ add linux-s entry (patch by Alexandre Montaron).\n+ drop long-obsolete convert_configure.pl\n+ add test/test_parm.c, for checking tparm changes.\n+ improve parameter-checking for tparm, adding function _nc_tiparm() to\n  handle the most-used case, which accepts only numeric parameters\n  (report/testcase by \"puppet-meteor\").\n+ use a more conservative estimate of the buffer-size in lib_tparm.c's\n  save_text() and save_number(), in case the sprintf() function\n  passes-through unexpected characters from a format specifier\n  (report/testcase by \"puppet-meteor\").\n+ add a check for end-of-string in cvtchar to handle a malformed\n  string in infotocap (report/testcase by \"puppet-meteor\").", "idx": 968}
{"func": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n\n    ValidateInputTensors(ctx, in0, in1);\n\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);\n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    if (adjoint_) std::swap(d0, d1);\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d0);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d0, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchMatrixTriangularSolve<Device, Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 1, "cwe": ["CWE-125"], "project": "tensorflow", "commit_id": "480641e3599775a8895254ffbc0fc45621334f68", "hash": 52832422839417006956550969270075508639, "size": 53, "message": "Validate (and ensure validation sticks) inputs for `MatrixTriangularSolve`.\n\nPiperOrigin-RevId: 370282444\nChange-Id: Iaed61a0b0727cc42c830658b72eb69f785f48dc5", "idx": 969}
{"func": "is_match_charset(\n    FontData\tfont_data,\n    char\t*font_name)\n{\n    char *last;\n    int length, name_len;\n\n    name_len = strlen(font_name);\n    last = font_name + name_len;\n\n    length = strlen(font_data->name);\n    if (length > name_len)\n\treturn False;\n\n    if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)\n\treturn True;\n\n    return False;\n}", "target": 0, "cwe": ["CWE-190"], "project": "libx11", "commit_id": "acdaaadcb3d85c61fd43669fc5dddf0f8c3f911d", "hash": 336382137434479831622596547329369739656, "size": 19, "message": "Fix an integer overflow in init_om()\n\nCVE-2020-14363\n\nThis can lead to a double free later, as reported by Jayden Rivers.\n\nSigned-off-by: Matthieu Herrb <matthieu@herrb.eu>", "idx": 970}
{"func": "ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,\n                                 struct ofpbuf *b, bool aggregate,\n                                 const struct tun_table *tun_table,\n                                 const struct vl_mff_map *vl_mff_map)\n{\n    const struct nx_flow_stats_request *nfsr;\n    enum ofperr error;\n\n    nfsr = ofpbuf_pull(b, sizeof *nfsr);\n    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,\n                          &fsr->cookie, &fsr->cookie_mask, tun_table,\n                          vl_mff_map);\n    if (error) {\n        return error;\n    }\n    if (b->size) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    fsr->aggregate = aggregate;\n    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));\n    fsr->out_group = OFPG_ANY;\n    fsr->table_id = nfsr->table_id;\n\n    return 0;\n}", "target": 0, "cwe": ["CWE-617", "CWE-703"], "project": "ovs", "commit_id": "4af6da3b275b764b1afe194df6499b33d2bf4cde", "hash": 94012392303668157824522491772796158362, "size": 26, "message": "ofp-group: Don't assert-fail decoding bad OF1.5 group mod type or command.\n\nWhen decoding a group mod, the current code validates the group type and\ncommand after the whole group mod has been decoded.  The OF1.5 decoder,\nhowever, tries to use the type and command earlier, when it might still be\ninvalid.  This caused an assertion failure (via OVS_NOT_REACHED).  This\ncommit fixes the problem.\n\novs-vswitchd does not enable support for OpenFlow 1.5 by default.\n\nReported-at: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9249\nSigned-off-by: Ben Pfaff <blp@ovn.org>\nReviewed-by: Yifeng Sun <pkusunyifeng@gmail.com>", "idx": 971}
{"func": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));\n\n  const int num_rows = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes / num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) /\n            sizeof(int32_t);\n    }\n\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n\n  return kTfLiteOk;\n}", "target": 1, "cwe": ["CWE-703", "CWE-369"], "project": "tensorflow", "commit_id": "5117e0851348065ed59c991562c0ec80d9193db2", "hash": 328764652976906339232792556679339264184, "size": 49, "message": "Prevent a division by 0\n\nPiperOrigin-RevId: 371007407\nChange-Id: Iecf2718de48d6bf5a69b02a9df9deda8ec1b19d3", "idx": 972}
{"func": "my_decimal *Field_temporal::val_decimal(my_decimal *d)\n{\n  MYSQL_TIME ltime;\n  if (get_date(&ltime, 0))\n  {\n    bzero(&ltime, sizeof(ltime));\n    ltime.time_type= mysql_type_to_time_type(type());\n  }\n  return TIME_to_my_decimal(&ltime, d);\n}", "target": 0, "cwe": ["CWE-120"], "project": "server", "commit_id": "eca207c46293bc72dd8d0d5622153fab4d3fccf1", "hash": 309552097285221872068721538246537833218, "size": 10, "message": "MDEV-25317 Assertion `scale <= precision' failed in decimal_bin_size And Assertion `scale >= 0 && precision > 0 && scale <= precision' failed in decimal_bin_size_inline/decimal_bin_size.\n\nPrecision should be kept below DECIMAL_MAX_SCALE for computations.\nIt can be bigger in Item_decimal. I'd fix this too but it changes the\nexisting behaviour so problemmatic to ix.", "idx": 973}
{"func": "oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,\n          const char *msg)\n{\n    int depth = X509_STORE_CTX_get_error_depth(certctx);\n    int err = X509_STORE_CTX_get_error(certctx);\n    const char *errstr = X509_verify_cert_error_string(err);\n\n    return oerr(context, code, _(\"%s (depth %d): %s\"), msg, depth, errstr);\n}", "target": 0, "cwe": ["CWE-119", "CWE-787"], "project": "krb5", "commit_id": "fbb687db1088ddd894d975996e5f6a4252b9a2b4", "hash": 175668660912107177552520975015514481933, "size": 9, "message": "Fix PKINIT cert matching data construction\n\nRewrite X509_NAME_oneline_ex() and its call sites to use dynamic\nallocation and to perform proper error checking.\n\nticket: 8617\ntarget_version: 1.16\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup", "idx": 974}
{"func": "static void restore_stack_limit (lua_State *L) {\n  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK - 1);\n  if (L->size_ci > LUAI_MAXCALLS) {  /* there was an overflow? */\n    int inuse = cast_int(L->ci - L->base_ci);\n    if (inuse + 1 < LUAI_MAXCALLS)  /* can `undo' overflow? */\n      luaD_reallocCI(L, LUAI_MAXCALLS);\n  }\n}", "target": 0, "cwe": ["CWE-200", "CWE-17"], "project": "redis", "commit_id": "fdf9d455098f54f7666c702ae464e6ea21e25411", "hash": 49078328733304596259146775430891657412, "size": 8, "message": "disable loading lua bytecode", "idx": 975}
{"func": "static int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tcompparms->stepsizes = jas_malloc(compparms->numstepsizes *\n\t\t  sizeof(uint_fast16_t));\n\t\tassert(compparms->stepsizes);\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "project": "jasper", "commit_id": "3c55b399c36ef46befcb21e4ebc4799367f89684", "hash": 81398054198756779421883938147957171219, "size": 54, "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems.", "idx": 976}
{"func": "    //! Wait for any event occuring either on the display \\c disp1, \\c disp2, \\c disp3, \\c disp4, ... \\c disp10.\n    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,\n                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,\n                     CImgDisplay& disp10) {\n      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =\n        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;\n      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||\n              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&\n             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&\n             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)\n        wait_all();", "target": 0, "cwe": ["CWE-125"], "project": "CImg", "commit_id": "10af1e8c1ad2a58a0a3342a856bae63e8f257abb", "hash": 198598905427859026848321565438617458521, "size": 11, "message": "Fix other issues in 'CImg<T>::load_bmp()'.", "idx": 977}
{"func": "int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n\t      const char *secret, size_t secret_len)\n{\n\tint n, length;\n\tuint8_t *buf;\n\tstruct l2tp_hdr_t *hdr;\n\tstruct l2tp_avp_t *avp;\n\tstruct l2tp_dict_attr_t *da;\n\tstruct l2tp_attr_t *attr, *RV = NULL;\n\tuint8_t *ptr;\n\tstruct l2tp_packet_t *pack;\n\tstruct sockaddr_in addr;\n\tsocklen_t len = sizeof(addr);\n\tstruct msghdr msg;\n\tchar msg_control[128];\n\tstruct cmsghdr *cmsg;\n\tuint16_t orig_avp_len;\n\tvoid *orig_avp_val;\n\n  *p = NULL;\n\n\tif (pkt_info) {\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.msg_control = msg_control;\n\t\tmsg.msg_controllen = 128;\n\n\t\tn = recvmsg(fd, &msg, MSG_PEEK);\n\n\t\tif (n < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn -1;\n\t\t\tlog_error(\"l2tp: recvmsg: %s\\n\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tif (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_PKTINFO) {\n\t\t\t\tmemcpy(pkt_info, CMSG_DATA(cmsg), sizeof(*pkt_info));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuf = mempool_alloc(buf_pool);\n\tif (!buf) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\treturn 0;\n\t}\n\thdr = (struct l2tp_hdr_t *)buf;\n\tptr = (uint8_t *)(hdr + 1);\n\n\tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &len);\n\n\tif (n < 0) {\n\t\tmempool_free(buf);\n\t\tif (errno == EAGAIN) {\n\t\t\treturn -1;\n\t\t} else if (errno == ECONNREFUSED) {\n\t\t\treturn -2;\n\t\t}\n\t\tlog_error(\"l2tp: recv: %s\\n\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tif (n < 6) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%zu)\\n\", n, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t}\n\n\tif (hdr->T == 0)\n\t\tgoto out_err_hdr;\n\n\tif (n < ntohs(hdr->length)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%i)\\n\", n, ntohs(hdr->length));\n\t\tgoto out_err_hdr;\n\t}\n\n\tif (hdr->ver == 2) {\n\t\tif (hdr->L == 0) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (L=0)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\n\t\tif (hdr->S == 0) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (S=0)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\n\t\tif (hdr->O == 1) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (O=1)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\t} else if (hdr->ver != 3) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\", hdr->ver);\n\t\tgoto out_err_hdr;\n\t}\n\n\tpack = mempool_alloc(pack_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\n\tmemcpy(&pack->addr, &addr, sizeof(addr));\n\tmemcpy(&pack->hdr, hdr, sizeof(*hdr));\n\tlength = ntohs(hdr->length) - sizeof(*hdr);\n\n\twhile (length) {\n\t\t*(uint16_t *)ptr = ntohs(*(uint16_t *)ptr);\n\t\tavp = (struct l2tp_avp_t *)ptr;\n\n\t\tif (avp->length > length) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect avp received (exceeds message length)\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (avp->vendor)\n\t\t\tgoto skip;\n\n\t\tda = l2tp_dict_find_attr_by_id(ntohs(avp->type));\n\t\tif (!da) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\", ntohs(avp->type), avp->M);\n\t\t\tif (avp->M && !conf_avp_permissive)\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\tif (da->M != -1 && da->M != avp->M) {\n\t\t\t\tif (conf_verbose)\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\", ntohs(avp->type), avp->M, da->M);\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (da->H != -1 && da->H != avp->H) {\n\t\t\t\tif (conf_verbose)\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\", ntohs(avp->type), avp->H, da->H);\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (avp->H) {\n\t\t\t\tif (!RV) {\n\t\t\t\t\tif (conf_verbose)\n\t\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=1, but Random-Vector is not received)\\n\", ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (secret == NULL || secret_len == 0) {\n\t\t\t\t\tlog_error(\"l2tp: impossible to decode\"\n\t\t\t\t\t\t  \" hidden avp (type %hu): no\"\n\t\t\t\t\t\t  \" secret set)\\n\",\n\t\t\t\t\t\t  ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (decode_avp(avp, RV, secret, secret_len) < 0)\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\t\t\tif (avp->H) {\n\t\t\t\torig_avp_len = ntohs(*(uint16_t *)avp->val) + sizeof(*avp);\n\t\t\t\torig_avp_val = avp->val + sizeof(uint16_t);\n\t\t\t} else {\n\t\t\t\torig_avp_len = avp->length;\n\t\t\t\torig_avp_val = avp->val;\n\t\t\t}\n\n\t\t\tattr->attr = da;\n\t\t\tattr->M = avp->M;\n\t\t\tattr->H = 0;\n\t\t\tattr->length = orig_avp_len - sizeof(*avp);\n\n\t\t\tif (attr->attr->id == Random_Vector)\n\t\t\t\tRV = attr;\n\n\t\t\tswitch (da->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 2)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint16 = ntohs(*(uint16_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 4)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint32 = ntohl(*(uint32_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT64:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 8)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint64 = be64toh(*(uint64_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tattr->val.octets = _malloc(attr->length);\n\t\t\t\t\tif (!attr->val.octets)\n\t\t\t\t\t\tgoto out_err_mem;\n\t\t\t\t\tmemcpy(attr->val.octets, orig_avp_val, attr->length);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tattr->val.string = _malloc(attr->length + 1);\n\t\t\t\t\tif (!attr->val.string)\n\t\t\t\t\t\tgoto out_err_mem;\n\t\t\t\t\tmemcpy(attr->val.string, orig_avp_val, attr->length);\n\t\t\t\t\tattr->val.string[attr->length] = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nskip:\n\t\tptr += avp->length;\n\t\tlength -= avp->length;\n\t}\n\n\t*p = pack;\n\n\tmempool_free(buf);\n\n\treturn 0;\n\nout_err:\n\tl2tp_packet_free(pack);\nout_err_hdr:\n\tmempool_free(buf);\n\treturn 0;\nout_err_len:\n\tif (conf_verbose)\n\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, incorrect length %i)\\n\", ntohs(avp->type), orig_avp_len);\n\tgoto out_err;\nout_err_mem:\n\tlog_emerg(\"l2tp: out of memory\\n\");\n\tgoto out_err;\n}", "target": 1, "cwe": ["CWE-119", "CWE-125", "CWE-120"], "project": "accel-ppp", "commit_id": "2324bcd5ba12cf28f47357a8f03cd41b7c04c52b", "hash": 301171951458517838175061545385663259946, "size": 245, "message": "l2tp: fix RCE through buffer overflow & fix LE/BE compatibility\n\nUnsufficent checks of valid l2tp header & avp length cause possible\nRCE through buffer overflow, reported by https://github.com/WinMin\nswings & leommxj, Chaitin Security Research Lab. Add missed header\nlength and avp length validation to fix the issue.\n\nOrder of struct bitfields is implementation-defined so current code\ndoesn't play well with big-endian arch. switch to explicit flag bit\nchecking/gathering to fix the issue.\n\nRFC 2661 and 3931 requires that length, seqeuence flags must be set\nand offset flag must not be set, so avp-premissive can't help in\nthis cases.", "idx": 978}
{"func": "void CLASS parse_minolta(int base)\n{\n  int tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 save;\n#else\n  int save;\n#endif\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n  if(offset>fsize-8) // At least 8 bytes for tag/len\n    offset = fsize-8;\n#endif\n\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    if(len < 0)\n      return; // just ignore wrong len?? or raise bad file exception?\n#ifdef LIBRAW_LIBRARY_BUILD\n    if((INT64)len + save + 8ULL > fsize)\n      return; // just ignore out of file metadata, stop parse\n#endif\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n#define imSony imgdata.makernotes.sony\n      imSony.prd_ImageHeight = get2();\n      imSony.prd_ImageWidth = get2();\n      fseek(ifp, 1L, SEEK_CUR);\n      imSony.prd_RawBitDepth = (ushort)fgetc(ifp);\n      imSony.prd_StorageMethod = (ushort)fgetc(ifp);\n      fseek(ifp, 4L, SEEK_CUR);\n      imSony.prd_BayerPattern = (ushort)fgetc(ifp);\n#undef imSony\n#endif\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n#define icWBC imgdata.color.WB_Coeffs\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        icWBC[LIBRAW_WBI_Tungsten][0] = get2();\n        icWBC[LIBRAW_WBI_Tungsten][2] = get2();\n        icWBC[LIBRAW_WBI_Daylight][0] = get2();\n        icWBC[LIBRAW_WBI_Daylight][2] = get2();\n        icWBC[LIBRAW_WBI_Cloudy][0] = get2();\n        icWBC[LIBRAW_WBI_Cloudy][2] = get2();\n        icWBC[LIBRAW_WBI_FL_W][0] = get2();\n        icWBC[LIBRAW_WBI_FL_W][2] = get2();\n        icWBC[LIBRAW_WBI_Flash][0] = get2();\n        icWBC[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        icWBC[LIBRAW_WBI_Shade][0] = get2();\n        icWBC[LIBRAW_WBI_Shade][2] = get2();\n        icWBC[LIBRAW_WBI_FL_D][0] = get2();\n        icWBC[LIBRAW_WBI_FL_D][2] = get2();\n        icWBC[LIBRAW_WBI_FL_N][0] = get2();\n        icWBC[LIBRAW_WBI_FL_N][2] = get2();\n        icWBC[LIBRAW_WBI_FL_WW][0] = get2();\n        icWBC[LIBRAW_WBI_FL_WW][2] = get2();\n        icWBC[LIBRAW_WBI_Daylight][1]   = icWBC[LIBRAW_WBI_Daylight][3] =\n          icWBC[LIBRAW_WBI_Tungsten][1] = icWBC[LIBRAW_WBI_Tungsten][3] =\n          icWBC[LIBRAW_WBI_Flash][1]    = icWBC[LIBRAW_WBI_Flash][3] =\n          icWBC[LIBRAW_WBI_Cloudy][1]   = icWBC[LIBRAW_WBI_Cloudy][3] =\n          icWBC[LIBRAW_WBI_Shade][1]    = icWBC[LIBRAW_WBI_Shade][3] =\n          icWBC[LIBRAW_WBI_FL_D][1]     = icWBC[LIBRAW_WBI_FL_D][3] =\n          icWBC[LIBRAW_WBI_FL_N][1]     = icWBC[LIBRAW_WBI_FL_N][3] =\n          icWBC[LIBRAW_WBI_FL_W][1]     = icWBC[LIBRAW_WBI_FL_W][3] =\n          icWBC[LIBRAW_WBI_FL_WW][1]    = icWBC[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#undef icWBC\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}", "target": 0, "cwe": ["CWE-400"], "project": "LibRaw", "commit_id": "e67a9862d10ebaa97712f532eca1eb5e2e410a22", "hash": 133518595681734569980695708924549622478, "size": 103, "message": "Fixed Secunia Advisory SA86384\n   - possible infinite loop in unpacked_load_raw()\n   - possible infinite loop in parse_rollei()\n   - possible infinite loop in parse_sinar_ia()\n\n Credits: Laurent Delosieres, Secunia Research at Flexera", "idx": 979}
{"func": "int main(int argc, char** argv) {\n    char userInput[50] = {0};\n    U32 timestamp = FUZ_GetMilliStart();\n    U32 seed=0;\n    int seedset=0;\n    int argNb;\n    int nbTests = NB_ATTEMPTS;\n    int testNb = 0;\n    int proba = FUZ_COMPRESSIBILITY_DEFAULT;\n\n    // Check command line\n    programName = argv[0];\n    for(argNb=1; argNb<argc; argNb++)\n    {\n        char* argument = argv[argNb];\n\n        if(!argument) continue;   // Protection if argument empty\n\n        // Decode command (note : aggregated commands are allowed)\n        if (argument[0]=='-')\n        {\n            if (!strcmp(argument, \"--no-prompt\")) { no_prompt=1; seedset=1; displayLevel=1; continue; }\n\n            while (argument[1]!=0)\n            {\n                argument++;\n                switch(*argument)\n                {\n                case 'h':\n                    return FUZ_usage();\n                case 'v':\n                    argument++;\n                    displayLevel=4;\n                    break;\n                case 'i':\n                    argument++;\n                    nbTests=0;\n                    while ((*argument>='0') && (*argument<='9'))\n                    {\n                        nbTests *= 10;\n                        nbTests += *argument - '0';\n                        argument++;\n                    }\n                    break;\n                case 's':\n                    argument++;\n                    seed=0; seedset=1;\n                    while ((*argument>='0') && (*argument<='9'))\n                    {\n                        seed *= 10;\n                        seed += *argument - '0';\n                        argument++;\n                    }\n                    break;\n                case 't':\n                    argument++;\n                    testNb=0;\n                    while ((*argument>='0') && (*argument<='9'))\n                    {\n                        testNb *= 10;\n                        testNb += *argument - '0';\n                        argument++;\n                    }\n                    break;\n                case 'p':\n                    argument++;\n                    proba=0;\n                    while ((*argument>='0') && (*argument<='9'))\n                    {\n                        proba *= 10;\n                        proba += *argument - '0';\n                        argument++;\n                    }\n                    if (proba<0) proba=0;\n                    if (proba>100) proba=100;\n                    break;\n                default: ;\n                }\n            }\n\n        }\n    }\n\n    // Get Seed\n    printf(\"Starting LZ4 fuzzer (%i-bits, %s)\\n\", (int)(sizeof(size_t)*8), LZ4_VERSION);\n\n    if (!seedset)\n    {\n        printf(\"Select an Initialisation number (default : random) : \");\n        fflush(stdout);\n        if ( no_prompt || fgets(userInput, sizeof userInput, stdin) )\n        {\n            if ( sscanf(userInput, \"%u\", &seed) == 1 ) {}\n            else seed = FUZ_GetMilliSpan(timestamp);\n        }\n    }\n    printf(\"Seed = %u\\n\", seed);\n    if (proba!=FUZ_COMPRESSIBILITY_DEFAULT) printf(\"Compressibility : %i%%\\n\", proba);\n\n    //FUZ_SecurityTest();\n\n    if (nbTests<=0) nbTests=1;\n\n    return FUZ_test(seed, nbTests, testNb, ((double)proba) / 100);\n}", "target": 1, "cwe": ["CWE-20"], "project": "lz4", "commit_id": "da5373197e84ee49d75b8334d4510689731d6e90", "hash": 44639841900288395886811841694385503095, "size": 105, "message": "Fixed : issue 52 (reported by Ludwig Strigeus)", "idx": 980}
{"func": "static int limit_this_process(void)\n{\n\tint rv;\n\tif (!is_root())\n\t\treturn 0;\n\n\tif (setregid(booth_conf->gid, booth_conf->gid) < 0) {\n\t\trv = errno;\n\t\tlog_error(\"setregid() didn't work: %s\", strerror(rv));\n\t\treturn rv;\n\t}\n\n\tif (setreuid(booth_conf->uid, booth_conf->uid) < 0) {\n\t\trv = errno;\n\t\tlog_error(\"setreuid() didn't work: %s\", strerror(rv));\n\t\treturn rv;\n\t}\n\n\treturn 0;\n}", "target": 0, "cwe": ["CWE-287", "CWE-284"], "project": "booth", "commit_id": "35bf0b7b048d715f671eb68974fb6b4af6528c67", "hash": 200153644061091409306480632946208239610, "size": 20, "message": "Revert \"Refactor: main: substitute is_auth_req macro\"\n\nThis reverts commit da79b8ba28ad4837a0fee13e5f8fb6f89fe0e24c.\n\nauthfile != authkey\n\nSigned-off-by: Jan Friesse <jfriesse@redhat.com>", "idx": 981}
{"func": "static apr_status_t session_identity_encode(request_rec * r, session_rec * z)\n{\n\n    char *buffer = NULL;\n    int length = 0;\n    if (z->expiry) {\n        char *expiry = apr_psprintf(z->pool, \"%\" APR_INT64_T_FMT, z->expiry);\n        apr_table_setn(z->entries, SESSION_EXPIRY, expiry);\n    }\n    apr_table_do(identity_count, &length, z->entries, NULL);\n    buffer = apr_pcalloc(r->pool, length + 1);\n    apr_table_do(identity_concat, buffer, z->entries, NULL);\n    z->encoded = buffer;\n    return OK;\n\n}", "target": 1, "cwe": ["CWE-787"], "project": "httpd", "commit_id": "7e09dd714fc62c08c5b0319ed7b9702594faf49b", "hash": 212496649079711101398847967247746681214, "size": 16, "message": "mod_session: account for the '&' in identity_concat().\n\ngit-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1887052 13f79535-47bb-0310-9956-ffa450edef68", "idx": 982}
{"func": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */\n  }\n}", "target": 1, "cwe": ["CWE-763"], "project": "lua", "commit_id": "a6da1472c0c5e05ff249325f979531ad51533110", "hash": 214764055066646968576960737240871936082, "size": 15, "message": "Fixed bug: barriers cannot be active during sweep\n\nBarriers cannot be active during sweep, even in generational mode.\n(Although gen. mode is not incremental, it can hit a barrier when\ndeleting a thread and closing its upvalues.)  The colors of objects are\nbeing changed during sweep and, therefore, cannot be trusted.", "idx": 983}
{"func": "int sudo_process_init(TALLOC_CTX *mem_ctx,\n                      struct tevent_context *ev,\n                      struct confdb_ctx *cdb)\n{\n    struct resp_ctx *rctx;\n    struct sss_cmd_table *sudo_cmds;\n    struct sudo_ctx *sudo_ctx;\n    struct be_conn *iter;\n    int ret;\n    int max_retries;\n\n    sudo_cmds = get_sudo_cmds();\n    ret = sss_process_init(mem_ctx, ev, cdb,\n                           sudo_cmds,\n                           SSS_SUDO_SOCKET_NAME, -1, NULL, -1,\n                           CONFDB_SUDO_CONF_ENTRY,\n                           SSS_SUDO_SBUS_SERVICE_NAME,\n                           SSS_SUDO_SBUS_SERVICE_VERSION,\n                           &monitor_sudo_methods,\n                           \"SUDO\",\n                           NULL,\n                           sss_connection_setup,\n                           &rctx);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"sss_process_init() failed\\n\");\n        return ret;\n    }\n\n    sudo_ctx = talloc_zero(rctx, struct sudo_ctx);\n    if (!sudo_ctx) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"fatal error initializing sudo_ctx\\n\");\n        ret = ENOMEM;\n        goto fail;\n    }\n\n    sudo_ctx->rctx = rctx;\n    sudo_ctx->rctx->pvt_ctx = sudo_ctx;\n\n    sss_ncache_prepopulate(sudo_ctx->rctx->ncache, sudo_ctx->rctx->cdb, rctx);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE,\n              \"failed to set ncache for sudo's filter_users\\n\");\n        goto fail;\n    }\n\n    /* Enable automatic reconnection to the Data Provider */\n    ret = confdb_get_int(sudo_ctx->rctx->cdb,\n                         CONFDB_SUDO_CONF_ENTRY,\n                         CONFDB_SERVICE_RECON_RETRIES,\n                         3, &max_retries);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE,\n              \"Failed to set up automatic reconnection\\n\");\n        goto fail;\n    }\n\n    for (iter = sudo_ctx->rctx->be_conns; iter; iter = iter->next) {\n        sbus_reconnect_init(iter->conn, max_retries,\n                            sudo_dp_reconnect_init, iter);\n    }\n\n    /* Get sudo_timed option */\n    ret = confdb_get_bool(sudo_ctx->rctx->cdb,\n                          CONFDB_SUDO_CONF_ENTRY, CONFDB_SUDO_TIMED,\n                          CONFDB_DEFAULT_SUDO_TIMED,\n                          &sudo_ctx->timed);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"Error reading from confdb (%d) [%s]\\n\",\n              ret, strerror(ret));\n        goto fail;\n    }\n\n    /* Get sudo_inverse_order option */\n    ret = confdb_get_bool(sudo_ctx->rctx->cdb,\n                          CONFDB_SUDO_CONF_ENTRY, CONFDB_SUDO_INVERSE_ORDER,\n                          CONFDB_DEFAULT_SUDO_INVERSE_ORDER,\n                          &sudo_ctx->inverse_order);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"Error reading from confdb (%d) [%s]\\n\",\n              ret, strerror(ret));\n        goto fail;\n    }\n\n    /* Get sudo_inverse_order option */\n    ret = confdb_get_int(sudo_ctx->rctx->cdb,\n                         CONFDB_SUDO_CONF_ENTRY, CONFDB_SUDO_THRESHOLD,\n                         CONFDB_DEFAULT_SUDO_THRESHOLD,\n                         &sudo_ctx->threshold);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"Error reading from confdb (%d) [%s]\\n\",\n              ret, strerror(ret));\n        goto fail;\n    }\n\n    ret = schedule_get_domains_task(rctx, rctx->ev, rctx, NULL);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"schedule_get_domains_tasks failed.\\n\");\n        goto fail;\n    }\n\n    DEBUG(SSSDBG_TRACE_FUNC, \"SUDO Initialization complete\\n\");\n\n    return EOK;\n\nfail:\n    talloc_free(rctx);\n    return ret;\n}", "target": 1, "cwe": ["CWE-200"], "project": "sssd", "commit_id": "ed90a20a0f0e936eb00d268080716c0384ffb01d", "hash": 165377820650353440801048475651780301505, "size": 108, "message": "SUDO: Create the socket with stricter permissions\n\nThis patch switches the sudo responder from being created as a public\nresponder where the permissions are open and not checked by the sssd\ndeaamon to a private socket. In this case, sssd creates the pipes with\nstrict permissions (see the umask in the call to create_pipe_fd() in\nset_unix_socket()) and additionaly checks the permissions with every read\nvia the tevent integrations (see accept_fd_handler()).\n\nResolves:\nhttps://pagure.io/SSSD/sssd/issue/3766 (CVE-2018-10852)\n\nReviewed-by: Sumit Bose <sbose@redhat.com>\nReviewed-by: Pavel Březina <pbrezina@redhat.com>", "idx": 984}
{"func": "window_pane_destroy(struct window_pane *wp)\n{\n\twindow_pane_reset_mode(wp);\n\tfree(wp->searchstr);\n\n\tif (wp->fd != -1) {\n\t\tbufferevent_free(wp->event);\n\t\tclose(wp->fd);\n\t}\n\n\tinput_free(wp);\n\n\tscreen_free(&wp->base);\n\tif (wp->saved_grid != NULL)\n\t\tgrid_destroy(wp->saved_grid);\n\n\tif (wp->pipe_fd != -1) {\n\t\tbufferevent_free(wp->pipe_event);\n\t\tclose(wp->pipe_fd);\n\t}\n\n\tif (event_initialized(&wp->resize_timer))\n\t\tevent_del(&wp->resize_timer);\n\n\tRB_REMOVE(window_pane_tree, &all_window_panes, wp);\n\n\tfree((void *)wp->cwd);\n\tfree(wp->shell);\n\tcmd_free_argv(wp->argc, wp->argv);\n\tfree(wp->palette);\n\tfree(wp);\n}", "target": 0, "cwe": [], "project": "src", "commit_id": "b32e1d34e10a0da806823f57f02a4ae6e93d756e", "hash": 180718999323504795080712951693794557019, "size": 32, "message": "evbuffer_new and bufferevent_new can both fail (when malloc fails) and\nreturn NULL. GitHub issue 1547.", "idx": 985}
{"func": "static inline void ConvertLuvToXYZ(const double L,const double u,const double v,\n  double *X,double *Y,double *Z)\n{\n  double\n    gamma;\n\n  assert(X != (double *) NULL);\n  assert(Y != (double *) NULL);\n  assert(Z != (double *) NULL);\n  if (L > (CIEK*CIEEpsilon))\n    *Y=(double) pow((L+16.0)/116.0,3.0);\n  else\n    *Y=L/CIEK;\n  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+\n    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));\n  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+\n    5.0*(*Y));\n  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-\n    5.0*(*Y);\n}", "target": 1, "cwe": [], "project": "ImageMagick6", "commit_id": "bbb2dff98d0e97a0fe3f7e187855476c4590eed2", "hash": 28780801601595420860923764130646890377, "size": 20, "message": "https://github.com/ImageMagick/ImageMagick/issues/3317", "idx": 986}
{"func": "static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size,\n\t\t\t      int flags)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\n\treturn unix_dgram_recvmsg(iocb, sock, msg, size, flags);\n}", "target": 0, "cwe": [], "project": "linux-2.6", "commit_id": "16e5726269611b71c930054ffe9b858c1cea88eb", "hash": 270556754145714689976975930501017392117, "size": 11, "message": "af_unix: dont send SCM_CREDENTIALS by default\n\nSince commit 7361c36c5224 (af_unix: Allow credentials to work across\nuser and pid namespaces) af_unix performance dropped a lot.\n\nThis is because we now take a reference on pid and cred in each write(),\nand release them in read(), usually done from another process,\neventually from another cpu. This triggers false sharing.\n\n# Events: 154K cycles\n#\n# Overhead  Command       Shared Object        Symbol\n# ........  .......  ..................  .........................\n#\n    10.40%  hackbench  [kernel.kallsyms]   [k] put_pid\n     8.60%  hackbench  [kernel.kallsyms]   [k] unix_stream_recvmsg\n     7.87%  hackbench  [kernel.kallsyms]   [k] unix_stream_sendmsg\n     6.11%  hackbench  [kernel.kallsyms]   [k] do_raw_spin_lock\n     4.95%  hackbench  [kernel.kallsyms]   [k] unix_scm_to_skb\n     4.87%  hackbench  [kernel.kallsyms]   [k] pid_nr_ns\n     4.34%  hackbench  [kernel.kallsyms]   [k] cred_to_ucred\n     2.39%  hackbench  [kernel.kallsyms]   [k] unix_destruct_scm\n     2.24%  hackbench  [kernel.kallsyms]   [k] sub_preempt_count\n     1.75%  hackbench  [kernel.kallsyms]   [k] fget_light\n     1.51%  hackbench  [kernel.kallsyms]   [k]\n__mutex_lock_interruptible_slowpath\n     1.42%  hackbench  [kernel.kallsyms]   [k] sock_alloc_send_pskb\n\nThis patch includes SCM_CREDENTIALS information in a af_unix message/skb\nonly if requested by the sender, [man 7 unix for details how to include\nancillary data using sendmsg() system call]\n\nNote: This might break buggy applications that expected SCM_CREDENTIAL\nfrom an unaware write() system call, and receiver not using SO_PASSCRED\nsocket option.\n\nIf SOCK_PASSCRED is set on source or destination socket, we still\ninclude credentials for mere write() syscalls.\n\nPerformance boost in hackbench : more than 50% gain on a 16 thread\nmachine (2 quad-core cpus, 2 threads per core)\n\nhackbench 20 thread 2000\n\n4.228 sec instead of 9.102 sec\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Tim Chen <tim.c.chen@linux.intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "idx": 987}
{"func": "static void hci_cc_write_voice_setting(struct hci_dev *hdev,\n\t\t\t\t       struct sk_buff *skb)\n{\n\t__u8 status = *((__u8 *) skb->data);\n\t__u16 setting;\n\tvoid *sent;\n\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, status);\n\n\tif (status)\n\t\treturn;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);\n\tif (!sent)\n\t\treturn;\n\n\tsetting = get_unaligned_le16(sent);\n\n\tif (hdev->voice_setting == setting)\n\t\treturn;\n\n\thdev->voice_setting = setting;\n\n\tBT_DBG(\"%s voice setting 0x%4.4x\", hdev->name, setting);\n\n\tif (hdev->notify)\n\t\thdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);\n}", "target": 0, "cwe": ["CWE-290"], "project": "linux", "commit_id": "3ca44c16b0dcc764b641ee4ac226909f5c421aa3", "hash": 89675846511590445582272308302468349233, "size": 28, "message": "Bluetooth: Consolidate encryption handling in hci_encrypt_cfm\n\nThis makes hci_encrypt_cfm calls hci_connect_cfm in case the connection\nstate is BT_CONFIG so callers don't have to check the state.\n\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>", "idx": 988}
{"func": "v3_keyid (gcry_mpi_t a, u32 *ki)\n{\n  byte *buffer, *p;\n  size_t nbytes;\n\n  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))\n    BUG ();\n  /* fixme: allocate it on the stack */\n  buffer = xmalloc (nbytes);\n  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))\n    BUG ();\n  if (nbytes < 8) /* oops */\n    ki[0] = ki[1] = 0;\n  else\n    {\n      p = buffer + nbytes - 8;\n      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];\n      p += 4;\n      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];\n    }\n  xfree (buffer);\n  return ki[1];\n}", "target": 1, "cwe": ["CWE-20"], "project": "gnupg", "commit_id": "2183683bd633818dd031b090b5530951de76f392", "hash": 295250359634765762478823088180877427160, "size": 23, "message": "Use inline functions to convert buffer data to scalars.\n\n* common/host2net.h (buf16_to_ulong, buf16_to_uint): New.\n(buf16_to_ushort, buf16_to_u16): New.\n(buf32_to_size_t, buf32_to_ulong, buf32_to_uint, buf32_to_u32): New.\n--\n\nCommit 91b826a38880fd8a989318585eb502582636ddd8 was not enough to\navoid all sign extension on shift problems.  Hanno Böck found a case\nwith an invalid read due to this problem.  To fix that once and for\nall almost all uses of \"<< 24\" and \"<< 8\" are changed by this patch to\nuse an inline function from host2net.h.\n\nSigned-off-by: Werner Koch <wk@gnupg.org>", "idx": 989}
{"func": "void inotify_destroy(struct inotify_handle *ih)\n{\n\t/*\n\t * Destroy all of the watches for this handle. Unfortunately, not very\n\t * pretty.  We cannot do a simple iteration over the list, because we\n\t * do not know the inode until we iterate to the watch.  But we need to\n\t * hold inode->inotify_mutex before ih->mutex.  The following works.\n\t */\n\twhile (1) {\n\t\tstruct inotify_watch *watch;\n\t\tstruct list_head *watches;\n\t\tstruct inode *inode;\n\n\t\tmutex_lock(&ih->mutex);\n\t\twatches = &ih->watches;\n\t\tif (list_empty(watches)) {\n\t\t\tmutex_unlock(&ih->mutex);\n\t\t\tbreak;\n\t\t}\n\t\twatch = list_first_entry(watches, struct inotify_watch, h_list);\n\t\tget_inotify_watch(watch);\n\t\tmutex_unlock(&ih->mutex);\n\n\t\tinode = watch->inode;\n\t\tmutex_lock(&inode->inotify_mutex);\n\t\tmutex_lock(&ih->mutex);\n\n\t\t/* make sure we didn't race with another list removal */\n\t\tif (likely(idr_find(&ih->idr, watch->wd))) {\n\t\t\tremove_watch_no_event(watch, ih);\n\t\t\tput_inotify_watch(watch);\n\t\t}\n\n\t\tmutex_unlock(&ih->mutex);\n\t\tmutex_unlock(&inode->inotify_mutex);\n\t\tput_inotify_watch(watch);\n\t}\n\n\t/* free this handle: the put matching the get in inotify_init() */\n\tput_inotify_handle(ih);\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux-2.6", "commit_id": "8f7b0ba1c853919b85b54774775f567f30006107", "hash": 97538541219067195626175215681474637018, "size": 41, "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "idx": 990}
{"func": "backward_search(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n                const UChar* range, UChar* adjrange, UChar** low, UChar** high)\n{\n  UChar *p;\n\n  p = s;\n\n retry:\n  switch (reg->optimize) {\n  case OPTIMIZE_STR:\n  exact_method:\n    p = slow_search_backward(reg->enc, reg->exact, reg->exact_end,\n                             range, adjrange, end, p);\n    break;\n\n  case OPTIMIZE_STR_CASE_FOLD:\n    p = slow_search_backward_ic(reg->enc, reg->case_fold_flag,\n                                reg->exact, reg->exact_end,\n                                range, adjrange, end, p);\n    break;\n\n  case OPTIMIZE_STR_FAST:\n  case OPTIMIZE_STR_FAST_STEP_FORWARD:\n    goto exact_method;\n    break;\n\n  case OPTIMIZE_MAP:\n    p = map_search_backward(reg->enc, reg->map, range, adjrange, p);\n    break;\n  }\n\n  if (p) {\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc, str, p);\n          if (IS_NOT_NULL(prev) && !ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n        }\n        break;\n\n      case ANCR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(prev)) goto fail;\n          if (ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 ) {\n          p = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(p)) goto fail;\n          goto retry;\n        }\n        break;\n      }\n    }\n\n    if (reg->dist_max != INFINITE_LEN) {\n      if ((ptrdiff_t )(p - str) < (ptrdiff_t )reg->dist_max)\n        *low = (UChar* )str;\n      else\n        *low = p - reg->dist_max;\n\n      if (reg->dist_min != 0) {\n        if ((ptrdiff_t )(p - str) < (ptrdiff_t )reg->dist_min)\n          *high = (UChar* )str;\n        else\n          *high = p - reg->dist_min;\n      }\n      else {\n        *high = p;\n      }\n\n      *high = onigenc_get_right_adjust_char_head(reg->enc, adjrange, *high);\n    }\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"backward_search: low: %d, high: %d\\n\",\n            (int )(*low - str), (int )(*high - str));\n#endif\n    return 1; /* success */\n  }\n\n fail:\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"backward_search: fail.\\n\");\n#endif\n  return 0; /* fail */\n}", "target": 1, "cwe": ["CWE-125"], "project": "oniguruma", "commit_id": "778a43dd56925ed58bbe26e3a7bb8202d72c3f3f", "hash": 217671523284336275693086027870049733409, "size": 102, "message": "fix #164: Integer overflow related to reg->dmax in search_in_range()", "idx": 991}
{"func": "ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}", "target": 0, "cwe": ["CWE-20"], "project": "libvpx", "commit_id": "f00890eecdf8365ea125ac16769a83aa6b68792d", "hash": 322884115710590675407012077409252316019, "size": 1, "message": "update libwebm to libwebm-1.0.0.27-352-g6ab9fcf\n\nhttps://chromium.googlesource.com/webm/libwebm/+log/af81f26..6ab9fcf\n\nChange-Id: I9d56e1fbaba9b96404b4fbabefddc1a85b79c25d", "idx": 992}
{"func": "leave_sysex(int dev)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             timeout = 0;\n\n\tif (!sysex_state[dev])\n\t\treturn;\n\n\tsysex_state[dev] = 0;\n\n\twhile (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&\n\t       timeout < 1000)\n\t\ttimeout++;\n\n\tsysex_state[dev] = 0;\n}", "target": 0, "cwe": ["CWE-703", "CWE-189"], "project": "linux", "commit_id": "b769f49463711205d57286e64cf535ed4daf59e9", "hash": 129389909382969240865702451835781439215, "size": 16, "message": "sound/oss: remove offset from load_patch callbacks\n\nWas: [PATCH] sound/oss/midi_synth: prevent underflow, use of\nuninitialized value, and signedness issue\n\nThe offset passed to midi_synth_load_patch() can be essentially\narbitrary.  If it's greater than the header length, this will result in\na copy_from_user(dst, src, negative_val).  While this will just return\n-EFAULT on x86, on other architectures this may cause memory corruption.\nAdditionally, the length field of the sysex_info structure may not be\ninitialized prior to its use.  Finally, a signed comparison may result\nin an unintentionally large loop.\n\nOn suggestion by Takashi Iwai, version two removes the offset argument\nfrom the load_patch callbacks entirely, which also resolves similar\nissues in opl3.  Compile tested only.\n\nv3 adjusts comments and hopefully gets copy offsets right.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "idx": 993}
{"func": "static Token *make_tok_qstr(Token *next, const char *str)\n{\n    return make_tok_qstr_len(next, str, strlen(str));\n}", "target": 0, "cwe": [], "project": "nasm", "commit_id": "6299a3114ce0f3acd55d07de201a8ca2f0a83059", "hash": 229243379305273674702487160660594795498, "size": 4, "message": "BR 3392708: fix NULL pointer reference for invalid %stacksize\n\nAfter issuing an error message for a missing %stacksize argument, need\nto quit rather than continuing to try to access the pointer.\n\nFold uses of tok_text() while we are at it.\n\nReported-by: Suhwan <prada960808@gmail.com>\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>", "idx": 994}
{"func": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties; \n\t\t\t    j++, i++) \n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-20"], "project": "php-src", "commit_id": "25b1dc917a53787dbb2532721ca22f3f36eb13c0", "hash": 264979757807768327559194419883794468728, "size": 193, "message": "Fixed Bug #67413 \tfileinfo: cdf_read_property_info insufficient boundary chec\n\nUpstream:\nhttps://github.com/file/file/commit/93e063ee374b6a75729df9e7201fb511e47e259d\n\nAdapted for C standard.", "idx": 995}
{"func": "create_account_details_ui (GoaProvider    *provider,\n                           GtkDialog      *dialog,\n                           GtkBox         *vbox,\n                           gboolean        new_account,\n                           AddAccountData *data)\n{\n  GtkWidget *action_area;\n  GtkWidget *grid0;\n  GtkWidget *grid1;\n  GtkWidget *grid2;\n  GtkWidget *hbox;\n  GtkWidget *label;\n  GtkWidget *spinner;\n  gint width;\n\n  goa_utils_set_dialog_title (provider, dialog, new_account);\n\n  grid0 = gtk_grid_new ();\n  gtk_container_set_border_width (GTK_CONTAINER (grid0), 5);\n  gtk_widget_set_margin_bottom (grid0, 6);\n  gtk_orientable_set_orientation (GTK_ORIENTABLE (grid0), GTK_ORIENTATION_VERTICAL);\n  gtk_grid_set_row_spacing (GTK_GRID (grid0), 12);\n  gtk_container_add (GTK_CONTAINER (vbox), grid0);\n\n  data->cluebar = gtk_info_bar_new ();\n  gtk_info_bar_set_message_type (GTK_INFO_BAR (data->cluebar), GTK_MESSAGE_ERROR);\n  gtk_widget_set_hexpand (data->cluebar, TRUE);\n  gtk_widget_set_no_show_all (data->cluebar, TRUE);\n  gtk_container_add (GTK_CONTAINER (grid0), data->cluebar);\n\n  data->cluebar_label = gtk_label_new (\"\");\n  gtk_label_set_line_wrap (GTK_LABEL (data->cluebar_label), TRUE);\n  gtk_container_add (GTK_CONTAINER (gtk_info_bar_get_content_area (GTK_INFO_BAR (data->cluebar))),\n                     data->cluebar_label);\n\n  grid1 = gtk_grid_new ();\n  gtk_orientable_set_orientation (GTK_ORIENTABLE (grid1), GTK_ORIENTATION_VERTICAL);\n  gtk_grid_set_row_spacing (GTK_GRID (grid1), 12);\n\n  grid2 = gtk_grid_new ();\n  gtk_orientable_set_orientation (GTK_ORIENTABLE (grid2), GTK_ORIENTATION_VERTICAL);\n  gtk_grid_set_row_spacing (GTK_GRID (grid2), 12);\n\n  hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);\n  gtk_box_set_homogeneous (GTK_BOX (hbox), FALSE);\n  gtk_box_pack_start (GTK_BOX (hbox), grid1, FALSE, FALSE, 0);\n  gtk_box_pack_start (GTK_BOX (hbox), grid2, TRUE, TRUE, 0);\n  gtk_container_add (GTK_CONTAINER (grid0), hbox);\n\n  add_entry (grid1, grid2, _(\"_E-mail\"), &data->email_address);\n  add_entry (grid1, grid2, _(\"_Password\"), &data->password);\n  if (new_account)\n    {\n      data->expander = gtk_expander_new_with_mnemonic (_(\"_Custom\"));\n      gtk_expander_set_expanded (GTK_EXPANDER (data->expander), FALSE);\n      gtk_expander_set_resize_toplevel (GTK_EXPANDER (data->expander), TRUE);\n      gtk_container_add (GTK_CONTAINER (grid0), data->expander);\n\n      grid1 = gtk_grid_new ();\n      gtk_orientable_set_orientation (GTK_ORIENTABLE (grid1), GTK_ORIENTATION_VERTICAL);\n      gtk_grid_set_row_spacing (GTK_GRID (grid1), 12);\n\n      grid2 = gtk_grid_new ();\n      gtk_orientable_set_orientation (GTK_ORIENTABLE (grid2), GTK_ORIENTATION_VERTICAL);\n      gtk_grid_set_row_spacing (GTK_GRID (grid2), 12);\n\n      hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);\n      gtk_box_set_homogeneous (GTK_BOX (hbox), FALSE);\n      gtk_box_pack_start (GTK_BOX (hbox), grid1, FALSE, FALSE, 0);\n      gtk_box_pack_start (GTK_BOX (hbox), grid2, TRUE, TRUE, 0);\n      gtk_container_add (GTK_CONTAINER (data->expander), hbox);\n\n      add_entry (grid1, grid2, _(\"User_name\"), &data->username);\n      add_entry (grid1, grid2, _(\"_Server\"), &data->server);\n    }\n\n  gtk_entry_set_visibility (GTK_ENTRY (data->password), FALSE);\n\n  gtk_widget_grab_focus ((new_account) ? data->email_address : data->password);\n\n  g_signal_connect (data->email_address, \"changed\", G_CALLBACK (on_email_address_or_password_changed), data);\n  g_signal_connect (data->password, \"changed\", G_CALLBACK (on_email_address_or_password_changed), data);\n\n  data->connect_button = gtk_dialog_add_button (data->dialog, GTK_STOCK_CONNECT, GTK_RESPONSE_OK);\n  gtk_dialog_set_default_response (data->dialog, GTK_RESPONSE_OK);\n  gtk_dialog_set_response_sensitive (data->dialog, GTK_RESPONSE_OK, FALSE);\n\n  action_area = gtk_dialog_get_action_area (data->dialog);\n\n  data->progress_grid = gtk_grid_new ();\n  gtk_widget_set_no_show_all (data->progress_grid, TRUE);\n  gtk_orientable_set_orientation (GTK_ORIENTABLE (data->progress_grid), GTK_ORIENTATION_HORIZONTAL);\n  gtk_grid_set_column_spacing (GTK_GRID (data->progress_grid), 3);\n  gtk_box_pack_end (GTK_BOX (action_area), data->progress_grid, FALSE, FALSE, 0);\n  gtk_box_reorder_child (GTK_BOX (action_area), data->progress_grid, 0);\n  gtk_button_box_set_child_non_homogeneous (GTK_BUTTON_BOX (action_area), data->progress_grid, TRUE);\n\n  spinner = gtk_spinner_new ();\n  gtk_widget_set_size_request (spinner, 20, 20);\n  gtk_widget_show (spinner);\n  gtk_spinner_start (GTK_SPINNER (spinner));\n  gtk_container_add (GTK_CONTAINER (data->progress_grid), spinner);\n\n  label = gtk_label_new (_(\"Connecting…\"));\n  gtk_widget_show (label);\n  gtk_container_add (GTK_CONTAINER (data->progress_grid), label);\n\n  gtk_window_get_size (GTK_WINDOW (data->dialog), &width, NULL);\n  gtk_widget_set_size_request (GTK_WIDGET (data->dialog), width, -1);\n}", "target": 0, "cwe": ["CWE-310"], "project": "gnome-online-accounts", "commit_id": "edde7c63326242a60a075341d3fea0be0bc4d80e", "hash": 136516712546352589819405401350864690870, "size": 110, "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240", "idx": 996}
{"func": "mainloop_get_child_userdata(mainloop_child_t *child)\n{\n    return child->privatedata;\n}", "target": 0, "cwe": ["CWE-399"], "project": "pacemaker", "commit_id": "564f7cc2a51dcd2f28ab12a13394f31be5aa3c93", "hash": 251084200428613864707741251919562283102, "size": 4, "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend.", "idx": 997}
{"func": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n\n  // Evaluate the content setting rules before\n  // IsWhitelistedForContentSettings(); if there is only the default rule\n  // allowing all scripts, it's quicker this way.\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1, "cwe": ["CWE-20", "CWE-200"], "project": "muon", "commit_id": "c18663aa171c6cdf03da3e8c70df8663645b97c4", "hash": 41135076388554943397487235791345219406, "size": 28, "message": "Issue: 15232 AllowScript should use atom::ContentSettingsManager like other Allow* methods in the observer", "idx": 998}
{"func": "read_channel_data (FILE        *f,\n                   PSPimage    *ia,\n                   guchar     **pixels,\n                   guint        bytespp,\n                   guint        offset,\n                   GeglBuffer  *buffer,\n                   guint32      compressed_len)\n{\n  gint i, y;\n  gint width = gegl_buffer_get_width (buffer);\n  gint height = gegl_buffer_get_height (buffer);\n  gint npixels = width * height;\n  guchar *buf;\n  guchar *buf2 = NULL;  /* please the compiler */\n  guchar runcount, byte;\n  z_stream zstream;\n\n  switch (ia->compression)\n    {\n    case PSP_COMP_NONE:\n      if (bytespp == 1)\n        {\n          if ((width % 4) == 0)\n            fread (pixels[0], height * width, 1, f);\n          else\n            {\n              for (y = 0; y < height; y++)\n                {\n                  fread (pixels[y], width, 1, f);\n                  fseek (f, 4 - (width % 4), SEEK_CUR);\n                }\n            }\n        }\n      else\n        {\n          buf = g_malloc (width);\n          for (y = 0; y < height; y++)\n            {\n              guchar *p, *q;\n\n              fread (buf, width, 1, f);\n              if (width % 4)\n                fseek (f, 4 - (width % 4), SEEK_CUR);\n              p = buf;\n              q = pixels[y] + offset;\n              for (i = 0; i < width; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n          g_free (buf);\n        }\n      break;\n\n    case PSP_COMP_RLE:\n      {\n        guchar *q, *endq;\n\n        q = pixels[0] + offset;\n        endq = q + npixels * bytespp;\n        buf = g_malloc (127);\n        while (q < endq)\n          {\n            fread (&runcount, 1, 1, f);\n            if (runcount > 128)\n              {\n                runcount -= 128;\n                fread (&byte, 1, 1, f);\n                memset (buf, byte, runcount);\n              }\n            else\n              fread (buf, runcount, 1, f);\n\n            /* prevent buffer overflow for bogus data */\n            runcount = MIN (runcount, (endq - q) / bytespp);\n\n            if (bytespp == 1)\n              {\n                memmove (q, buf, runcount);\n                q += runcount;\n              }\n            else\n              {\n                guchar *p = buf;\n\n                for (i = 0; i < runcount; i++)\n                  {\n                    *q = *p++;\n                    q += bytespp;\n                  }\n              }\n          }\n        g_free (buf);\n      }\n      break;\n\n    case PSP_COMP_LZ77:\n      buf = g_malloc (compressed_len);\n      fread (buf, compressed_len, 1, f);\n      zstream.next_in = buf;\n      zstream.avail_in = compressed_len;\n      zstream.zalloc = psp_zalloc;\n      zstream.zfree = psp_zfree;\n      zstream.opaque = f;\n      if (inflateInit (&zstream) != Z_OK)\n        {\n          g_message (\"zlib error\");\n          return -1;\n        }\n      if (bytespp == 1)\n        zstream.next_out = pixels[0];\n      else\n        {\n          buf2 = g_malloc (npixels);\n          zstream.next_out = buf2;\n        }\n      zstream.avail_out = npixels;\n      if (inflate (&zstream, Z_FINISH) != Z_STREAM_END)\n        {\n          g_message (\"zlib error\");\n          inflateEnd (&zstream);\n          return -1;\n        }\n      inflateEnd (&zstream);\n      g_free (buf);\n\n      if (bytespp > 1)\n        {\n          guchar *p, *q;\n\n          p = buf2;\n          q = pixels[0] + offset;\n          for (i = 0; i < npixels; i++)\n            {\n              *q = *p++;\n              q += bytespp;\n            }\n          g_free (buf2);\n        }\n      break;\n    }\n\n  return 0;\n}", "target": 0, "cwe": ["CWE-125"], "project": "gimp", "commit_id": "eb2980683e6472aff35a3117587c4f814515c74d", "hash": 177926695387034465861423542891229604456, "size": 145, "message": "Bug 790853 - (CVE-2017-17787) heap overread in psp importer.\n\nAs any external data, we have to check that strings being read at fixed\nlength are properly nul-terminated.", "idx": 999}
